<!DOCTYPE html>
<html lang="zh-CN">
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="深入理解virtio packed virtqueue机制">




  <meta name="keywords" content="virtio, L">










  <link rel="alternate" href="/atom.xml" title="L">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1">



<link rel="canonical" href="http://liujunming.github.io/2025/06/01/深入理解virtio-packed-virtqueue机制/">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1">



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> 深入理解virtio packed virtqueue机制 - L </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">L</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/links">
        <li class="mobile-menu-item">
          
          
            Links
          
        </li>
      </a>
    
      <a href="/books">
        <li class="mobile-menu-item">
          
          
            Books
          
        </li>
      </a>
    
      <a href="/course">
        <li class="mobile-menu-item">
          
          
            Course
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">L</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/links">
            
            
              Links
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/books">
            
            
              Books
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/course">
            
            
              Course
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          深入理解virtio packed virtqueue机制
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2025-06-01
        </span>
        
          <span class="post-category">
            
              <a href="/categories/virtio/">virtio</a>
            
          </span>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Prerequisite"><span class="toc-text">Prerequisite</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Terms"><span class="toc-text">Terms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Motivation"><span class="toc-text">Motivation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#For-software-backends"><span class="toc-text">For software backends</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#For-hardware-implementation"><span class="toc-text">For hardware implementation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview"><span class="toc-text">Overview</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#相对split-desc去掉了next字段"><span class="toc-text">相对split desc去掉了next字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flags字段的变化"><span class="toc-text">flags字段的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相对split-desc增加了id字段"><span class="toc-text">相对split desc增加了id字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#核心要点"><span class="toc-text">核心要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Placing-Available-Buffers-Into-The-Descriptor-Ring"><span class="toc-text">Placing Available Buffers Into The Descriptor Ring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Device-writes-used-descriptor"><span class="toc-text">Device writes used descriptor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Example"><span class="toc-text">Example</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#案例1"><span class="toc-text">案例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例2"><span class="toc-text">案例2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码解析"><span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#driver往Descriptor-Ring生产Available-Buffers"><span class="toc-text">driver往Descriptor Ring生产Available Buffers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#device从Descriptor-Ring消费Available-Buffers"><span class="toc-text">device从Descriptor Ring消费Available Buffers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#device往Descriptor-Ring生产used-Buffers"><span class="toc-text">device往Descriptor Ring生产used Buffers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#driver从Descriptor-Ring消费used-Buffers"><span class="toc-text">driver从Descriptor Ring消费used Buffers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注释"><span class="toc-text">注释</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p>本文将基于第一性原理，深入解析virtio packed virtqueue机制。<a id="more"></a></p>
<h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><p>读者需要对split virtqueue有深刻的理解。 </p>
<h2 id="Terms"><a href="#Terms" class="headerlink" title="Terms"></a>Terms</h2><ol>
<li>本文将virtio spec中标准的”Driver Ring Wrap Counter”统称为avail_wrap_counter</li>
<li>本文将virtio spec中标准的”Device Ring Wrap Counter”统称为used_wrap_counter</li>
</ol>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><h3 id="For-software-backends"><a href="#For-software-backends" class="headerlink" title="For software backends"></a>For software backends</h3><ul>
<li>Bad cache utilization, several cache misses per request<ul>
<li>metadata is scattered into several places </li>
<li>descriptor chain is not contiguous in memory</li>
<li>cache contention in many places</li>
</ul>
</li>
</ul>
<h3 id="For-hardware-implementation"><a href="#For-hardware-implementation" class="headerlink" title="For hardware implementation"></a>For hardware implementation</h3><ul>
<li>several PCIe transactions per descriptor</li>
</ul>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>packed virtqueue将virtio1.0中的desc ring，avail ring，used ring三个ring打包成一个desc ring了。</p>
<p><img src="/images/2025/05/015.png" alt></p>
<h3 id="相对split-desc去掉了next字段"><a href="#相对split-desc去掉了next字段" class="headerlink" title="相对split desc去掉了next字段"></a>相对split desc去掉了next字段</h3><p>在split desc中next字段是记录一个desc chain中的下一个desc idx使用的，通常配合flags这样使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((descs[idx].flags &amp; VRING_DESC_F_NEXT) == <span class="number">1</span>)</span><br><span class="line">        nextdesc = descs[ descs[idx].next];</span><br></pre></td></tr></table></figure></p>
<p>但是在<strong>packed desc ring中一个desc chain一定是相邻的</strong>（可以理解为链表变为了数组），所以next字段就用不上了，上面获取nextdesc的方式可以转化为如下方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((descs[idx].flags &amp; VRING_DESC_F_NEXT) == <span class="number">1</span>)</span><br><span class="line">        nextdesc = descs[++idx];</span><br></pre></td></tr></table></figure></p>
<h3 id="flags字段的变化"><a href="#flags字段的变化" class="headerlink" title="flags字段的变化"></a>flags字段的变化</h3><p>为了仅仅使用desc ring就能标记avail ring与used ring信息，packed virtqueue引入了avail_wrap_counter与used_wrap_counter这两个flag。相对split desc，flags字段仍然保留，但是其取值增加了，因为要把三个ring合一，每个desc就需要更多的信息表明身份（是used还是avail）。在原有flags的基础上增加了两个flag：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VRING_DESC_F_AVAIL          (1ULL &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VRING_DESC_F_USED (1ULL &lt;&lt; 15)</span></span><br></pre></td></tr></table></figure></p>
<p>avail desc：当desc flags关于VRING_DESC_F_AVAIL的设置和avail_wrap_counter同步，且VRING_DESC_F_USED的设置和avail_wrap_counter相反时，表示desc为avail desc。例如avail_wrap_counter为1时，flags应该设置VRING_DESC_F_AVAIL|~VRING_DESC_F_USED，当avail_wrap_counter为0时，flags应该设置~VRING_DESC_F_AVAIL|VRING_DESC_F_USED。</p>
<p>used desc：当desc flags关于VRING_DESC_F_USED的设置和used_wrap_counter同步，且VRING_DESC_F_AVAIL的设置也和used_wrap_counter同步时，表示desc为used desc。例如used_wrap_counter为1时，flags应该设置VRING_DESC_F_AVAIL|VRING_DESC_F_USED，当used_wrap_counter为0时，flags应该设置~VRING_DESC_F_AVAIL|~VRING_DESC_F_USED。</p>
<p>综上可以看出，avail desc的两个flag总是相反的（只能设置一个），而used desc的两个flag总是相同的，要么都设置，要么都不设置。</p>
<h3 id="相对split-desc增加了id字段"><a href="#相对split-desc增加了id字段" class="headerlink" title="相对split desc增加了id字段"></a>相对split desc增加了id字段</h3><p>这个id比较特殊，他是buffer id，注意不是desc的下标idx。</p>
<h3 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h3><p>last_used_idx &lt;= used_idx  &lt;= last_avail_idx &lt;= avail_idx</p>
<ol>
<li>avail_idx/avail_wrap_counter会由driver的局部变量维护</li>
<li>last_avail_idx/对应时刻的avail_wrap_counter会由device的局部变量维护</li>
<li>used_idx/used_wrap_counter会由device的局部变量维护</li>
<li>last_used_idx/对应时刻的used_wrap_counter会由driver的局部变量维护</li>
</ol>
<h2 id="Placing-Available-Buffers-Into-The-Descriptor-Ring"><a href="#Placing-Available-Buffers-Into-The-Descriptor-Ring" class="headerlink" title="Placing Available Buffers Into The Descriptor Ring"></a>Placing Available Buffers Into The Descriptor Ring</h2><p>For each buffer element, b:</p>
<ol>
<li>Get the next descriptor table entry, d</li>
<li>Get the next free buffer id value</li>
<li>Set <code>d.addr</code> to the physical address of the start of b</li>
<li>Set <code>d.len</code> to the length of b.</li>
<li>Set <code>d.id</code> to the buffer id</li>
<li>Calculate the flags as follows:<ol>
<li>If b is device-writable, set the VIRTQ_DESC_F_WRITE bit to 1, otherwise 0</li>
<li>Set the VIRTQ_DESC_F_AVAIL bit to the current value of the Driver Ring Wrap Counter</li>
<li>Set the VIRTQ_DESC_F_USED bit to inverse value</li>
</ol>
</li>
<li>Perform a memory barrier to ensure that the descriptor has been initialized</li>
<li>Set <code>d.flags</code> to the calculated flags value</li>
<li>If d is the last descriptor in the ring, toggle the Driver Ring Wrap Counter</li>
<li>Otherwise, increment d to point at the next descriptor</li>
</ol>
<p>This makes a single descriptor buffer available. However, in general the driver MAY make use of a batch of descriptors as part of a single request. In that case, <u>it defers updating the descriptor flags for the first descriptor (and the previous memory barrier) until after the rest of the descriptors have been initialized</u>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note: vq-&gt;avail_wrap_count is initialized to 1 */</span> </span><br><span class="line"><span class="comment">/* Note: vq-&gt;sgs is an array same size as the ring */</span> </span><br><span class="line"> </span><br><span class="line">id = alloc_id(vq); </span><br><span class="line"> </span><br><span class="line">first = vq-&gt;next_avail; </span><br><span class="line">sgs = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (each buffer element b) &#123;</span><br><span class="line">        sgs++; </span><br><span class="line"> </span><br><span class="line">        vq-&gt;desc[vq-&gt;next_avail].address = get_addr(b); </span><br><span class="line">        vq-&gt;desc[vq-&gt;next_avail].len = get_len(b); </span><br><span class="line"> </span><br><span class="line">        avail = vq-&gt;avail_wrap_count ? VIRTQ_DESC_F_AVAIL : <span class="number">0</span>; </span><br><span class="line">        used = !vq-&gt;avail_wrap_count ? VIRTQ_DESC_F_USED : <span class="number">0</span>; </span><br><span class="line">        f = get_flags(b) | avail | used; </span><br><span class="line">        <span class="keyword">if</span> (b is <span class="keyword">not</span> the last buffer element) &#123; </span><br><span class="line">                f |= VIRTQ_DESC_F_NEXT; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        vq-&gt;desc[vq-&gt;next_avail].id = id; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Don’t mark the 1st descriptor available until all of them are ready. */</span> </span><br><span class="line">        <span class="keyword">if</span> (vq-&gt;next_avail == first) &#123; </span><br><span class="line">                flags = f; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                vq-&gt;desc[vq-&gt;next_avail].flags = f;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        vq-&gt;next_avail++; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (vq-&gt;next_avail &gt;= vq-&gt;size) &#123; </span><br><span class="line">                vq-&gt;next_avail = <span class="number">0</span>; </span><br><span class="line">                vq-&gt;avail_wrap_count \^= <span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line">vq-&gt;sgs[id] = sgs; </span><br><span class="line">write_memory_barrier(); </span><br><span class="line">vq-&gt;desc[first].flags = flags; </span><br><span class="line"> </span><br><span class="line">memory_barrier(); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (vq-&gt;device_event.flags != RING_EVENT_FLAGS_DISABLE) &#123; </span><br><span class="line">        notify_device(vq); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Don’t mark the 1st descriptor available until all of them are ready<br>原因: The driver always makes the first descriptor in the list available after the rest of the list has been written out into the ring. This guarantees that the device will never observe a partial scatter/gather list in the ring.</p>
<h2 id="Device-writes-used-descriptor"><a href="#Device-writes-used-descriptor" class="headerlink" title="Device writes used descriptor"></a>Device writes used descriptor</h2><blockquote>
<p>The device only writes out a single used descriptor for the whole list. It then skips forward according to the number of descriptors in the list. The driver needs to keep track of the size of the list corresponding to each buffer ID, to be able to skip to where the next used descriptor is written by the device.</p>
</blockquote>
<p>When the device has finished processing the buffer, it writes a used device descriptor including the Buffer ID into the Descriptor Ring (overwriting a driver descriptor previously made available), and sends a used event notification.</p>
<p>对于一个Descriptor chain，device仅仅往第一个desc中写入used_wrap_counter，而不是往Descriptor chain中的所有desc中写入used_wrap_counter。这样在hardware实现的packed virtqueue中，可以减少设备侧的TLP交互次数。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>接下来的案例以一个desc table大小为4的vring为例，展示packed virtqueue的流程与相关rule的原因。Flag中的A表示VIRTQ_DESC_F_AVAIL，U表示VIRTQ_DESC_F_USED，N表示VIRTQ_DESC_F_NEXT。</p>
<h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>step1: 初始化<br><img src="/images/2025/05/017.png" alt></p>
<p>step2: driver生产Available Buffers<br><img src="/images/2025/05/018.png" alt></p>
<p>step3: device拉取Available Buffers<br><img src="/images/2025/05/019.png" alt></p>
<p>step4: device生产used Buffers<br><img src="/images/2025/05/020.png" alt><br>对于buffer id 0，device只更新了desc 0的flag(A|U)。</p>
<p>step5: driver消费used Buffers<br><img src="/images/2025/05/021.png" alt><br>driver知道buffer id 0的size为3，因此更新last_used_idx为3。</p>
<p>step6: driver生产Available Buffers<br><img src="/images/2025/05/022.png" alt></p>
<p>step7: device拉取Available Buffers<br><img src="/images/2025/05/023.png" alt><br>基于avail_wrap_counter的值，device可以知道desc 1(flag为A|~U|N)为上一轮的avail desc，而非本轮的avail desc。</p>
<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>step1: 初始化<br><img src="/images/2025/05/017.png" alt></p>
<p>step2: driver生产Available Buffers<br><img src="/images/2025/05/024.png" alt></p>
<p>step3: device拉取Available Buffers<br><img src="/images/2025/05/025.png" alt></p>
<p>step4: device生产used Buffers<br><img src="/images/2025/05/026.png" alt><br>device只更新了desc 0的flag(A|U)，更新了desc 0的id为1。</p>
<p>step5: driver消费used Buffers<br><img src="/images/2025/05/027.png" alt><br>driver知道buffer id 1的size为2，因此更新last_used_idx为2。</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Buffer Address. */</span></span><br><span class="line">	__le64 addr;</span><br><span class="line">	<span class="comment">/* Buffer Length. */</span></span><br><span class="line">	__le32 len;</span><br><span class="line">	<span class="comment">/* Buffer ID. */</span></span><br><span class="line">	__le16 id;</span><br><span class="line">	<span class="comment">/* The flags depending on descriptor type. */</span></span><br><span class="line">	__le16 flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://elixir.bootlin.com/linux/v6.14/source/drivers/virtio/virtio_ring.c" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v6.14/source/drivers/virtio/virtio_ring.c</a><br><a href="https://elixir.bootlin.com/qemu/v8.0.0/source/hw/virtio/virtio.c" target="_blank" rel="noopener">https://elixir.bootlin.com/qemu/v8.0.0/source/hw/virtio/virtio.c</a></p>
<h3 id="driver往Descriptor-Ring生产Available-Buffers"><a href="#driver往Descriptor-Ring生产Available-Buffers" class="headerlink" title="driver往Descriptor Ring生产Available Buffers"></a>driver往Descriptor Ring生产Available Buffers</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_virtqueue_packed</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Actual memory layout for this queue. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> num;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc_event</span> *<span class="title">driver</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc_event</span> *<span class="title">device</span>;</span></span><br><span class="line">	&#125; vring;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Driver ring wrap counter. */</span></span><br><span class="line">	<span class="keyword">bool</span> avail_wrap_counter;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Avail used flags. */</span></span><br><span class="line">	u16 avail_used_flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Index of the next avail descriptor. */</span></span><br><span class="line">	u16 next_avail_idx;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vring_desc_state_packed</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> *data;			<span class="comment">/* Data for callback. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Indirect desc table and extra table, if any. These two will be</span></span><br><span class="line"><span class="comment">	 * allocated together. So we won't stress more to the memory allocator.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vring_packed_desc</span> *<span class="title">indir_desc</span>;</span></span><br><span class="line">	u16 num;			<span class="comment">/* Descriptor list length. */</span></span><br><span class="line">	u16 last;			<span class="comment">/* The last desc state in a list. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">virtqueue_add_packed</span><span class="params">(struct virtqueue *_vq,</span></span></span><br><span class="line"><span class="function"><span class="params">				       struct scatterlist *sgs[],</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">unsigned</span> <span class="keyword">int</span> total_sg,</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">unsigned</span> <span class="keyword">int</span> out_sgs,</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">unsigned</span> <span class="keyword">int</span> in_sgs,</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">void</span> *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">bool</span> premapped,</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">gfp_t</span> gfp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">	head = vq-&gt;packed.next_avail_idx;</span><br><span class="line">	avail_used_flags = vq-&gt;packed.avail_used_flags;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(total_sg &gt; vq-&gt;packed.vring.num &amp;&amp; !vq-&gt;indirect);</span><br><span class="line"></span><br><span class="line">	desc = vq-&gt;packed.vring.desc;</span><br><span class="line">	i = head;</span><br><span class="line">	descs_used = total_sg;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">	id = vq-&gt;free_head;</span><br><span class="line">	BUG_ON(id == vq-&gt;packed.vring.num);</span><br><span class="line"></span><br><span class="line">	curr = id;</span><br><span class="line">	c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; out_sgs + in_sgs; n++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (sg = sgs[n]; sg; sg = sg_next(sg)) &#123;</span><br><span class="line">			<span class="keyword">dma_addr_t</span> addr;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (vring_map_one_sg(vq, sg, n &lt; out_sgs ?</span><br><span class="line">					     DMA_TO_DEVICE : DMA_FROM_DEVICE,</span><br><span class="line">					     &amp;addr, &amp;len, premapped))</span><br><span class="line">				<span class="keyword">goto</span> unmap_release;</span><br><span class="line"></span><br><span class="line">			flags = cpu_to_le16(vq-&gt;packed.avail_used_flags |</span><br><span class="line">				    (++c == total_sg ? <span class="number">0</span> : VRING_DESC_F_NEXT) |</span><br><span class="line">				    (n &lt; out_sgs ? <span class="number">0</span> : VRING_DESC_F_WRITE));</span><br><span class="line">			<span class="keyword">if</span> (i == head)</span><br><span class="line">				head_flags = flags;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				desc[i].flags = flags;</span><br><span class="line"></span><br><span class="line">			desc[i].addr = cpu_to_le64(addr);</span><br><span class="line">			desc[i].len = cpu_to_le32(len);</span><br><span class="line">			desc[i].id = cpu_to_le16(id);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (unlikely(vq-&gt;use_dma_api)) &#123;</span><br><span class="line">				vq-&gt;packed.desc_extra[curr].addr = premapped ?</span><br><span class="line">					DMA_MAPPING_ERROR : addr;</span><br><span class="line">				vq-&gt;packed.desc_extra[curr].len = len;</span><br><span class="line">				vq-&gt;packed.desc_extra[curr].flags =</span><br><span class="line">					le16_to_cpu(flags);</span><br><span class="line">			&#125;</span><br><span class="line">			prev = curr;</span><br><span class="line">			curr = vq-&gt;packed.desc_extra[curr].next;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((unlikely(++i &gt;= vq-&gt;packed.vring.num))) &#123;</span><br><span class="line">				i = <span class="number">0</span>;</span><br><span class="line">				vq-&gt;packed.avail_used_flags ^=</span><br><span class="line">					<span class="number">1</span> &lt;&lt; VRING_PACKED_DESC_F_AVAIL |</span><br><span class="line">					<span class="number">1</span> &lt;&lt; VRING_PACKED_DESC_F_USED;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i &lt;= head)</span><br><span class="line">		vq-&gt;packed.avail_wrap_counter ^= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We're using some buffers from the free list. */</span></span><br><span class="line">	vq-&gt;vq.num_free -= descs_used;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update free pointer */</span></span><br><span class="line">	vq-&gt;packed.next_avail_idx = i;</span><br><span class="line">	vq-&gt;free_head = curr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Store token. */</span></span><br><span class="line">	vq-&gt;packed.desc_state[id].num = descs_used;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>vq-&gt;packed.avail_wrap_counter</code>是driver侧维护的avail_wrap_counter，<code>vq-&gt;packed.next_avail_idx</code>是driver侧维护的avail_idx，<code>vq-&gt;packed.desc_state[id].num</code>是driver侧维护的size of the list corresponding to buffer <code>id</code>。</p>
<h3 id="device从Descriptor-Ring消费Available-Buffers"><a href="#device从Descriptor-Ring消费Available-Buffers" class="headerlink" title="device从Descriptor Ring消费Available Buffers"></a>device从Descriptor Ring消费Available Buffers</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">virtqueue_packed_pop</span><span class="params">(VirtQueue *vq, <span class="keyword">size_t</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    vq-&gt;last_avail_idx += elem-&gt;ndescs;</span><br><span class="line">    vq-&gt;inuse += elem-&gt;ndescs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vq-&gt;last_avail_idx &gt;= vq-&gt;vring.num) &#123;</span><br><span class="line">        vq-&gt;last_avail_idx -= vq-&gt;vring.num;</span><br><span class="line">        vq-&gt;last_avail_wrap_counter ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>vq-&gt;last_avail_idx</code>是device侧维护的last_avail_idx，<code>vq-&gt;last_avail_wrap_counter</code>是device侧维护的last_avail_idx时刻对应的avail_wrap_counter。</p>
<h3 id="device往Descriptor-Ring生产used-Buffers"><a href="#device往Descriptor-Ring生产used-Buffers" class="headerlink" title="device往Descriptor Ring生产used Buffers"></a>device往Descriptor Ring生产used Buffers</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtqueue_packed_flush</span><span class="params">(VirtQueue *vq, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    vq-&gt;inuse -= ndescs;</span><br><span class="line">    vq-&gt;used_idx += ndescs;</span><br><span class="line">    <span class="keyword">if</span> (vq-&gt;used_idx &gt;= vq-&gt;vring.num) &#123;</span><br><span class="line">        vq-&gt;used_idx -= vq-&gt;vring.num;</span><br><span class="line">        vq-&gt;used_wrap_counter ^= <span class="number">1</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>vq-&gt;used_idx</code>是device侧维护的used_idx，<code>vq-&gt;used_wrap_counter</code>是device侧维护的used_wrap_counter。</p>
<h3 id="driver从Descriptor-Ring消费used-Buffers"><a href="#driver从Descriptor-Ring消费used-Buffers" class="headerlink" title="driver从Descriptor Ring消费used Buffers"></a>driver从Descriptor Ring消费used Buffers</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">virtqueue_get_buf_ctx_packed</span><span class="params">(struct virtqueue *_vq,</span></span></span><br><span class="line"><span class="function"><span class="params">					  <span class="keyword">unsigned</span> <span class="keyword">int</span> *len,</span></span></span><br><span class="line"><span class="function"><span class="params">					  <span class="keyword">void</span> **ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vring_virtqueue</span> *<span class="title">vq</span> = <span class="title">to_vvq</span>(_<span class="title">vq</span>);</span></span><br><span class="line">	u16 last_used, id, last_used_idx;</span><br><span class="line">	<span class="keyword">bool</span> used_wrap_counter;</span><br><span class="line">	<span class="keyword">void</span> *ret;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Only get used elements after they have been exposed by host. */</span></span><br><span class="line">	virtio_rmb(vq-&gt;weak_barriers);</span><br><span class="line"></span><br><span class="line">	last_used_idx = READ_ONCE(vq-&gt;last_used_idx);</span><br><span class="line">	used_wrap_counter = packed_used_wrap_counter(last_used_idx);</span><br><span class="line">	last_used = packed_last_used(last_used_idx);</span><br><span class="line">	id = le16_to_cpu(vq-&gt;packed.vring.desc[last_used].id);</span><br><span class="line">	*len = le32_to_cpu(vq-&gt;packed.vring.desc[last_used].len);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* detach_buf_packed clears data, so grab it now. */</span></span><br><span class="line">	ret = vq-&gt;packed.desc_state[id].data;</span><br><span class="line">	detach_buf_packed(vq, id, ctx);</span><br><span class="line"></span><br><span class="line">	last_used += vq-&gt;packed.desc_state[id].num;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(last_used &gt;= vq-&gt;packed.vring.num)) &#123;</span><br><span class="line">		last_used -= vq-&gt;packed.vring.num;</span><br><span class="line">		used_wrap_counter ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	last_used = (last_used | (used_wrap_counter &lt;&lt; VRING_PACKED_EVENT_F_WRAP_CTR));</span><br><span class="line">	WRITE_ONCE(vq-&gt;last_used_idx, last_used);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Packed virtqueues support up to 2^15 entries each.</p>
<p><img src="/images/2025/05/016.png" alt></p>
<p>其中，<code>vq-&gt;last_used_idx</code>的第14~第0 bit为driver侧维护的last_used_idx，<code>vq-&gt;last_used_idx</code>的第15 bit为driver侧维护的last_used_idx时刻对应的used_wrap_counter。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol>
<li>Packed virtqueues支持2^15 entries;</li>
<li>每个packed virtqueue 有三部分构成：<ul>
<li>Descriptor Ring</li>
<li>Driver Event Suppression：后端（device）只读，用来控制后端向前端（driver）的通知（used notifications）</li>
<li>Device Event Suppression：前端（driver）只读，用来控制前端向后端（device）的通知（avail notifications）</li>
</ul>
</li>
<li>Write Flag，VIRTQ_DESC_F_WRITE<ul>
<li>对于avail desc这个flag用来标记其关联的buffer是只读的还是只写的；</li>
<li>对于used desc这个flag用来表示去关联的buffer是否有被后端（device）写入数据；</li>
</ul>
</li>
<li>desc中的len<ul>
<li>对于avail desc，len表示desc关联的buffer中被写入的数据长度；</li>
<li>对于uesd desc，当VIRTQ_DESC_F_WRITE被设置时，len表示后端（device）写入数据的长度，当VIRTQ_DESC_F_WRITE没有被设置时，len没有意义；</li>
</ul>
</li>
<li>Descriptor Chain<br>VIRTQ_DESC_F_NEXT在used desc中是没有意义的</li>
</ol>
<hr>
<p>参考资料:</p>
<ol>
<li><a href="http://blog.chinaunix.net/uid-28541347-id-5819237.html" target="_blank" rel="noopener">从dpdk1811看virtio1.1 的实现—packed ring</a></li>
<li><a href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html" target="_blank" rel="noopener">Virtual I/O Device (VIRTIO) Version 1.1</a></li>
<li><a href="https://archive.fosdem.org/2018/schedule/event/virtio/attachments/slides/2167/export/events/attachments/virtio/slides/2167/fosdem_virtio1_1.pdf" target="_blank" rel="noopener">What’s new in Virtio 1.1? by Jens Freimann</a></li>
<li><a href="https://www.youtube.com/watch?v=_UNuDBgI5VI" target="_blank" rel="noopener">What’s New in Virtio 1.1 - Jason Wang</a></li>
<li><a href="https://www.redhat.com/en/blog/packed-virtqueue-how-reduce-overhead-virtio" target="_blank" rel="noopener">Packed virtqueue: How to reduce overhead with virtio</a></li>
<li><a href="https://blog.csdn.net/faxiang1230/article/details/120210082" target="_blank" rel="noopener">virtio系列-packed virtqueue</a></li>
<li><a href="https://github.com/oasis-tcs/virtio-spec/issues/3" target="_blank" rel="noopener">add packed ring layout support</a></li>
<li><a href="https://lists.oasis-open.org/archives/virtio/201803/msg00041.html" target="_blank" rel="noopener">[PATCH v10 00/13] packed ring layout spec</a></li>
<li><a href="https://mp.weixin.qq.com/s/Q-ikJ3UbOvWNgDswVO0KSQ" target="_blank" rel="noopener">Virtio I/O 虚拟化（二）：Packed Virtqueue</a></li>
<li><a href="https://mp.weixin.qq.com/s/h_LTJiscJ17cKPQLNCCcgA" target="_blank" rel="noopener">异步模式下的 Vhost Packed Ring 设计介绍</a></li>
<li><a href="https://lore.kernel.org/all/20181121100330.24846-1-tiwei.bie@intel.com/" target="_blank" rel="noopener">[virtio-dev] [PATCH net-next v3 00/13] virtio: support packed ring</a></li>
</ol>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/virtio/">virtio</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2025/05/18/Notes-about-NVMe-verify-command/">
        <span class="next-text nav-default">Notes about NVMe verify command</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:liujunming1163@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/liujunming" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2016 - 
    
    2025

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">liujunming</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://liujunming.github.io/2025/06/01/深入理解virtio-packed-virtqueue机制/';
        this.page.identifier = '2025/06/01/深入理解virtio-packed-virtqueue机制/';
        this.page.title = '深入理解virtio packed virtqueue机制';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//http-liujunming-top-2.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script>

  </body>
</html>
