<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2023-08-26T11:26:02.768Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notes about PV sched yield</title>
    <link href="http://liujunming.github.io/2023/08/26/Notes-about-PV-sched-yield/"/>
    <id>http://liujunming.github.io/2023/08/26/Notes-about-PV-sched-yield/</id>
    <published>2023-08-26T10:08:30.000Z</published>
    <updated>2023-08-26T11:26:02.768Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark下kvm中的PV sched yield相关notes，参考内核版本是v6.0。<a id="more"></a></p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Idea:<br>When sending a call-function IPI-many to vCPUs, yield(by hypercall) if any of the IPI target vCPU was preempted, yield to(让步于) the first preempted target vCPU which we found.</p><p>如果IPI的source vCPU不yield to the preempted target vCPU的话，source vCPU在Non-root mode下依然需要polling(参考<code>smp_call_function_many_cond</code>函数)，直到preempted target vCPU被调度到Non-root mode后才结束；还不如直接yiled source vCPU，yield to the preempted target vCPU。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">smp_call_function_many_cond</span><span class="params">(<span class="keyword">const</span> struct cpumask *mask,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">smp_call_func_t</span> func, <span class="keyword">void</span> *info,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">int</span> scf_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">smp_cond_func_t</span> cond_func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (run_remote &amp;&amp; wait) &#123;</span><br><span class="line">        <span class="comment">// 按顺序等各个cpu修改csd的flag，不然就死等</span></span><br><span class="line">        for_each_cpu(cpu, cfd-&gt;cpumask) &#123;</span><br><span class="line">            <span class="keyword">call_single_data_t</span> *csd;</span><br><span class="line"></span><br><span class="line">            csd = &amp;per_cpu_ptr(cfd-&gt;pcpu, cpu)-&gt;csd;</span><br><span class="line">            csd_lock_wait(csd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="kvm-side"><a href="#kvm-side" class="headerlink" title="kvm side"></a>kvm side</h3><p>export this feature to the guest<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __do_cpuid_func(struct kvm_cpuid_array *<span class="built_in">array</span>, u32 function)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> KVM_CPUID_FEATURES:</span><br><span class="line">        entry-&gt;eax = (<span class="number">1</span> &lt;&lt; KVM_FEATURE_CLOCKSOURCE) |</span><br><span class="line">                  ...</span><br><span class="line">                 (<span class="number">1</span> &lt;&lt; KVM_FEATURE_PV_SCHED_YIELD) |</span><br></pre></td></tr></table></figure></p><h3 id="guest-side"><a href="#guest-side" class="headerlink" title="guest side"></a>guest side</h3><p>When the guest startup it will replace the <code>smp_ops.send_call_func_ipi</code> with <code>kvm_smp_send_call_func_ipi</code> if the PV sched yield feature supported.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">kvm_guest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (pv_sched_yield_supported()) &#123;</span><br><span class="line">        smp_ops.send_call_func_ipi = kvm_smp_send_call_func_ipi;</span><br><span class="line">        pr_info(<span class="string">"setup PV sched yield\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">pv_sched_yield_supported</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (kvm_para_has_feature(KVM_FEATURE_PV_SCHED_YIELD) &amp;&amp;</span><br><span class="line">        !kvm_para_has_hint(KVM_HINTS_REALTIME) &amp;&amp;</span><br><span class="line">        kvm_para_has_feature(KVM_FEATURE_STEAL_TIME) &amp;&amp;</span><br><span class="line">        !boot_cpu_has(X86_FEATURE_MWAIT) &amp;&amp;</span><br><span class="line">        (num_possible_cpus() != <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="yield-to-the-preempted-target-vCPU"><a href="#yield-to-the-preempted-target-vCPU" class="headerlink" title="yield to the preempted target vCPU"></a>yield to the preempted target vCPU</h2><h3 id="guest-side-1"><a href="#guest-side-1" class="headerlink" title="guest side"></a>guest side</h3><p>When the guest send call func IPI, the current vcpu will call <code>native_send_call_func_ipi</code> to send IPI to the target vcpu. If the target vCPU is preempted, it will issue a hypercall <code>KVM_HC_SCHED_YIELD</code>. </p><p>We just select the first preempted target vCPU which we found since the state of target vCPUs can change underneath and to avoid race conditions.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_smp_send_call_func_ipi</span><span class="params">(<span class="keyword">const</span> struct cpumask *mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">    native_send_call_func_ipi(mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure other vCPUs get a chance to run if they need to. */</span></span><br><span class="line">    for_each_cpu(cpu, mask) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!idle_cpu(cpu) &amp;&amp; vcpu_is_preempted(cpu)) &#123;</span><br><span class="line">            kvm_hypercall1(KVM_HC_SCHED_YIELD, per_cpu(x86_cpu_to_apicid, cpu));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="kvm-side-1"><a href="#kvm-side-1" class="headerlink" title="kvm side"></a>kvm side</h3><p>kvm needs to implement the hypercall handler to process the yield hypercall.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_emulate_hypercall</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> KVM_HC_SCHED_YIELD:</span><br><span class="line">        <span class="keyword">if</span> (!guest_pv_has(vcpu, KVM_FEATURE_PV_SCHED_YIELD))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        kvm_sched_yield(vcpu, a0);</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Find the target vcpu and yield to it.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_sched_yield</span><span class="params">(struct kvm_vcpu *vcpu, <span class="keyword">unsigned</span> <span class="keyword">long</span> dest_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">target</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_apic_map</span> *<span class="title">map</span>;</span></span><br><span class="line"></span><br><span class="line">    vcpu-&gt;stat.directed_yield_attempted++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (single_task_running())</span><br><span class="line">        <span class="keyword">goto</span> no_yield;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="built_in">map</span> = rcu_dereference(vcpu-&gt;kvm-&gt;arch.apic_map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(<span class="built_in">map</span>) &amp;&amp; dest_id &lt;= <span class="built_in">map</span>-&gt;max_apic_id &amp;&amp; <span class="built_in">map</span>-&gt;phys_map[dest_id])</span><br><span class="line">        target = <span class="built_in">map</span>-&gt;phys_map[dest_id]-&gt;vcpu;</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!target || !READ_ONCE(target-&gt;ready))</span><br><span class="line">        <span class="keyword">goto</span> no_yield;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ignore requests to yield to self */</span></span><br><span class="line">    <span class="keyword">if</span> (vcpu == target)</span><br><span class="line">        <span class="keyword">goto</span> no_yield;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kvm_vcpu_yield_to(target) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> no_yield;</span><br><span class="line"></span><br><span class="line">    vcpu-&gt;stat.directed_yield_successful++;</span><br><span class="line"></span><br><span class="line">no_yield:</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码的第26行<code>kvm_vcpu_yield_to(target)</code>，<code>target</code>就是目标vCPU，当前代码的执行上下文是IPI的source vCPU thread，执行完<code>kvm_vcpu_yield_to</code>后，即可yield to 目标vCPU。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_vcpu_yield_to</span><span class="params">(struct kvm_vcpu *target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    pid = rcu_dereference(target-&gt;pid);</span><br><span class="line">    <span class="keyword">if</span> (pid)</span><br><span class="line">        task = get_pid_task(pid, PIDTYPE_PID);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">if</span> (!task)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    ret = yield_to(task, <span class="number">1</span>);</span><br><span class="line">    put_task_struct(task);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下<code>yield_to</code>函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> *  true (&gt;0) if we indeed boosted the target task.</span></span><br><span class="line"><span class="comment"> *  false (0) if we failed to boost the target.</span></span><br><span class="line"><span class="comment"> *  -ESRCH if there's no task to yield to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">sched <span class="title">yield_to</span><span class="params">(struct task_struct *p, <span class="keyword">bool</span> preempt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// yield_to_task主动放弃CPU并执行指定的task_struct</span></span><br><span class="line">    yielded = curr-&gt;sched_class-&gt;yield_to_task(rq, p, preempt);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>参考资料:</p><ol><li><a href="http://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/09/10/kvm-performance-1" target="_blank" rel="noopener">kvm performance optimization technologies, part one</a></li><li><a href="https://lore.kernel.org/kvm/1560255830-8656-1-git-send-email-wanpengli@tencent.com/" target="_blank" rel="noopener">KVM: Yield to IPI target if necessary</a></li><li><a href="https://static.sched.com/hosted_files/kvmforum2020/6e/KVM%20Latency%20and%20Scalability%20Performance%20Tuning.pdf" target="_blank" rel="noopener">KVM Latency and Scalability Performance Tuning</a></li><li><a href="https://zhuanlan.zhihu.com/p/442921692" target="_blank" rel="noopener">进程管理：一文读懂Linux内核中的任务间调度策略</a></li><li><a href="https://cloud.tencent.com/developer/article/1648811" target="_blank" rel="noopener">从一个softlock问题来谈谈Kernel IPI的实现</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark下kvm中的PV sched yield相关notes，参考内核版本是v6.0。
    
    </summary>
    
      <category term="KVM" scheme="http://liujunming.github.io/categories/KVM/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
      <category term="调度" scheme="http://liujunming.github.io/tags/%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Notes about PV EOI</title>
    <link href="http://liujunming.github.io/2023/08/26/Notes-about-PV-EOI/"/>
    <id>http://liujunming.github.io/2023/08/26/Notes-about-PV-EOI/</id>
    <published>2023-08-26T05:35:07.000Z</published>
    <updated>2023-08-26T05:46:46.058Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考内核版本为v5.0。主要内容转载自:<a href="http://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/09/10/kvm-performance-1" target="_blank" rel="noopener">kvm performance optimization technologies, part one</a></p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>PV EOI is an old pv optimization. The idea behind pv eoi is to avoid the EOI write in APIC. This exit is expensive. PV EOI uses a shared memory. The VMM set a flag in this shared memory before injecting the interrupt, when the guest process the interrupt and write an EOI, if it finds this flag it will clear it and just return.<a id="more"></a></p><p><img src="/images/2023/08/013.jpeg" alt></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><img src="/images/2023/08/pv-eoi-init.svg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_PV_EOI_BIT 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_PV_EOI_MASK (0x1 &lt;&lt; KVM_PV_EOI_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_PV_EOI_ENABLED KVM_PV_EOI_MASK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_PV_EOI_DISABLED 0x0</span></span><br></pre></td></tr></table></figure><p>Linux guest:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU_DECRYPTED</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>, kvm_apic_eoi)</span> </span>= KVM_PV_EOI_DISABLED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_guest_cpu_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pa;</span><br><span class="line">        __this_cpu_write(kvm_apic_eoi, <span class="number">0</span>);</span><br><span class="line">        pa = slow_virt_to_phys(this_cpu_ptr(&amp;kvm_apic_eoi))</span><br><span class="line">            | KVM_MSR_ENABLED;</span><br><span class="line">        wrmsrl(MSR_KVM_PV_EOI_EN, pa);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>kvm:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_lapic_enable_pv_eoi</span><span class="params">(struct kvm_vcpu *vcpu, u64 data, <span class="keyword">unsigned</span> <span class="keyword">long</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u64 addr = data &amp; ~KVM_MSR_ENABLED;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gfn_to_hva_cache</span> *<span class="title">ghc</span> = &amp;<span class="title">vcpu</span>-&gt;<span class="title">arch</span>.<span class="title">pv_eoi</span>.<span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> new_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IS_ALIGNED(addr, <span class="number">4</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    vcpu-&gt;arch.pv_eoi.msr_val = data;</span><br><span class="line">    <span class="keyword">if</span> (!pv_eoi_enabled(vcpu))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr == ghc-&gt;gpa &amp;&amp; len &lt;= ghc-&gt;len)</span><br><span class="line">        new_len = ghc-&gt;len;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        new_len = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kvm_gfn_to_hva_cache_init(vcpu-&gt;kvm, ghc, addr, new_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Linux guest:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">kvm_guest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_PV_EOI))</span><br><span class="line">        apic_set_eoi_write(kvm_guest_apic_eoi_write);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> notrace <span class="keyword">void</span> <span class="title">kvm_guest_apic_eoi_write</span><span class="params">(u32 reg, u32 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This relies on __test_and_clear_bit to modify the memory</span></span><br><span class="line"><span class="comment">     * in a way that is atomic with respect to the local CPU.</span></span><br><span class="line"><span class="comment">     * The hypervisor only accesses this memory from the local CPU so</span></span><br><span class="line"><span class="comment">     * there's no need for lock or memory barriers.</span></span><br><span class="line"><span class="comment">     * An optimization barrier is implied in apic write.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (__test_and_clear_bit(KVM_PV_EOI_BIT, this_cpu_ptr(&amp;kvm_apic_eoi)))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    apic-&gt;native_eoi_write(APIC_EOI, APIC_EOI_ACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="interrupt-injection-before-vmentry"><a href="#interrupt-injection-before-vmentry" class="headerlink" title="interrupt injection before vmentry"></a>interrupt injection before vmentry</h2><p>The <code>apic_sync_pv_eoi_to_guest</code> will be called when vmentry.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * apic_sync_pv_eoi_to_guest - called before vmentry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Detect whether it's safe to enable PV EOI and</span></span><br><span class="line"><span class="comment"> * if yes do so.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apic_sync_pv_eoi_to_guest</span><span class="params">(struct kvm_vcpu *vcpu,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct kvm_lapic *apic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pv_eoi_enabled(vcpu) ||</span><br><span class="line">        <span class="comment">/* IRR set or many bits in ISR: could be nested. */</span></span><br><span class="line">        apic-&gt;irr_pending ||</span><br><span class="line">        <span class="comment">/* Cache not set: could be safe but we don't bother. */</span></span><br><span class="line">        apic-&gt;highest_isr_cache == <span class="number">-1</span> ||</span><br><span class="line">        <span class="comment">/* Need EOI to update ioapic. */</span></span><br><span class="line">        kvm_ioapic_handles_vector(apic, apic-&gt;highest_isr_cache)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * PV EOI was disabled by apic_sync_pv_eoi_from_guest</span></span><br><span class="line"><span class="comment">         * so we need not do anything here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pv_eoi_set_pending(apic-&gt;vcpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>pv_eoi_set_pending</code> will set the <code>KVM_PV_EOI_ENABLED</code> flag in shared memory.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pv_eoi_set_pending</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        apic_debug(<span class="string">"Can't set EOI MSR value: 0x%llx\n"</span>,</span><br><span class="line">               (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)vcpu-&gt;arch.pv_eoi.msr_val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __set_bit(KVM_APIC_PV_EOI_PENDING, &amp;vcpu-&gt;arch.apic_attention);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pv_eoi_put_user</span><span class="params">(struct kvm_vcpu *vcpu, u8 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kvm_write_guest_cached(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.pv_eoi.data, &amp;val,</span><br><span class="line">                      <span class="keyword">sizeof</span>(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apic-sync-pv-eoi-from-guest-after-vmexit"><a href="#apic-sync-pv-eoi-from-guest-after-vmexit" class="headerlink" title="apic_sync_pv_eoi_from_guest after vmexit"></a>apic_sync_pv_eoi_from_guest after vmexit</h2><p>The <code>apic_sync_pv_eoi_from_guest</code> will be called when vmexit or cancel interrupt.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * apic_sync_pv_eoi_from_guest - called on vmexit or cancel interrupt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Detect whether guest triggered PV EOI since the</span></span><br><span class="line"><span class="comment"> * last entry. If yes, set EOI on guests's behalf.</span></span><br><span class="line"><span class="comment"> * Clear PV EOI in guest memory in any case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apic_sync_pv_eoi_from_guest</span><span class="params">(struct kvm_vcpu *vcpu,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct kvm_lapic *apic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> pending;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">vector</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host</span></span><br><span class="line"><span class="comment">     * and KVM_PV_EOI_ENABLED in guest memory as follows:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * KVM_APIC_PV_EOI_PENDING is unset:</span></span><br><span class="line"><span class="comment">     *  -&gt; host disabled PV EOI.</span></span><br><span class="line"><span class="comment">     * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:</span></span><br><span class="line"><span class="comment">     *  -&gt; host enabled PV EOI, guest did not execute EOI yet.</span></span><br><span class="line"><span class="comment">     * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:</span></span><br><span class="line"><span class="comment">     *  -&gt; host enabled PV EOI, guest executed EOI.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BUG_ON(!pv_eoi_enabled(vcpu));</span><br><span class="line">    pending = pv_eoi_get_pending(vcpu);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Clear pending bit in any case: it will be set again on vmentry.</span></span><br><span class="line"><span class="comment">     * While this might not be ideal from performance point of view,</span></span><br><span class="line"><span class="comment">     * this makes sure pv eoi is only enabled when we know it's safe.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pv_eoi_clr_pending(vcpu);</span><br><span class="line">    <span class="keyword">if</span> (pending)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">vector</span> = apic_set_eoi(apic);</span><br><span class="line">    trace_kvm_pv_eoi(apic, <span class="built_in">vector</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>pv_eoi_get_pending</code> will get the status of the shared flag. If it is still pending, it means the no guest trigger the EOI write, nothing to do. If the guest trigger the EOI here will call <code>apic_set_eoi</code> set the EOI of APIC on guests’s behalf.</p><p>Note the <code>apic-&gt;irr_pending</code> will always be true with virtual interrupt delivery enabled. So pv eoi today I think is little used as the APICv is very common.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/2023/08/pv-eoi-full-pic.drawio.svg" alt></p><hr><p>参考资料:</p><ol><li><a href="http://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/09/10/kvm-performance-1" target="_blank" rel="noopener">http://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/09/10/kvm-performance-1</a></li><li><a href="https://lwn.net/Articles/502176/" target="_blank" rel="noopener">https://lwn.net/Articles/502176/</a></li><li><a href="https://lore.kernel.org/kvm/cover.1337695416.git.mst@redhat.com/" target="_blank" rel="noopener">https://lore.kernel.org/kvm/cover.1337695416.git.mst@redhat.com/</a></li><li><a href="https://www.kernel.org/doc/Documentation/virtual/kvm/msr.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/virtual/kvm/msr.txt</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文参考内核版本为v5.0。主要内容转载自:&lt;a href=&quot;http://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/09/10/kvm-performance-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kvm performance optimization technologies, part one&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;PV EOI is an old pv optimization. The idea behind pv eoi is to avoid the EOI write in APIC. This exit is expensive. PV EOI uses a shared memory. The VMM set a flag in this shared memory before injecting the interrupt, when the guest process the interrupt and write an EOI, if it finds this flag it will clear it and just return.
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Notes about pvpanic</title>
    <link href="http://liujunming.github.io/2023/08/13/Notes-about-pvpanic/"/>
    <id>http://liujunming.github.io/2023/08/13/Notes-about-pvpanic/</id>
    <published>2023-08-13T12:36:43.000Z</published>
    <updated>2023-08-13T12:44:44.733Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark下pvpanic相关notes。<a id="more"></a></p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>pvpanic, which is a paravirtualized device emulated by QEMU and used by the guest OS to report to the VMM when it experiences a panic/crash. This mechanism allows a guest OS kernel to signal the hypervisor when it panics, before any crash dump is collected.</p><h3 id="pvpanic-device"><a href="#pvpanic-device" class="headerlink" title="pvpanic device"></a>pvpanic device</h3><p>pvpanic device is a simulated device, through which a guest panic event is sent to qemu, and a QMP event is generated. This allows management apps (e.g. libvirt) to be notified and respond to the event.</p><p>The management app has the option of waiting for GUEST_PANICKED events, and/or polling for guest-panicked RunState, to learn when the pvpanic device has fired a panic event.</p><p>The pvpanic device can be implemented as an ISA device (using IOPORT) or as a PCI device.</p><h3 id="crash-kexec-post-notifiers"><a href="#crash-kexec-post-notifiers" class="headerlink" title="crash_kexec_post_notifiers"></a>crash_kexec_post_notifiers</h3><p>During initialization, the pvpanic module registers a callback with the <code>panic_notifier_list</code> notifier chain. When the kernel panics, the value of <code>crash_kexec_post_notifiers</code> determines whether or not the callbacks registered in the panic_notifier_list are invoked before kexec’ing into the capture kernel which will collect the crash dump. The <code>panic()</code> code in <code>kernel/panic.c</code> is extensively commented and worth a look if you are interested in the details.</p><hr><p>参考资料:</p><ol><li><a href="https://github.com/qemu/qemu/blob/master/docs/specs/pvpanic.txt" target="_blank" rel="noopener">docs/specs/pvpanic.txt</a></li><li><a href="https://blogs.oracle.com/linux/post/an-introduction-to-pvpanic" target="_blank" rel="noopener">An introduction to pvpanic</a></li><li><a href="https://cloud.tencent.com/developer/news/345830" target="_blank" rel="noopener">PVPanic的实现原理以及应用</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark下pvpanic相关notes。
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>盘点内存虚拟化探索之路</title>
    <link href="http://liujunming.github.io/2023/08/13/%E7%9B%98%E7%82%B9%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8B%E8%B7%AF/"/>
    <id>http://liujunming.github.io/2023/08/13/盘点内存虚拟化探索之路/</id>
    <published>2023-08-13T02:29:45.000Z</published>
    <updated>2023-08-13T03:17:30.112Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容转载自:<a href="https://mp.weixin.qq.com/s/f_bgSfz4nzG50izBYYzdLA" target="_blank" rel="noopener">致敬 hacker ｜盘点内存虚拟化探索之路</a>。<a id="more"></a></p><h2 id="云与虚拟化"><a href="#云与虚拟化" class="headerlink" title="云与虚拟化"></a>云与虚拟化</h2><p>云计算是通过 Internet 服务的方式提供动态可伸缩资源的计算模式，经过多年的发展已成为企业 IT 技术的重要支撑。虚拟化是云计算的核心技术之一，将一台计算机抽象为多台逻辑计算机，即虚拟机，每个虚拟机是一个单独安全的环境，可运行不同的操作系统且互不影响。</p><p>虚拟化技术给资源使用和调度带来了极大便利，云计算系统可以根据负载情况及时进行资源调度，在提升资源利用率的同时保证应用和服务不会因资源不足而影响服务质量。然而虚拟化也是有代价的，对资源的抽象带来了性能损失，这也是虚拟化一直致力解决的问题。</p><p>虚拟化的资源抽象可以简单划分为三部分：CPU 虚拟化、内存虚拟化和设备虚拟化。其中设备虚拟化已经可以实现网络、存储等设备直通虚拟机，没有性能损失；CPU 虚拟化在硬件特性的支持下，执行普通指令性能与裸机相同；而内存虚拟化相比裸机，仍然存在较大差异，是当下值得关注的问题。</p><h2 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>说到内存虚拟化，就不得不提虚拟内存的概念。早期的操作系统只有物理地址且空间有限，进程使用内存时必须小心翼翼以避免覆盖其他进程的内存。为避免此问题，虚拟内存的概念被抽象出来，保证每个进程都有一块连续的、独立的虚拟内存空间。进程直接通过 VA（Virtual Address）使用内存，CPU 访存时发出的 VA 由硬件 MMU（Memory Management Unit）拦截并转换为 PA（Physical Address），VA 到 PA 的映射使用页表进行管理，MMU 在转换时会自动查询页表。</p><p><img src="/images/2023/08/001.png" alt></p><h3 id="内存虚拟化-1"><a href="#内存虚拟化-1" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h3><p>与虚拟内存的概念类似，一台主机上的每个虚拟机认为自己独占整个物理地址空间，因而需要对内存再做一次抽象，即内存虚拟化，保证每个虚拟机都有独立的地址空间。这样一来，在虚拟机和物理机中均有 VA 和 PA 的概念，即 GVA（Guest  Virtual Address）和 GPA（Guest Physical Address），以及 HVA（Host Virtual Address）和 HPA（Host Physical Address）。虚拟机内的程序使用的是GVA，最终需要转换成 HPA。两个 VA 到 PA（ GVA 到 GPA 以及 HVA 到 HPA）的映射同样使用页表管理，GPA 到 HVA 一般是几段连续的线性映射，由虚拟机的管理程序 VMM（Virtual Machine Monitor）进行管理。</p><p><img src="/images/2023/08/002.png" alt></p><p>进程访存需要从 VA 转换成 PA，在引入内存虚拟化后，转换路径发生了很大的变化。原本只需要将 VA 转换为 PA，虚拟化后转换过程变成 GVA -&gt; GPA -&gt; HVA -&gt; HPA 。路径变得更长更复杂之后，对于访存的安全和性能都带来了挑战，这两点也是内存虚拟化需要达到的目标：1）安全 ，即地址转换的合法性，虚拟机不能访问不属于自己的内存；2）性能，即地址转换的高效性，包括转换关系建立的开销低，以及转换过程本身的开销低。</p><h2 id="经典方案"><a href="#经典方案" class="headerlink" title="经典方案"></a>经典方案</h2><p>为达成内存虚拟化的目标，已经有很多虚拟化方案被提出，SPT（Shadow Page Table）和 EPT（Extended Page Table）是两种典型的方案，也是大家最熟悉的方案。我们先以此为切入点，看看他们是如何工作的，然后再讨论其他的虚拟化方案。</p><h3 id="SPT"><a href="#SPT" class="headerlink" title="SPT"></a>SPT</h3><p>由于最初的硬件只支持一层页表转换，直接用来转换虚拟机或物理机上的 VA 到 PA 都无法完成 GVA 到 HPA 的转换。因此 SPT 建立了一条捷径，即影子页表，直接管理 GVA 到 HPA 的映射，如下图所示。每一个影子页表实例对应虚拟机内一个进程，影子页表的建立需要 VMM 查询虚拟机内进程的页表。</p><p><img src="/images/2023/08/003.png" alt></p><p>由于影子页表管理的是 GVA 到 HPA 的直接映射，SPT 地址转换路径与物理机路径相当，直接查询一层页表就可以完成地址转换。在使用 4 级页表时，转换过程如下图所示。</p><p><img src="/images/2023/08/004.png" alt></p><p><strong>优势</strong>：SPT 地址转换过程的开销低，与物理机相当。</p><p><strong>劣势</strong>：</p><ol><li>地址转换关系的建立开销很大，为保证地址转换的合法性，所有的转换关系建立，即虚拟机进程的页表修改，都会被拦截之后陷出到特权的 VMM 中代为执行；</li><li>影子页表本身需要占用内存，且一个影子页表只对应虚拟机内一个进程，整体会占用较多内存资源。</li></ol><h3 id="EPT"><a href="#EPT" class="headerlink" title="EPT"></a>EPT</h3><p>后来的硬件针对虚拟化增加了嵌套页表的支持，使得硬件可以自动完成两层页表转换。EPT 即是基于硬件支持的方案，在管理 GVA 到 GPA 的虚拟机页表基础上，新增扩展页表管理 GPA 到 HPA 的映射，如下图所示。这两层页表相互独立，两层映射关系转换都由硬件自动完成。</p><p><img src="/images/2023/08/005.png" alt></p><p>由于虚拟机内各级页表（gL4, gL3, gL2, gL1）内容只是 GPA，查询下一级时必须先经扩展页表（nL4, nL3, nL2, nL1）转换为 HPA，使得整个转换路径很长。在两层页表均为 4 级时，转换过程如下图所示。</p><p><img src="/images/2023/08/006.png" alt></p><p><strong>优势</strong>：地址转换关系的建立开销低，独立的 EPT 页表的存在保证了地址转换的合法性，因此虚拟机的页表可以自行修改而无需 VMM 的干预。</p><p><strong>劣势</strong>：转换过程的开销很大，最坏情况下需要 24（4 + 4 + 4 * 4）次硬件查表转换。</p><p>两种经典的方案在安全上都有坚实的保证，但在性能上各有缺陷。SPT 为保证地址转换的合法性在建立转换关系时付出了很大代价，而 EPT 虽然消除了建立转换关系的开销，转换路径却更长了。</p><h2 id="其他探索"><a href="#其他探索" class="headerlink" title="其他探索"></a>其他探索</h2><p>业界和学术界关于内存虚拟化还有很多的探索，基本思想与 SPT 或 EPT 类似，可以据此分为三类来看：1）一层页表方案。与 SPT 类似，使用一层页表直接管理 GVA 到 HPA 的映射；2）两层页表方案。与 EPT 类似，使用两层独立页表分别管理 GVA 到 GPA 以及 GPA 到 HPA 的映射；3）混合方案。结合前两类方案，进行动态的选择。</p><h3 id="Direct-Paging"><a href="#Direct-Paging" class="headerlink" title="Direct Paging"></a>Direct Paging</h3><p>一层页表方案，这是 Xen 在早期硬件仅支持一层页表时的半虚拟化方案。相比于 SPT 最大的区别是，没有单独维护 GVA 到 GPA 的虚拟机页表，虚拟机知道自己处于虚拟化环境，即知道自己的页表内容是 HPA。虚拟机修改页表也需要陷出，但是采用主动陷出的方式，可以 batch 化，而 SPT 则是被动拦截陷出；读取页表时只能拿到 HPA，需要查一张 M2P（Machine to Physical）表才能得到 GPA。</p><p><img src="/images/2023/08/007.png" alt></p><p>Direct Paging 同样使用一层页表管理 GVA 到 HPA 映射，地址转换的路径与 SPT 是相同的。在使用 4 级页表时，最坏只需 4 次查表。</p><p><strong>优势</strong>：地址转换过程的开销低，与物理机相当。</p><p><strong>劣势</strong>：</p><ol><li>地址转换关系的建立开销很大，所有页表修改都需要主动陷出；</li><li>需要虚拟机做半虚拟化的适配，虚拟机需要感知自己的页表管理的是 GVA 到 HPA 的映射。</li></ol><h3 id="Direct-Segment"><a href="#Direct-Segment" class="headerlink" title="Direct Segment"></a>Direct Segment</h3><p>两层页表方案，这是学术界基于新硬件的方案。GVA 到 GPA 的映射管理与 EPT 相同，同样采用多级页表。但 GPA 到 HPA 的映射采用分段机制， GPA 转换为 HPA 时只需要通过硬件加上一个偏移即可。</p><p><img src="/images/2023/08/008.png" alt></p><p>GPA 虽然不等于 HPA，但二者的映射关系十分简单，只需要 Direct Segment 硬件添加一个偏移，整个转换路径与物理机的路径相比差别很小，仅多了几次硬件偏移。虚拟机使用 4 级页表时，转换路径如下图所示，其中 DS 表示 GPA 到 HPA 转换的硬件支持。</p><p><img src="/images/2023/08/009.png" alt></p><p><strong>优势</strong>：地址转换关系的建立开销低，同时转换过程的开销也很低。</p><p><strong>劣势</strong>：</p><ol><li>需要硬件支持 GPA 到 HPA 分段映射，现有的硬件不具备这样的功能；</li><li>需要分配大段连续的内存，即主机不能有太多内存碎片。</li></ol><h3 id="Flat-EPT"><a href="#Flat-EPT" class="headerlink" title="Flat EPT"></a>Flat EPT</h3><p>两层页表方案，这也是学术界提出的基于新硬件的方案。整体与 EPT 非常相似，唯一的区别在于 EPT 管理 GPA 到 HPA 的使用多级页表，一般是 4 级，每级 512 项；而 Flat EPT 使用仅有一级的扁平页表，表项远不止 512。</p><p><img src="/images/2023/08/010.png" alt></p><p>与 EPT 相同，虚拟机内各级页表的内容也是 GPA，查询下一级时需要先经过扁平扩展页表（nL4）转换为 HPA。由于扁平扩展页表只有一级，转换路径相比 EPT 缩短了非常多。在虚拟机内使用4级页表时，转换路径如下图所示，最坏只需 9（4 + 1 + 4 * 1）次查表。</p><p><img src="/images/2023/08/011.png" alt></p><p><strong>优势</strong>：地址转换关系的建立开销低，同时转换过程的开销也较低。相比于 Direct Segment 对内存分配要求很低，只需要少量连续内存用作扁平扩展页表即可（8G规格虚拟机只需要 16M）。</p><p><strong>劣势</strong>：需要硬件支持扁平扩展页表，当前的硬件只支持表项为 512 的多级扩展页表。</p><h3 id="Mix-SPT-and-EPT"><a href="#Mix-SPT-and-EPT" class="headerlink" title="Mix SPT and EPT"></a>Mix SPT and EPT</h3><p>混合方案，这是学术界较早提出的方案，简单而言就是动态的分时切换 SPT 与 EPT。在虚拟机运行时监控和采集 TLB miss 与 Page Fault 的数据，在二者达到设定的阈值时进行 SPT 与 EPT 之间的切换，如下图所示：</p><ul><li>TLB miss 率高于阈值 T1，Page Fault 频率低于阈值 T2 时，从 EPT 切换到 SPT</li><li>TLB miss 率低于阈值 T1，Page Fault 频率高于阈值 T2 时，从 SPT 切换到 EPT</li></ul><p><img src="/images/2023/08/012.png" alt></p><p><strong>优势</strong>：有机会充分利用SPT与EPT的优势，达到更好的性能。</p><p><strong>劣势</strong>：</p><ol><li>页表切换阈值的设定很困难，硬件配置都可能影响阈值；</li><li>SPT与EPT的切换也是有代价的，主要是SPT的销毁与重建。</li></ol><h3 id="TPT"><a href="#TPT" class="headerlink" title="TPT"></a>TPT</h3><p>值得一提的是，ATC’23的paper<a href="https://www.usenix.org/system/files/atc23-bergman.pdf" target="_blank" rel="noopener">Translation Pass-Through for Near-Native Paging Performance in VMs</a>也是本topic的工作，可以仔细阅读论文中的Related Work一节，了解更多相关工作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一层页表显著的优势是地址转换过程开销低，与物理机相同，需要解决的问题是减少地址转换建立的开销。一个可能的方向是放弃一些安全性，让页表的修改更轻量；另一个更实际的方向是在合适的场景使用，即针对页表修改不频繁的负载使用。</p><p>两层页表的优势是地址转换建立的开销小，虚拟机可以独立修改页表，需要考虑的问题是缩短转换路径。这个方向其实可行性很高，但是依赖新硬件的支持，短期不太可能出现符合要求的新硬件。</p><p>混合页表的设计初衷是希望充分利用两类页表的优势，但是做好动态的模式切换是非常困难的，负载的差异甚至硬件的差异都可能影响切换的效果。或许针对已知负载做定向的调优是一个可行的方向。</p><p>长远来看，如果有新硬件的加持，两层页表（尤其是Flat EPT）是比较完善的方案，地址转换可以很高效，也不需要在安全和通用性上做一些牺牲。但是短期来看，新硬件为时尚早，在一层页表方案上做进一步的探索和优化，是更加实际的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容转载自:&lt;a href=&quot;https://mp.weixin.qq.com/s/f_bgSfz4nzG50izBYYzdLA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;致敬 hacker ｜盘点内存虚拟化探索之路&lt;/a&gt;。
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="内存管理" scheme="http://liujunming.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Interrupt Request Lines (IRQs)</title>
    <link href="http://liujunming.github.io/2023/08/12/Notes-about-Interrupt-Request-Lines-IRQs/"/>
    <id>http://liujunming.github.io/2023/08/12/Notes-about-Interrupt-Request-Lines-IRQs/</id>
    <published>2023-08-12T04:02:00.000Z</published>
    <updated>2023-08-12T04:12:46.496Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark下IRQs相关notes。<a id="more"></a></p><p>An interrupt request (IRQ) is a hardware signal sent to the processor instructing it to suspend its current activity and handle some external event, such as a keyboard input or a mouse movement. In x86 based computer systems, IRQs are numbered from 0 to 15. Newer computers, including x86-64 systems, provide more than these 16 interrupts (usually 24). Some interrupts are reserved for specific purposes, such as the keyboard and the real-time clock; others have common uses but may be reassigned; and some are left available for extra devices that may be added to the system.</p><p>Here is a list of the IRQs and their common purposes in the x86 system:<br><img src="/images/2023/07/003.jpeg" alt></p><p>In Linux, IRQ mappings are stored in the /proc/interrupts file:<br><img src="/images/2023/07/004.jpeg" alt><br>In the picture above, you can see the names of the drivers that are using each IRQ. For example, the keyborad is using IRQ 1, the mouse is using IRQ 12.</p><p>File ‘/proc/interrupts’ is the procfs Linux interface to the interrupt subsystem, and it presents a table about the number of interrupts on every CPU core in the system in the following form:</p><ul><li>First column: interrupt number</li><li>CPUx columns: interrupt counters for every CPU core in the system</li><li>Next column: interrupt type:<ul><li>IO-APIC-edge — edge-triggered interrupt for the I/O APIC controller</li><li>IO-APIC-fasteoi — level-triggered interrupt for the I/O APIC controller</li><li>PCI-MSI-edge — MSI interrupt</li><li>XT-PIC-XT-PIC — interrupt for the PIC controller</li></ul></li><li>Last column: device (driver) associated with this interrupt</li></ul><hr><p>参考资料:</p><ol><li><a href="https://geek-university.com/irq-interrupt-request/" target="_blank" rel="noopener">IRQ (Interrupt Request)</a></li><li><a href="http://bucarotechelp.com/computers/architecture/90032101.asp" target="_blank" rel="noopener">Interrupt Request Lines (IRQs) by Stephen Bucaro</a></li><li><a href="https://habr.com/en/articles/501660/" target="_blank" rel="noopener">External Interrupts in the x86 system. Part 2. Linux kernel boot options</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark下IRQs相关notes。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第35期</title>
    <link href="http://liujunming.github.io/2023/08/12/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC35%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2023/08/12/每周分享第35期/</id>
    <published>2023-08-11T23:31:57.000Z</published>
    <updated>2023-08-12T01:51:53.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="chrome-CCFRank"><a href="#chrome-CCFRank" class="headerlink" title="chrome CCFRank"></a>chrome CCFRank</h3><p><a href="https://chrome.google.com/webstore/detail/ccfrank/pfcajmbenomfbjnbjhgbnbdjmiklnkie" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/ccfrank/pfcajmbenomfbjnbjhgbnbdjmiklnkie</a><br>在dblp、Google学术、Connected Papers和WoS的搜索结果中显示中国计算机学会推荐的会议和期刊排名。<a id="more"></a></p><h3 id="Zotero论文管理"><a href="#Zotero论文管理" class="headerlink" title="Zotero论文管理"></a>Zotero论文管理</h3><p><a href="https://cloud.tencent.com/developer/article/1894275" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1894275</a><br><a href="https://www.zotero.org/" target="_blank" rel="noopener">https://www.zotero.org/</a></p><h3 id="Remote-Procedure-Calls"><a href="#Remote-Procedure-Calls" class="headerlink" title="Remote Procedure Calls"></a>Remote Procedure Calls</h3><p><a href="https://people.cs.rutgers.edu/~pxk/417/notes/rpc.html" target="_blank" rel="noopener">https://people.cs.rutgers.edu/~pxk/417/notes/rpc.html</a></p><h3 id="华为天才少年大模型创业-李博杰"><a href="#华为天才少年大模型创业-李博杰" class="headerlink" title="华为天才少年大模型创业 - 李博杰"></a>华为天才少年大模型创业 - 李博杰</h3><p><a href="https://mp.weixin.qq.com/s/XVHbQngpq36WtZSRRVlA9g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/XVHbQngpq36WtZSRRVlA9g</a></p><h3 id="李博杰面试经历分享"><a href="#李博杰面试经历分享" class="headerlink" title="李博杰面试经历分享"></a>李博杰面试经历分享</h3><p><a href="https://mp.weixin.qq.com/s/1Oozg1kcVoyYjf9F0ssAUQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1Oozg1kcVoyYjf9F0ssAUQ</a></p><h3 id="High-Bandwidth-Memory-HBM"><a href="#High-Bandwidth-Memory-HBM" class="headerlink" title="High-Bandwidth Memory (HBM)"></a>High-Bandwidth Memory (HBM)</h3><p><a href="https://www.amd.com/system/files/documents/high-bandwidth-memory-hbm.pdf" target="_blank" rel="noopener">https://www.amd.com/system/files/documents/high-bandwidth-memory-hbm.pdf</a></p><h3 id="Linux-之父“开炮”！曾喊-AMD-真香，今炮轰-AMD：怒批-fTPM-“愚蠢”、“破玩意儿”"><a href="#Linux-之父“开炮”！曾喊-AMD-真香，今炮轰-AMD：怒批-fTPM-“愚蠢”、“破玩意儿”" class="headerlink" title="Linux 之父“开炮”！曾喊 AMD 真香，今炮轰 AMD：怒批 fTPM “愚蠢”、“破玩意儿”"></a>Linux 之父“开炮”！曾喊 AMD 真香，今炮轰 AMD：怒批 fTPM “愚蠢”、“破玩意儿”</h3><p><a href="https://mp.weixin.qq.com/s/f5as7KGXCN3NJ5yAYcOAxg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/f5as7KGXCN3NJ5yAYcOAxg</a></p><h3 id="阿里造“神龙”"><a href="#阿里造“神龙”" class="headerlink" title="阿里造“神龙”"></a>阿里造“神龙”</h3><p><a href="https://mp.weixin.qq.com/s/Jp0CeqxyB6hlIeGyiw6Gnw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Jp0CeqxyB6hlIeGyiw6Gnw</a></p><h3 id="vmtouch命令"><a href="#vmtouch命令" class="headerlink" title="vmtouch命令"></a>vmtouch命令</h3><p><a href="https://www.cnblogs.com/coldplayerest/archive/2012/02/28/2371881.html" target="_blank" rel="noopener">https://www.cnblogs.com/coldplayerest/archive/2012/02/28/2371881.html</a></p><h3 id="ASAN-Address-Sanitizer"><a href="#ASAN-Address-Sanitizer" class="headerlink" title="ASAN(Address Sanitizer)"></a>ASAN(Address Sanitizer)</h3><p>ASan，即Address Sanitizer，是一个适用于c/c++程序的动态内存错误检测器，它由一个编译器检测模块（LLVM pass）和一个替换malloc函数的运行时库组成，在性能及检测内存错误方面都优于Valgrind。</p><p><a href="https://mp.weixin.qq.com/s/aGq2NFjIb7OZbv1lsV6UXA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/aGq2NFjIb7OZbv1lsV6UXA</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;chrome-CCFRank&quot;&gt;&lt;a href=&quot;#chrome-CCFRank&quot; class=&quot;headerlink&quot; title=&quot;chrome CCFRank&quot;&gt;&lt;/a&gt;chrome CCFRank&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/ccfrank/pfcajmbenomfbjnbjhgbnbdjmiklnkie&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://chrome.google.com/webstore/detail/ccfrank/pfcajmbenomfbjnbjhgbnbdjmiklnkie&lt;/a&gt;&lt;br&gt;在dblp、Google学术、Connected Papers和WoS的搜索结果中显示中国计算机学会推荐的会议和期刊排名。
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel SRCU usage</title>
    <link href="http://liujunming.github.io/2023/08/06/Linux-kernel-SRCU-usage/"/>
    <id>http://liujunming.github.io/2023/08/06/Linux-kernel-SRCU-usage/</id>
    <published>2023-08-06T01:56:41.000Z</published>
    <updated>2023-08-05T14:35:31.543Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark下Linux kernel中SRCU相关API的使用方法。<a id="more"></a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>Read-copy update (RCU)是一种在读多写少场景下可替代读写锁的高性能同步机制，RCU的读端不加锁，因此开销很低，不会被阻塞，执行的时间确定。这种设计决定了RCU写端不能阻塞读端，因此RCU写端的开销很高，因为它必须保留临界区数据直到没有读者访问，然后回收临界区数据</li><li>RCU要求访问临界区的读者不能睡眠或者被阻塞，原因是睡眠意味者上下文切换，进程的cpu被抢占，是不允许出现在处于临界区的读者身上的，因为会影响宽限期的检查。</li><li>在许多场景下我们又要求进程是可睡眠的，比如实时系统，高优先级的进程可以抢占低优先级进程的cpu，因此低优先级的进程必须让出cpu，低优先级进程如果拿了RCU的读锁，此时就会睡眠，会破坏RCU宽限期的检查。</li></ul><p>一个<strong>可以睡眠的RCU同步进制</strong>就被提了出来。</p><h2 id="SRCU-Implementation-Strategy"><a href="#SRCU-Implementation-Strategy" class="headerlink" title="SRCU Implementation Strategy"></a>SRCU Implementation Strategy</h2><p>将宽限期的检查隔离到一个子系统中，这样即使一个读者的睡眠时间无限延长，那么也只有处于这个子系统中的写者受到影响。</p><h2 id="SRCU-API-and-Usage"><a href="#SRCU-API-and-Usage" class="headerlink" title="SRCU API and Usage"></a>SRCU API and Usage</h2><p><a href="https://www.kernel.org/doc/Documentation/RCU/lockdep.txt" target="_blank" rel="noopener">Documentation/RCU/lockdep.txt</a>可以查询相关API的使用信息。</p><p>The SRCU API is shown in below. The following sections describe how to use it.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int init_srcu_struct(struct srcu_struct *sp);</span><br><span class="line">void cleanup_srcu_struct(struct srcu_struct *sp);</span><br><span class="line">int srcu_read_lock(struct srcu_struct *sp);</span><br><span class="line">void srcu_read_unlock(struct srcu_struct *sp, int idx);</span><br><span class="line">void synchronize_srcu(struct srcu_struct *sp);</span><br></pre></td></tr></table></figure></p><p>一个<code>struct srcu_struct</code>代表一个逻辑SRCU子系统。</p><h3 id="Initialization-and-Cleanup"><a href="#Initialization-and-Cleanup" class="headerlink" title="Initialization and Cleanup"></a>Initialization and Cleanup</h3><p>Each subsystem using SRCU must create an <code>struct srcu_struct</code>, either by declaring a variable of this type or by dynamically allocating the memory, for example, via <code>kmalloc()</code>. Once this structure is in place, it must be initialized via <code>init_srcu_struct()</code>, which returns zero for success or an error code for failure (for example, upon memory exhaustion).</p><p>If the <code>struct srcu_struct</code> is dynamically allocated, then <code>cleanup_srcu_struct()</code> must be called before it is freed. Similarly, if the struct <code>srcu_struct</code> is a variable declared within a Linux kernel module, then <code>cleanup_srcu_struct()</code> must be called before the module is unloaded. Either way, the caller must take care to ensure that all SRCU read-side critical sections have completed (and that no more will commence) before calling <code>cleanup_srcu_struct()</code>. </p><h3 id="Read-Side-Primitives"><a href="#Read-Side-Primitives" class="headerlink" title="Read-Side Primitives"></a>Read-Side Primitives</h3><p>The read-side <code>srcu_read_lock()</code> and <code>srcu_read_unlock()</code> primitives are used as shown:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idx = srcu_read_lock(&amp;ss);</span><br><span class="line"><span class="comment">/* read-side critical section. */</span></span><br><span class="line">srcu_read_unlock(&amp;ss, idx);</span><br></pre></td></tr></table></figure></p><p>The <code>ss</code> variable is the <code>struct srcu_struct</code> whose initialization was described above, and the <code>idx</code> variable is an integer that in effect tells <code>srcu_read_unlock()</code> the grace period during which the corresponding <code>srcu_read_lock()</code> started.</p><h3 id="Update-Side-Primitives"><a href="#Update-Side-Primitives" class="headerlink" title="Update-Side Primitives"></a>Update-Side Primitives</h3><p>The <code>synchronize_srcu()</code> primitives may be used as shown below:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list_del_rcu(p);</span><br><span class="line">synchronize_srcu(&amp;ss);</span><br><span class="line">kfree(p);</span><br></pre></td></tr></table></figure><p>As one might expect by analogy with Classic RCU, this primitive blocks until after the completion of all SRCU read-side critical sections that started before the <code>synchronize_srcu()</code> started, as shown in Table 1.</p><p><img src="/images/2023/07/002.jpg" alt></p><p>Here, CPU 1 need only wait for the completion of CPU 0’s SRCU read-side critical section. It need not wait for the completion of CPU 2’s SRCU read-side critical section, because CPU 2 did not start this critical section until <em>after</em> CPU 1 began executing <code>synchronize_srcu()</code>. Finally, CPU 1’s <code>synchronize_srcu()</code> need not wait for CPU 3’s SRCU read-side critical section, because CPU 3 is using <code>s2</code> rather than <code>s1</code> as its <code>struct srcu_struct</code>. CPU 3’s SRCU read-side critical section is thus related to a different set of grace periods than those of CPUs 0 and 2.</p><h3 id="MISC-API"><a href="#MISC-API" class="headerlink" title="MISC API"></a>MISC API</h3><ul><li>synchronize_srcu_expedited</li></ul><p>Wait for an SRCU grace period to elapse, but be more aggressive about spinning rather than blocking when waiting.</p><ul><li>srcu_dereference_check</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * srcu_dereference_check - fetch SRCU-protected pointer for later dereferencing</span></span><br><span class="line"><span class="comment"> * @p: the pointer to fetch and protect for later dereferencing</span></span><br><span class="line"><span class="comment"> * @ssp: pointer to the srcu_struct, which is used to check that we</span></span><br><span class="line"><span class="comment"> *  really are in an SRCU read-side critical section.</span></span><br><span class="line"><span class="comment"> * @c: condition to check for update-side use</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If PROVE_RCU is enabled, invoking this outside of an RCU read-side</span></span><br><span class="line"><span class="comment"> * critical section will result in an RCU-lockdep splat, unless @c evaluates</span></span><br><span class="line"><span class="comment"> * to 1.  The @c argument will normally be a logical expression containing</span></span><br><span class="line"><span class="comment"> * lockdep_is_held() calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> srcu_dereference_check(p, ssp, c) \</span></span><br><span class="line">    __rcu_dereference_check((p), (c) || srcu_read_lock_held(ssp), __rcu)</span><br></pre></td></tr></table></figure><p>readers/updaters均可能会调用该函数。</p><hr><p>参考资料:</p><ol><li><a href="https://blog.csdn.net/huang987246510/article/details/102762067" target="_blank" rel="noopener">SRCU的简单实现</a></li><li><a href="https://blog.csdn.net/huang987246510/article/details/103039355" target="_blank" rel="noopener">SRCU的内核简单实现</a></li><li><a href="https://lwn.net/Articles/202847/" target="_blank" rel="noopener">Sleepable RCU</a></li><li><a href="https://linuxtv.org/downloads/v4l-dvb-internals/device-drivers/API-synchronize-srcu-expedited.html" target="_blank" rel="noopener">synchronize_srcu_expedited</a></li><li><a href="https://linuxtv.org/downloads/v4l-dvb-internals/device-drivers/API-synchronize-srcu.html" target="_blank" rel="noopener">synchronize_srcu</a></li><li><a href="https://docs.kernel.org/core-api/kernel-api.html#c.srcu_dereference_check" target="_blank" rel="noopener">srcu_dereference_check</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark下Linux kernel中SRCU相关API的使用方法。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Notes about cmpxchg/cmpxchg64 in Linux kernel</title>
    <link href="http://liujunming.github.io/2023/08/05/Notes-about-cmpxchg-cmpxchg64-in-Linux-kernel/"/>
    <id>http://liujunming.github.io/2023/08/05/Notes-about-cmpxchg-cmpxchg64-in-Linux-kernel/</id>
    <published>2023-08-05T05:28:09.000Z</published>
    <updated>2023-08-05T08:01:32.939Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark下Linux kernel中cmpxchg/cmpxchg64的相关笔记。<a id="more"></a>对于底层实现的硬件原理，待有空了再分析。</p><p>本文参考的内核版本为<a href="https://elixir.bootlin.com/linux/v5.0/source" target="_blank" rel="noopener">v5.0</a>。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>cmpxchg(void* ptr, int old, int new) 将old和ptr指向的内容比较</p><ul><li>如果相等，则将new写入到ptr中，返回old</li><li>如果不相等，则返回ptr指向的内容</li></ul><p>整个过程中操作是原子的。</p><p>From the point of view of a Linux kernel programmer, compare-and-swap has the following prototype:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T cmpxchg(T *ptr, T old, T new);</span><br></pre></td></tr></table></figure></p><p>where <code>T</code> can be either an integer type that is at most as wide as a pointer, or a pointer type. In order to support such polymorphism, <code>cmpxchg()</code> is defined as a macro rather than a function, but the macro is written carefully to avoid evaluating its arguments multiple times. Linux also has a <code>cmpxchg64()</code> macro that takes 64-bit integers as the arguments, but it may not be available on all 32-bit platforms.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Posted-Interrupt Descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pi_desc</span> &#123;</span></span><br><span class="line">    u32 pir[<span class="number">8</span>];     <span class="comment">/* Posted interrupt requested */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                <span class="comment">/* bit 256 - Outstanding Notification */</span></span><br><span class="line">            u16 on  : <span class="number">1</span>,</span><br><span class="line">                <span class="comment">/* bit 257 - Suppress Notification */</span></span><br><span class="line">                sn  : <span class="number">1</span>,</span><br><span class="line">                <span class="comment">/* bit 271:258 - Reserved */</span></span><br><span class="line">                rsvd_1  : <span class="number">14</span>;</span><br><span class="line">                <span class="comment">/* bit 279:272 - Notification Vector */</span></span><br><span class="line">            u8  nv;</span><br><span class="line">                <span class="comment">/* bit 287:280 - Reserved */</span></span><br><span class="line">            u8  rsvd_2;</span><br><span class="line">                <span class="comment">/* bit 319:288 - Notification Destination */</span></span><br><span class="line">            u32 ndst;</span><br><span class="line">        &#125;;</span><br><span class="line">        u64 control;</span><br><span class="line">    &#125;;</span><br><span class="line">    u32 rsvd[<span class="number">6</span>];</span><br><span class="line">&#125; __aligned(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __pi_post_block(struct kvm_vcpu *vcpu)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pi_desc</span> *<span class="title">pi_desc</span> = <span class="title">vcpu_to_pi_desc</span>(<span class="title">vcpu</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pi_desc</span> <span class="title">old</span>, <span class="title">new</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        old.control = <span class="keyword">new</span>.control = pi_desc-&gt;control;</span><br><span class="line">        WARN(old.nv != POSTED_INTR_WAKEUP_VECTOR,</span><br><span class="line">             <span class="string">"Wakeup handler not enabled while the VCPU is blocked\n"</span>);</span><br><span class="line"></span><br><span class="line">        dest = cpu_physical_id(vcpu-&gt;cpu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x2apic_enabled())</span><br><span class="line">            <span class="keyword">new</span>.ndst = dest;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">new</span>.ndst = (dest &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xFF00</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set 'NV' to 'notification vector' */</span></span><br><span class="line">        <span class="keyword">new</span>.nv = POSTED_INTR_VECTOR;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cmpxchg64(&amp;pi_desc-&gt;control, old.control,</span><br><span class="line">               <span class="keyword">new</span>.control) != old.control);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是:<code>ndst</code>和<code>nv</code>field均属于pi_desc的<code>control</code>。</p><p>在上述代码片段中，old.control的类型是u64，在第31行到43行执行过程中，IOMMU硬件是有可能更改 <code>on</code> （Outstanding Notification）bit的，也就是说pi_desc-&gt;control的内容可能会发生变化。<br>因此会在第44行到45行检测pi_desc-&gt;control与old.control是否相等:</p><ul><li>如果相等(说明过程中IOMMU硬件没有更改<code>on</code>)，就将new.control写入到&amp;pi_desc-&gt;control中，并返回old.control，则会跳出do while循环</li><li>如果不相等(说明过程中IOMMU硬件更改了<code>on</code>)，就会返回pi_desc-&gt;control，则继续进入do while循环</li></ul><hr><p>参考资料:</p><ol><li><a href="https://blog.csdn.net/zdy0_2004/article/details/48013829" target="_blank" rel="noopener">Linux内核中的cmpxchg函数</a></li><li><a href="https://cloud.tencent.com/developer/article/1021133" target="_blank" rel="noopener">Linux Kernel CMPXCHG函数分析</a></li><li><a href="https://lostjeffle.bitcron.com/post/blog/mweb/docs/15936033639789" target="_blank" rel="noopener">Atomic - Reference Count</a></li><li><a href="https://blog.csdn.net/Linux_Everything/article/details/115315107" target="_blank" rel="noopener">LWN: Lockless编程模式 - 介绍compare-and-swap！</a></li><li><a href="https://lwn.net/Articles/847973/" target="_blank" rel="noopener">Lockless patterns: an introduction to compare-and-swap</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark下Linux kernel中cmpxchg/cmpxchg64的相关笔记。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>(转)自动检测 Linux 错误的工具 - 静态篇</title>
    <link href="http://liujunming.github.io/2023/08/05/%E8%BD%AC-%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B-Linux-%E9%94%99%E8%AF%AF%E7%9A%84%E5%B7%A5%E5%85%B7-%E9%9D%99%E6%80%81%E7%AF%87/"/>
    <id>http://liujunming.github.io/2023/08/05/转-自动检测-Linux-错误的工具-静态篇/</id>
    <published>2023-08-05T02:09:21.000Z</published>
    <updated>2023-08-05T02:37:19.233Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自: <a href="https://zhuanlan.zhihu.com/p/641596339" target="_blank" rel="noopener">兰新宇:自动检测 Linux 错误的工具 - 静态篇</a><a id="more"></a></p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>怎么检测出代码中存在的 bug？目前主要的手段一是靠测试，研发自测、QA 测试，二是靠 code review。测试如果自动化程度不高，会耗费大量的人力，而 code review 取决于 reviewer 的能力和责任心，也难免存在疏忽。</p><p>当代码量越来越大时，通过肉眼来发现错误也变得愈发的困难，这时就需要借助一些工具，自动地帮我们找到代码中潜在的问题。这样的工具可分为两类：在代码的编译阶段分析缺陷的（静态检测），和在代码的运行阶段识别异常的（动态检测）。</p><p>市面上 static analysis tools 繁多，这里介绍三种免费的、适用于 Linux 内核的，且笔者亲身使用过的。</p><h3 id="Sparse"><a href="#Sparse" class="headerlink" title="Sparse"></a>Sparse</h3><p>这是由 Linus Torvalds 本尊于 2003 年开发的（可能是 semantic parser 的意思），是 Linux 内核原生的、默认的代码静态检查工具。</p><p>之所以说它是默认的，从它的用法上就可以看出端倪。下载<a href="https://git.kernel.org/pub/scm/devel/sparse/sparse.git" target="_blank" rel="noopener">sparse源码</a>后，执行 “make” 命令编译，然后 “make install” 将其安装到系统环境变量可识别的路径（比如 “/usr/bin”），然后在编译内核/驱动时， make 参数加上 “C=2”（或 “C=1”）即可。</p><p>C 表示 Checker，打开 Linux 顶层 Makefile 看下，”CHECK” 变量的初始设定就是 “sparse” 。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make C=1  [targets] Check re-compiled c source with $$CHECK (sparse by default)'</span><br><span class="line">make C=2  [targets] Force check of all c source with $$CHECK'</span><br></pre></td></tr></table></figure></p><p>sparse 侧重于数据类型的检查，其在预编译阶段就埋下了自己的 hook：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CHECKER__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __iomem __attribute__((noderef, address_space(2)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __iomem</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>像 “__iomem” 代表的<a href="https://zhuanlan.zhihu.com/p/609594794" target="_blank" rel="noopener">I/O memory</a>，映射后是不适合直接用指针（虚拟地址）读写的，而应该使用和<br>CPU arch 相适配的专有 API 来访问（比如 readl 和 writel）。如果你违反了这个规则，sparse 就会给出告警。</p><p>类似地还有表示用户态地址的 “__user” 关键字，是不适合在内核态直接读写的。</p><h3 id="Smatch"><a href="#Smatch" class="headerlink" title="Smatch"></a>Smatch</h3><p>Sparse 可以说是简单高效，但其检测范围有限，一个更强大的工具是 smatch。其使用方法同 sparse 类似，也是<a href="https://repo.or.cz/w/smatch.git" target="_blank" rel="noopener">下载源码</a>后 make，稍有区别的是由于它不是嫡子，需要手动指定下它的安装路径，并且声明 -p（代表 project）为 “kernel”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CHECK=&quot;~/&lt;path-to-smatch&gt;/smatch -p=kernel&quot; C=1</span><br></pre></td></tr></table></figure></p><p>smatch 擅长 flow analysis ，下面以伪代码来展示一个案例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># alloc mememory for A</span><br><span class="line"></span><br><span class="line"># check whethe A is on list, if not, add it to list</span><br><span class="line"></span><br><span class="line"># function return</span><br></pre></td></tr></table></figure></p><p>如果 A 被加入链表，那么 A 的内存会在链表销毁时释放，但是如果没有加入链表，内存就没有释放，smatch 会在函数返回时提示 “possible memory leak of A”。</p><p>当然，这属于程序设计的不妥当，正常应该先确定 A 不在链表，再为 A 分配内存。类似的还有异常返回时 mutex 没有 unlock 等，都算是资源泄露。</p><p>另一个 smatch 的优势是跟踪变量在生命周期内的值，同样通过伪代码的形式来说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int A;</span><br><span class="line"></span><br><span class="line">if (...)</span><br><span class="line">    # add object to link（and assign a non-zero value to A）</span><br><span class="line"></span><br><span class="line">if (A)</span><br><span class="line">    # remove object from link</span><br></pre></td></tr></table></figure></p><p>第二个 if 的意图是判断 A 非 0，说明之前被加入过链表，那么之后需要从链表移除，但其隐含了一个假设，就是变量 A 会被初始化为 0。但 C 语言里 local variable 是否初始化为 0 是编译器的行为，<a href="https://stackoverflow.com/questions/21152138/local-variable-initialized-to-zero-in-c" target="_blank" rel="noopener">是不可靠的</a>，smatch 会提示 “uninitialized symbol A”。</p><p>此外，如果你用的一个内核 API 有了一个更推荐的版本，smatch 也会给你指出来，比如用更简洁的 kvcalloc 替换 kvmalloc_array。</p><p>其中当然不可避免地会有一些 false positive 的 warning/error，但笔者并不愿将其称之为<strong>误报</strong>。虽然仔细分析报告点的代码逻辑后，发现没有问题，但这样的代码多少是有些别扭的，语义上不是很直接，结构上是存在可以优化的空间的。</p><p>文末链接里有 smatch 的开发者 Dan Carpenter 的一个分享，他提到 smatch 还在不断演进，还有不少<a href="https://github.com/illumos/smatch/blob/master/Documentation/TODO.md" target="_blank" rel="noopener">可以加强的地方</a>，比如 scheduling in atomic 的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spin_lock(A)</span><br><span class="line">mutex_lock(B)</span><br><span class="line"># do something</span><br><span class="line">mutex_unlock(B)</span><br><span class="line">spin_unlock(A)</span><br></pre></td></tr></table></figure></p><p>要说它的缺点么，大概就是文档比较匮乏吧。这是作者自己说的，笔者在使用过程中也有同感，里面好多 scripts 不会用，白瞎了。</p><h3 id="Cppcheck"><a href="#Cppcheck" class="headerlink" title="Cppcheck"></a>Cppcheck</h3><p>以上介绍的两种工具都主要面向 Linux 内核，而更为广泛使用的一个工具是 cppcheck，从名字上也可看出来，只要是 C/C++ 程序，它都可以。</p><p>不需要手动去找源码来下载，直接 “yum/apt install cppcheck” 就可以安装（从安装方式的差异也能看出，它确实被用的更普遍，进了默认的软件镜像源）。</p><p>用法也很简单，直接 <code>cppcheck &lt;file-name&gt;/&lt;folder-name&gt;</code>即可检测单个文件，或目录中所有文件。 默认仅检测 error 级别的，可加上 “–enable=warning” 来使能 warning 级别的（甚至可以是 style 级别）。</p><p>cppchek 算是对 compiler 的一种补充吧， 来看几个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pdev = get_dev_by_id(...);</span><br><span class="line"><span class="keyword">if</span> (!pdev)</span><br><span class="line">    dev_err(pdev-&gt;dev, ...);</span><br></pre></td></tr></table></figure></p><p>指针判空之后，为了打印信息的需要（表示哪个 dev 出了问题），无意中造成了 null pointer deference。这种异常分支的错误靠测试很难发现（corner case），因为平时走不进去，但一旦进去了，就是系统 crash 的大雷啊。</p><p>再比如下面这个，如果 “pdev-&gt;dev” 为空，那么 if 条件判断还会继续，那 “pdev-&gt;dev-&gt;type” 不又是妥妥的「空指针引用」嘛。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!pdev-&gt;dev &amp;&amp; !pdev-&gt;dev-&gt;type)</span><br></pre></td></tr></table></figure><p>其他像内存泄露的一些问题，也能被 cppcheck 检查出来。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>静态检查工具可以在编译阶段就发现很多潜在的隐患，是保障代码质量的一种<strong>低成本</strong>方案。比如 memory leak 吧，目前 Linux 内核也就能用 kmemleak 来检查，但往往需要重新编译内核不说，没执行到的异常分支造成的泄露还检测不出来。所以，目前有些公司要求代码提交必须通过 cppcheck 检测，不失为一种值得效仿的业界最佳实践（ best practice）。</p><p>这三种静态工具在检测范围上有一些重叠的地方，但也各有各的特色。如果条件允许的话，建议都用上，反正使用成本都比较低，如果非只能选一种的话，那笔者会选择效果最为拔群的 smatch。</p><hr><p>参考资料:</p><ol><li><a href="https://lwn.net/Articles/689907/" target="_blank" rel="noopener">Sparse: a look under the hood</a></li><li><a href="https://lwn.net/Articles/87538/" target="_blank" rel="noopener">Finding kernel problems automatically</a></li><li><a href="https://man7.org/linux/man-pages/man1/sparse.1.html" target="_blank" rel="noopener">sparse(1) - Linux manual page</a></li><li><a href="https://events.linuxfoundation.org/wp-content/uploads/2022/10/Dan-Carpenter-Smatch-Mentorship-Series-Presentation-Template.pdf" target="_blank" rel="noopener">Smatch: New ideas for Static Analysis</a></li><li><a href="https://lwn.net/Articles/691882/" target="_blank" rel="noopener">Smatch: pluggable static analysis for C</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/641596339&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;兰新宇:自动检测 Linux 错误的工具 - 静态篇&lt;/a&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel RCU usage</title>
    <link href="http://liujunming.github.io/2023/07/30/Linux-kernel-RCU-usage/"/>
    <id>http://liujunming.github.io/2023/07/30/Linux-kernel-RCU-usage/</id>
    <published>2023-07-30T14:08:27.000Z</published>
    <updated>2023-08-05T13:40:13.334Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍Linux kernel中RCU的使用。<a id="more"></a></p><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>需要仔细阅读<a href="/2018/12/13/深入理解-Linux-的-RCU-机制/">深入理解 Linux 的 RCU 机制</a>。</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://lwn.net/Articles/609973/" target="_blank" rel="noopener">The RCU API tables</a><br><a href="https://lwn.net/Articles/263130/" target="_blank" rel="noopener">What is RCU? Part 2: Usage</a><br><a href="https://www.kernel.org/doc/Documentation/RCU/lockdep.txt" target="_blank" rel="noopener">Documentation/RCU/lockdep.txt</a>可以查询相关API的使用信息。</p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p><a href="https://github.com/jinb-park/rcu_example/blob/master/list_rcu_example.c" target="_blank" rel="noopener">list_rcu_example</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * list_rcu_example.c - list rcu sample module</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016 Jinbum Park &lt;jinb.park7@gmail.com&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is free software; you can redistribute it and/or</span></span><br><span class="line"><span class="comment"> * modify it under the terms of the GNU General Public License</span></span><br><span class="line"><span class="comment"> * as published by the Free Software Foundation; either version 2</span></span><br><span class="line"><span class="comment"> * of the License, or (at your option) any later version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment"> * GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment"> * along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rculist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/preempt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct book - a book</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @borrow: If it is 0, book is not borrowed. it is 1, book is borrowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> borrow;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(books)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">spinlock_t</span> books_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * callback function for async-reclaim</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * call_rcu()       :  callback function is called when finish to wait every grace periods (async)</span></span><br><span class="line"><span class="comment"> * synchronize_rcu() :  wait to finish every grace periods (sync)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">book_reclaim_callback</span><span class="params">(struct rcu_head *rcu)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span> = <span class="title">container_of</span>(<span class="title">rcu</span>, <span class="title">struct</span> <span class="title">book</span>, <span class="title">rcu</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Why print preemt_count??</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * To check whether this callback is atomic context or not.</span></span><br><span class="line"><span class="comment">     * preempt_count here is more than 0. Because it is irq context.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pr_info(<span class="string">"callback free : %lx, preempt_count : %d\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)b, preempt_count());</span><br><span class="line">    kfree(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_book</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *author)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    b = kzalloc(<span class="keyword">sizeof</span>(struct book), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    b-&gt;id = id;</span><br><span class="line">    <span class="built_in">strncpy</span>(b-&gt;name, name, <span class="keyword">sizeof</span>(b-&gt;name));</span><br><span class="line">    <span class="built_in">strncpy</span>(b-&gt;author, author, <span class="keyword">sizeof</span>(b-&gt;author));</span><br><span class="line">    b-&gt;borrow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * list_add_rcu</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * add_node(writer - add) use spin_lock()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    spin_lock(&amp;books_lock);</span><br><span class="line">    list_add_rcu(&amp;b-&gt;node, &amp;books);</span><br><span class="line">    spin_unlock(&amp;books_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">borrow_book</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">new_b</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">old_b</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * updater</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * (updater) require that alloc new node &amp; copy, update new node &amp; reclaim old node</span></span><br><span class="line"><span class="comment">     * list_replace_rcu() is used to do that.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(b, &amp;books, node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;id == id) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b-&gt;borrow) &#123;</span><br><span class="line">                rcu_read_unlock();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            old_b = b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!old_b) &#123;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    new_b = kzalloc(<span class="keyword">sizeof</span>(struct book), GFP_ATOMIC);</span><br><span class="line">    <span class="keyword">if</span>(!new_b) &#123;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_b, old_b, <span class="keyword">sizeof</span>(struct book));</span><br><span class="line">    new_b-&gt;borrow = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    spin_lock(&amp;books_lock);</span><br><span class="line">    list_replace_rcu(&amp;old_b-&gt;node, &amp;new_b-&gt;node);</span><br><span class="line">    spin_unlock(&amp;books_lock);</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(async) &#123;</span><br><span class="line">        call_rcu(&amp;old_b-&gt;rcu, book_reclaim_callback);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        synchronize_rcu();</span><br><span class="line">        kfree(old_b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"borrow success %d, preempt_count : %d\n"</span>, id, preempt_count());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">is_borrowed_book</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reader</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * iteration(read) require rcu_read_lock(), rcu_read_unlock()</span></span><br><span class="line"><span class="comment">     * and use list_for_each_entry_rcu()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    list_for_each_entry_rcu(b, &amp;books, node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;id == id) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">return</span> b-&gt;borrow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    pr_err(<span class="string">"not exist book\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">return_book</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">new_b</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">old_b</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * updater</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * (updater) require that alloc new node &amp; copy, update new node &amp; reclaim old node</span></span><br><span class="line"><span class="comment">     * list_replace_rcu() is used to do that.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(b, &amp;books, node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;id == id) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!b-&gt;borrow) &#123;</span><br><span class="line">                rcu_read_unlock();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            old_b = b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!old_b) &#123;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    new_b = kzalloc(<span class="keyword">sizeof</span>(struct book), GFP_ATOMIC);</span><br><span class="line">    <span class="keyword">if</span>(!new_b) &#123;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_b, old_b, <span class="keyword">sizeof</span>(struct book));</span><br><span class="line">    new_b-&gt;borrow = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    spin_lock(&amp;books_lock);</span><br><span class="line">    list_replace_rcu(&amp;old_b-&gt;node, &amp;new_b-&gt;node);</span><br><span class="line">    spin_unlock(&amp;books_lock);</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(async) &#123;</span><br><span class="line">        call_rcu(&amp;old_b-&gt;rcu, book_reclaim_callback);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        synchronize_rcu();</span><br><span class="line">        kfree(old_b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"return success %d, preempt_count : %d\n"</span>, id, preempt_count());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_book</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;books_lock);</span><br><span class="line">    list_for_each_entry(b, &amp;books, node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;id == id) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * list_del</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * del_node(writer - delete) require locking mechanism.</span></span><br><span class="line"><span class="comment">             * we can choose 3 ways to lock. Use 'a' here.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  a.  locking,</span></span><br><span class="line"><span class="comment">             *  b.  atomic operations, or</span></span><br><span class="line"><span class="comment">             *  c.  restricting updates to a single task.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            list_del_rcu(&amp;b-&gt;node);</span><br><span class="line">            spin_unlock(&amp;books_lock);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(async) &#123;</span><br><span class="line">                call_rcu(&amp;b-&gt;rcu, book_reclaim_callback);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                synchronize_rcu();</span><br><span class="line">                kfree(b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;books_lock);</span><br><span class="line"></span><br><span class="line">    pr_err(<span class="string">"not exist book\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_book</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    list_for_each_entry_rcu(b, &amp;books, node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;id == id) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Why print address of "struct book *b"??</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * If b was updated, address of b must be different.</span></span><br><span class="line"><span class="comment">             * We can know whether b is updated or not by address.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            pr_info(<span class="string">"id : %d, name : %s, author : %s, borrow : %d, addr : %lx\n"</span>, \</span><br><span class="line">                        b-&gt;id, b-&gt;name, b-&gt;author, b-&gt;borrow, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)b);</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    pr_err(<span class="string">"not exist book\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_example</span><span class="params">(<span class="keyword">int</span> async)</span> </span>&#123;</span><br><span class="line">    add_book(<span class="number">0</span>, <span class="string">"book1"</span>, <span class="string">"jb"</span>);</span><br><span class="line">    add_book(<span class="number">1</span>, <span class="string">"book2"</span>, <span class="string">"jb"</span>);</span><br><span class="line"></span><br><span class="line">    print_book(<span class="number">0</span>);</span><br><span class="line">    print_book(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"book1 borrow : %d\n"</span>, is_borrowed_book(<span class="number">0</span>));</span><br><span class="line">    pr_info(<span class="string">"book2 borrow : %d\n"</span>, is_borrowed_book(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    borrow_book(<span class="number">0</span>, async);</span><br><span class="line">    borrow_book(<span class="number">1</span>, async);</span><br><span class="line"></span><br><span class="line">    print_book(<span class="number">0</span>);</span><br><span class="line">    print_book(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    return_book(<span class="number">0</span>, async);</span><br><span class="line">    return_book(<span class="number">1</span>, async);</span><br><span class="line"></span><br><span class="line">    print_book(<span class="number">0</span>);</span><br><span class="line">    print_book(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    delete_book(<span class="number">0</span>, async);</span><br><span class="line">    delete_book(<span class="number">1</span>, async);</span><br><span class="line"></span><br><span class="line">    print_book(<span class="number">0</span>);</span><br><span class="line">    print_book(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">list_rcu_example_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    spin_lock_init(&amp;books_lock);</span><br><span class="line"></span><br><span class="line">    test_example(<span class="number">0</span>);</span><br><span class="line">    test_example(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_rcu_example_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(list_rcu_example_init);</span><br><span class="line">module_exit(list_rcu_example_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><h3 id="struct-rcu-head"><a href="#struct-rcu-head" class="headerlink" title="struct rcu_head"></a>struct rcu_head</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct callback_head - callback structure for use with RCU and task_work</span></span><br><span class="line"><span class="comment"> * @next: next update requests in a list</span></span><br><span class="line"><span class="comment"> * @func: actual update function to call after the grace period.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The struct is aligned to size of pointer. On most architectures it happens</span></span><br><span class="line"><span class="comment"> * naturally due ABI requirements, but some architectures (like CRIS) have</span></span><br><span class="line"><span class="comment"> * weird ABI and we need to ask it explicitly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The alignment is required to guarantee that bit 0 of @next will be</span></span><br><span class="line"><span class="comment"> * clear under normal conditions -- as long as we use call_rcu() or</span></span><br><span class="line"><span class="comment"> * call_srcu() to queue the callback.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This guarantee is important for few reasons:</span></span><br><span class="line"><span class="comment"> *  - future call_rcu_lazy() will make use of lower bits in the pointer;</span></span><br><span class="line"><span class="comment"> *  - the structure shares storage space in struct page with @compound_head,</span></span><br><span class="line"><span class="comment"> *    which encode PageTail() in bit 0. The guarantee is needed to avoid</span></span><br><span class="line"><span class="comment"> *    false-positive PageTail().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(struct callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>回调的时候使用，可以结合call_rcu(Queue an RCU callback for invocation after a grace period)使用。</p><h3 id="rcu-dereference-protected"><a href="#rcu-dereference-protected" class="headerlink" title="rcu_dereference_protected"></a>rcu_dereference_protected</h3><p><code>rcu_dereference_protected()</code> primitive is used to access RCU-protected pointers from update-side code. Because the update-side code is using some other synchronization mechanism (locks, atomic operations, single updater thread, etc.), it does not need to put RCU read-side protections in place. This primitive also takes a lockdep expression, which can be used to assert that the right locks are held and that any other necessary conditions hold.</p><p><img src="/images/2023/07/001.jpg" alt></p><h3 id="rcu"><a href="#rcu" class="headerlink" title="__rcu"></a>__rcu</h3><p>If the kernel is built with the <code>CONFIG_SPARSE_RCU_POINTER</code> config option, <code>__rcu</code> is defined in <code>include/linux/compiler.h</code> as<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># define __rcu          __attribute__((noderef, address_space(4)))</span><br></pre></td></tr></table></figure></p><p>This is an annotation for a the Sparse code analysis tool that can warn about certain things the programmer may have overlooked. How this is relevant to RCU is explained in <a href="https://www.kernel.org/doc/Documentation/RCU/checklist.txt" target="_blank" rel="noopener">Documentation/RCU/checklist.txt</a>:</p><blockquote><p>__rcu sparse checks: tag the pointer to the RCU-protected data structure with __rcu, and sparse will warn you if you access that pointer without the services of one of the variants of rcu_dereference().</p></blockquote><p><code>rcu_dereference()</code> returns a pointer that can be safely dereferenced by the code and documents the programmer’s intention to protect the pointer with the RCU mechanism, enabling tools like Sparse to check for programming errors and omissions.</p><hr><p>参考资料:</p><ol><li><a href="https://lwn.net/Articles/777036/" target="_blank" rel="noopener">The RCU API, 2019 edition</a></li><li><a href="https://stackoverflow.com/questions/39251287/rcu-dereference-vs-rcu-dereference-protected" target="_blank" rel="noopener">rcu_dereference() vs rcu_dereference_protected()?</a></li><li><a href="https://stackoverflow.com/questions/17128210/what-does-rcu-stands-for-in-linux" target="_blank" rel="noopener">what does __rcu stands for in linux?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍Linux kernel中RCU的使用。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>kprobe/kretprobe使用方法</title>
    <link href="http://liujunming.github.io/2023/07/22/%E8%BD%AC-kprobe-kretprobe%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://liujunming.github.io/2023/07/22/转-kprobe-kretprobe使用方法/</id>
    <published>2023-07-22T07:54:06.000Z</published>
    <updated>2023-07-22T08:37:45.001Z</updated>
    
    <content type="html"><![CDATA[<p>转载自:<a href="https://kernel.love/kprobe.html" target="_blank" rel="noopener">https://kernel.love/kprobe.html</a> <a id="more"></a> </p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>有时候想知道下发某个操作后内核在做些什么，这个时候就要对内核进行调试， 然而KGDB这种方法操作起来相对麻烦，这个时候我们就可以使用kprobe来探测内核的行为。</p><p>介绍kprobe和kretprobe的文档为:<a href="https://www.kernel.org/doc/Documentation/kprobes.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/kprobes.txt</a></p><p>划重点，这里是文档和很多博客没有解释清楚的地方：</p><ol><li>对于kprobe而言，理论上它可以probe任何一个地方（只需要指定某个代码段地址就行了，例如函数的地址）；</li><li>对于kprobe而言，pre_handler回调函数执行是发生在probe断点执行之前，post_handler回调执行是发生在probe断点<em>单步执行</em>之后，而不是函数返回之前；</li><li>对于kretprobe而言，一般只用来探测函数，entry_handler回调执行是在函数入口的地方（这时候我们可以探测函数的入参），handler回调函数执行是发生在函数准备返回的时候，注意这个时候参数都已经弹栈，我们只能探测函数的返回值。</li></ol><h2 id="kprobe"><a href="#kprobe" class="headerlink" title="kprobe"></a>kprobe</h2><p>下面举一个最简单的例子，介绍如何使用kprobe来查看<code>inet_bind</code>这个函数的调用情况。 <code>inet_bind</code>函数是在发生ipv4 socket bind阶段调用的一个内核函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched/clock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kprobes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ptrace.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sockios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/net.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/inet_common.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* For each probe you need to allocate a kprobe structure */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kprobe</span> <span class="title">kp</span> = &#123;</span></span><br><span class="line">    .symbol_name    = <span class="string">"inet_bind"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kprobe pre_handler: called just before the probed instruction is executed */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handler_pre</span><span class="params">(struct kprobe *p, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARM64</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span> = <span class="title">regs</span>-&gt;<span class="title">regs</span>[0];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">uaddr</span> = <span class="title">regs</span>-&gt;<span class="title">regs</span>[1];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span> = <span class="title">regs</span>-&gt;<span class="title">di</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">uaddr</span> = <span class="title">regs</span>-&gt;<span class="title">si</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> =  (<span class="title">struct</span> <span class="title">sockaddr_in</span> *)<span class="title">uaddr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> snum = ntohs(addr-&gt;sin_port);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"%s name:%s pid:%d socket bind port=%d\n"</span>,</span><br><span class="line">            p-&gt;symbol_name, current-&gt;comm, task_pid_nr(current), snum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* kprobe post_handler: called after the probed instruction is executed */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler_post</span><span class="params">(struct kprobe *p, struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">"%s called\n"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fault_handler: this is called if an exception is generated for any</span></span><br><span class="line"><span class="comment"> * instruction within the pre- or post-handler, or when Kprobes</span></span><br><span class="line"><span class="comment"> * single-steps the probed instruction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handler_fault</span><span class="params">(struct kprobe *p, struct pt_regs *regs, <span class="keyword">int</span> trapnr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"fault_handler: p-&gt;addr = 0x%p, trap #%dn"</span>,</span><br><span class="line">            p-&gt;addr, trapnr);</span><br><span class="line">    <span class="comment">/* Return 0 because we don't handle the fault. */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">kprobe_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    kp.pre_handler = handler_pre;</span><br><span class="line">    kp.post_handler = handler_post;</span><br><span class="line">    kp.fault_handler = handler_fault;</span><br><span class="line"></span><br><span class="line">    ret = register_kprobe(&amp;kp);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">"register_kprobe failed, returned %d\n"</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Planted kprobe at %p\n"</span>, kp.addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">kprobe_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unregister_kprobe(&amp;kp);</span><br><span class="line">    printk(KERN_INFO <span class="string">"kprobe at %p unregistered\n"</span>, kp.addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kprobe_init)</span><br><span class="line">module_exit(kprobe_exit)</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><p>使用下面的Makefile文件，对其进行编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m := kprobe_example.o</span><br><span class="line">CROSS_COMPILE=&apos;&apos;</span><br><span class="line">KDIR := /lib/modules/$(shell uname -r)/build</span><br><span class="line">all:  </span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules   </span><br><span class="line">clean:  </span><br><span class="line">    rm -f *.ko *.o *.mod.o *.mod.c .*.cmd *.symvers  modul*</span><br></pre></td></tr></table></figure></p><p>编译完成后会生产一个名为<em>kprobe_example.ko</em>的内核模块文件，执行<code>insmod kprobe_example.ko</code>后内核模块立即生效，通过<code>dmesg</code>命令可以查看到<code>inet_bind</code>这个函数的调用情况。从dmesg日志可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[46071.632951] inet_bind name:test pid:68248 socdmket bind port=49152</span><br><span class="line">[46071.632984] inet_bind name:test pid:68248 socket bind port=49152</span><br><span class="line">[46071.632995] inet_bind name:test pid:68248 socket bind port=49152</span><br></pre></td></tr></table></figure></p><h3 id="函数参数获取"><a href="#函数参数获取" class="headerlink" title="函数参数获取"></a>函数参数获取</h3><p>值得一提的是，kprobe里面我们在probe某个函数的时候，获取函数参数的时候是和体系结构相关的。</p><p>例如：在x86平台上，根据C ABI <a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/ptrace.h" target="_blank" rel="noopener">ptrace</a>接口规范，函数的参数和pt_regs的对应关系是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren't saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled "struct pt_regs".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r15;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r14;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r13;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r12;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> bp;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> bx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r11;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r10;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r9;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r8;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> ax;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> cx;   <span class="comment">// mapped to arg[3]</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> dx;   <span class="comment">// mapped to arg[2]</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> si;   <span class="comment">// mapped to arg[1]</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> di;   <span class="comment">// mapped to arg[0]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it's IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> orig_ax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> ip;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> sp;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在ARM64平台上，根据C ABI <a href="https://elixir.bootlin.com/linux/v4.19.69/source/arch/arm64/include/asm/ptrace.h" target="_blank" rel="noopener">ptrace</a>规范， 函数的参数和pt_regs的对应关系是：入参args[0]对应了regs[0]，入参args[1]对应regs[1]依此类推。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct defines the way the registers are stored on the stack during an</span></span><br><span class="line"><span class="comment"> * exception. Note that sizeof(struct pt_regs) has to be a multiple of 16 (for</span></span><br><span class="line"><span class="comment"> * stack alignment). struct user_pt_regs must form a prefix of struct pt_regs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">user_pt_regs</span> <span class="title">user_regs</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        u64 regs[<span class="number">31</span>];</span><br><span class="line">                        u64 sp;</span><br><span class="line">                        u64 pc;</span><br><span class="line">                        u64 pstate;</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        u64 orig_x0;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __AARCH64EB__</span></span><br><span class="line">        u32 unused2;</span><br><span class="line">        s32 syscallno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        s32 syscallno;</span><br><span class="line">        u32 unused2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        u64 orig_addr_limit;</span><br><span class="line">        <span class="comment">/* Only valid when ARM64_HAS_IRQ_PRIO_MASKING is enabled. */</span></span><br><span class="line">        u64 pmr_save;</span><br><span class="line">        u64 stackframe[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="kretprobe"><a href="#kretprobe" class="headerlink" title="kretprobe"></a>kretprobe</h2><p>kretprobe可以用来探测函数的返回值，示例中我们用它来探测<code>inet_release</code>函数的返回值和执行时间：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kretprobe_example.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Here's a sample kernel module showing the use of return probes to</span></span><br><span class="line"><span class="comment"> * report the return value and total time taken for probed function</span></span><br><span class="line"><span class="comment"> * to run.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * usage: insmod kretprobe_example.ko func=&lt;func_name&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If no func_name is specified, inet_release is instrumented</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For more information on theory of operation of kretprobes, see</span></span><br><span class="line"><span class="comment"> * Documentation/kprobes.txt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Build and insert the kernel module as done in the kprobe example.</span></span><br><span class="line"><span class="comment"> * You will see the trace data in /var/log/messages and on the console</span></span><br><span class="line"><span class="comment"> * whenever the probed function returns. (Some messages may be suppressed</span></span><br><span class="line"><span class="comment"> * if syslogd is configured to eliminate duplicate messages.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kprobes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ktime.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> func_name[NAME_MAX] = <span class="string">"inet_release"</span>;</span><br><span class="line">module_param_string(func, func_name, NAME_MAX, S_IRUGO);</span><br><span class="line">MODULE_PARM_DESC(func, <span class="string">"Function to kretprobe; this module will report the"</span></span><br><span class="line">                        <span class="string">" function's execution time"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* per-instance private data */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_data</span> &#123;</span></span><br><span class="line">        <span class="keyword">ktime_t</span> entry_stamp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here we use the entry_hanlder to timestamp function entry */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">entry_handler</span><span class="params">(struct kretprobe_instance *ri, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">my_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!current-&gt;mm)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">/* Skip kernel threads */</span></span><br><span class="line"></span><br><span class="line">        data = (struct my_data *)ri-&gt;data;</span><br><span class="line">        data-&gt;entry_stamp = ktime_get();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return-probe handler: Log the return value and duration. Duration may turn</span></span><br><span class="line"><span class="comment"> * out to be zero consistently, depending upon the granularity of time</span></span><br><span class="line"><span class="comment"> * accounting on the platform.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ret_handler</span><span class="params">(struct kretprobe_instance *ri, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> retval = regs_return_value(regs);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">my_data</span> *<span class="title">data</span> = (<span class="title">struct</span> <span class="title">my_data</span> *)<span class="title">ri</span>-&gt;<span class="title">data</span>;</span></span><br><span class="line">        s64 delta;</span><br><span class="line">        <span class="keyword">ktime_t</span> now;</span><br><span class="line"></span><br><span class="line">        now = ktime_get();</span><br><span class="line">        delta = ktime_to_ns(ktime_sub(now, data-&gt;entry_stamp));</span><br><span class="line"></span><br><span class="line">        printk(KERN_INFO <span class="string">"%s returned %d and took %lld ns to execute\n"</span>,</span><br><span class="line">                        func_name, retval, (<span class="keyword">long</span> <span class="keyword">long</span>)delta);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kretprobe</span> <span class="title">my_kretprobe</span> = &#123;</span></span><br><span class="line">        .handler                = ret_handler,</span><br><span class="line">        .entry_handler          = entry_handler,</span><br><span class="line">        .data_size              = <span class="keyword">sizeof</span>(struct my_data),</span><br><span class="line">        <span class="comment">/* Probe up to 20 instances concurrently. */</span></span><br><span class="line">        .maxactive              = <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">kretprobe_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        my_kretprobe.kp.symbol_name = func_name;</span><br><span class="line">        ret = register_kretprobe(&amp;my_kretprobe);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                printk(KERN_INFO <span class="string">"register_kretprobe failed, returned %d\n"</span>,</span><br><span class="line">                                ret);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(KERN_INFO <span class="string">"Planted return probe at %s: %p\n"</span>,</span><br><span class="line">                        my_kretprobe.kp.symbol_name, my_kretprobe.kp.addr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">kretprobe_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        unregister_kretprobe(&amp;my_kretprobe);</span><br><span class="line">        printk(KERN_INFO <span class="string">"kretprobe at %p unregistered\n"</span>,</span><br><span class="line">                        my_kretprobe.kp.addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* nmissed &gt; 0 suggests that maxactive was set too low. */</span></span><br><span class="line">        printk(KERN_INFO <span class="string">"Missed probing %d instances of %s\n"</span>,</span><br><span class="line">                my_kretprobe.nmissed, my_kretprobe.kp.symbol_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kretprobe_init)</span><br><span class="line">module_exit(kretprobe_exit)</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure></p><p>探测的结果输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[60362.085372] inet_release returned 0 and took 16360 ns to execute</span><br><span class="line">[60362.091124] inet_release returned 0 and took 8880 ns to execute</span><br><span class="line">[60362.091147] inet_release returned 0 and took 7640 ns to execute</span><br><span class="line">[60362.091173] inet_release returned 0 and took 7900 ns to execute</span><br><span class="line">[60362.941665] inet_release returned 0 and took 9100 ns to execute</span><br><span class="line">[60363.099577] inet_release returned 0 and took 9240 ns to execute</span><br><span class="line">[60363.126682] inet_release returned 0 and took 6000 ns to execute</span><br><span class="line">[60363.153610] inet_release returned 0 and took 9060 ns to execute</span><br><span class="line">[60363.153820] inet_release returned 0 and took 3220 ns to execute</span><br><span class="line">[60363.154699] inet_release returned 0 and took 3260 ns to execute</span><br><span class="line">[60363.159178] inet_release returned 0 and took 3200 ns to execute</span><br><span class="line">[60363.180098] inet_release returned 0 and took 3080 ns to execute</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自:&lt;a href=&quot;https://kernel.love/kprobe.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://kernel.love/kprobe.html&lt;/a&gt;
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第34期</title>
    <link href="http://liujunming.github.io/2023/06/10/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC34%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2023/06/10/每周分享第34期/</id>
    <published>2023-06-10T08:34:02.000Z</published>
    <updated>2023-06-25T11:58:28.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="X86-S"><a href="#X86-S" class="headerlink" title="X86-S"></a>X86-S</h3><p>A 64-bit mode-only architecture removes some older appendages of the architecture, reducing the overall complexity of the software and hardware architecture. </p><p><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/envisioning-future-simplified-architecture.html" target="_blank" rel="noopener">Envisioning a Simplified Intel Architecture</a><a id="more"></a> </p><p><a href="https://mp.weixin.qq.com/s/iZDb1l5I3OMFsMpmEvLjrw" target="_blank" rel="noopener">英特尔颠覆性的纯64位CPU架构x86s是什么？会有哪些影响？</a></p><p><a href="https://mp.weixin.qq.com/s/O0_nc55vqSZ510YTd-JvUw" target="_blank" rel="noopener">X86指令集的未来</a></p><h3 id="从网络到-AI：我的一点思考"><a href="#从网络到-AI：我的一点思考" class="headerlink" title="从网络到 AI：我的一点思考"></a>从网络到 AI：我的一点思考</h3><p><a href="https://bojieli.com/2023/04/from-networking-to-ai/" target="_blank" rel="noopener">https://bojieli.com/2023/04/from-networking-to-ai/</a></p><h3 id="Mac操作系统进化史"><a href="#Mac操作系统进化史" class="headerlink" title="Mac操作系统进化史"></a>Mac操作系统进化史</h3><p><a href="https://mp.weixin.qq.com/s/PFsR13qDZM3cw3lFpGKFhg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PFsR13qDZM3cw3lFpGKFhg</a></p><h3 id="Linux-Perf-底层数据收集机制概述"><a href="#Linux-Perf-底层数据收集机制概述" class="headerlink" title="Linux  Perf 底层数据收集机制概述"></a>Linux  Perf 底层数据收集机制概述</h3><p><a href="https://www.bilibili.com/video/BV1sW4y1X7QE/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1sW4y1X7QE/</a></p><h3 id="MMU-notifier"><a href="#MMU-notifier" class="headerlink" title="MMU notifier"></a>MMU notifier</h3><p><a href="http://www.biscuitos.cn/blog/Human-Knowledge-Common/#H000012" target="_blank" rel="noopener">http://www.biscuitos.cn/blog/Human-Knowledge-Common/#H000012</a></p><h3 id="Systems-Architecture-Video"><a href="#Systems-Architecture-Video" class="headerlink" title="Systems Architecture Video"></a>Systems Architecture Video</h3><p><a href="https://www.youtube.com/channel/UCPSsA8oxlSBjidJsSPdpjsQ/playlists" target="_blank" rel="noopener">https://www.youtube.com/channel/UCPSsA8oxlSBjidJsSPdpjsQ/playlists</a></p><h3 id="Posted-write"><a href="#Posted-write" class="headerlink" title="Posted write"></a>Posted write</h3><p>A posted write is a computer bus write transaction that does not wait for a write completion response to indicate success or failure of the write transaction.</p><h3 id="如何选择开源许可证"><a href="#如何选择开源许可证" class="headerlink" title="如何选择开源许可证"></a>如何选择开源许可证</h3><p><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</a></p><h3 id="Linux-LFS"><a href="#Linux-LFS" class="headerlink" title="Linux LFS"></a>Linux LFS</h3><p>Linux From Scratch (LFS) is a project that provides you with step-by-step instructions for building your own custom Linux system, entirely from source code.<br><a href="https://www.linuxfromscratch.org/" target="_blank" rel="noopener">https://www.linuxfromscratch.org/</a></p><h3 id="NVMe-VFIO-Live-Migration-for-IPU-DPU-Devices"><a href="#NVMe-VFIO-Live-Migration-for-IPU-DPU-Devices" class="headerlink" title="NVMe VFIO Live Migration for IPU/DPU Devices"></a>NVMe VFIO Live Migration for IPU/DPU Devices</h3><p><a href="https://mp.weixin.qq.com/s/GnN06H864XuXU41-jFH4jA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GnN06H864XuXU41-jFH4jA</a></p><h3 id="OOB"><a href="#OOB" class="headerlink" title="OOB"></a>OOB</h3><p>所谓“带外”，指的区别于数据传输通道的另外一条传输通道。</p><p><a href="https://en.wiktionary.org/wiki/out-of-band" target="_blank" rel="noopener">https://en.wiktionary.org/wiki/out-of-band</a><br>Relating to communication on a different channel, or by a different method, from that of the primary communication channel.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;X86-S&quot;&gt;&lt;a href=&quot;#X86-S&quot; class=&quot;headerlink&quot; title=&quot;X86-S&quot;&gt;&lt;/a&gt;X86-S&lt;/h3&gt;&lt;p&gt;A 64-bit mode-only architecture removes some older appendages of the architecture, reducing the overall complexity of the software and hardware architecture. &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.intel.com/content/www/us/en/developer/articles/technical/envisioning-future-simplified-architecture.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Envisioning a Simplified Intel Architecture&lt;/a&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解virtio-balloon</title>
    <link href="http://liujunming.github.io/2023/06/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3virtio-balloon/"/>
    <id>http://liujunming.github.io/2023/06/03/深入理解virtio-balloon/</id>
    <published>2023-06-03T11:46:04.000Z</published>
    <updated>2023-06-03T14:42:07.433Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2023/06/02.jpg" alt><br>本文将结合virtio spec、qemu与Linux kernel源码深入解析virtio-balloon的原理与实现。<a id="more"></a> </p><p>本文参考的virtio spec是<a href="https://ozlabs.org/~rusty/virtio-spec/virtio-0.9.5.pdf" target="_blank" rel="noopener">0.9.5</a>，qemu版本为<a href="https://gitlab.com/qemu-project/qemu/-/tree/v2.6.0" target="_blank" rel="noopener">v2.6.0</a>，Linux kernel版本为<a href="https://elixir.bootlin.com/linux/v4.19/source" target="_blank" rel="noopener">v4.19</a>。</p><p>为了简单起见，本文只介绍virtio-balloon的inflate操作，deflate、Memory Statistics就不赘述了。</p><p>本文考虑的场景:guest原先的内存为4096M，现在希望利用virtio-balloon，从guest内回收20M内存。</p><h3 id="在hmp中设置内存"><a href="#在hmp中设置内存" class="headerlink" title="在hmp中设置内存"></a>在hmp中设置内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ETEXI</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        .name       = <span class="string">"balloon"</span>,</span><br><span class="line">        .args_type  = <span class="string">"value:M"</span>,</span><br><span class="line">        .params     = <span class="string">"target"</span>,</span><br><span class="line">        .help       = <span class="string">"request VM to change its memory allocation (in MB)"</span>,</span><br><span class="line">        .mhandler.cmd = hmp_balloon,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">STEXI</span><br><span class="line">@item balloon @var&#123;value&#125;</span><br><span class="line">@findex balloon</span><br><span class="line">Request VM to change its memory allocation to @var&#123;value&#125; (in MB).</span><br></pre></td></tr></table></figure><p>在QEMU的hmp中执行<code>balloon 4076</code>，将guest的内存设置为4076M(4096-20)。此时会触发virtio-balloon设备的cofiguration change interrupt。</p><h3 id="cofiguration-change-interrupt"><a href="#cofiguration-change-interrupt" class="headerlink" title="cofiguration change interrupt"></a>cofiguration change interrupt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QEMU</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtio_balloon_to_target</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">ram_addr_t</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VirtIOBalloon *dev = VIRTIO_BALLOON(opaque);</span><br><span class="line">    VirtIODevice *vdev = VIRTIO_DEVICE(dev);</span><br><span class="line">    <span class="keyword">ram_addr_t</span> vm_ram_size = get_current_ram_size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target &gt; vm_ram_size) &#123;</span><br><span class="line">        target = vm_ram_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        dev-&gt;num_pages = (vm_ram_size - target) &gt;&gt; VIRTIO_BALLOON_PFN_SHIFT;</span><br><span class="line">        virtio_notify_config(vdev);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dev-&gt;num_pages</code>记录了Number of pages host wants Guest to give up。<code>virtio_notify_config</code>会给guest发送cofiguration change interrupt。<br>guest cofiguration change interrupt的handler是<code>virtballoon_changed</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// guest driver</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtballoon_changed</span><span class="params">(struct virtio_device *vdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_balloon</span> *<span class="title">vb</span> = <span class="title">vdev</span>-&gt;<span class="title">priv</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;vb-&gt;stop_update_lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (!vb-&gt;stop_update)</span><br><span class="line">        queue_work(system_freezable_wq, &amp;vb-&gt;update_balloon_size_work);</span><br><span class="line">    spin_unlock_irqrestore(&amp;vb-&gt;stop_update_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>vb-&gt;update_balloon_size_work</code>就是<code>update_balloon_size_func</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// guest driver</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_balloon_size_func</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_balloon</span> *<span class="title">vb</span>;</span></span><br><span class="line">    s64 diff;</span><br><span class="line"></span><br><span class="line">    vb = container_of(work, struct virtio_balloon,</span><br><span class="line">              update_balloon_size_work);</span><br><span class="line">    diff = towards_target(vb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">        diff -= fill_balloon(vb, diff);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">        diff += leak_balloon(vb, -diff);</span><br><span class="line">    update_balloon_size(vb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff)</span><br><span class="line">        queue_work(system_freezable_wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="guest-inflate"><a href="#guest-inflate" class="headerlink" title="guest inflate"></a>guest inflate</h3><p>首先思考下这个问题，guest怎么知道要inflate的呢？<br><code>update_balloon_size_func</code>会调用<code>towards_target</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// guest driver</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> s64 <span class="title">towards_target</span><span class="params">(struct virtio_balloon *vb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s64 target;</span><br><span class="line">    u32 num_pages;</span><br><span class="line"></span><br><span class="line">    virtio_cread(vb-&gt;vdev, struct virtio_balloon_config, num_pages,</span><br><span class="line">             &amp;num_pages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Legacy balloon config space is LE, unlike all other devices. */</span></span><br><span class="line">    <span class="keyword">if</span> (!virtio_has_feature(vb-&gt;vdev, VIRTIO_F_VERSION_1))</span><br><span class="line">        num_pages = le32_to_cpu((__force __le32)num_pages);</span><br><span class="line"></span><br><span class="line">    target = num_pages;</span><br><span class="line">    <span class="keyword">return</span> target - vb-&gt;num_pages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>towards_target</code>会读取<code>virtio_balloon_config</code>中的<code>num_pages</code>寄存器。<br><img src="/images/2023/06/04.jpg" alt><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_balloon_config</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Number of pages host wants Guest to give up. */</span></span><br><span class="line">    __u32 num_pages;</span><br><span class="line">    <span class="comment">/* Number of pages we've actually got in balloon. */</span></span><br><span class="line">    __u32 actual;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>因为<code>num_pages</code>位于PIO BAR0中，因此会发生VM Exit，QEMU的<code>virtio_balloon_get_config</code>最终会模拟<code>num_pages</code>寄存器的读。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QEMU</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtio_balloon_get_config</span><span class="params">(VirtIODevice *vdev, <span class="keyword">uint8_t</span> *config_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VirtIOBalloon *dev = VIRTIO_BALLOON(vdev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_balloon_config</span> <span class="title">config</span>;</span></span><br><span class="line"></span><br><span class="line">    config.num_pages = cpu_to_le32(dev-&gt;num_pages);</span><br><span class="line">    config.actual = cpu_to_le32(dev-&gt;actual);</span><br><span class="line"></span><br><span class="line">    trace_virtio_balloon_get_config(config.num_pages, config.actual);</span><br><span class="line">    <span class="built_in">memcpy</span>(config_data, &amp;config, <span class="keyword">sizeof</span>(struct virtio_balloon_config));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终guest看到的<code>num_pages</code>寄存器的值就是<code>dev-&gt;num_pages</code>，即为Number of pages host wants Guest to give up。</p><p><code>towards_target</code>中<code>vb-&gt;num_pages</code>的含义为Number of balloon pages guest has told the Host it’s not using. 在我们考虑的场景中，<code>vb-&gt;num_pages</code>为0(初始值)，此时<code>towards_target</code>返回的值为20 * （2MB/4KB）= 10K。因此<code>update_balloon_size_func</code>中的<code>diff</code>变量大于0，此时会调用<code>fill_balloon</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fill_balloon</span><br><span class="line">├── balloon_page_enqueue</span><br><span class="line">└── tell_host</span><br><span class="line">    ├── virtqueue_add_outbuf</span><br><span class="line">    └── virtqueue_kick</span><br></pre></td></tr></table></figure><p><code>balloon_page_enqueue</code>函数是guest os实现的回收unused pages的功能,与本文关系不大，这里就不继续往下追了。<code>virtqueue_add_outbuf</code>会往descs中填充pages的GFN(Guest Frame Number)，并更新avail ring，最后<code>virtqueue_kick</code>会写kick寄存器来通知QEMU回收内存。</p><h3 id="QEMU回收内存"><a href="#QEMU回收内存" class="headerlink" title="QEMU回收内存"></a>QEMU回收内存</h3><p><img src="/images/2023/06/01.jpg" alt></p><p>guest driver调用<code>virtqueue_kick</code>后，QEMU最终会调用<code>virtio_balloon_handle_output</code>来回收内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtio_balloon_handle_output</span><span class="params">(VirtIODevice *vdev, VirtQueue *vq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);</span><br><span class="line">    VirtQueueElement *elem;</span><br><span class="line">    MemoryRegionSection section;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> pfn;</span><br><span class="line">        elem = virtqueue_pop(vq, <span class="keyword">sizeof</span>(VirtQueueElement));</span><br><span class="line">        <span class="keyword">if</span> (!elem) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iov_to_buf(elem-&gt;out_sg, elem-&gt;out_num, offset, &amp;pfn, <span class="number">4</span>) == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">ram_addr_t</span> pa;</span><br><span class="line">            <span class="keyword">ram_addr_t</span> addr;</span><br><span class="line">            <span class="keyword">int</span> p = virtio_ldl_p(vdev, &amp;pfn);</span><br><span class="line"></span><br><span class="line">            pa = (<span class="keyword">ram_addr_t</span>) p &lt;&lt; VIRTIO_BALLOON_PFN_SHIFT;</span><br><span class="line">            offset += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            section = memory_region_find(get_system_memory(), pa, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!int128_nz(section.size) || !memory_region_is_ram(section.mr))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            trace_virtio_balloon_handle_output(memory_region_name(section.mr),</span><br><span class="line">                                               pa);</span><br><span class="line">            <span class="comment">/* Using memory_region_get_ram_ptr is bending the rules a bit, but</span></span><br><span class="line"><span class="comment">               should be OK because we only want a single page.  */</span></span><br><span class="line">            addr = section.offset_within_region;</span><br><span class="line">            balloon_page(memory_region_get_ram_ptr(section.mr) + addr,</span><br><span class="line">                         !!(vq == s-&gt;dvq));</span><br><span class="line">            memory_region_unref(section.mr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        virtqueue_push(vq, elem, offset);</span><br><span class="line">        virtio_notify(vdev, vq);</span><br><span class="line">        g_free(elem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>virtqueue_pop</code>会读取avail ring，从descs中获取要回收pages的GFN，然后进行内存的回收，回收完毕后，<code>virtqueue_push</code>会更新used ring，最后<code>virtio_notify</code>会发送inflateq的中断。</p><h3 id="guest-inflateq-handler"><a href="#guest-inflateq-handler" class="headerlink" title="guest inflateq handler"></a>guest inflateq handler</h3><p>guest inflateq handler是<code>balloon_ack</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">balloon_ack</span><span class="params">(struct virtqueue *vq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_balloon</span> *<span class="title">vb</span> = <span class="title">vq</span>-&gt;<span class="title">vdev</span>-&gt;<span class="title">priv</span>;</span></span><br><span class="line"></span><br><span class="line">    wake_up(&amp;vb-&gt;acked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>guest在<code>tell_host</code>中注册了<code>virtqueue_get_buf</code> callback，最终<code>balloon_ack</code>的结果就是读取inflateq的used ring，回收descs。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell_host</span><span class="params">(struct virtio_balloon *vb, struct virtqueue *vq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* When host has read buffer, this completes via balloon_ack */</span></span><br><span class="line">    wait_event(vb-&gt;acked, virtqueue_get_buf(vq, &amp;len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="guest-updates-balloon-size"><a href="#guest-updates-balloon-size" class="headerlink" title="guest updates balloon size"></a>guest updates balloon size</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update_balloon_size_func</span><br><span class="line">├── fill_balloon</span><br><span class="line">└── update_balloon_size</span><br></pre></td></tr></table></figure><p><code>update_balloon_size_func</code>在调用完<code>fill_balloon</code>来回收内存后，guest driver会调用<code>update_balloon_size</code>来通知QEMU Number of pages it’s actually got in balloon。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_balloon_size</span><span class="params">(struct virtio_balloon *vb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u32 actual = vb-&gt;num_pages;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Legacy balloon config space is LE, unlike all other devices. */</span></span><br><span class="line">    <span class="keyword">if</span> (!virtio_has_feature(vb-&gt;vdev, VIRTIO_F_VERSION_1))</span><br><span class="line">        actual = (__force u32)cpu_to_le32(actual);</span><br><span class="line"></span><br><span class="line">    virtio_cwrite(vb-&gt;vdev, struct virtio_balloon_config, actual,</span><br><span class="line">              &amp;actual);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>guest最终会将<code>vb-&gt;num_pages</code>(在<code>fill_balloon</code>中会确定<code>vb-&gt;num_pages</code>的值)写到<code>virtio_balloon_config</code>中的<code>actual</code>寄存器来通知QEMU。<br><img src="/images/2023/06/06.jpg" alt><br>QEMU最终会调用<code>virtio_balloon_set_config</code>，将guest写入的<code>vb-&gt;num_pages</code>值记录到<code>dev-&gt;actual</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtio_balloon_set_config</span><span class="params">(VirtIODevice *vdev,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="keyword">uint8_t</span> *config_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VirtIOBalloon *dev = VIRTIO_BALLOON(vdev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_balloon_config</span> <span class="title">config</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> oldactual = dev-&gt;actual;</span><br><span class="line">    <span class="keyword">ram_addr_t</span> vm_ram_size = get_current_ram_size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;config, config_data, <span class="keyword">sizeof</span>(struct virtio_balloon_config));</span><br><span class="line">    dev-&gt;actual = le32_to_cpu(config.actual);</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;actual != oldactual) &#123;</span><br><span class="line">        qapi_event_send_balloon_change(vm_ram_size -</span><br><span class="line">                        ((<span class="keyword">ram_addr_t</span>) dev-&gt;actual &lt;&lt; VIRTIO_BALLOON_PFN_SHIFT),</span><br><span class="line">                        &amp;error_abort);</span><br><span class="line">    &#125;</span><br><span class="line">    trace_virtio_balloon_set_config(dev-&gt;actual, oldactual);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/2023/06/03.jpg" alt><br>the descriptor describing the resulting 32-bit array is added to the inflateq中<strong>32-bit array</strong>的含义如下所示:<br><img src="/images/2023/06/05.jpg" alt></p><hr><p>参考资料:</p><ol><li><a href="http://ssdxiao.github.io/linux/2017/03/20/Virtio-Balloon.html" target="_blank" rel="noopener">Virtio-Balloon超详细分析</a></li><li><a href="https://static.sched.com/hosted_files/kvmforum2020/51/The%20Practice%20Method%20to%20Speed%20Up%2010x%20Boot-up%20Time%20for%20Guest%20in%20Alibaba%20Cloud.pdf" target="_blank" rel="noopener">Speed Up Boot-up Time for Guest in Alibaba Cloud</a></li><li><a href="https://hhb584520.github.io/kvm_blog/2017/04/14/kvm-overcommit.html" target="_blank" rel="noopener">内存过载使用</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2023/06/02.jpg&quot; alt&gt;&lt;br&gt;本文将结合virtio spec、qemu与Linux kernel源码深入解析virtio-balloon的原理与实现。
    
    </summary>
    
      <category term="virtio" scheme="http://liujunming.github.io/categories/virtio/"/>
    
    
      <category term="virtio" scheme="http://liujunming.github.io/tags/virtio/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Linux swiotlb技术</title>
    <link href="http://liujunming.github.io/2023/05/28/Notes-about-Linux-swiotlb%E6%8A%80%E6%9C%AF/"/>
    <id>http://liujunming.github.io/2023/05/28/Notes-about-Linux-swiotlb技术/</id>
    <published>2023-05-28T06:18:14.000Z</published>
    <updated>2023-05-28T07:47:44.247Z</updated>
    
    <content type="html"><![CDATA[<p>本文将总结下Linux swiotlb技术。<a id="more"></a></p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><img src="/images/2023/05/52.jpg" alt></p><h3 id="2-bounce-buffer"><a href="#2-bounce-buffer" class="headerlink" title="2. bounce buffer"></a>2. bounce buffer</h3><p><img src="/images/2023/05/53.jpg" alt><br>If the requested DMA operation is a DMA read (the device reads from memory DMA_TO_DEVICE), the data is copied from the original buffer to the bounce buffer, and the adapter reads it from the bounce buffer’s memory location. If the requested DMA operation is a write, the data is written(the device writes to memory DMA_FROM_DEVICE) by the adapter to the bounce buffer, and then copied to the original buffer.</p><p><img src="/images/2023/05/54.jpg" alt><br><img src="/images/2023/05/55.jpg" alt></p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>理解mmap时、同步时、unmap时的内存copy即可。<br>为了简单起见，只讨论DMA_FROM_DEVICE与DMA_TO_DEVICE这两个case。</p><ol><li>mmap时，建立原始物理地址与swiotlb buffer的映射，对于DMA_TO_DEVICE，需要将数据从原始物理地址处拷贝到swiotlb buffer</li><li>当设备往swiotlb buffer写入后，driver CPU需要读DMA内存时，需要sync下，将数据从swiotlb buffer拷贝到原始物理地址处</li><li>driver CPU更改原始物理地址内存，当需要DMA_TO_DEVICE时，需要sync下，将数据从原始物理地址处拷贝到swiotlb buffer</li><li>unmap时，解除原始物理地址与swiotlb buffer的映射，对于DMA_FROM_DEVICE，需要将数据从swiotlb buffer拷贝到原始物理地址处</li></ol><hr><p>参考资料:</p><ol><li><a href="https://research.ibm.com/haifa/dept/stt/pubs/utilizing-iommus-ols06.pdf" target="_blank" rel="noopener">Utilizing IOMMUs for Virtualization in Linux and Xen</a></li><li><a href="https://blog.csdn.net/liuhangtiant/article/details/87825466" target="_blank" rel="noopener">Linux swiotlb技术解析</a></li><li><a href="https://blog.csdn.net/qq_34719392/article/details/114873284" target="_blank" rel="noopener">Linux x86-64 IOMMU详解（二）——SWIOTLB（软件IOMMU）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将总结下Linux swiotlb技术。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Linux NAPI</title>
    <link href="http://liujunming.github.io/2023/05/28/Notes-about-Linux-NAPI/"/>
    <id>http://liujunming.github.io/2023/05/28/Notes-about-Linux-NAPI/</id>
    <published>2023-05-28T03:48:45.000Z</published>
    <updated>2023-05-28T04:55:05.588Z</updated>
    
    <content type="html"><![CDATA[<p>本文将学习下Linux网络收包的NAPI机制。<a id="more"></a></p><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>NAPI (“new API,” though it is not so new anymore) is an interrupt mitigation mechanism used with network devices. </p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><blockquote><p>随着网络带宽的发展，网速越来越快，之前的中断收包模式已经无法适应目前千兆，万兆的带宽了。如果每个数据包大小等于MTU大小(1460字节)。当驱动以千兆网速收包时，CPU将每秒被中断91829次。过多的中断会引起一个问题，CPU一直陷入硬中断而没有时间来处理别的事情了。为了解决这个问题，内核引入了NAPI机制。</p></blockquote><blockquote><p>NAPI就是混合中断和轮询的方式来收包，当有中断来了，驱动关闭中断，通知内核收包，内核软中断轮询当前网卡，在规定时间尽可能多的收包。时间用尽或者没有数据可收，内核再次开启中断，准备下一次收包。</p></blockquote><p>When network traffic is heavy, the kernel can safely predict that incoming packets will be available anytime it gets around to looking, so there is no need to have the adapter interrupting it (possibly thousands of times per second) to tell it about those packets. So a NAPI-compliant driver will turn off the packet receive interrupt and provide a <code>poll()</code> method to the kernel. When the kernel is ready to deal with more packets, <code>poll()</code> will be called with a maximum number of packets it is allowed to feed into the kernel; it should process up to that many packets and quit.</p><h3 id="Full-Picture"><a href="#Full-Picture" class="headerlink" title="Full Picture"></a>Full Picture</h3><p><img src="/images/2023/05/51.png" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/2023/05/50.jpg" alt></p><hr><p>参考资料:</p><ol><li><a href="https://lwn.net/Articles/214457/" target="_blank" rel="noopener">Reworking NAPI</a></li><li><a href="https://lwn.net/Articles/244640/" target="_blank" rel="noopener">Newer, newer NAPI</a></li><li><a href="https://docs.kernel.org/networking/napi.html" target="_blank" rel="noopener">NAPI</a></li><li><a href="https://blog.csdn.net/Rong_Toa/article/details/109401935" target="_blank" rel="noopener">Linux网络协议栈：NAPI机制与处理流程分析（图解）</a></li><li><a href="https://zhuanlan.zhihu.com/p/610334133" target="_blank" rel="noopener">NAPI 内核机制与驱动实现</a></li><li><a href="https://wenfh2020.com/2021/12/29/kernel-tcp-receive/" target="_blank" rel="noopener">Linux 网络数据接收流程（TCP）- NAPI</a></li><li><a href="https://access.redhat.com/sites/default/files/attachments/20150325_network_performance_tuning.pdf" target="_blank" rel="noopener">Red Hat Enterprise Linux Network Performance Tuning Guide</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将学习下Linux网络收包的NAPI机制。
    
    </summary>
    
      <category term="计算机网络" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="计算机网络" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Notes about SMAP and SMEP</title>
    <link href="http://liujunming.github.io/2023/05/27/Notes-about-SMAP-and-SMEP/"/>
    <id>http://liujunming.github.io/2023/05/27/Notes-about-SMAP-and-SMEP/</id>
    <published>2023-05-27T07:54:33.000Z</published>
    <updated>2023-05-27T10:16:36.435Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark下SMAP(Supervisor Memory Access Protection) and SMEP(Supervisor Memory Execute Protection)相关notes，参考kernel版本为<a href="https://elixir.bootlin.com/linux/v6.3/source" target="_blank" rel="noopener">v6.3</a>。<a id="more"></a></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>SMEP prevents the kernel running in ring 0 from executing code which is user accessible. SMAP prevents the kernel from accessing userspace memory while the AC flag in the RFLAGS register is clear. These features can help harden the kernel against exploitation and prevent certain kinds of memory corruption.</p><h3 id="Description-from-SDM"><a href="#Description-from-SDM" class="headerlink" title="Description from SDM"></a>Description from SDM</h3><p><img src="/images/2023/05/45.jpg" alt><br><img src="/images/2023/05/46.jpg" alt><br><img src="/images/2023/05/47.jpg" alt></p><p><img src="/images/2023/05/48.jpg" alt><br><img src="/images/2023/05/49.jpg" alt></p><h3 id="copy-to-user"><a href="#copy-to-user" class="headerlink" title="copy_to_user"></a>copy_to_user</h3><p>由于内核空间与用户空间的内存不能直接互访，因此需要借助内核函数<code>copy_to_user</code>完成内核空间到用户空间的复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * igb_ptp_get_ts_config - get hardware time stamping config</span></span><br><span class="line"><span class="comment"> * @netdev: netdev struct</span></span><br><span class="line"><span class="comment"> * @ifr: interface struct</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Get the hwtstamp_config settings to return to the user. Rather than attempt</span></span><br><span class="line"><span class="comment"> * to deconstruct the settings from the registers, just return a shadow copy</span></span><br><span class="line"><span class="comment"> * of the last known settings.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">igb_ptp_get_ts_config</span><span class="params">(struct net_device *netdev, struct ifreq *ifr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">igb_adapter</span> *<span class="title">adapter</span> = <span class="title">netdev_priv</span>(<span class="title">netdev</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hwtstamp_config</span> *<span class="title">config</span> = &amp;<span class="title">adapter</span>-&gt;<span class="title">tstamp_config</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copy_to_user(ifr-&gt;ifr_data, config, <span class="keyword">sizeof</span>(*config)) ?</span><br><span class="line">        -EFAULT : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">copy_to_user</span><br><span class="line">└── _copy_to_user</span><br><span class="line">    └── raw_copy_to_user</span><br><span class="line">        └── copy_user_generic</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline __must_check <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">copy_user_generic(<span class="keyword">void</span> *to, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">unsigned</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If CPU has ERMS feature, use copy_user_enhanced_fast_string.</span></span><br><span class="line"><span class="comment">     * Otherwise, if CPU has rep_good feature, use copy_user_generic_string.</span></span><br><span class="line"><span class="comment">     * Otherwise, use copy_user_generic_unrolled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    alternative_call_2(copy_user_generic_unrolled,</span><br><span class="line">             copy_user_generic_string,</span><br><span class="line">             X86_FEATURE_REP_GOOD,</span><br><span class="line">             copy_user_enhanced_fast_string,</span><br><span class="line">             X86_FEATURE_ERMS,</span><br><span class="line">             ASM_OUTPUT2(<span class="string">"=a"</span> (ret), <span class="string">"=D"</span> (to), <span class="string">"=S"</span> (from),</span><br><span class="line">                     <span class="string">"=d"</span> (len)),</span><br><span class="line">             <span class="string">"1"</span> (to), <span class="string">"2"</span> (from), <span class="string">"3"</span> (len)</span><br><span class="line">             : <span class="string">"memory"</span>, <span class="string">"rcx"</span>, <span class="string">"r8"</span>, <span class="string">"r9"</span>, <span class="string">"r10"</span>, <span class="string">"r11"</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SYM_FUNC_START(copy_user_generic_string)</span><br><span class="line">    ASM_STAC</span><br><span class="line">    cmpl $<span class="number">8</span>,%edx</span><br><span class="line">    jb <span class="number">2f</span>       <span class="comment">/* less than 8 bytes, go to byte copy loop */</span></span><br><span class="line">    ALIGN_DESTINATION</span><br><span class="line">    movl %edx,%ecx</span><br><span class="line">    shrl $<span class="number">3</span>,%ecx</span><br><span class="line">    andl $<span class="number">7</span>,%edx</span><br><span class="line"><span class="number">1</span>:  rep movsq</span><br><span class="line"><span class="number">2</span>:  movl %edx,%ecx</span><br><span class="line"><span class="number">3</span>:  rep movsb</span><br><span class="line">    xorl %eax,%eax</span><br><span class="line">    ASM_CLAC</span><br><span class="line">    RET</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>: leal (%rdx,%rcx,<span class="number">8</span>),%ecx</span><br><span class="line"><span class="number">12</span>: movl %ecx,%edx      <span class="comment">/* ecx is zerorest also */</span></span><br><span class="line">    jmp .Lcopy_user_handle_tail</span><br><span class="line"></span><br><span class="line">    _ASM_EXTABLE_CPY(<span class="number">1b</span>, <span class="number">11b</span>)</span><br><span class="line">    _ASM_EXTABLE_CPY(<span class="number">3b</span>, <span class="number">12b</span>)</span><br><span class="line">SYM_FUNC_END(copy_user_generic_string)</span><br><span class="line">EXPORT_SYMBOL(copy_user_generic_string)</span><br></pre></td></tr></table></figure><p>从copy_user_generic_string的第2行可知，在内核态往用户态复制内存前，需要运行<code>STAC</code>指令；从第13行可知，在内核态往用户态复制内存后，需要运行<code>CLAC</code>指令。</p><hr><p>参考资料:</p><ol><li><a href="https://wiki.osdev.org/Supervisor_Memory_Protection" target="_blank" rel="noopener">Supervisor Memory Protection</a></li><li><a href="https://lore.kernel.org/all/1348256595-29119-9-git-send-email-hpa@linux.intel.com/" target="_blank" rel="noopener">x86, smap: Add STAC and CLAC instructions to control user space access</a></li><li><a href="https://blog.csdn.net/Haomione/article/details/122217131" target="_blank" rel="noopener">copy_to_user/copy_from_user参数解析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark下SMAP(Supervisor Memory Access Protection) and SMEP(Supervisor Memory Execute Protection)相关notes，参考kernel版本为&lt;a href=&quot;https://elixir.bootlin.com/linux/v6.3/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v6.3&lt;/a&gt;。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Notes about iommu=pt kernel parameter</title>
    <link href="http://liujunming.github.io/2023/05/21/Notes-about-iommu-pt-kernel-parameter/"/>
    <id>http://liujunming.github.io/2023/05/21/Notes-about-iommu-pt-kernel-parameter/</id>
    <published>2023-05-21T07:22:58.000Z</published>
    <updated>2023-05-21T13:02:58.896Z</updated>
    
    <content type="html"><![CDATA[<p>当使用KVM pass-thru设备时，通常会设置<code>intel_iommu=on iommu=pt</code>内核参数，其中<code>intel_iommu=on</code>就是使能intel iommu，本文将介绍<code>iommu=pt</code>。<a id="more"></a></p><p>本文参考的内核版本是<a href="https://elixir.bootlin.com/linux/v5.0/source" target="_blank" rel="noopener">v5.0</a>。</p><p>identity mapping指的是iova与hpa 1:1映射。</p><h2 id="1-Motivation"><a href="#1-Motivation" class="headerlink" title="1. Motivation"></a>1. Motivation</h2><p>The <code>pt</code> option only enables IOMMU translation for devices used in pass-thru ,doesn’t enable IOMMU translation for host used devices ,and this will improve performance for host PCIe devices (which are not pass-thru to a VM).</p><p>内核的注释：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This variable becomes 1 if iommu=pt is passed on the kernel command line.</span></span><br><span class="line"><span class="comment"> * If this variable is 1, IOMMU implementations do no DMA translation for</span></span><br><span class="line"><span class="comment"> * devices and allow every device to access to whole physical memory. This is</span></span><br><span class="line"><span class="comment"> * useful if a user wants to use an IOMMU only for KVM device assignment to</span></span><br><span class="line"><span class="comment"> * guests and not for driver dma translation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> iommu_pass_through __read_mostly = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h2><h3 id="2-1-pt-option解析"><a href="#2-1-pt-option解析" class="headerlink" title="2.1 pt option解析"></a>2.1 <code>pt</code> option解析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __<span class="function">init <span class="keyword">int</span> <span class="title">iommu_setup</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(p, <span class="string">"pt"</span>, <span class="number">2</span>))</span><br><span class="line">        iommu_pass_through = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-init-dmars"><a href="#2-2-init-dmars" class="headerlink" title="2.2 init_dmars"></a>2.2 init_dmars</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDENTMAP_ALL        1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This domain is a statically identity mapping domain.</span></span><br><span class="line"><span class="comment"> *  1. This domain creats a static 1:1 mapping to all usable memory.</span></span><br><span class="line"><span class="comment"> *  2. It maps to each iommu if successful.</span></span><br><span class="line"><span class="comment"> *  3. Each iommu maps to this domain if successful.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dmar_domain</span> *<span class="title">si_domain</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> hw_pass_through = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_dmars</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!ecap_pass_through(iommu-&gt;ecap))</span><br><span class="line">        hw_pass_through = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (iommu_pass_through)</span><br><span class="line">        iommu_identity_mapping |= IDENTMAP_ALL;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (iommu_identity_mapping) &#123;</span><br><span class="line">        ret = si_domain_init(hw_pass_through);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> free_iommu;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (iommu_identity_mapping) &#123;</span><br><span class="line">        ret = iommu_prepare_static_identity_mapping(hw_pass_through);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            pr_crit(<span class="string">"Failed to setup IOMMU pass-through\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> free_iommu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#define ecap_pass_through(e)    ((e &gt;&gt; 6) &amp; 0x1)</code></p><p><code>ecap_pass_through(iommu-&gt;ecap)</code>的含义是检查Extended Capability Register的<code>PT</code> field。<br><img src="/images/2023/05/43.jpg" alt><br>如果Hardware supports pass-through translation type,那么<code>hw_pass_through</code>为1；否则<code>hw_pass_through</code>为0。</p><p>当<code>iommu_pass_through</code>被设置时，<code>iommu_identity_mapping</code>也会被设置。接着会依次调用<code>si_domain_init</code>与<code>iommu_prepare_static_identity_mapping</code>。</p><h3 id="2-3-si-domain-init"><a href="#2-3-si-domain-init" class="headerlink" title="2.3 si_domain_init"></a>2.3 si_domain_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">si_domain_init</span><span class="params">(<span class="keyword">int</span> hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nid, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    si_domain = alloc_domain(DOMAIN_FLAG_STATIC_IDENTITY);</span><br><span class="line">    <span class="keyword">if</span> (!si_domain)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (md_domain_init(si_domain, DEFAULT_DOMAIN_ADDRESS_WIDTH)) &#123;</span><br><span class="line">        domain_exit(si_domain);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">"Identity mapping domain allocated\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hw)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    for_each_online_node(nid) &#123; <span class="comment">//迭代所有的活动结点(针对NUMA)</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> start_pfn, end_pfn;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        for_each_mem_pfn_range(i, nid, &amp;start_pfn, &amp;end_pfn, <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ret = iommu_domain_identity_map(si_domain, <span class="comment">//iova与hpa 1:1映射</span></span><br><span class="line">                    PFN_PHYS(start_pfn), PFN_PHYS(end_pfn));</span><br><span class="line">            <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可知，当<code>hw_pass_through</code>为1时，无需建立iova与hpa 1:1映射的iommu页表；否则需要对all usable memory建立iova与hpa 1:1映射的iommu页表。</p><h3 id="2-4-iommu-prepare-static-identity-mapping"><a href="#2-4-iommu-prepare-static-identity-mapping" class="headerlink" title="2.4 iommu_prepare_static_identity_mapping"></a>2.4 iommu_prepare_static_identity_mapping</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iommu_prepare_static_identity_mapping</span><br><span class="line">└── dev_prepare_static_identity_mapping</span><br><span class="line">    └── domain_add_dev_info</span><br><span class="line">        └── dmar_insert_one_dev_info</span><br><span class="line">            └── domain_context_mapping</span><br><span class="line">                └── domain_context_mapping_one</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">domain_context_mapping_one</span><span class="params">(struct dmar_domain *domain,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      struct intel_iommu *iommu,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      u8 bus, u8 devfn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设置translation type 为 pass through</span></span><br><span class="line">    <span class="keyword">if</span> (hw_pass_through &amp;&amp; domain_type_is_si(domain))</span><br><span class="line">        translation = CONTEXT_TT_PASS_THROUGH;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取这个设备在contex table表里面的地址</span></span><br><span class="line">    context = iommu_context_addr(iommu, bus, devfn, <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dma_pte</span> *<span class="title">pgd</span> = <span class="title">domain</span>-&gt;<span class="title">pgd</span>;</span> <span class="comment">// iova页表基址</span></span><br><span class="line">    <span class="keyword">int</span> agaw;</span><br><span class="line"></span><br><span class="line">    context_set_domain_id(context, did);</span><br><span class="line">    <span class="comment">// 设置转换类型</span></span><br><span class="line">    context_set_translation_type(context, translation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面代码可以看出pass through模式不会设置iova页表地址</span></span><br><span class="line">    <span class="keyword">if</span> (translation != CONTEXT_TT_PASS_THROUGH) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 非pass through模式下需要设置iova页表的基地址</span></span><br><span class="line">        context_set_address_root(context, virt_to_phys(pgd));</span><br><span class="line">        context_set_address_width(context, agaw);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * In pass through mode, AW must be programmed to</span></span><br><span class="line"><span class="comment">         * indicate the largest AGAW value supported by</span></span><br><span class="line"><span class="comment">         * hardware. And ASR is ignored by hardware.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        context_set_address_width(context, iommu-&gt;msagaw);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#define CONTEXT_TT_PASS_THROUGH 2</code><br><img src="/images/2023/05/44.jpg" alt><br>因此<code>CONTEXT_TT_PASS_THROUGH</code>为10b，即是2。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>配置了<code>iommu=pt</code>就会实现identity mapping:</p><ul><li>如果Hardware supports pass-through translation type，则配置pass-through translation type即可实现identity mapping，此时无需配置iommu页表;</li><li>如果Hardware doesn’t support pass-through translation type，则需要配置iommu页表，使得iova与hpa 1:1映射。</li></ul><p>当<code>hw_pass_through</code>=0时，依然要走iommu页表，因此性能是不如<code>hw_pass_through</code>=1的。</p><hr><p>参考资料:</p><ol><li><a href="http://blog.chinaunix.net/uid-28541347-id-5868588.html" target="_blank" rel="noopener">iommu passthrough分析</a></li><li>Intel VT-d spec</li><li><a href="https://zhuanlan.zhihu.com/p/365408539" target="_blank" rel="noopener">IOMMU(二)-从配置说起</a></li><li><a href="https://pve.proxmox.com/wiki/PCI_Passthrough#PT_Mode" target="_blank" rel="noopener">PCI_Passthrough PT Mode</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_virtualization/4.1/html/installation_guide/appe-configuring_a_hypervisor_host_for_pci_passthrough" target="_blank" rel="noopener">Configuring a Host for PCI Passthrough</a></li><li><a href="https://mp.weixin.qq.com/s/6OK4e-m_NRn4vdl3p4sbTw" target="_blank" rel="noopener">深入了解iommu系列一：iommu硬件架构和驱动初始化</a></li><li><a href="https://zhuanlan.zhihu.com/p/479963917" target="_blank" rel="noopener">深入了解iommu系列二:iommu 工作原理解析之dma remapping</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当使用KVM pass-thru设备时，通常会设置&lt;code&gt;intel_iommu=on iommu=pt&lt;/code&gt;内核参数，其中&lt;code&gt;intel_iommu=on&lt;/code&gt;就是使能intel iommu，本文将介绍&lt;code&gt;iommu=pt&lt;/code&gt;。
    
    </summary>
    
      <category term="IOMMU" scheme="http://liujunming.github.io/categories/IOMMU/"/>
    
    
      <category term="IOMMU" scheme="http://liujunming.github.io/tags/IOMMU/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Speed Up Boot-up Time for Guest in Alibaba Cloud</title>
    <link href="http://liujunming.github.io/2023/05/14/Notes-about-Speed-Up-Boot-up-Time-for-Guest-in-Alibaba-Cloud/"/>
    <id>http://liujunming.github.io/2023/05/14/Notes-about-Speed-Up-Boot-up-Time-for-Guest-in-Alibaba-Cloud/</id>
    <published>2023-05-14T04:31:55.000Z</published>
    <updated>2023-05-14T10:01:50.931Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about <a href="https://static.sched.com/hosted_files/kvmforum2020/51/The%20Practice%20Method%20to%20Speed%20Up%2010x%20Boot-up%20Time%20for%20Guest%20in%20Alibaba%20Cloud.pdf" target="_blank" rel="noopener">Speed Up Boot-up Time for Guest in Alibaba Cloud</a>。</p><p>Motivation: 当有<a href="/2021/07/29/Notes-about-guest-memory-pinning-when-direct-assignment-of-I-0-devices/">pass-thru设备</a>，虚拟机启动时，需要分配好全部内存;当虚拟机内存较大时，开机时间较长。<br>Idea: 利用气球驱动，guest刚启动时，气球充气，Only map necessary memory first；guest启动后，气球放气，将内存还给guest。这样在guest启动过程中，只需map必要内存，无需map所有内存，即可达到Speed Up Boot-up Time for Guest的目的。<br><a id="more"></a></p><p><img src="/images/2023/05/39.jpg" alt><br><img src="/images/2023/05/40.jpg" alt><br><img src="/images/2023/05/42.jpg" alt><br><img src="/images/2023/05/41.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about &lt;a href=&quot;https://static.sched.com/hosted_files/kvmforum2020/51/The%20Practice%20Method%20to%20Speed%20Up%2010x%20Boot-up%20Time%20for%20Guest%20in%20Alibaba%20Cloud.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Speed Up Boot-up Time for Guest in Alibaba Cloud&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Motivation: 当有&lt;a href=&quot;/2021/07/29/Notes-about-guest-memory-pinning-when-direct-assignment-of-I-0-devices/&quot;&gt;pass-thru设备&lt;/a&gt;，虚拟机启动时，需要分配好全部内存;当虚拟机内存较大时，开机时间较长。&lt;br&gt;Idea: 利用气球驱动，guest刚启动时，气球充气，Only map necessary memory first；guest启动后，气球放气，将内存还给guest。这样在guest启动过程中，只需map必要内存，无需map所有内存，即可达到Speed Up Boot-up Time for Guest的目的。&lt;br&gt;
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Crystal Beach DMA(CBDMA)</title>
    <link href="http://liujunming.github.io/2023/05/14/Notes-about-Crystal-Beach-DMA-CBDMA/"/>
    <id>http://liujunming.github.io/2023/05/14/Notes-about-Crystal-Beach-DMA-CBDMA/</id>
    <published>2023-05-14T03:23:54.000Z</published>
    <updated>2023-05-14T04:16:06.272Z</updated>
    
    <content type="html"><![CDATA[<p>Crystal Beach DMA(CBDMA)其实就是<a href="/2022/03/29/Introduction-to-Intel-I-OAT/#2-Intel®-QuickData-Technology">Intel® QuickData Technology</a>，说白了就是offload memory copy to DMA engine，<a href="/2022/10/23/Notes-about-Intel-Data-Streaming-Accelerator-DSA/">DSA</a>代替了该技术。<a id="more"></a></p><p><img src="/images/2023/05/37.jpg" alt></p><p><img src="/images/2023/05/38.jpg" alt></p><p>FAST ‘23 paper <a href="https://www.usenix.org/conference/fast23/presentation/su" target="_blank" rel="noopener">Revitalizing the Forgotten On-Chip DMA to Expedite Data Movement in NVM-based Storage Systems</a>也是使用了CBDMA来offload memory copy。</p><hr><p>参考资料:</p><ol><li><a href="https://zhuanlan.zhihu.com/p/133489817" target="_blank" rel="noopener">NFV加速利器，CPU中的CBDMA引擎</a></li><li><a href="https://www.dpdk.org/wp-content/uploads/sites/35/2018/12/JiayuHu_Accelerating_paravirtio_with_CBDMA.pdf" target="_blank" rel="noopener">Accelerating Para-Virtual I/O with CBDMA</a></li><li><a href="https://static.sched.com/hosted_files/dpdkbordeaux2019/09/Asynchronous%20CBDMA%20Enqueue%20Framework%20for%20vHost-User.pdf" target="_blank" rel="noopener">Asynchronous CBDMA Enqueue Framework for vHost-User</a></li><li><a href="https://insujang.github.io/2021-04-26/using-intel-ioat-dma/" target="_blank" rel="noopener">Using Intel IOAT DMA</a></li><li><a href="https://www.intel.com/content/www/us/en/wireless-network/accel-technology.html" target="_blank" rel="noopener">Intel® I/O Acceleration Technology</a></li><li><a href="https://www.usenix.org/conference/fast23/presentation/su" target="_blank" rel="noopener">Revitalizing the Forgotten On-Chip DMA to Expedite Data Movement in NVM-based Storage Systems</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Crystal Beach DMA(CBDMA)其实就是&lt;a href=&quot;/2022/03/29/Introduction-to-Intel-I-OAT/#2-Intel®-QuickData-Technology&quot;&gt;Intel® QuickData Technology&lt;/a&gt;，说白了就是offload memory copy to DMA engine，&lt;a href=&quot;/2022/10/23/Notes-about-Intel-Data-Streaming-Accelerator-DSA/&quot;&gt;DSA&lt;/a&gt;代替了该技术。
    
    </summary>
    
      <category term="Intel" scheme="http://liujunming.github.io/categories/Intel/"/>
    
    
      <category term="Intel" scheme="http://liujunming.github.io/tags/Intel/"/>
    
  </entry>
  
  <entry>
    <title>Notes about VT-d Virtual Command Support</title>
    <link href="http://liujunming.github.io/2023/05/13/Notes-about-VT-d-Virtual-Command-Support/"/>
    <id>http://liujunming.github.io/2023/05/13/Notes-about-VT-d-Virtual-Command-Support/</id>
    <published>2023-05-12T23:41:02.000Z</published>
    <updated>2023-05-13T03:45:24.725Z</updated>
    
    <content type="html"><![CDATA[<p>Virtual Command Support (VCS) - Virtual register intended to help support virtualization of the IOMMU. Unlike an SR-IOV device where an entire device is exposed to a guest, the new model creates device instances using PASID. This requires the PASID to be a flat global space which <strong>requires the guest and host PASIDs to be the same</strong>. Only virtual IOMMUs exposed to a guest would enumerate this capability. <strong>It provides an interface to for the host to control allocation of PASIDs in a guest OS</strong>.<a id="more"></a></p><p><img src="/images/2023/05/36.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Virtual command interface for enlightened pasid management. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_CMD_ALLOC          0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_CMD_FREE           0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_VRSP_IP            0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_VRSP_SC(e)         (((e) &amp; 0xff) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_VRSP_SC_SUCCESS        0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_VRSP_SC_NO_PASID_AVAIL 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_VRSP_SC_INVALID_PASID  16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_VRSP_RESULT_PASID(e)   (((e) &gt;&gt; 16) &amp; 0xfffff)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_CMD_OPERAND(e)     ((e) &lt;&lt; 16)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vcmd_alloc_pasid</span><span class="params">(struct intel_iommu *iommu, u32 *pasid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    u8 status_code;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    u64 res;</span><br><span class="line"></span><br><span class="line">    raw_spin_lock_irqsave(&amp;iommu-&gt;register_lock, flags);</span><br><span class="line">    dmar_writeq(iommu-&gt;reg + DMAR_VCMD_REG, VCMD_CMD_ALLOC);</span><br><span class="line">    IOMMU_WAIT_OP(iommu, DMAR_VCRSP_REG, dmar_readq,</span><br><span class="line">              !(res &amp; VCMD_VRSP_IP), res);</span><br><span class="line">    raw_spin_unlock_irqrestore(&amp;iommu-&gt;register_lock, flags);</span><br><span class="line"></span><br><span class="line">    status_code = VCMD_VRSP_SC(res);</span><br><span class="line">    <span class="keyword">switch</span> (status_code) &#123;</span><br><span class="line">    <span class="keyword">case</span> VCMD_VRSP_SC_SUCCESS:</span><br><span class="line">        *pasid = VCMD_VRSP_RESULT_PASID(res);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VCMD_VRSP_SC_NO_PASID_AVAIL:</span><br><span class="line">        pr_info(<span class="string">"IOMMU: %s: No PASID available\n"</span>, iommu-&gt;name);</span><br><span class="line">        ret = -ENOSPC;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -ENODEV;</span><br><span class="line">        pr_warn(<span class="string">"IOMMU: %s: Unexpected error code %d\n"</span>,</span><br><span class="line">            iommu-&gt;name, status_code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vcmd_free_pasid</span><span class="params">(struct intel_iommu *iommu, u32 pasid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    u8 status_code;</span><br><span class="line">    u64 res;</span><br><span class="line"></span><br><span class="line">    raw_spin_lock_irqsave(&amp;iommu-&gt;register_lock, flags);</span><br><span class="line">    dmar_writeq(iommu-&gt;reg + DMAR_VCMD_REG,</span><br><span class="line">            VCMD_CMD_OPERAND(pasid) | VCMD_CMD_FREE);</span><br><span class="line">    IOMMU_WAIT_OP(iommu, DMAR_VCRSP_REG, dmar_readq,</span><br><span class="line">              !(res &amp; VCMD_VRSP_IP), res);</span><br><span class="line">    raw_spin_unlock_irqrestore(&amp;iommu-&gt;register_lock, flags);</span><br><span class="line"></span><br><span class="line">    status_code = VCMD_VRSP_SC(res);</span><br><span class="line">    <span class="keyword">switch</span> (status_code) &#123;</span><br><span class="line">    <span class="keyword">case</span> VCMD_VRSP_SC_SUCCESS:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VCMD_VRSP_SC_INVALID_PASID:</span><br><span class="line">        pr_info(<span class="string">"IOMMU: %s: Invalid PASID\n"</span>, iommu-&gt;name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        pr_warn(<span class="string">"IOMMU: %s: Unexpected error code %d\n"</span>,</span><br><span class="line">            iommu-&gt;name, status_code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程主要分为如下两个步骤:</p><ol><li><p>guest分配pasid时，写vIOMMU的vcmd寄存器，此时会trap下来，host会将分配好的host paisd传给guest，这样guest与host的pasid就一样了。</p></li><li><p>当guest配置WQ Configuration register(MMIO寄存器)的PASID field时需要trap下来，hypervisor会检查guest的pasid与host的pasid是否一致，如果一致，那么hypervisor会将这个host PASID写入物理WQ Configuration register的PASID field。</p></li></ol><hr><p>参考资料:</p><ol><li><a href="https://01.org/blogs/ashokraj/2018/recent-enhancements-intel-virtualization-technology-directed-i/o-intel-vt-d" target="_blank" rel="noopener">RECENT ENHANCEMENTS IN INTEL® VIRTUALIZATION TECHNOLOGY FOR DIRECTED I/O (INTEL® VT-D)</a></li><li><a href="https://elixir.bootlin.com/linux/v6.3/source" target="_blank" rel="noopener">Linux kernel v6.3</a></li><li>Intel VT-d spec</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Virtual Command Support (VCS) - Virtual register intended to help support virtualization of the IOMMU. Unlike an SR-IOV device where an entire device is exposed to a guest, the new model creates device instances using PASID. This requires the PASID to be a flat global space which &lt;strong&gt;requires the guest and host PASIDs to be the same&lt;/strong&gt;. Only virtual IOMMUs exposed to a guest would enumerate this capability. &lt;strong&gt;It provides an interface to for the host to control allocation of PASIDs in a guest OS&lt;/strong&gt;.
    
    </summary>
    
      <category term="VT-d" scheme="http://liujunming.github.io/categories/VT-d/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
</feed>
