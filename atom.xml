<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2021-05-16T14:32:19.749Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Introduction to upx</title>
    <link href="http://liujunming.github.io/2021/05/16/Introduction-to-upx/"/>
    <id>http://liujunming.github.io/2021/05/16/Introduction-to-upx/</id>
    <published>2021-05-16T12:54:02.000Z</published>
    <updated>2021-05-16T14:32:19.749Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍upx相关知识。<a id="more"></a></p><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>upx(The Ultimate Packer for eXecutables)的基本原理:</p><ol><li>将可执行文件压缩</li><li>将压缩完的程序作为新程序的一部分</li><li>在新程序的开头加上解压和执行代码</li></ol><p>压缩完的新程序是可执行的。</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>对于可执行程序，upx是用时间换空间的做法。</p><p>需要注意的是，实际使用中，需要保证压缩率产生的收益比加上额外的解压代码要高，否则就没意义。</p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">junmingl@junming:~/test$ cp /bin/ls ls_upx</span><br><span class="line">junmingl@junming:~/test$ ./ls_upx -ls</span><br><span class="line">total 132</span><br><span class="line">132 -rwxr-xr-x 1 junmingl junmingl 133792 5月  17 05:09 ls_upx</span><br><span class="line">junmingl@junming:~/test$ upx ls_upx</span><br><span class="line">                       Ultimate Packer for eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2017</span><br><span class="line">UPX 3.94        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   May 12th 2017</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">    133792 -&gt;     61332   45.84%   linux/amd64   ls_upx</span><br><span class="line"></span><br><span class="line">Packed 1 file.</span><br><span class="line">junmingl@junming:~/test$ ./ls_upx -ls</span><br><span class="line">total 60</span><br><span class="line">60 -rwxr-xr-x 1 junmingl junmingl 61332 5月  17 05:09 ls_upx</span><br></pre></td></tr></table></figure><p>压缩了有超过 50%。UPX 的压缩成绩是 50~70%，关键是，可执行程序压缩完还是可以执行的。</p><hr><p>参考资料：</p><ol><li><a href="http://tinylab.org/program-size-opt-with-upx/" target="_blank" rel="noopener">单个程序 Size 优化之压缩后自解压执行</a></li><li><a href="https://linux.die.net/man/1/upx" target="_blank" rel="noopener">upx(1) - Linux man page</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍upx相关知识。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第23期</title>
    <link href="http://liujunming.github.io/2021/05/16/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC23%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/05/16/每周分享第23期/</id>
    <published>2021-05-16T04:14:22.000Z</published>
    <updated>2021-05-16T14:32:19.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Quick-Assist"><a href="#Quick-Assist" class="headerlink" title="Quick Assist"></a>Quick Assist</h3><p><a href="https://support.microsoft.com/en-us/windows/solve-pc-problems-over-a-remote-connection-b077e31a-16f4-2529-1a47-21f6a9040bf3" target="_blank" rel="noopener">Solve PC problems over a remote connection</a><a id="more"></a></p><h3 id="科学思想的核心"><a href="#科学思想的核心" class="headerlink" title="科学思想的核心"></a>科学思想的核心</h3><p>先于验证就能理解某种事物的能力，是科学思想的核心。</p><h3 id="stanford-cs-101"><a href="#stanford-cs-101" class="headerlink" title="stanford cs 101"></a>stanford cs 101</h3><p><a href="https://web.stanford.edu/class/cs101/" target="_blank" rel="noopener">https://web.stanford.edu/class/cs101/</a></p><h3 id="codesys"><a href="#codesys" class="headerlink" title="codesys"></a>codesys</h3><p>CODESYS is the leading manufacturer-independent IEC 61131-3 automation software for engineering control systems.</p><h3 id="VNC-还是-RDP-云上的远程桌面究竟该如何选"><a href="#VNC-还是-RDP-云上的远程桌面究竟该如何选" class="headerlink" title="VNC 还是 RDP? 云上的远程桌面究竟该如何选"></a>VNC 还是 RDP? 云上的远程桌面究竟该如何选</h3><p><a href="https://aws.amazon.com/cn/blogs/china/vnc-or-rdp-how-to-choose-a-remote-desktop-on-the-cloud/" target="_blank" rel="noopener">https://aws.amazon.com/cn/blogs/china/vnc-or-rdp-how-to-choose-a-remote-desktop-on-the-cloud/</a></p><h3 id="一名系统研究者的攀登之路"><a href="#一名系统研究者的攀登之路" class="headerlink" title="一名系统研究者的攀登之路"></a>一名系统研究者的攀登之路</h3><p><a href="http://prof.ict.ac.cn/lugang/readings/%E4%B8%80%E5%90%8D%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6%E8%80%85%E7%9A%84%E6%94%80%E7%99%BB%E4%B9%8B%E8%B7%AF.pdf" target="_blank" rel="noopener">http://prof.ict.ac.cn/lugang/readings/%E4%B8%80%E5%90%8D%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6%E8%80%85%E7%9A%84%E6%94%80%E7%99%BB%E4%B9%8B%E8%B7%AF.pdf</a></p><h3 id="what-is-the-reason-for-explicitly-declaring-L-or-UL-for-long-values"><a href="#what-is-the-reason-for-explicitly-declaring-L-or-UL-for-long-values" class="headerlink" title="what is the reason for explicitly declaring L or UL for long values"></a>what is the reason for explicitly declaring L or UL for long values</h3><p><a href="https://stackoverflow.com/questions/13134956/what-is-the-reason-for-explicitly-declaring-l-or-ul-for-long-values" target="_blank" rel="noopener">https://stackoverflow.com/questions/13134956/what-is-the-reason-for-explicitly-declaring-l-or-ul-for-long-values</a></p><h3 id="Why-can’t-I-write-to-the-file-mmaped"><a href="#Why-can’t-I-write-to-the-file-mmaped" class="headerlink" title="Why can’t I write to the file mmaped"></a>Why can’t I write to the file mmaped</h3><p><a href="https://stackoverflow.com/questions/27645215/why-cant-i-write-to-the-file-mmaped" target="_blank" rel="noopener">https://stackoverflow.com/questions/27645215/why-cant-i-write-to-the-file-mmaped</a></p><h3 id="SPDK-vhost-NVMe-Accelerating-I-Os-in-virtual-machines-on-NVMe-SSDs-via-user-space-vhost-target"><a href="#SPDK-vhost-NVMe-Accelerating-I-Os-in-virtual-machines-on-NVMe-SSDs-via-user-space-vhost-target" class="headerlink" title="SPDK vhost-NVMe: Accelerating I/Os in virtual machines on NVMe SSDs via user space vhost target"></a>SPDK vhost-NVMe: Accelerating I/Os in virtual machines on NVMe SSDs via user space vhost target</h3><h3 id="百代小红楼"><a href="#百代小红楼" class="headerlink" title="百代小红楼"></a>百代小红楼</h3><p><a href="https://www.sohu.com/a/347046007_617488" target="_blank" rel="noopener">https://www.sohu.com/a/347046007_617488</a></p><h3 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h3><p>Provides control over the resources available to the shell and processes it creates, on systems that allow such control.</p><p>For more details, please type <code>ulimit --help</code></p><h3 id="如何评价上海交通大学-18-级计算机系第一名「迟先生」的言论？"><a href="#如何评价上海交通大学-18-级计算机系第一名「迟先生」的言论？" class="headerlink" title="如何评价上海交通大学 18 级计算机系第一名「迟先生」的言论？"></a>如何评价上海交通大学 18 级计算机系第一名「迟先生」的言论？</h3><p><a href="https://www.zhihu.com/question/439622084/answer/1695860678" target="_blank" rel="noopener">https://www.zhihu.com/question/439622084/answer/1695860678</a></p><ul><li>培养能力而非其他</li><li>见识决定了你的上限</li><li>努力决定了你的下限</li><li>自驱：让这个过程更加美好</li><li>分享：与世界一起成长</li><li>创造：本质幸福的来源</li><li>后记：科班教育能带给我们什么</li></ul><h3 id="以大多数人努力程度之低，根本轮不到拼智商"><a href="#以大多数人努力程度之低，根本轮不到拼智商" class="headerlink" title="以大多数人努力程度之低，根本轮不到拼智商"></a>以大多数人努力程度之低，根本轮不到拼智商</h3><p><a href="https://www.zhihu.com/question/20712208" target="_blank" rel="noopener">https://www.zhihu.com/question/20712208</a><br><a href="http://www.360doc.com/content/17/1121/11/11555490_705804890.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/17/1121/11/11555490_705804890.shtml</a></p><h3 id="jekyll-page-build-failure"><a href="#jekyll-page-build-failure" class="headerlink" title="jekyll page build failure"></a>jekyll page build failure</h3><p><a href="https://stackoverflow.com/questions/40176947/jekyll-page-build-failure" target="_blank" rel="noopener">https://stackoverflow.com/questions/40176947/jekyll-page-build-failure</a></p><p>The problem was caused by a GitHub server outage, not a problem in my code.</p><p>Anyone can check over at the <a href="https://www.githubstatus.com/" target="_blank" rel="noopener">github status website</a> if their server is down. If it is, there isn’t much you can do except wait until it is back up again…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Quick-Assist&quot;&gt;&lt;a href=&quot;#Quick-Assist&quot; class=&quot;headerlink&quot; title=&quot;Quick Assist&quot;&gt;&lt;/a&gt;Quick Assist&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://support.microsoft.com/en-us/windows/solve-pc-problems-over-a-remote-connection-b077e31a-16f4-2529-1a47-21f6a9040bf3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Solve PC problems over a remote connection&lt;/a&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>how to configure thunderbird to read the mailing list</title>
    <link href="http://liujunming.github.io/2021/05/15/how-to-configure-thunderbird-to-read-the-patch/"/>
    <id>http://liujunming.github.io/2021/05/15/how-to-configure-thunderbird-to-read-the-patch/</id>
    <published>2021-05-15T10:42:56.000Z</published>
    <updated>2021-05-15T11:59:22.532Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何配置thunderbird以阅读邮件列表。<a id="more"></a><br>为什么要这么折腾呢？是为了在Windows系统下，方便阅读邮件列表以提高效率。</p><h3 id="1-Why"><a href="#1-Why" class="headerlink" title="1. Why"></a>1. Why</h3><h4 id="1-1-Thread视图"><a href="#1-1-Thread视图" class="headerlink" title="1.1 Thread视图"></a>1.1 Thread视图</h4><p>outlook<br><img src="/images/2021/05/09.PNG" alt></p><p>thunderbird<br><img src="/images/2021/05/11.PNG" alt></p><h4 id="1-2-嵌套引用"><a href="#1-2-嵌套引用" class="headerlink" title="1.2 嵌套引用"></a>1.2 嵌套引用</h4><p>outlook<br><img src="/images/2021/05/10.PNG" alt></p><p>thunderbird<br><img src="/images/2021/05/12.PNG" alt></p><h4 id="1-3-Patch邮件"><a href="#1-3-Patch邮件" class="headerlink" title="1.3 Patch邮件"></a>1.3 Patch邮件</h4><p>outlook<br><img src="/images/2021/05/10.PNG" alt></p><p>thunderbird<br><img src="/images/2021/05/13.PNG" alt></p><h3 id="2-How"><a href="#2-How" class="headerlink" title="2. How"></a>2. How</h3><h4 id="2-1-配置IMAP-and-SMTP-server"><a href="#2-1-配置IMAP-and-SMTP-server" class="headerlink" title="2.1 配置IMAP  and SMTP server"></a>2.1 配置IMAP  and SMTP server</h4><p>这个步骤是specific的，需要根据你的邮箱server信息正确配置。</p><h4 id="2-2-Message-threading-in-Thunderbird"><a href="#2-2-Message-threading-in-Thunderbird" class="headerlink" title="2.2 Message threading in Thunderbird"></a>2.2 Message threading in Thunderbird</h4><p><img src="/images/2021/05/14.PNG" alt></p><h4 id="2-3-Highlighting-patch-format"><a href="#2-3-Highlighting-patch-format" class="headerlink" title="2.3 Highlighting patch format"></a>2.3 Highlighting patch format</h4><p>Thunderbird has a <a href="https://addons.mozilla.org/en-us/thunderbird/addon/colored-diffs/" target="_blank" rel="noopener">Colored Diffs</a> add-on.</p><p><img src="/images/2021/05/15.png" alt></p><p>  个人遇到的坑：在Windows系统下，有时候高亮显示有问题，不妨重启下系统试试（貌似thunderbird关闭，之后再打开，就不会有高亮显示，重启下系统再打开又会有高亮了）。</p><hr><p> 参考资料：</p><ol><li><a href="https://support.mozilla.org/en-US/kb/message-threading-thunderbird" target="_blank" rel="noopener">Message threading in Thunderbird - keep messages grouped by conversation</a></li><li><a href="https://stackoverflow.com/questions/16185408/recommended-email-client-to-read-apply-git-patches" target="_blank" rel="noopener">Recommended email client to read/apply git patches?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍如何配置thunderbird以阅读邮件列表。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Mutt</title>
    <link href="http://liujunming.github.io/2021/05/09/Introduction-to-Mutt/"/>
    <id>http://liujunming.github.io/2021/05/09/Introduction-to-Mutt/</id>
    <published>2021-05-09T00:24:10.000Z</published>
    <updated>2021-05-09T08:59:09.229Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容转载自:<a href="https://fancyseeker.github.io/2015/08/19/mutt/" target="_blank" rel="noopener">Mutt: 阅读邮件列表</a>。对该文甚是喜欢，个人收获是：不仅仅学到了Mutt这个tools，还可以借鉴作者学习工具的思路。<a id="more"></a></p><blockquote><p> 我需要用Mutt来阅读邮件列表, 之所以选Mutt而不使用传统的邮件客户端或是常用的邮箱是因为其在阅读邮件列表时表现不佳, 缺乏效率. 而当我要着手配置Mutt的时候, 网络上的诸多文章仅仅只能起到参考的作用, 我希望能做到自己来定制Mutt并且是真的了解为什么这么配才去配, 而不是随手拿来一个配置文件就用. 再者, 就是本人有些许强迫症, 像Mutt和其它的一些在Unix-like环境下运行的Tools具有极强定制性的工具, 总是希望能将其尽可能的配置到顺手为止. 因此, 我才花时间来写下这篇文章, 一方面记录自己的配置过程, 方便以后回顾用, 另一方面, 若能顺便帮助下有需要的人, 那也算是意外收获了吧.</p></blockquote><h3 id="1-Why-为什么使用Mutt"><a href="#1-Why-为什么使用Mutt" class="headerlink" title="1. Why: 为什么使用Mutt"></a>1. Why: 为什么使用Mutt</h3><p>从阅读邮件的角度来说, 有很多很好用的邮箱, Gmail就是本人很喜欢的邮箱, 并且一直在用, 除了一些不可控的原因影响其用户体验外, 其它方面确实表现的很好. 那为什么我还要花这么大的力气去配置Mutt呢? Mutt跟其它的邮箱相比, 到底有哪些好处呢? 接下来我们来对比下集中应用场景(主要针对邮件列表阅读).</p><h4 id="1-1-Thread视图"><a href="#1-1-Thread视图" class="headerlink" title="1.1 Thread视图"></a>1.1 Thread视图</h4><p><img src="/images/2021/05/02.jpg" alt><br>Gmail中的邮件列表视图</p><p><img src="/images/2021/05/03.png" alt><br>Mutt中的邮件列表视图</p><p>从上图的对比中可以看到, Gmail中的邮件列表视图是基于发信时间的, 虽然这样可以查看到最新的邮件, 但是邮件列表的上下文逻辑就看不清楚了. Mutt则是基于邮件主题的模式进行排列的, 每封邮件都按照Thread的前后回复逻辑组织在一起, 一眼看去回复关系非常清楚, 而且Mutt还能设置高亮, 例如在上图的配置中, 将未读的邮件设置成高亮的蓝色, 已读的邮件设置成白色, 未读的Thread设置成高亮蓝色, 部分已读部分未读的Thread设置成紫色, 这些高亮都是可以自定义的, 因此打开Mutt的邮件列表视图, 一眼看去就知道哪些邮件是已经看过的, 哪些邮件是完全没看过的以及哪些邮件是只看一部分未看全的.</p><h4 id="1-2-嵌套引用"><a href="#1-2-嵌套引用" class="headerlink" title="1.2 嵌套引用"></a>1.2 嵌套引用</h4><p><img src="/images/2021/05/04.png" alt><br>Gmail中的嵌套引用</p><p><img src="/images/2021/05/05.png" alt><br>Mutt中的嵌套引用</p><p>在邮件列表的阅读中, 经常会出现多层的嵌套引用, 从上图的对比中可以看出, Gmail并未对嵌套的引文做任何处理, 而Mutt则可以使用不同的颜色区分不同层的引文, 引用次序非常清晰明了.</p><h4 id="1-3-Patch邮件"><a href="#1-3-Patch邮件" class="headerlink" title="1.3 Patch邮件"></a>1.3 Patch邮件</h4><p><img src="/images/2021/05/06.png" alt><br>Gmail中的Patch邮件</p><p><img src="/images/2021/05/07.png" alt><br>Mutt中的Patch邮件</p><p>在开源社区, 在发送Patch的时候常常使用<code>git sendmail</code>来发送Patch, 而不是以附件的形式. 我们可以看到, 在Gmail中将Patch中代码的部分直接当做正文来处理, 因此很难看清楚到底Patch中对哪里做了修改, 而在Mutt中, 可以通过正则表达式的方式来匹配正文中的任意字段实现高亮, 将其应用到Patch邮件的正文中, 将增减的行高亮出来, 这样就能很清楚的看明白Patch到底对哪里进行了修改.</p><p>以上例子仅仅只是针对邮件列表阅读这种特殊的应用场景而言, 之所以拿Gmail来比较是因为Gmail本身非常优秀, 也是本人最喜欢的邮箱, 并没有贬低Gmail的意思, 只是应用场景不同罢了. 事实上, 除了邮件列表和工作邮件, 本人的其它私人邮件使用的都是Gmail, 一方面UI设计简洁大方, 另一方面, 邮件搜索过滤对于日常应用来说确实非常好~</p><p>在弄清楚了应用场合之后, 我们来进入正文…</p><h3 id="2-What-Mutt是什么"><a href="#2-What-Mutt是什么" class="headerlink" title="2. What: Mutt是什么"></a>2. What: Mutt是什么</h3><h4 id="2-1-Mutt简介"><a href="#2-1-Mutt简介" class="headerlink" title="2.1 Mutt简介"></a>2.1 Mutt简介</h4><p>Mutt是什么? 或者说Mutt是什么样子的? 根据<a href="http://www.mutt.org/" target="_blank" rel="noopener">Mutt官网</a>上的介绍, Mutt是Unix系统环境下一个小巧但是强大的文本邮件客户端. 小是显而易见的, 功能强大对于本人而言主要体现在以下几个<a href="http://www.mutt.org/#Features" target="_blank" rel="noopener">Mutt Features</a>:</p><ul><li>支持配色</li><li>对邮件列表支持很好</li><li>高度可定制, 支持键绑定和宏</li><li>支持正则表达式以及内部模式匹配等多种搜索</li><li>高效</li></ul><p>此外, Mutt还支持其它很多特性, 比如MIME(这是什么我并不知道, 估计也不会用到), PGP(没有加密邮件的习惯), 支持POP3和IMAP协议(是个邮箱都支持), 完全控制邮件头部等等等等…但是这些特性其它的邮箱也有, 有的甚至做的更好.</p><p>因此, 对于Mutt, 我最看重的还是其它邮箱所没有的特性.</p><ol><li>高度可定制化, 键位绑定和宏对于习惯了Vim和CLI的人来说能提高不少效率;</li><li>对邮件列表支持完善, 这也是我之所以选用Mutt最关键的原因, Mutt针对邮件列表添加了很多很方便的设置和操作, 极大的提高了阅读和回复邮件列表的效率;</li><li>邮件内容支持配色, 这对于阅读带有代码或是多层嵌套引用的邮件来说简直是神技.</li><li>高效, 主要反应在打开一个1000+邮件的信箱只需要1s不到时间, 很快.</li></ol><p>诚然Mutt有很多优点, 但是Mutt仅仅只是一个邮件客户端, 那么问题来了, 什么是邮件客户端(Mail Client)? 通常我们认为一个邮件客户端应该像Outlook和Thunderbird那样, 能收能发能整理能查找. 但是很遗憾的, Mutt跟他们并不一样, Mutt是Unix环境下的small and powerful的邮件客户端, 按照Unix大多工具的尿性, 一般只会提供小而精的功能, 并不会做大而全的封装. Mutt也是一样, <strong>Mutt只管理邮件, 而不负责邮件的收发</strong>. 详细点说, Mutt做的事情只是从本机上的某个位置读取邮件, 或是把邮件存放到本机上的某个位置, 此外, 还负责邮件的阅读, 查找, 标记等事务, 与其说Mutt是一个邮件客户端, 不如说<strong>Mutt是一个邮件管理工具</strong>.</p><h4 id="2-2-Email工作原理"><a href="#2-2-Email工作原理" class="headerlink" title="2.2 Email工作原理"></a>2.2 <a href="/2021/05/08/Email工作原理/">Email工作原理</a></h4><h4 id="2-3-Mutt与msmtp-getmail和procmail的关系"><a href="#2-3-Mutt与msmtp-getmail和procmail的关系" class="headerlink" title="2.3 Mutt与msmtp, getmail和procmail的关系"></a>2.3 Mutt与msmtp, getmail和procmail的关系</h4><p>解释了半天, 相信大家已经被各种M*A给整懵了吧. 以下对邮件发送过程中的各个部分(Agent)做下简要的解释:</p><ul><li><strong>MUA(Mail User Agent)</strong>: 邮件客户端, 负责邮件的管理, 阅读等. 一些集成度较高的MUA会带有收发邮件乃至过滤邮件的功能如Outlook和Thunderbird, Mutt也带有简单的发送邮件功能, 不过一般不采用.</li><li><strong>MTA(Mail Transfer Agent)</strong>: 邮件传送代理, 负责邮件的发送, 处理发送过程中的主机识别, 路由跳转等问题. 对于用户而言MTA就是负责从本地发送邮件的部件. 常见的MTA有sendmail, emstp, msmtp.</li><li><strong>MRA(Mail Retrieval Agent)</strong>: 邮件收取代理, 负责从远端的邮件服务器收取邮件至本地文件夹. 常见的MRA有fetchmail, getmail.</li><li><strong>MDA(Mail Delivery Agent)</strong>: 邮件分发代理, 负责根据规则过滤邮件并将邮件投放到不同的文件夹中. 常见的MDA有procmail.</li></ul><p>之所以讲了这么多Email的工作原理, 主要是为了两件事情.</p><ol><li>明确Mutt在整个邮件收发过程中的位置.</li><li>解释为什么在配置Mutt的时候需要额外安装配置msmtp, getmail乃至procmail.</li></ol><p>当弄明白了Email的工作原理后, 其实也就不难理解为什么在网上搜索Mutt相关资料的时候, 跳出来的都是mutt+getmail+msmtp+procmail之类的文章了. 因为光一个Mutt, 根本无法完成最基本的邮件收发功能啊, 必须需要靠msmtp来发邮件, 靠getmail来收邮件, 如果还需要自定义一些邮件分类过滤行为的话, 还需要procmail来帮忙. 因此, 现在我们在谈论Mutt的时候, 我们其实实在谈论mutt+getmail+msmtp这一串东西.</p><p>然后, 我想再来看看以下这张图, 就明白Mutt与getmail, msmtp以及procmail之间的关系了.</p><p><img src="/images/2021/05/08.jpg" alt><br>Mutt与相关工具的关系(图片版权为tekkamanninja所有)</p><hr><p>参考资料：</p><ol><li><a href="/pdf/Mutt_ 阅读邮件列表 _ FancySeeker.pdf">Mutt: 阅读邮件列表</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容转载自:&lt;a href=&quot;https://fancyseeker.github.io/2015/08/19/mutt/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mutt: 阅读邮件列表&lt;/a&gt;。对该文甚是喜欢，个人收获是：不仅仅学到了Mutt这个tools，还可以借鉴作者学习工具的思路。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Email工作原理</title>
    <link href="http://liujunming.github.io/2021/05/08/Email%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://liujunming.github.io/2021/05/08/Email工作原理/</id>
    <published>2021-05-08T07:15:39.000Z</published>
    <updated>2021-05-08T23:34:33.634Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍<a href="https://fancyseeker.github.io/2015/08/19/mutt/#email%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">Email工作原理</a>。<a id="more"></a></p><center><img src="/images/2021/05/01.png" alt></center><br><center>Email的工作原理</center><p>从上面的原理图中, 我们可以看到整个邮件发送接收的过程。首先, 邮件在MUA(Mail User Agent)中编辑完成, 交由MTA(Mail Transfer Agent)进行发送, 在发送的过程中, 邮件会在多个路由和MTA服务器中中转, 邮件从一个MTA服务器被传输到另一个MTA服务器, 其中使用的是名为<a href="https://zh.wikipedia.org/zh/简单邮件传输协议" target="_blank" rel="noopener">SMTP</a>的邮件传输协议。当邮件到达收件人所处的网络中的MTA时, MTA将邮件交给邮件服务器, 邮件服务器负责将邮件发送给指定用户的信箱中, 邮件服务器在分发邮件的时候, 具有MDA(Mail Delivery Agent)的功能, 其中可能会包含防火墙, 过滤垃圾邮件, 屏蔽黑名单等功能, 我们常见的网络邮箱的工作模式大致是这样的。</p><p>另外, 如果我们使用的是邮件客户端来接收邮件的话, 客户端还需要负责从远端的信箱中拖取邮件到本地的信箱中。这里就需要使用MRA(Mail Retrieval Agent)来完成从远端信箱收取邮件至本地的操作, 在MRA取邮件的时候, 涉及到这么一个问题, 是单纯的将远端邮箱的邮件复制来呢, 还是让本机的信箱跟远端的信箱保持同步呢, 根据收取方式的不同, 区分了两种主流的收取邮件协议<a href="https://zh.wikipedia.org/wiki/郵局協定" target="_blank" rel="noopener">POP3</a>和<a href="https://zh.wikipedia.org/wiki/IMAP" target="_blank" rel="noopener">IMAP</a>。 在邮件到达本地后, 有时在本机上, 会再次对邮件进行一部分分拣和过滤, 例如将来自邮件列表的邮件放到一个特定的文件夹中, 将包含特定文字的邮件放到垃圾邮件文件中等, 这些功能, 是通过本地的MDA来完成的。 最后, 邮件到达了特定的文件夹, MUA, 即邮件客户端从特定文件夹读取邮件, 并解码邮件格式, 展示给用户阅读。 而Mutt, 在整个邮件收发过程中, 做的也就是这个部分(MUA)的事情!</p><p><strong>总结一下</strong>：</p><p>4个M*A</p><ul><li>MUA(Mail User Agent)</li><li>MTA(Mail Transfer Agent)</li><li>MRA(Mail Retrieval Agent)</li><li>MDA(Mail Delivery Agent)</li></ul><p>3个协议：</p><ul><li>SMTP(Simple Mail Transfer Protocol)</li><li>POP3(Post Office Protocol - Version 3)</li><li>IMAP(Internet Message Access Protocol)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍&lt;a href=&quot;https://fancyseeker.github.io/2015/08/19/mutt/#email%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Email工作原理&lt;/a&gt;。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>What is the -fPIE option for position-independent executables in gcc and ld?</title>
    <link href="http://liujunming.github.io/2021/04/17/What-is-the-fPIE-option-for-position-independent-executables-in-gcc-and-ld/"/>
    <id>http://liujunming.github.io/2021/04/17/What-is-the-fPIE-option-for-position-independent-executables-in-gcc-and-ld/</id>
    <published>2021-04-17T05:28:04.000Z</published>
    <updated>2021-04-17T07:31:17.219Z</updated>
    
    <content type="html"><![CDATA[<p>在stackoverflow上看了<a href="https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld" target="_blank" rel="noopener">What is the -fPIE option for position-independent executables in gcc and ld?</a>，对其中的答案甚是满意，所以转载到博客中。<a id="more"></a></p><h3 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h3><p>PIE(position-independent executables) is to support <a href="http://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="noopener">address space layout randomization (ASLR)</a> in executable files.</p><p>Before the PIE mode was created, the program’s executable could not be placed at a random address in memory, only position independent code (PIC) dynamic libraries could be relocated to a random offset. It works very much like what PIC does for dynamic libraries, the difference is that a Procedure Linkage Table (PLT) is not created, instead PC-relative relocation is used.</p><p>After enabling PIE support in gcc/linkers, the body of program is compiled and linked as position-independent code. A dynamic linker does full relocation processing on the program module, just like dynamic libraries. Any usage of global data is converted to access via the Global Offsets Table (GOT) and GOT relocations are added.</p><h3 id="2-Example"><a href="#2-Example" class="headerlink" title="2. Example"></a>2. Example</h3><h4 id="2-1-Minimal-runnable-example-GDB-the-executable-twice"><a href="#2-1-Minimal-runnable-example-GDB-the-executable-twice" class="headerlink" title="2.1 Minimal runnable example: GDB the executable twice"></a>2.1 Minimal runnable example: GDB the executable twice</h4><p>Let’s see ASLR work on the PIE executable and change addresses across runs:</p><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/usr/bin/env bash</span><br><span class="line">echo 2 | sudo tee /proc/sys/kernel/randomize_va_space</span><br><span class="line">for pie in no-pie pie; do</span><br><span class="line">  exe="$&#123;pie&#125;.out"</span><br><span class="line">  gcc -O0 -std=c99 "-$&#123;pie&#125;" "-f$&#123;pie&#125;" -ggdb3 -o "$exe" main.c</span><br><span class="line">  gdb -batch -nh -q \</span><br><span class="line">    -ex 'set disable-randomization off' \</span><br><span class="line">    -ex 'break main' \</span><br><span class="line">    -ex 'run' \</span><br><span class="line">    -ex 'printf "pc = 0x%llx\n", (long  long unsigned)$pc' \</span><br><span class="line">    -ex 'run' \</span><br><span class="line">    -ex 'printf "pc = 0x%llx\n", (long  long unsigned)$pc' \</span><br><span class="line">    "./$exe" \</span><br><span class="line">  ;</span><br><span class="line">  echo</span><br><span class="line">  echo</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>For the one with <code>-no-pie</code>, everything is boring:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1 at 0x40052a: file main.c, line 4.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:4</span><br><span class="line">4           puts(&quot;hello&quot;);</span><br><span class="line">pc = 0x40052a</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:4</span><br><span class="line">4           puts(&quot;hello&quot;);</span><br><span class="line">pc = 0x40052a</span><br></pre></td></tr></table></figure><p>Before starting execution, <code>break main</code> sets a breakpoint at <code>0x40052a</code>.</p><p>Then, during both executions, <code>run</code> stops at address <code>0x40052a</code>.</p><p>The one with <code>-pie</code> however is much more interesting:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1 at 0x754: file main.c, line 4.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:4</span><br><span class="line">4           puts(&quot;hello&quot;);</span><br><span class="line">pc = 0x56093aa99754</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:4</span><br><span class="line">4           puts(&quot;hello&quot;);</span><br><span class="line">pc = 0x55615b05e754</span><br></pre></td></tr></table></figure><p>Before starting execution, GDB just takes a “dummy” address that is present in the executable: <code>0x754</code>.</p><p>After it starts however, GDB intelligently notices that the dynamic loader placed the program in a different location, and the first break stopped at <code>0x56093aa99754</code>.</p><p>Then, the second run also intelligently noticed that the executable moved again, and ended up breaking at <code>0x55615b05e754</code>.</p><p><code>echo 2 | sudo tee /proc/sys/kernel/randomize_va_space</code> ensures that ASLR is on: <a href="https://askubuntu.com/questions/318315/how-can-i-temporarily-disable-aslr-address-space-layout-randomization" target="_blank" rel="noopener">How can I temporarily disable ASLR (Address space layout randomization)? | Ask Ubuntu</a>.</p><p><code>set disable-randomization off</code> is needed otherwise GDB, as the name suggests, turns off ASLR for the process by default to give fixed addresses across runs to improve the debugging experience: <a href="https://stackoverflow.com/questions/10061475/difference-between-gdb-addresses-and-real-addresses" target="_blank" rel="noopener">Difference between gdb addresses and “real” addresses? | Stack Overflow</a>.</p><p><strong>readelf analysis</strong></p><p>Furthermore, we can also observe that:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s ./no-pie.out | grep main</span><br></pre></td></tr></table></figure><p>gives the actual runtime load address (pc pointed to the following instruction 4 bytes after):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">68: 0000000000400526    21 FUNC    GLOBAL DEFAULT   14 main</span><br></pre></td></tr></table></figure><p>while:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s ./pie.out | grep main</span><br></pre></td></tr></table></figure><p>gives just an offset:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">68: 0000000000000750    23 FUNC    GLOBAL DEFAULT   14 main</span><br></pre></td></tr></table></figure><p>By turning ASLR off (with either <code>randomize_va_space</code> or <code>set disable-randomization off</code>), GDB always gives <code>main</code> the address: <code>0x555555554754</code>, so we deduce that the <code>-pie</code> address is composed from:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x555555554000 + random offset + symbol offset (750)</span><br></pre></td></tr></table></figure><h4 id="2-2-Minimal-assembly-example"><a href="#2-2-Minimal-assembly-example" class="headerlink" title="2.2 Minimal assembly example"></a>2.2 Minimal assembly example</h4><p>Another cool thing we can do is to play around with some assembly code to understand more concretely what PIE means.</p><p>We can do that with a Linux x86_64 freestanding assembly hello world:</p><p>main.S</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        .global _start</span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line">_start:</span><br><span class="line">        # write(1, message, 13)</span><br><span class="line">        mov     $1, %rax                # system call 1 is write</span><br><span class="line">        mov     $1, %rdi                # file handle 1 is stdout</span><br><span class="line">        mov     $message, %rsi          # address of string to output</span><br><span class="line">        mov     $13, %rdx               # number of bytes</span><br><span class="line">        syscall                         # invoke operating system to do the write</span><br><span class="line"></span><br><span class="line">        # exit(0)</span><br><span class="line">        mov     $60, %rax               # system call 60 is exit</span><br><span class="line">        xor     %rdi, %rdi              # we want return code 0</span><br><span class="line">        syscall                         # invoke operating system to exit</span><br><span class="line">message:</span><br><span class="line">        .ascii  <span class="string">"Hello, world\n"</span></span><br></pre></td></tr></table></figure><p>and it assembles and runs fine with:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">as -o main.o main.S</span><br><span class="line">ld -o main.out main.o</span><br><span class="line">./main.out</span><br></pre></td></tr></table></figure><p>However, if we try to link it as PIE with (<code>--no-dynamic-linker</code> is required as explained at: <a href="https://stackoverflow.com/questions/55664494/how-to-create-a-statically-linked-position-independent-executable-elf-in-linux" target="_blank" rel="noopener">How to create a statically linked position independent executable ELF in Linux?</a>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld --no-dynamic-linker -pie -o main.out main.o</span><br></pre></td></tr></table></figure><p>then link will fail with:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ld: main.o: relocation R_X86_64_32S against `.text&apos; can not be used when making a shared object; recompile with -fPIC</span><br><span class="line">main.o: error adding symbols: Bad value</span><br></pre></td></tr></table></figure><p>Because the line:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     $message, %rsi          # address of string to output</span><br></pre></td></tr></table></figure><p>hardcodes the message address in the <code>mov</code> operand, and is therefore not position independent.</p><p>If we instead write it in a position independent way:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea message(%rip), %rsi# address of string to output</span><br></pre></td></tr></table></figure><p>then PIE link works fine, and GDB shows us that the executable does get loaded at a different location in memory every time.</p><p>The difference here is that <code>lea</code> encoded the address of <code>msg</code> relative to the current PC address due to the <code>rip</code> syntax, see also:<a href="/2021/04/11/How-to-use-x64-RIP-addressing/">How to use x64 RIP-relative addressing</a></p><p>Another fun thing that we can do is to put the <code>msg</code> in the data section instead of <code>.text</code> with:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">message:</span><br><span class="line">        .ascii  &quot;Hello, world\n&quot;</span><br></pre></td></tr></table></figure><p>Now the <code>.o</code> assembles to:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e:   48 8d 35 00 00 00 00    lea    0x0(%rip),%rsi        # 15 &lt;_start+0x15&gt;</span><br></pre></td></tr></table></figure><p>so the RIP offset is now <code>0</code>, and we guess that a relocation has been requested by the assembler. We confirm that with:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -r main.o</span><br></pre></td></tr></table></figure><p>which gives:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Relocation section &apos;.rela.text&apos; at offset 0x118 contains 1 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000011  000200000002 R_X86_64_PC32     0000000000000000 .data - 4</span><br></pre></td></tr></table></figure><p>so clearly <code>R_X86_64_PC32</code> is a PC relative relocation that <code>ld</code> can handle for PIE executables.</p><p>This experiment taught us that the linker itself checks the program can be PIE and marks it as such.</p><p>Then when compiling with GCC, <code>-pie</code> tells GCC to generate position independent assembly.</p><p>But if we write assembly ourselves, we must manually ensure that we have achieved position independence.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在stackoverflow上看了&lt;a href=&quot;https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What is the -fPIE option for position-independent executables in gcc and ld?&lt;/a&gt;，对其中的答案甚是满意，所以转载到博客中。
    
    </summary>
    
      <category term="计算机编程" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机编程" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>How to use GDB to analyze core dump file</title>
    <link href="http://liujunming.github.io/2021/04/16/How-to-use-GDB-to-analyze-core-dump-file/"/>
    <id>http://liujunming.github.io/2021/04/16/How-to-use-GDB-to-analyze-core-dump-file/</id>
    <published>2021-04-16T12:07:32.000Z</published>
    <updated>2021-04-16T15:52:08.053Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍core dump的相关内容，最后以一个具体的例子来展示:使用GDB解析core dump的基本用法。<br><a id="more"></a></p><h3 id="1-core-dump的基本概念"><a href="#1-core-dump的基本概念" class="headerlink" title="1. core dump的基本概念"></a>1. core dump的基本概念</h3><blockquote><p>A core dump is the recorded state of the working memory of a computer program at a specific time, generally when the program has terminated abnormally (crashed). In practice, other key pieces of program state are usually dumped at the same time, including the processor registers, which may include the program counter and stack pointer, memory management information, and other processor and operating system flags and information. </p></blockquote><h3 id="2-启用core-dump"><a href="#2-启用core-dump" class="headerlink" title="2. 启用core dump"></a>2. 启用core dump</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:~$ help ulimit</span><br><span class="line">    Options:</span><br><span class="line">      -c        the maximum size of core files created</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure><h3 id="3-设置-core-文件的存储目录和命名格式"><a href="#3-设置-core-文件的存储目录和命名格式" class="headerlink" title="3. 设置 core 文件的存储目录和命名格式"></a>3. 设置 core 文件的存储目录和命名格式</h3><p>设置 core 的存储目录和命名格式，主要是修改配置文件 <code>/proc/sys/kernel/core_pattern</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1. 默认在当前程序执行目录下生成，core-程序名-程序pid-时间 [core-test-3451-1516257740]</span><br><span class="line">echo "core-%e-%p-%t" &gt; /proc/sys/kernel/core_pattern</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 2. 添加路径，可以把所有的 core 集中到一个文件夹里 [把所有的core文件放到 /root/core-file 目录下]</span><br><span class="line">echo "/root/core-file/core-%e-%p-%t" &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>为什么会有设置core文件存储目录这个需求呢？答案是：如果程序中调用了<code>chdir</code>函数，则有可能改变了当前工作目录。这时core文件创建在<code>chdir</code>指定的路径下。</p><p>为什么会有设置core文件命名格式的需求呢？答案是：内核在coredump时所产生的core文件放在与该程序相同的目录中，并且文件名固定为<em>core</em>。很显然，如果有多个程序产生core文件，或者同一个程序多次崩溃，就会重复覆盖同一个core文件，因此我们有必要对不同程序生成的core文件分别命名。</p><h3 id="4-如何判断一个文件是coredump文件？"><a href="#4-如何判断一个文件是coredump文件？" class="headerlink" title="4. 如何判断一个文件是coredump文件？"></a>4. 如何判断一个文件是coredump文件？</h3><h4 id="4-1-method1"><a href="#4-1-method1" class="headerlink" title="4.1 method1"></a>4.1 method1</h4><p>在Linux系统下，coredump文件本身是ELF格式的，因此，我们可以通过<code>readelf</code>命令进行判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:~/test$ readelf -h core</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              CORE (Core file)</span><br></pre></td></tr></table></figure><p>可以看到ELF文件头的Type字段的类型是：<code>CORE (Core file)</code></p><h4 id="4-2-method2"><a href="#4-2-method2" class="headerlink" title="4.2 method2"></a>4.2 method2</h4><p>通过简单的file命令进行快速判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:~/test$ file core</span><br><span class="line">core: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from &apos;./a.out&apos;</span><br></pre></td></tr></table></figure><p><code>core file</code></p><h3 id="5-Example"><a href="#5-Example" class="headerlink" title="5. Example"></a>5. Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FILE：test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repeatFree</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* pstr =(<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    repeatFree(pstr); <span class="comment">// 第一次释放</span></span><br><span class="line"></span><br><span class="line">    repeatFree(pstr); <span class="comment">// 第二次释放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:~/test$ gcc -g test.c -o test</span><br><span class="line">acrn@acrn:~/test$ ./test</span><br><span class="line">*** Error in `./test&apos;: double free or corruption (fasttop): 0x000000000164c010 ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7fb1be3fb7e5]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x8037a)[0x7fb1be40437a]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7fb1be40853c]</span><br><span class="line">./test[0x400585]</span><br><span class="line">./test[0x4005b6]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7fb1be3a4830]</span><br><span class="line">./test[0x400499]</span><br><span class="line">======= Memory map: ========</span><br><span class="line">00400000-00401000 r-xp 00000000 103:02 3938165                           /home/acrn/test/test</span><br><span class="line">00600000-00601000 r--p 00000000 103:02 3938165                           /home/acrn/test/test</span><br><span class="line">00601000-00602000 rw-p 00001000 103:02 3938165                           /home/acrn/test/test</span><br><span class="line">0164c000-0166d000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7fb1b8000000-7fb1b8021000 rw-p 00000000 00:00 0</span><br><span class="line">7fb1b8021000-7fb1bc000000 ---p 00000000 00:00 0</span><br><span class="line">7fb1be16e000-7fb1be184000 r-xp 00000000 103:02 8917652                   /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7fb1be184000-7fb1be383000 ---p 00016000 103:02 8917652                   /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7fb1be383000-7fb1be384000 rw-p 00015000 103:02 8917652                   /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7fb1be384000-7fb1be544000 r-xp 00000000 103:02 8913417                   /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7fb1be544000-7fb1be744000 ---p 001c0000 103:02 8913417                   /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7fb1be744000-7fb1be748000 r--p 001c0000 103:02 8913417                   /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7fb1be748000-7fb1be74a000 rw-p 001c4000 103:02 8913417                   /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7fb1be74a000-7fb1be74e000 rw-p 00000000 00:00 0</span><br><span class="line">7fb1be74e000-7fb1be774000 r-xp 00000000 103:02 8913403                   /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7fb1be955000-7fb1be958000 rw-p 00000000 00:00 0</span><br><span class="line">7fb1be972000-7fb1be973000 rw-p 00000000 00:00 0</span><br><span class="line">7fb1be973000-7fb1be974000 r--p 00025000 103:02 8913403                   /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7fb1be974000-7fb1be975000 rw-p 00026000 103:02 8913403                   /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7fb1be975000-7fb1be976000 rw-p 00000000 00:00 0</span><br><span class="line">7fff6edaa000-7fff6edcb000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7fff6edf8000-7fff6edfb000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7fff6edfb000-7fff6edfd000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line">Aborted (core dumped)</span><br><span class="line">acrn@acrn:~/test$ ls</span><br><span class="line">core-test-14363-1618606735  test  test.c</span><br></pre></td></tr></table></figure><p>gdb 调试，找出出错的位置 <code>gdb 程序名 core文件名</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:~/test$ gdb test core-test-14363-1618606735</span><br><span class="line">Reading symbols from test...done.</span><br><span class="line">[New LWP 14363]</span><br><span class="line">Core was generated by `./test&apos;.</span><br><span class="line">Program terminated with signal SIGABRT, Aborted.</span><br><span class="line">#0  0x00007fb1be3b9428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54</span><br><span class="line">54      ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007fb1be3b9428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54</span><br><span class="line">#1  0x00007fb1be3bb02a in __GI_abort () at abort.c:89</span><br><span class="line">#2  0x00007fb1be3fb7ea in __libc_message (do_abort=do_abort@entry=2, fmt=fmt@entry=0x7fb1be514ed8 &quot;*** Error in `%s&apos;: %s: 0x%s ***\n&quot;) at ../sysdeps/posix/libc_fatal.c:175</span><br><span class="line">#3  0x00007fb1be40437a in malloc_printerr (ar_ptr=&lt;optimized out&gt;, ptr=&lt;optimized out&gt;, str=0x7fb1be514fa0 &quot;double free or corruption (fasttop)&quot;, action=3) at malloc.c:5006</span><br><span class="line">#4  _int_free (av=&lt;optimized out&gt;, p=&lt;optimized out&gt;, have_lock=0) at malloc.c:3867</span><br><span class="line">#5  0x00007fb1be40853c in __GI___libc_free (mem=&lt;optimized out&gt;) at malloc.c:2968</span><br><span class="line">#6  0x0000000000400585 in repeatFree (p=0x164c010 &quot;&quot;) at test.c:8</span><br><span class="line">#7  0x00000000004005b6 in main () at test.c:18</span><br></pre></td></tr></table></figure><p>在 gdb 内，输入 <code>where</code> 或者<code>bt</code>可以看出， 我们写的程序出错的两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#6  0x0000000000400585 in repeatFree (p=0x164c010 &quot;&quot;) at test.c:8</span><br><span class="line">#7  0x00000000004005b6 in main () at test.c:18</span><br></pre></td></tr></table></figure><p>在 repeatFree 函数中，test.c 文件的第 8 行错啦，释放了两次内存。</p><p>还有一个值得挖掘的信息是:<code>Program terminated with signal SIGABRT, Aborted.</code></p><p>signal的详细信息请查询<a href="https://man7.org/linux/man-pages/man7/signal.7.html" target="_blank" rel="noopener">signal(7)</a>。</p><h3 id="6-material"><a href="#6-material" class="headerlink" title="6. material"></a>6. material</h3><p>如果想要了解更加详细的内容，推荐阅读<a href="https://averageradical.github.io/Linux_Core_Dumps.pdf" target="_blank" rel="noopener">https://averageradical.github.io/Linux_Core_Dumps.pdf</a> 中对于core dump的介绍。</p><hr><p>参考资料:</p><ol><li><a href="https://www.jianshu.com/p/dc7e7bd7d1a2" target="_blank" rel="noopener">Linux 下生成 core dump 配置和用法</a></li><li><a href="https://blog.csdn.net/tenfyguo/article/details/8159176" target="_blank" rel="noopener">详解coredump</a></li><li><a href="https://man7.org/linux/man-pages/man7/signal.7.html" target="_blank" rel="noopener">signal(7)</a></li><li><a href="https://en.wikipedia.org/wiki/Core_dump" target="_blank" rel="noopener">wikipedia Core dump</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍core dump的相关内容，最后以一个具体的例子来展示:使用GDB解析core dump的基本用法。&lt;br&gt;
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第22期</title>
    <link href="http://liujunming.github.io/2021/04/11/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC22%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/04/11/每周分享第22期/</id>
    <published>2021-04-11T13:01:27.000Z</published>
    <updated>2021-04-11T15:08:43.214Z</updated>
    
    <content type="html"><![CDATA[<h3 id="gitub-代码片段链接"><a href="#gitub-代码片段链接" class="headerlink" title="gitub 代码片段链接"></a>gitub 代码片段链接</h3><p><a href="https://github.com/projectacrn/acrn-hypervisor/blob/master/devicemodel/hw/pci/gvt.c#L53-L65" target="_blank" rel="noopener">https://github.com/projectacrn/acrn-hypervisor/blob/master/devicemodel/hw/pci/gvt.c#L53-L65</a><a id="more"></a></p><h3 id="hard-copy"><a href="#hard-copy" class="headerlink" title="hard-copy"></a>hard-copy</h3><p>A hard copy (or “hardcopy”) is a printed copy of information from a computer.</p><h3 id="IT-圈里有哪些经常被读错的词？"><a href="#IT-圈里有哪些经常被读错的词？" class="headerlink" title="IT 圈里有哪些经常被读错的词？"></a>IT 圈里有哪些经常被读错的词？</h3><p><a href="https://www.zhihu.com/question/19739907" target="_blank" rel="noopener">https://www.zhihu.com/question/19739907</a></p><h3 id="操作系统实验最全学习资料（xv6、ucore）等"><a href="#操作系统实验最全学习资料（xv6、ucore）等" class="headerlink" title="操作系统实验最全学习资料（xv6、ucore）等"></a>操作系统实验最全学习资料（xv6、ucore）等</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg4NjUxMzg5MA==&amp;mid=100004327&amp;idx=1&amp;sn=f0354f86bc655e7998cf3ccc735add3e&amp;chksm=4f99d86a78ee517c252dce904796640d5edc0f3abc0567939df02bf3a395d92d21cde42910b8#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg4NjUxMzg5MA==&amp;mid=100004327&amp;idx=1&amp;sn=f0354f86bc655e7998cf3ccc735add3e&amp;chksm=4f99d86a78ee517c252dce904796640d5edc0f3abc0567939df02bf3a395d92d21cde42910b8#rd</a></p><h3 id="rfc-patch"><a href="#rfc-patch" class="headerlink" title="rfc patch"></a>rfc patch</h3><p><a href="https://git-scm.com/docs/git-format-patch" target="_blank" rel="noopener">https://git-scm.com/docs/git-format-patch</a></p><p>RFC means “Request For Comments”; use this when sending an experimental patch for discussion rather than application.</p><h3 id="使用VGA显示字符串"><a href="#使用VGA显示字符串" class="headerlink" title="使用VGA显示字符串"></a>使用VGA显示字符串</h3><p><a href="https://blog.csdn.net/whimewcm/article/details/83155026" target="_blank" rel="noopener">https://blog.csdn.net/whimewcm/article/details/83155026</a></p><h3 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h3><p><a href="https://zh.wikipedia.org/wiki/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6</a></p><h3 id="城市规划局"><a href="#城市规划局" class="headerlink" title="城市规划局"></a>城市规划局</h3><p><a href="http://www.zgghw.org.cn/" target="_blank" rel="noopener">http://www.zgghw.org.cn/</a></p><h3 id="海天一洲"><a href="#海天一洲" class="headerlink" title="海天一洲"></a>海天一洲</h3><p><a href="https://baike.baidu.com/item/%E6%B5%B7%E5%A4%A9%E4%B8%80%E6%B4%B2" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%B5%B7%E5%A4%A9%E4%B8%80%E6%B4%B2</a></p><h3 id="职场心得：灵性，悟性，积极性"><a href="#职场心得：灵性，悟性，积极性" class="headerlink" title="职场心得：灵性，悟性，积极性"></a>职场心得：灵性，悟性，积极性</h3><h3 id="舟山旅游心得"><a href="#舟山旅游心得" class="headerlink" title="舟山旅游心得"></a>舟山旅游心得</h3><ol><li>若想去东极岛，提前三天，早上五点，公众号(舟山海星轮船)上抢票</li><li>舟山新区交通公众号可以购买不少船票</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;gitub-代码片段链接&quot;&gt;&lt;a href=&quot;#gitub-代码片段链接&quot; class=&quot;headerlink&quot; title=&quot;gitub 代码片段链接&quot;&gt;&lt;/a&gt;gitub 代码片段链接&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/projectacrn/acrn-hypervisor/blob/master/devicemodel/hw/pci/gvt.c#L53-L65&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/projectacrn/acrn-hypervisor/blob/master/devicemodel/hw/pci/gvt.c#L53-L65&lt;/a&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>How to use x64 RIP-relative addressing</title>
    <link href="http://liujunming.github.io/2021/04/11/How-to-use-x64-RIP-addressing/"/>
    <id>http://liujunming.github.io/2021/04/11/How-to-use-x64-RIP-addressing/</id>
    <published>2021-04-11T01:29:36.000Z</published>
    <updated>2021-04-16T15:52:08.054Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍x64 RIP-relative addressing的使用方法。<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><blockquote><p>RIP-relative addressing: this is new for x64 and allows accessing data tables and such in the code relative to the current instruction pointer, making position independent code easier to implement.</p></blockquote><p>position independent code的相关内容较为复杂，本文不会介绍，后续会推出系列文章介绍该部分内容。</p><h3 id="2-Example"><a href="#2-Example" class="headerlink" title="2. Example"></a>2. Example</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># ----------------------------------------------------------------------------------------</span><br><span class="line"># Writes &quot;Hello, World&quot; to the console using only system calls. Runs on 64-bit Linux only.</span><br><span class="line"># To assemble and run:</span><br><span class="line">#</span><br><span class="line">#     gcc -c hello.s &amp;&amp; ld hello.o &amp;&amp; ./a.out</span><br><span class="line">#</span><br><span class="line"># or</span><br><span class="line">#</span><br><span class="line">#     gcc -nostdlib hello.s &amp;&amp; ./a.out</span><br><span class="line"># ----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">        .global _start</span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line">_start:</span><br><span class="line">        # write(1, message, 13)</span><br><span class="line">        mov     $1, %rax                # system call 1 is write</span><br><span class="line">        mov     $1, %rdi                # file handle 1 is stdout</span><br><span class="line">        lea message(%rip), %rsi# address of string to output</span><br><span class="line">        mov     $13, %rdx               # number of bytes</span><br><span class="line">        syscall                         # invoke operating system to do the write</span><br><span class="line"></span><br><span class="line">        # exit(0)</span><br><span class="line">        mov     $60, %rax               # system call 60 is exit</span><br><span class="line">        xor     %rdi, %rdi              # we want return code 0</span><br><span class="line">        syscall                         # invoke operating system to exit</span><br><span class="line">message:</span><br><span class="line">        .ascii  &quot;Hello, world\n&quot;</span><br></pre></td></tr></table></figure><p><code>lea     message(%rip), %rsi</code>就使用了x64 RIP-relative addressing。</p><blockquote><p>AT&amp;T: ‘symbol(%rip)’, Intel: ‘[rip + symbol]’<br>Points to the symbol in RIP relative way.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:~/test$ objdump -D a.out</span><br><span class="line"></span><br><span class="line">a.out:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000400078 &lt;_start&gt;:</span><br><span class="line">  400078:       48 c7 c0 01 00 00 00    mov    $0x1,%rax</span><br><span class="line">  40007f:       48 c7 c7 01 00 00 00    mov    $0x1,%rdi</span><br><span class="line">  400086:       48 8d 35 15 00 00 00    lea    0x15(%rip),%rsi        # 4000a2 &lt;message&gt;</span><br><span class="line">  40008d:       48 c7 c2 0d 00 00 00    mov    $0xd,%rdx</span><br><span class="line">  400094:       0f 05                   syscall</span><br><span class="line">  400096:       48 c7 c0 3c 00 00 00    mov    $0x3c,%rax</span><br><span class="line">  40009d:       48 31 ff                xor    %rdi,%rdi</span><br><span class="line">  4000a0:       0f 05                   syscall</span><br><span class="line"></span><br><span class="line">00000000004000a2 &lt;message&gt;:</span><br><span class="line">  4000a2:       48                      rex.W</span><br><span class="line">  4000a3:       65 6c                   gs insb (%dx),%es:(%rdi)</span><br><span class="line">  4000a5:       6c                      insb   (%dx),%es:(%rdi)</span><br><span class="line">  4000a6:       6f                      outsl  %ds:(%rsi),(%dx)</span><br><span class="line">  4000a7:       2c 20                   sub    $0x20,%al</span><br><span class="line">  4000a9:       77 6f                   ja     40011a &lt;message+0x78&gt;</span><br><span class="line">  4000ab:       72 6c                   jb     400119 &lt;message+0x77&gt;</span><br><span class="line">  4000ad:       64                      fs</span><br><span class="line">  4000ae:       0a                      .byte 0xa</span><br></pre></td></tr></table></figure><p>第11行展示了x64 RIP-relative addressing的效果。为什么是0x15呢？计算公式为:0x4000a2 - 0x40008d</p><h3 id="3-Extension"><a href="#3-Extension" class="headerlink" title="3. Extension"></a>3. Extension</h3><p>Intel SDM Vol2 2.2.1.6 RIP-Relative Addressing</p><blockquote><p>A new addressing form, RIP-relative (relative instruction-pointer) addressing, is implemented in 64-bit mode. An effective address is formed by adding displacement to the 64-bit RIP of the next instruction.</p></blockquote><p>想了解更多细节的话，请查阅SDM。</p><hr><p>参考资料:</p><ol><li><a href="https://sourceware.org/binutils/docs/as/i386_002dMemory.html" target="_blank" rel="noopener">Memory References</a></li><li><a href="https://software.intel.com/content/www/us/en/develop/articles/introduction-to-x64-assembly.html" target="_blank" rel="noopener">Introduction to x64 Assembly</a></li><li><a href="https://stackoverflow.com/questions/3250277/how-to-use-rip-relative-addressing-in-a-64-bit-assembly-program" target="_blank" rel="noopener">How to use RIP Relative Addressing in a 64-bit assembly program?</a></li><li><a href="https://www.polarxiong.com/archives/x64%E4%B8%8BPIC%E7%9A%84%E6%96%B0%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-RIP%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.html" target="_blank" rel="noopener">x64下PIC的新寻址方式：RIP相对寻址</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍x64 RIP-relative addressing的使用方法。
    
    </summary>
    
      <category term="计算机编程" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机编程" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Notes about system call</title>
    <link href="http://liujunming.github.io/2021/04/10/Notes-about-system-call/"/>
    <id>http://liujunming.github.io/2021/04/10/Notes-about-system-call/</id>
    <published>2021-04-10T10:49:52.000Z</published>
    <updated>2021-04-10T12:24:50.645Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要汇总system call相关资料。<a id="more"></a></p><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h3><p>建议阅读<a href="https://cs.lmu.edu/~ray/notes/syscalls/" target="_blank" rel="noopener">ray的notes</a>，并编译运行里面的程序。</p><p><a href="/pdf/syscall/System Calls.pdf">ray’s notes</a></p><p><a href="/pdf/syscall/Linux System Call Table for x86 64 · Ryan A. Chapman.pdf">LINUX SYSTEM CALL TABLE FOR X86 64</a></p><h3 id="2-syscall-vs-sysenter-vs-int-0x80"><a href="#2-syscall-vs-sysenter-vs-int-0x80" class="headerlink" title="2. syscall vs sysenter vs int 0x80"></a>2. syscall vs sysenter vs int 0x80</h3><blockquote><ul><li><code>syscall</code> is the default way of entering kernel mode on <code>x86-64</code>. This instruction is not available in 32 bit modes of operation <em>on Intel processors</em>.</li><li><code>sysenter</code> is an instruction most frequently used to invoke system calls in 32 bit modes of operation. It is similar to <code>syscall</code>, a bit more difficult to use though, but that is the kernel’s concern.</li><li><code>int 0x80</code> is a legacy way to invoke a system call and should be avoided.</li></ul></blockquote><p><a href="https://stackoverflow.com/questions/12806584/what-is-better-int-0x80-or-syscall-in-32-bit-code-on-linux" target="_blank" rel="noopener">What is better “int 0x80” or “syscall” in 32-bit code on Linux?</a></p><p>传统的int 0x80有点慢, Intel实现了sysenter和syscall, 即所谓的快速系统调用指令, 使用它们更快。</p><h3 id="3-vDSO-virtual-dynamic-shared-object"><a href="#3-vDSO-virtual-dynamic-shared-object" class="headerlink" title="3. vDSO(virtual dynamic shared object)"></a>3. vDSO(virtual dynamic shared object)</h3><p>首先运行几个指令，给读者直观地展示vDSO，测试环境为64-bit Linux。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:/proc$ cat /proc/self/maps | tail -2</span><br><span class="line">7ffe0ce1b000-7ffe0ce1d000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line">acrn@acrn:/proc$ cat /proc/self/maps | tail -2</span><br><span class="line">7ffc9c356000-7ffc9c358000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure><p>Note that the vDSO area has moved, while the vsyscall page remains at the same location. The location of the vsyscall page is nailed down in the kernel ABI, but the vDSO area - like most other areas in the user-space memory layout - has its location randomized every time it is mapped.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:/proc$ ldd /bin/sh</span><br><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffc03ffd000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2d40401000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f2d409f3000)</span><br></pre></td></tr></table></figure><p><code>linux-vdso.so.1</code> is a virtual shared object that doesn’t have any physical file on the disk; it’s a part of the kernel that’s exported into every program’s address space when it’s loaded.</p><p>For a more detailed description, <code>man vdso</code></p><p><a href="https://en.wikipedia.org/wiki/VDSO" target="_blank" rel="noopener">wikipedia</a>较好地介绍了vDSO。</p><h4 id="3-1-Introduction"><a href="#3-1-Introduction" class="headerlink" title="3.1 Introduction"></a>3.1 Introduction</h4><blockquote><p><strong>vDSO (virtual dynamic shared object)</strong> is a kernel mechanism for exporting a carefully selected set of kernel space routines to user space applications so that applications can call these kernel space routines in-process, without incurring the performance penalty of a mode switch from user mode to kernel mode that is inherent when calling these same kernel space routines by means of the system call interface.</p></blockquote><h4 id="3-2-Virtual-dynamic-shared-object"><a href="#3-2-Virtual-dynamic-shared-object" class="headerlink" title="3.2 Virtual dynamic shared object"></a>3.2 Virtual dynamic shared object</h4><blockquote><p>vDSO uses standard mechanisms for linking and loading i.e. standard Executable and Linkable Format (ELF) format. vDSO is a memory area allocated in user space which exposes some kernel functionalities. vDSO is dynamically allocated, offers improved safety through address space layout randomization, and supports more than 4 system calls. Some C standard libraries, like glibc, may provide vDSO links so that if the kernel does not have vDSO support, a traditional syscall is made. vDSO helps to reduce the calling overhead on simple kernel routines, and it also can work as a way to select the best system-call method on some computer architectures such as IA-32. </p></blockquote><h4 id="3-3-Vsyscall"><a href="#3-3-Vsyscall" class="headerlink" title="3.3 Vsyscall"></a>3.3 Vsyscall</h4><blockquote><p>DSO was developed to offer the vsyscall features while overcoming its limitations: a small amount of statically allocated memory, which allows only 4 system calls, and the same addresses application binary interface (ABI) in each process, which compromises security. This security issue has been mitigated by emulating a virtual system call, but the emulation introduces additional latency.</p></blockquote><h3 id="4-extension"><a href="#4-extension" class="headerlink" title="4. extension"></a>4. extension</h3><p>Linux内核中system call的实现，以及vDSO的具体实现较为复杂，本文不会介绍相关内容。读者若有兴趣，可以参阅本文引用的链接。当然，读者可以结合源码以及相关资料去学习具体的实现细节。</p><hr><p>参考资料：</p><ol><li><a href="https://lwn.net/Articles/446528/" target="_blank" rel="noopener">On vsyscalls and the vDSO</a></li><li><a href="https://stackoverflow.com/questions/58657036/where-is-linux-vdso-so-1-present-on-the-file-system" target="_blank" rel="noopener">Where is linux-vdso.so.1 present on the file system</a></li><li><a href="https://stackoverflow.com/questions/19938324/what-are-vdso-and-vsyscall" target="_blank" rel="noopener">What are vdso and vsyscall?</a></li><li><a href="https://blog.csdn.net/luozhaotian/article/details/79609077" target="_blank" rel="noopener">VDSO与vsyscall</a></li><li><a href="https://blog.packagecloud.io/eng/2017/03/08/system-calls-are-much-slower-on-ec2/" target="_blank" rel="noopener">Two frequently used system calls are ~77% slower on AWS EC2</a></li><li><a href="https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/" target="_blank" rel="noopener">The Definitive Guide to Linux System Calls</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要汇总system call相关资料。
    
    </summary>
    
      <category term="操作系统" scheme="http://liujunming.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://liujunming.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>The usage of .byte in GAS</title>
    <link href="http://liujunming.github.io/2021/04/01/The-usage-of-byte-in-GAS/"/>
    <id>http://liujunming.github.io/2021/04/01/The-usage-of-byte-in-GAS/</id>
    <published>2021-04-01T08:05:30.000Z</published>
    <updated>2021-04-01T12:26:34.269Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍<a href="/2021/03/29/Notes-for-GNU-related-knowledge/#GAS">GAS</a>中 <code>.byte</code>的用法。<a id="more"></a></p><p><a href="https://sourceware.org/binutils/docs/as/Byte.html#Byte" target="_blank" rel="noopener">权威说法</a>：</p><blockquote><p><code>.byte</code> expects zero or more expressions, separated by commas. Each expression is assembled into the next byte.</p></blockquote><p>本文主要内容转载自：<a href="https://stackoverflow.com/questions/7290318/what-is-the-use-of-byte-assembler-directive-in-gnu-assembly" target="_blank" rel="noopener">What is the use of .byte assembler directive in gnu assembly?</a></p><p><strong>Minimal runnable example</strong></p><p><code>.byte</code> spits out bytes wherever you are. </p><p>If you happen to be in the text segment, then that byte might get run like code.</p><p>Here’s a Linux x86_64 implementation of <code>exit(0)</code> with a <code>nop</code> thrown in:</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    mov $<span class="number">60</span>, %rax</span><br><span class="line">    nop</span><br><span class="line">    mov $<span class="number">0</span>, %rdi</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p>produces the exact same executable as:</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    mov $<span class="number">60</span>, %rax</span><br><span class="line">    .byte <span class="number">0x90</span></span><br><span class="line">    mov $<span class="number">0</span>, %rdi</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p>since <code>nop</code> is encoded as the byte <code>0x90</code>.</p><p><img src="/images/2021/04/1.PNG" alt></p><p>Here’s the method to run the example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as -o my_exit.o my_exit.s &amp;&amp; ld -s -o my_exit my_exit.o &amp;&amp; ./my_exit</span><br></pre></td></tr></table></figure><p><strong>One use case: new instructions</strong></p><p>One use case is when new instructions are added to a CPU ISA, but only very edge versions of the assembler would support it.</p><p>So project maintainers may choose to inline the bytes directly to make it compilable on older assemblers.</p><p>See for example this Spectre workaround on the Linux kernel with the analogous <code>.inst</code> directive: <a href="https://github.com/torvalds/linux/blob/94710cac0ef4ee177a63b5227664b38c95bbf703/arch/arm/include/asm/barrier.h#L23" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/94710cac0ef4ee177a63b5227664b38c95bbf703/arch/arm/include/asm/barrier.h#L23</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSDB    <span class="meta-string">".inst  0xe320f014"</span></span></span><br></pre></td></tr></table></figure><p>A new instruction was added for Spectre, and the kernel decided to hardcode it for the time being.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍&lt;a href=&quot;/2021/03/29/Notes-for-GNU-related-knowledge/#GAS&quot;&gt;GAS&lt;/a&gt;中 &lt;code&gt;.byte&lt;/code&gt;的用法。
    
    </summary>
    
      <category term="计算机编程" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机编程" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第21期</title>
    <link href="http://liujunming.github.io/2021/03/30/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC21%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/03/30/每周分享第21期/</id>
    <published>2021-03-30T11:09:58.000Z</published>
    <updated>2021-03-30T10:51:17.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="紧急复位孔"><a href="#紧急复位孔" class="headerlink" title="紧急复位孔"></a>紧急复位孔</h3><p><a href="https://zhuanlan.zhihu.com/p/35785409" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35785409</a></p><p><a href="https://download.lenovo.com/pccbbs/mobiles_pdf/x1_carbon_ug_zh-cn.pdf" target="_blank" rel="noopener">https://download.lenovo.com/pccbbs/mobiles_pdf/x1_carbon_ug_zh-cn.pdf</a></p><p>如果计算机停止响应，并且无法通过按电源按键关闭计算机，请卸下交流电源适配器，然后向紧急复位孔插入拉直的曲别针以使计算机复位。</p><a id="more"></a><h3 id="如何设置Outlook按照开源社区的方式进行回复"><a href="#如何设置Outlook按照开源社区的方式进行回复" class="headerlink" title="如何设置Outlook按照开源社区的方式进行回复"></a>如何设置Outlook按照开源社区的方式进行回复</h3><p><a href="https://blog.csdn.net/leoufung/article/details/49175751" target="_blank" rel="noopener">https://blog.csdn.net/leoufung/article/details/49175751</a></p><h3 id="中国专利查询"><a href="#中国专利查询" class="headerlink" title="中国专利查询"></a>中国专利查询</h3><p><a href="http://epub.sipo.gov.cn/gjcx.jsp" target="_blank" rel="noopener">http://epub.sipo.gov.cn/gjcx.jsp</a></p><h3 id="Keem-Bay"><a href="#Keem-Bay" class="headerlink" title="Keem Bay"></a>Keem Bay</h3><p>Intel has now detailed what it calls the Gen 3 Intel Movidius VPU codenamed Keem Bay. </p><p><a href="https://www.tomshardware.com/news/intel-announces-movidius-keem-bay-vpu" target="_blank" rel="noopener">https://www.tomshardware.com/news/intel-announces-movidius-keem-bay-vpu</a></p><h3 id="Movidius"><a href="#Movidius" class="headerlink" title="Movidius"></a>Movidius</h3><p>Movidius is a company based in San Mateo, California that designs specialised low-power processor chips for computer vision. The company was acquired by Intel in September 2016.</p><h3 id="chromebook"><a href="#chromebook" class="headerlink" title="chromebook"></a>chromebook</h3><p><a href="https://www.google.com/chromebook/" target="_blank" rel="noopener">https://www.google.com/chromebook/</a></p><h3 id="brpc"><a href="#brpc" class="headerlink" title="brpc"></a>brpc</h3><p><a href="https://github.com/apache/incubator-brpc" target="_blank" rel="noopener">https://github.com/apache/incubator-brpc</a></p><p>An industrial-grade RPC framework used throughout Baidu, with 1,000,000+ instances(not counting clients) and thousands kinds of services. “brpc” means “better RPC”.</p><h3 id="https-salaryfly-com"><a href="#https-salaryfly-com" class="headerlink" title="https://salaryfly.com/"></a><a href="https://salaryfly.com/" target="_blank" rel="noopener">https://salaryfly.com/</a></h3><h3 id="KVM-switch"><a href="#KVM-switch" class="headerlink" title="KVM switch"></a>KVM switch</h3><p><a href="https://en.wikipedia.org/wiki/KVM_switch" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/KVM_switch</a></p><p>A KVM switch (with KVM being an abbreviation for “keyboard, video and mouse”) is a hardware device that allows a user to control multiple computers from one or more sets of keyboards, video monitors, and mice.</p><p><a href="https://www.youtube.com/watch?v=CYq9aeDNAFA" target="_blank" rel="noopener">KVM Switch Setup – 2 Laptops to 1 Monitor – Mac &amp; PC + Zoom – Easy Setup!</a></p><h3 id="Create-a-bootable-USB-drive-using-Etcher"><a href="#Create-a-bootable-USB-drive-using-Etcher" class="headerlink" title="Create a bootable USB drive using Etcher*"></a>Create a bootable USB drive using Etcher*</h3><p><a href="https://docs.01.org/clearlinux/latest/get-started/bootable-usb.html#bootable-usb" target="_blank" rel="noopener">https://docs.01.org/clearlinux/latest/get-started/bootable-usb.html#bootable-usb</a></p><p><a href="/pdf/Create a bootable USB drive using Etcher.pdf">Create a bootable USB drive using Etcher*</a></p><h3 id="atlassian"><a href="#atlassian" class="headerlink" title="atlassian"></a>atlassian</h3><p><a href="https://www.atlassian.com/software/confluence" target="_blank" rel="noopener">https://www.atlassian.com/software/confluence</a></p><p>Confluence is your remote-friendly team workspace where knowledge and collaboration meet.</p><h3 id="学计算机治好了我的完美主义"><a href="#学计算机治好了我的完美主义" class="headerlink" title="学计算机治好了我的完美主义"></a><a href="https://zhuanlan.zhihu.com/p/355089813" target="_blank" rel="noopener">学计算机治好了我的完美主义</a></h3><p><a href="/pdf/学计算机治好了我的完美主义.pdf">学计算机治好了我的完美主义</a></p><blockquote><p>有三种美，结构的美（代表为设计模式）;解构的美（代表为软件开发中的刀砍火烧，虽然程序一团迷惑，但却能正确运行）;重构的美（代表为在开发过程中整理代码，对目标的理解逐渐清晰，逐渐形成团队的共识）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;紧急复位孔&quot;&gt;&lt;a href=&quot;#紧急复位孔&quot; class=&quot;headerlink&quot; title=&quot;紧急复位孔&quot;&gt;&lt;/a&gt;紧急复位孔&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35785409&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/35785409&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://download.lenovo.com/pccbbs/mobiles_pdf/x1_carbon_ug_zh-cn.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://download.lenovo.com/pccbbs/mobiles_pdf/x1_carbon_ug_zh-cn.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果计算机停止响应，并且无法通过按电源按键关闭计算机，请卸下交流电源适配器，然后向紧急复位孔插入拉直的曲别针以使计算机复位。&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>A Simple LD_PRELOAD Tutorial, Part Two</title>
    <link href="http://liujunming.github.io/2021/03/30/A-Simple-LD-PRELOAD-Tutorial-Part-Two/"/>
    <id>http://liujunming.github.io/2021/03/30/A-Simple-LD-PRELOAD-Tutorial-Part-Two/</id>
    <published>2021-03-30T07:10:02.000Z</published>
    <updated>2021-04-11T06:47:51.432Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自:</p><ul><li><a href="https://catonmat.net/simple-ld-preload-tutorial-part-two" target="_blank" rel="noopener">A Simple LD_PRELOAD Tutorial, Part Two</a></li></ul><a id="more"></a><p><a href="https://catonmat.net/simple-ld-preload-tutorial" target="_blank" rel="noopener">Last time</a> I showed you how to override functions in shared libraries by creating your own shared library and preloading it via the <code>LD_PRELOAD</code> environment variable. Today I’ll show you how to call the original function from the overridden function.</p><p>First, let’s review the code example that we used in the previous article. We had a program called <code>prog.c</code> that used <code>fopen</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Calling the fopen() function...\n"</span>);</span><br><span class="line"></span><br><span class="line">    FILE *fd = fopen(<span class="string">"test.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fopen() returned NULL\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fopen() succeeded\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Today let’s write a shared library called <code>myfopen.c</code> that overrides <code>fopen</code> in <code>prog.c</code> and calls the original <code>fopen</code> from the C standard library:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In our own fopen, opening %s\n"</span>, path);</span><br><span class="line"></span><br><span class="line">    FILE *(*original_fopen)(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line">    original_fopen = dlsym(RTLD_NEXT, <span class="string">"fopen"</span>);</span><br><span class="line">    <span class="keyword">return</span> (*original_fopen)(path, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This shared library exports the <code>fopen</code> function that prints the path and then uses <code>dlsym</code> with the <code>RTLD_NEXT</code> pseudohandle to find the original <code>fopen</code> function.</p><p>We must define the _GNU_SOURCE feature macro in order to get the <code>RTLD_NEXT</code> definition from <code>&lt;dlfcn.h&gt;</code>. What <code>RTLD_NEXT</code> does is finds the next occurrence of a function in the search order after the current library.</p><p>We can compile this shared library this way:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -fPIC -shared -o myfopen.so myfopen.c -ldl</span><br></pre></td></tr></table></figure><p>When we preload it and run <code>prog</code> we get the following output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> LD_PRELOAD=./myfopen.so ./prog</span><br><span class="line">Calling the fopen() function...</span><br><span class="line">In our own fopen, opening test.txt</span><br><span class="line">fopen() succeeded</span><br></pre></td></tr></table></figure><p>It prints the filename of the file we’re opening and successfully opens it.</p><p>This is really useful if you need to change how a part of a program works or do some advanced debugging.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://catonmat.net/simple-ld-preload-tutorial-part-two&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A Simple LD_PRELOAD Tutorial, Part Two&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机编程" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机编程" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>A Simple LD_PRELOAD Tutorial</title>
    <link href="http://liujunming.github.io/2021/03/30/A-Simple-LD-PRELOAD-Tutorial/"/>
    <id>http://liujunming.github.io/2021/03/30/A-Simple-LD-PRELOAD-Tutorial/</id>
    <published>2021-03-30T06:21:08.000Z</published>
    <updated>2021-04-11T06:47:51.432Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自:</p><ul><li><a href="https://catonmat.net/simple-ld-preload-tutorial" target="_blank" rel="noopener">A Simple LD_PRELOAD Tutorial</a></li></ul><a id="more"></a><p><code>LD_PRELOAD</code> 的详细描述可以从<code>man ld.so</code>中查询。</p><p>Did you know you could override the C standard library functions, such as <code>printf</code> and <code>fopen</code> with your own functions in any program? In this short article I’ll teach you how to do it via the <code>LD_PRELOAD</code> environment variable.</p><p>Let’s start with a simple C program (prog.c):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Calling the fopen() function...\n"</span>);</span><br><span class="line"></span><br><span class="line">    FILE *fd = fopen(<span class="string">"test.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fopen() returned NULL\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fopen() succeeded\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The code above simply makes a call to the standard <code>fopen</code> function and then checks its return value. Now, let’s compile and execute it:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ls</span><br><span class="line">prog.c  test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> gcc prog.c -o prog</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">prog  prog.c  test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ./prog</span><br><span class="line">Calling the fopen() function...</span><br><span class="line">fopen() succeeded</span><br></pre></td></tr></table></figure></p><p>As you can see, the call to <code>fopen</code> was successful.</p><p>Now, let’s write our own version of <code>fopen</code> that always fails and call this file <code>myfopen.c</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Always failing fopen\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Let’s compile it as a shared library called <code>myfopen.so</code>:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -fPIC -shared -o myfopen.so myfopen.c</span><br></pre></td></tr></table></figure></p><p>Now, if we set the <code>LD_PRELOAD</code> environment variable to <code>myfopen.so</code> shared library before running the program that we created earlier, we get this output:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> LD_PRELOAD=./myfopen.so ./prog</span><br><span class="line">Calling the fopen() function...</span><br><span class="line">Always failing fopen</span><br><span class="line">fopen() returned NULL</span><br></pre></td></tr></table></figure></p><p>As you can see, <code>fopen</code> got replaced with our own version that is always failing.</p><p>This is really handy if you need to debug or replace certain parts of programs or libraries that you didn’t write.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://catonmat.net/simple-ld-preload-tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A Simple LD_PRELOAD Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机编程" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机编程" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Notes for GNU related knowledge</title>
    <link href="http://liujunming.github.io/2021/03/29/Notes-for-GNU-related-knowledge/"/>
    <id>http://liujunming.github.io/2021/03/29/Notes-for-GNU-related-knowledge/</id>
    <published>2021-03-29T08:05:17.000Z</published>
    <updated>2021-05-16T10:51:27.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h3><p><a href="https://www.gnu.org/" target="_blank" rel="noopener">https://www.gnu.org/</a></p><p>GNU is an operating system that is <a href="https://www.gnu.org/philosophy/free-sw.html" target="_blank" rel="noopener">free software</a>—that is, it respects users’ freedom. The GNU operating system consists of GNU packages (programs specifically released by the GNU Project) as well as free software released by third parties. The development of GNU made it possible to use a computer without software that would trample your freedom.</p><a id="more"></a><p>发音：革奴</p><h3 id="GNU-Software"><a href="#GNU-Software" class="headerlink" title="GNU Software"></a>GNU Software</h3><p><a href="https://www.gnu.org/software/" target="_blank" rel="noopener">https://www.gnu.org/software/</a></p><h3 id="groff"><a href="#groff" class="headerlink" title="groff"></a>groff</h3><p><a href="https://www.gnu.org/software/groff/" target="_blank" rel="noopener">https://www.gnu.org/software/groff/</a></p><p>Groff (GNU troff) is a typesetting system that reads plain text mixed with formatting commands and produces formatted output. </p><h3 id="texinfo"><a href="#texinfo" class="headerlink" title="texinfo"></a>texinfo</h3><p><a href="https://www.gnu.org/software/texinfo/" target="_blank" rel="noopener">https://www.gnu.org/software/texinfo/</a></p><p>Texinfo is the official documentation format of the GNU project. It is used by many non-GNU projects as well.</p><h3 id="GAS"><a href="#GAS" class="headerlink" title="GAS"></a>GAS</h3><p><a href="https://sourceware.org/binutils/docs/as/" target="_blank" rel="noopener">https://sourceware.org/binutils/docs/as/</a></p><p>The GNU Assembler, commonly known as gas or simply as, its executable name, is the assembler used by the GNU Project. It is the default back-end of GCC. It is used to assemble the GNU operating system and the Linux kernel, and various other software. It is a part of the GNU Binutils package.</p><p>The GAS executable is named as, the standard name for a Unix assembler. GAS is cross-platform, and both runs on and assembles for a number of different computer architectures.</p><h3 id="glibc"><a href="#glibc" class="headerlink" title="glibc"></a>glibc</h3><p><a href="https://www.gnu.org/software/libc/" target="_blank" rel="noopener">https://www.gnu.org/software/libc/</a><br>The GNU C Library project provides the core libraries for the GNU system and GNU/Linux systems, as well as many other systems that use Linux as the kernel. These APIs include such foundational facilities as <code>open</code>, <code>read</code>, <code>write</code>, <code>malloc</code>, <code>printf</code>, <code>getaddrinfo</code>, <code>dlopen</code>, <code>pthread_create</code>, <code>crypt</code>, <code>login</code>, <code>exit</code> and more.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;GNU&quot;&gt;&lt;a href=&quot;#GNU&quot; class=&quot;headerlink&quot; title=&quot;GNU&quot;&gt;&lt;/a&gt;GNU&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.gnu.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GNU is an operating system that is &lt;a href=&quot;https://www.gnu.org/philosophy/free-sw.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;free software&lt;/a&gt;—that is, it respects users’ freedom. The GNU operating system consists of GNU packages (programs specifically released by the GNU Project) as well as free software released by third parties. The development of GNU made it possible to use a computer without software that would trample your freedom.&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Linux下如何有效使用帮助命令</title>
    <link href="http://liujunming.github.io/2021/03/29/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/"/>
    <id>http://liujunming.github.io/2021/03/29/Linux下如何有效使用帮助命令/</id>
    <published>2021-03-29T07:45:07.000Z</published>
    <updated>2021-03-30T10:51:17.708Z</updated>
    
    <content type="html"><![CDATA[<p>建议阅读如下参考资料:</p><ol><li><a href="https://www.jianshu.com/p/1ab03290f8bc" target="_blank" rel="noopener">linux：帮助命令help、man、info</a></li><li><a href="https://unix.stackexchange.com/questions/19451/difference-between-help-info-and-man-command/159817" target="_blank" rel="noopener">Difference between help, info and man command</a></li></ol><ul><li><p>For help page of  <code>tig</code>, type <code>tig --help</code></p></li><li><p>When you enter <code>tig</code>, type <code>h</code> key for more detailed info.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;建议阅读如下参考资料:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/1ab03290f8bc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;linux：帮助命令help、man、info&lt;/a&gt;&lt;/li&gt;
      
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第20期</title>
    <link href="http://liujunming.github.io/2021/03/27/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC20%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/03/27/每周分享第20期/</id>
    <published>2021-03-27T10:42:41.000Z</published>
    <updated>2021-03-27T14:07:57.655Z</updated>
    
    <content type="html"><![CDATA[<h3 id="101"><a href="#101" class="headerlink" title="101"></a>101</h3><p><a href="https://en.wikipedia.org/wiki/101_(topic)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/101_(topic)</a><br>101 (pronounced “one-oh-one”) is a topic for beginners in any area. It has all the basic principles and concepts that are expected in a particular field.</p><a id="more"></a><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p><a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Universally_unique_identifier</a><br>A universally unique identifier (UUID) is a 128-bit number used to identify information in computer systems. The term globally unique identifier (GUID) is also used, typically in software created by Microsoft.</p><p><strong>UUIDs</strong> are generally <strong>used for</strong> identifying information that needs to be unique within a system or network thereof. Their uniqueness and low probability in being repeated makes them useful for being associative keys in databases and identifiers for physical hardware within an organization.</p><h3 id="SpanDB"><a href="#SpanDB" class="headerlink" title="SpanDB"></a>SpanDB</h3><p><a href="https://github.com/SpanDB/SpanDB" target="_blank" rel="noopener">https://github.com/SpanDB/SpanDB</a></p><p>SpanDB: A Fast, Cost-Effective LSM-tree Based KV Store on Hybrid Storage</p><h3 id="posix-error-code"><a href="#posix-error-code" class="headerlink" title="posix error code"></a>posix error code</h3><p><a href="https://man7.org/linux/man-pages/man3/errno.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/errno.3.html</a><br><a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html" target="_blank" rel="noopener">https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html</a></p><h3 id="usbserial-pl2303"><a href="#usbserial-pl2303" class="headerlink" title="usbserial/pl2303"></a>usbserial/pl2303</h3><p><a href="https://os.mbed.com/handbook/USBSerial" target="_blank" rel="noopener">USBSerial</a> interface is used to emulate a serial port over USB. </p><p>Prolific (PL2303) adapter is an common solution about USB to Serial port adapters.</p><h3 id="Intel-VTune"><a href="#Intel-VTune" class="headerlink" title="Intel VTune"></a>Intel VTune</h3><p><a href="https://software.intel.com/content/www/us/en/develop/tools/oneapi/components/vtune-profiler.html" target="_blank" rel="noopener">https://software.intel.com/content/www/us/en/develop/tools/oneapi/components/vtune-profiler.html</a><br>Intel® VTune™ Profiler optimizes application performance, system performance, and system configuration for HPC, cloud, IoT, media, storage, and more.</p><h3 id="Kata-Container-介绍"><a href="#Kata-Container-介绍" class="headerlink" title="Kata Container 介绍"></a>Kata Container 介绍</h3><p><a href="https://www.cnblogs.com/qccz123456/p/10978505.html" target="_blank" rel="noopener">https://www.cnblogs.com/qccz123456/p/10978505.html</a></p><h3 id="Github-项目与-Travis-CI-集成"><a href="#Github-项目与-Travis-CI-集成" class="headerlink" title="Github 项目与 Travis CI 集成"></a>Github 项目与 Travis CI 集成</h3><p><a href="https://lingxiankong.github.io/2018-06-28-travis-ci-integration.html" target="_blank" rel="noopener">https://lingxiankong.github.io/2018-06-28-travis-ci-integration.html</a><br>要知道什么是 Travis CI，首先要知道什么是持续集成。持续集成，Continuous Integration，简称CI，意思是，在一个项目中，任何人对代码库的任何改动，都会触发CI服务器自动对项目进行构建，自动运行测试，自动编译，甚至自动部署到测试环境。这样做的好处就是，随时发现问题，随时修复。因为修复问题的成本随着时间的推移而增长，越早发现，修复成本越低。</p><p>Travis CI 是在线托管的CI服务，用Travis来进行持续集成，不需要自己搭服务器，在网页上点几下就好，用起来更方便。最重要的是，Travis CI 对 Github 友好，这也是很多程序员喜欢 Travis CI 的理由。写完代码，提交，让 Traivs CI 跑自动化测试，或者 repo 收到 PR 时也会自动跑测试，repo owner 自然就根据测试结果决定是否 review，提高效率。</p><h3 id="Question-on-MMIO-for-a-PCI-device"><a href="#Question-on-MMIO-for-a-PCI-device" class="headerlink" title="Question on MMIO for a PCI device"></a>Question on MMIO for a PCI device</h3><p><a href="https://community.osr.com/discussion/143641/question-on-mmio-for-a-pci-device" target="_blank" rel="noopener">https://community.osr.com/discussion/143641/question-on-mmio-for-a-pci-device</a><br><a href="/pdf/Question on MMIO for a PCI device — OSR.pdf">Question on MMIO for a PCI device</a></p><h3 id="Junfeng-Yang"><a href="#Junfeng-Yang" class="headerlink" title="Junfeng Yang"></a>Junfeng Yang</h3><p><a href="http://www.cs.columbia.edu/~junfeng/" target="_blank" rel="noopener">http://www.cs.columbia.edu/~junfeng/</a></p><h3 id="十年，阿里云重构“计算”"><a href="#十年，阿里云重构“计算”" class="headerlink" title="十年，阿里云重构“计算”"></a>十年，阿里云重构“计算”</h3><p><a href="https://mp.weixin.qq.com/s/RECOMlm46-yaFbEgwlH6iA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/RECOMlm46-yaFbEgwlH6iA</a></p><h3 id="ghproxy-com"><a href="#ghproxy-com" class="headerlink" title="ghproxy.com"></a><a href="http://ghproxy.com" target="_blank" rel="noopener">ghproxy.com</a></h3><p>GitHub 文件 , Releases , archive 以及 raw.githubusercontent.com 文件加速下载服务</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;101&quot;&gt;&lt;a href=&quot;#101&quot; class=&quot;headerlink&quot; title=&quot;101&quot;&gt;&lt;/a&gt;101&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/101_(topic)&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://en.wikipedia.org/wiki/101_(topic)&lt;/a&gt;&lt;br&gt;101 (pronounced “one-oh-one”) is a topic for beginners in any area. It has all the basic principles and concepts that are expected in a particular field.&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化学习心得:three context</title>
    <link href="http://liujunming.github.io/2021/03/20/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97-three-context/"/>
    <id>http://liujunming.github.io/2021/03/20/虚拟化学习心得-three-context/</id>
    <published>2021-03-20T11:40:49.000Z</published>
    <updated>2021-04-09T23:46:59.117Z</updated>
    
    <content type="html"><![CDATA[<p>在虚拟化的学习过程中，对于特权资源，必须知道三个 context: virtual context, shadow context and physical context。同时需要具有如下两个mindsets:</p><ol><li>Know what is done by hardware, what is done by software</li><li>Know what is done in root mode, what is done in non-root mode<a id="more"></a></li></ol><p>详细的讲解可以参考<a href="/pdf/virtualization_basic_concept_discussion.pdf">Basic Concepts of Virtualization</a>。若有疑问，可邮箱联系作者：<a href="mailto:ljm0910@mail.ustc.edu.cn" target="_blank" rel="noopener">ljm0910@mail.ustc.edu.cn</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在虚拟化的学习过程中，对于特权资源，必须知道三个 context: virtual context, shadow context and physical context。同时需要具有如下两个mindsets:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Know what is done by hardware, what is done by software&lt;/li&gt;
&lt;li&gt;Know what is done in root mode, what is done in non-root mode
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>高级操作系统-清华大学-陈渝</title>
    <link href="http://liujunming.github.io/2021/02/09/%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-%E9%99%88%E6%B8%9D/"/>
    <id>http://liujunming.github.io/2021/02/09/高级操作系统-清华大学-陈渝/</id>
    <published>2021-02-09T14:24:39.000Z</published>
    <updated>2021-02-18T13:44:19.018Z</updated>
    
    <content type="html"><![CDATA[<h3 id="课程主页"><a href="#课程主页" class="headerlink" title="课程主页"></a>课程主页</h3><p><a href="http://os.cs.tsinghua.edu.cn/oscourse/AOS2020" target="_blank" rel="noopener">http://os.cs.tsinghua.edu.cn/oscourse/AOS2020</a><br><a id="more"></a></p><h3 id="b站资源"><a href="#b站资源" class="headerlink" title="b站资源"></a>b站资源</h3><p><a href="https://www.bilibili.com/video/BV1pC4y1x7iw" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1pC4y1x7iw</a></p><h3 id="OS2020-video"><a href="#OS2020-video" class="headerlink" title="OS2020-video"></a>OS2020-video</h3><p><a href="https://cloud.tsinghua.edu.cn/d/339de5f93d8c420ebbb7/?p=%2F&amp;mode=list" target="_blank" rel="noopener">https://cloud.tsinghua.edu.cn/d/339de5f93d8c420ebbb7/?p=%2F&amp;mode=list</a></p><h3 id="云学堂"><a href="#云学堂" class="headerlink" title="云学堂"></a>云学堂</h3><p><a href="https://www.xuetangx.com/course/thu080917777/3234209" target="_blank" rel="noopener">https://www.xuetangx.com/course/thu080917777/3234209</a><br>本课程主要围绕操作系统相关研究领域的经典和前沿论文和研究成果进行讲解。大致课程内容如下：</p><p>Lec 1 Advanced OS Overview:</p><ol><li>Course Overview</li><li>Course Scheduling</li><li>Rethink OS Components</li><li>Tendency of OS – Performance</li><li>Tendency of OS – Reliability</li><li>Tendency of OS – Correctness</li><li>Summary</li></ol><p>Lec 2 OS Architecture</p><ol><li>History of OS Architecture – THE</li><li>Monolithic Kernel – UNIX</li><li>Micro Kernel – L4</li><li>ExoKernel</li><li>Extensible Kernel</li><li>Summary</li></ol><p>Lec 3+4 System Virtualization Overview</p><ol><li>Introduction</li><li>Traditional Virtualization Challenges</li><li>Virtualization Technologies -CPU</li><li>Virtualization Technologies -Mmeory</li><li>Virtualization Technologies -I/O</li><li>Some VMMs</li><li>Summary</li></ol><p>Lec 5+6 OS/System API/Interface</p><ol><li>Introduction</li><li>Rethinking the Library OS from the Top Down</li><li>DPDK: Accelerating the I/O Path</li><li>Dune: Safe User-level Access to Privileged CPU Features</li><li>Safe and Secure Drivers in High-Level Languages</li><li>Summary</li></ol><p>Lec 7+8 OS for MultiCore Architecture</p><ol><li>Introduction</li><li>How to analyze the OS bottleneck for multicore arch</li><li>How to optimize the OS for multicore arch</li><li>Optimizing the OS performance from MIT’s research</li><li>Scalable Kernel TCP Design and Implementation for Short-Lived Connections</li><li>Summary</li></ol><p>Lec 9+10 OS/System Security</p><ol><li>Introduction</li><li>Improving Integer Security for Systems with KINT</li><li>PF-Miner: A new paired functions mining method for Android kernel in error paths</li><li>RID: Finding Reference Count Bugs with Inconsistent Path Pair Checking</li><li>Summary</li></ol><p>Lec 11+12 Correctness: OS/System Verification</p><ol><li>Introduction</li><li>seL4: Formal Verification of an OS Kernel</li><li>Jitk: A trustworthy in-kernel interpreter infrastructure</li><li>Hyperkernel: Push-Button Verification of an OS Kernel</li><li>Summary</li></ol><p>Lec 13+14 OS Kernel and HLL</p><ol><li>Introduction</li><li>Multiprogramming a 64 kB Computer Safely and Efficiently</li><li>The benefits and costs of writing a POSIX kernel in a high-level language</li><li>Summary</li></ol><p>Lec 15+16 Invited Talks From Visitors &amp; Students</p><ol><li>High-Performance Network Optimization on Data Center</li><li>Security OS Design for  Multi-tenancy</li><li>OS Performance Optimization for Serverless Service</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;课程主页&quot;&gt;&lt;a href=&quot;#课程主页&quot; class=&quot;headerlink&quot; title=&quot;课程主页&quot;&gt;&lt;/a&gt;课程主页&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://os.cs.tsinghua.edu.cn/oscourse/AOS2020&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://os.cs.tsinghua.edu.cn/oscourse/AOS2020&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://liujunming.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://liujunming.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>软技巧合集</title>
    <link href="http://liujunming.github.io/2021/02/09/%E8%BD%AF%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/"/>
    <id>http://liujunming.github.io/2021/02/09/软技巧合集/</id>
    <published>2021-02-09T06:21:29.000Z</published>
    <updated>2021-04-01T12:26:34.270Z</updated>
    
    <content type="html"><![CDATA[<h3 id="The-Essence-of-Programming"><a href="#The-Essence-of-Programming" class="headerlink" title="The Essence of Programming"></a>The Essence of Programming</h3><p><a href="https://www.gingerbill.org/article/2021/02/01/the-essence-of-programming/" target="_blank" rel="noopener">https://www.gingerbill.org/article/2021/02/01/the-essence-of-programming/</a><br><a id="more"></a></p><h3 id="5W1H"><a href="#5W1H" class="headerlink" title="5W1H"></a>5W1H</h3><p><a href="https://zhuanlan.zhihu.com/p/53393292" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53393292</a></p><p><a href="https://www.humanperf.com/en/blog/nowiunderstand-glossary/articles/5W1H-method" target="_blank" rel="noopener">https://www.humanperf.com/en/blog/nowiunderstand-glossary/articles/5W1H-method</a></p><h3 id="系统设计黄金法则：简单之美"><a href="#系统设计黄金法则：简单之美" class="headerlink" title="系统设计黄金法则：简单之美"></a>系统设计黄金法则：简单之美</h3><p><a href="http://blog.sciencenet.cn/blog-414166-562616.html" target="_blank" rel="noopener">http://blog.sciencenet.cn/blog-414166-562616.html</a></p><h3 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h3><p><a href="https://zhuanlan.zhihu.com/p/118183282" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/118183282</a></p><p><a href="https://www.youtube.com/watch?v=hh9kFKVKpSM" target="_blank" rel="noopener">从学渣到博士：一个学习方法改变我的命运，自创2.0版费曼学习法</a></p><h3 id="What-is-Applied-Category-Theory"><a href="#What-is-Applied-Category-Theory" class="headerlink" title="What is Applied Category Theory?"></a>What is Applied Category Theory?</h3><p><a href="https://arxiv.org/pdf/1809.05923.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1809.05923.pdf</a></p><p> 什么是应用范畴论？</p><p>这是一本关于应用范畴理论的介绍性、解释性笔记集，灵感来自2018年应用范畴理论研讨会，在这些笔记中，我们悠闲地漫步于两个主题（功能语义和组合性），领域内的两个构造（单倍体范畴和修饰cospans）和两个例子（化学反应网络和自然语言处理）  </p><h3 id="如何高效地使用搜索引擎？"><a href="#如何高效地使用搜索引擎？" class="headerlink" title="如何高效地使用搜索引擎？"></a>如何高效地使用搜索引擎？</h3><p><a href="https://www.zhihu.com/question/28013848/answer/62475371" target="_blank" rel="noopener">https://www.zhihu.com/question/28013848/answer/62475371</a></p><h3 id="发现bug的心得"><a href="#发现bug的心得" class="headerlink" title="发现bug的心得"></a>发现bug的心得</h3><p>排列组合所有情况，同时注意corner case，比如边界值。然后给定输入，看看实际的输出与期待的输出是否有差距。写dmar command register就是一个教训，没有考虑初始值，需要将那四位清零之后，再保存到软件的缓存值，否则可能会违背vt-d的spec。<br>分析出各种状态以及状态之间的转换情况，逐个去分析。比如disable physical msi的位置，要考虑到之前的physical msi是enable的，如果放发错位置，那么，当guest disable MSI时，物理的MSI可能并不会disable掉，这就引入了新的bug。<a href="https://lists.projectacrn.org/g/acrn-dev/topic/patch_v3_hv_vpci_fix_msi/81519474?p=,,,20,0,0,0::recentpostdate%2Fsticky,,,20,2,0,81519474" target="_blank" rel="noopener">hv: vpci: fix msi enable issue under some cases</a></p><h3 id="理解不同角色的任务分解"><a href="#理解不同角色的任务分解" class="headerlink" title="理解不同角色的任务分解"></a>理解不同角色的任务分解</h3><ul><li><p>在底层系统学习过程中，要理解：</p><ol><li><p>什么操作是硬件完成的</p></li><li><p>什么操作是软件完成的</p></li></ol></li><li><p>在虚拟化的学习过程中，要理解：</p><ol><li>什么操作是在non-root mode下完成的</li><li>什么操作是在root mode下完成的</li></ol></li><li><p>程序的编译,链接,加载过程中，要理解：</p><ol><li>什么操作是编译器完成的</li><li>什么操作是链接器完成的</li><li>什么操作是加载器完成的</li></ol></li><li><p>C语言打印hello world过程中，要理解：</p><ol><li>什么操作是上层应用程序完成的</li><li>什么操作是<code>glibc</code>完成的</li><li>什么操作是操作系统完成的(系统调用)</li></ol></li></ul><h3 id="如何做工作"><a href="#如何做工作" class="headerlink" title="如何做工作"></a>如何做工作</h3><p><a href="https://weibo.com/3947739858/ItsaLtHbk" target="_blank" rel="noopener">https://weibo.com/3947739858/ItsaLtHbk</a></p><blockquote><p>  张文宏医生技术硬，党性高，牛逼的是还很会做逆境传播，比有些新闻发言人的公共关系水平高不知道多少。</p><p>他没有粉饰太平，直言情况很糟糕，可能还会更糟糕，但解决方法有一二三，我们一起努力好不好。大家感觉你在说真话还说得很清楚，也愿意跟着做。这些算不得正能量，但给了我继续闷在家的能量。  </p></blockquote><blockquote><p>会做工作的，都是这样的，先把情况都讲清楚，把困难说出来，然后再说123我们有多少种办法来解决这些问题？需要什么外部的资源和支撑条件？让领导们都知道情况，然后领导也知道自己该从哪个角度或从从哪方面去帮助他，协调好问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;The-Essence-of-Programming&quot;&gt;&lt;a href=&quot;#The-Essence-of-Programming&quot; class=&quot;headerlink&quot; title=&quot;The Essence of Programming&quot;&gt;&lt;/a&gt;The Essence of Programming&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.gingerbill.org/article/2021/02/01/the-essence-of-programming/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.gingerbill.org/article/2021/02/01/the-essence-of-programming/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
</feed>
