<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2019-08-10T11:26:07.066Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IOMMU的简单介绍</title>
    <link href="http://liujunming.github.io/2019/08/10/IOMMU%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://liujunming.github.io/2019/08/10/IOMMU的简单介绍/</id>
    <published>2019-08-10T01:15:13.000Z</published>
    <updated>2019-08-10T11:26:07.066Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍下IOMMU的相关知识点，相关细节，将在后续的文章中，结合代码，详细讲解。<br><a id="more"></a><br>本文内容是对相关材料的汇总，并非原创。详情参见文章末尾的参考资料。</p><h2 id="1-什么是IOMMU"><a href="#1-什么是IOMMU" class="headerlink" title="1. 什么是IOMMU"></a>1. 什么是IOMMU</h2><p>IOMMU（Input/Output Memory Management Unit）是一个内存管理单元（Memory Management Unit），它的作用是连接DMA-capable I/O总线（Direct Memory Access-capable I/O Bus）和主存（main memory）。传统的内存管理单元会把CPU访问的虚拟地址转化成实际的物理地址。而IOMMU则是把设备（device）访问的虚拟地址转化成物理地址。</p><p><img src="/images/2019/8/4.png" alt></p><h2 id="2-为什么要有IOMMU"><a href="#2-为什么要有IOMMU" class="headerlink" title="2. 为什么要有IOMMU"></a>2. 为什么要有IOMMU</h2><p>首先，我们看下没有IOMMU的世界吧。</p><h3 id="2-1-physical-DMA-without-IOMMU"><a href="#2-1-physical-DMA-without-IOMMU" class="headerlink" title="2.1 physical DMA without IOMMU"></a>2.1 physical DMA without IOMMU</h3><ul><li>一些设备需要大量的物理连续内存，但是os无法为其分配。可以有如下解决方案：<ul><li>在内核启动是为设备保留内存</li><li>将MMU内嵌到设备中，如<a href="http://liujunming.top/2019/07/16/Intel-GPU-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">GPU</a></li></ul></li><li>一些设备有DMA寻址限制，例如，只支持32位的DMA寻址。可以有如下解决方案：<ul><li><a href="http://www.chudov.com/tmp/LinuxVM/html/understand/node65.html" target="_blank" rel="noopener">Bounce buffer</a></li></ul></li><li>没有内存保护机制，设备可能会错误地访问内存地址</li><li>不能支持PCI设备的<a href="http://liujunming.top/pdf/passthrough.pdf" target="_blank" rel="noopener">pass-through</a></li></ul><p>接下来，我们看下拥有IOMMU的世界吧。</p><h3 id="2-2-with-IOMMU"><a href="#2-2-with-IOMMU" class="headerlink" title="2.2 with IOMMU"></a>2.2 with IOMMU</h3><ul><li>使用更大的DMA寻址空间<ul><li>每个设备都用自己独立的DMA内存寻址空间</li></ul></li><li>使用更大的连续DMA内存<ul><li>可以将非连续的物理内存映射到连续的DMA内存空间中</li><li>避免使用<a href="https://knowledge.ni.com/KnowledgeArticleDetails?id=kA00Z0000019NMqSAM" target="_blank" rel="noopener">scatter-gather list</a></li></ul></li><li>避免使用<a href="http://www.chudov.com/tmp/LinuxVM/html/understand/node65.html" target="_blank" rel="noopener">Bounce buffer</a></li><li>提供了访问内存保护机制<ul><li>防止设备错误地访问内存</li></ul></li><li>支持PCI设备的<a href="http://liujunming.top/pdf/passthrough.pdf" target="_blank" rel="noopener">pass-through</a></li></ul><h2 id="3-IOMMU在虚拟化中的用途"><a href="#3-IOMMU在虚拟化中的用途" class="headerlink" title="3. IOMMU在虚拟化中的用途"></a>3. IOMMU在虚拟化中的用途</h2><p>IOMMU的一个重要用途是在虚拟化技术（virtualization）：虚拟机上运行的操作系统（guest OS）通常不知道它所访问的host-physical内存地址。如果要进行DMA操作，就有可能破坏内存，因为实际的硬件（hardware）不知道guest-physical和host-physical内存地址之间的映射关系。IOMMU根据guest-physical和host-physical内存地址之间的转换表（translation table），re-mapping硬件访问的地址，就可以解决这个问题。</p><p>在AMD的<a href="http://pages.cs.wisc.edu/~basu/isca_iommu_tutorial/IOMMU_TUTORIAL_ASPLOS_2016.pdf" target="_blank" rel="noopener">VIRTUALIZING IO THROUGH THE IO MEMORY MANAGEMENT UNIT (IOMMU)</a>文档中，也有一个更全面的总结图：</p><p><img src="/images/2019/8/5.jpg" alt></p><p>引入虚拟化后，带来的问题是：设备看到的是GPA(guest physical address)，但是访问的是HPA(host physical address)。</p><h3 id="3-1-per-BDF-DMA-remapping"><a href="#3-1-per-BDF-DMA-remapping" class="headerlink" title="3.1 per-BDF DMA remapping"></a>3.1 per-BDF DMA remapping</h3><blockquote><p>DMA Remapping通过IOMMU页表方式将直通设备对内存的访问限制到特定的domain中，在提高IO性能的同时完成了直通设备的隔离，保证了直通设备DMA的安全性。</p></blockquote><p><img src="/images/2019/8/6.png" alt></p><h3 id="3-2-interrupt-remapping"><a href="#3-2-interrupt-remapping" class="headerlink" title="3.2 interrupt remapping"></a>3.2 interrupt remapping</h3><blockquote><p>Interrupt Remapping则提供IO设备的中断重映射和路由功能，来达到中断隔离和中断迁移的目的，提升了虚拟化环境下直通设备的中断处理效率。</p></blockquote><blockquote><p>为什么要搞中断重映射这么一套东西呢？直通设备的中断不能直通到虚拟机内部吗？ 我们知道直通场景下直通设备的MSI/MSI-X Msg信息都是由Guest直接分配的，那么问题来了：设备发送中断的时候写的Msg地址是GPA，肯定不能直接往host上投递，否则就乱套了。在虚拟化场景下，直通设备的中断是无法直接投递到Guest中的，那么我们该怎么办？我们可以由IOMMU截获中断，先将中断映射到host的某个中断上，然后再重定向（由VMM投递）到Guest内部。</p></blockquote><p>对于MSI/MSI-X中断机制的相关知识，会在后续的文章中陆续推出。</p><hr><p>参考资料：</p><ol><li><a href="https://lists.linuxfoundation.org/pipermail/iommu/2011-November/003185.html" target="_blank" rel="noopener">Kai Huang mail.kai.huang at gmail.com </a></li><li><a href="https://nanxiao.me/iommu-introduction/" target="_blank" rel="noopener">什么是IOMMU？</a></li><li><a href="https://invisiblethingslab.com/resources/2011/Software%20Attacks%20on%20Intel%20VT-d.pdf" target="_blank" rel="noopener">Software attacks against Intel(R) VT-d technology</a></li><li><a href="https://kernelgo.org/interrupt-remapping.html" target="_blank" rel="noopener">VT-d Interrupt Remapping</a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2019/08/04/iommu-introduction" target="_blank" rel="noopener">IOMMU introduction</a></li><li><a href="https://www.wikiwand.com/en/Input%E2%80%93output_memory_management_unit" target="_blank" rel="noopener">Input–output memory management unit</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍下IOMMU的相关知识点，相关细节，将在后续的文章中，结合代码，详细讲解。&lt;br&gt;
    
    </summary>
    
      <category term="IO系统" scheme="http://liujunming.github.io/categories/IO%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="IO系统" scheme="http://liujunming.github.io/tags/IO%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Makefile 与Linux内核编译系统kbuild</title>
    <link href="http://liujunming.github.io/2019/08/09/Makefile-%E4%B8%8ELinux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9Fkbuild/"/>
    <id>http://liujunming.github.io/2019/08/09/Makefile-与Linux内核编译系统kbuild/</id>
    <published>2019-08-09T10:41:16.000Z</published>
    <updated>2019-08-09T12:52:16.885Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://blog.csdn.net/thisway_diy/article/details/76981113" target="_blank" rel="noopener">内核的Makefile、Kconfig和.config文件</a></p><a id="more"></a><p>如果对makefile一点不懂，可以参考<a href="http://liujunming.top/2017/07/15/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">makefile入门教程</a>。</p><p>最权威资料请查阅<a href="https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt" target="_blank" rel="noopener">Linux Kernel Makefiles</a>。</p><p>Linux内核源码文件繁多，搞不清Makefile、Kconfig、.config间的关系，不了解内核编译体系，编译修改内核有问题无从下手，自己写的驱动不知道怎么编进内核，不知道怎么配置内核，这些问题都和Makefile、Kconfig、.config有关，下面简单谈谈Makefile、Kconfig和.config。</p><h2 id="1-三者的作用"><a href="#1-三者的作用" class="headerlink" title="1. 三者的作用"></a>1. 三者的作用</h2><p>简单来说就是去饭店点菜：Kconfig是菜单，Makefile是做法，.config就是你点的菜。</p><ul><li><p>Makefile：一个文本形式的文件，编译源文件的方法。</p></li><li><p>Kconfig：一个文本形式的文件，内核的配置菜单。</p></li><li><p>.config：编译内核所依据的配置。</p></li></ul><h2 id="2-三者的语法"><a href="#2-三者的语法" class="headerlink" title="2. 三者的语法"></a>2. 三者的语法</h2><h3 id="2-1-Makefile"><a href="#2-1-Makefile" class="headerlink" title="2.1 Makefile"></a>2.1 Makefile</h3><p>参考：linux-3.4.2/drivers/Makefile</p><p>作用：用来定义哪些内容作为模块编译，哪些条件编译等。子目录Makefile被顶层Makefile包含。</p><ol><li><p>直接编译<br><code>obj-y      +=xxx.o</code><br>表示由xxx.c或xxx.s编译得到xxx.o并直接编进内核。</p></li><li><p>条件编译<br><code>obj -$(CONFIG_HELLO)  +=xxx.o</code><br>根据.config文件的CONFIG_XXX来决定文件是否编进内核。</p></li><li><p>模块编译<br><code>obj-m     +=xxx.o</code><br>表示xxx作为模块编译，即执行make modules时才会被编译。</p></li></ol><h3 id="2-2-Kconfig"><a href="#2-2-Kconfig" class="headerlink" title="2.2 Kconfig"></a>2.2 Kconfig</h3><p>每个config菜单项都有类型定义: bool布尔类型、 tristate三态(内建、模块、移除)、string字符串、 hex十六进制、integer整型。 </p><p>作用：决定make menuconfig时展示的菜单项，</p><p>参考：linux-3.4.2/drivers/leds/kconfig：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config LEDS_S3C24XX</span><br><span class="line">       tristate&quot;LED Support for Samsung S3C24XX GPIO LEDs&quot;</span><br><span class="line">       dependson LEDS_CLASS</span><br><span class="line">       dependson ARCH_S3C24XX</span><br><span class="line">       help</span><br><span class="line">         This option enables support for LEDs connected to GPIO lines on Samsung S3C24XX series CPUs, such as the S3C2410 and S3C2440.</span><br></pre></td></tr></table></figure></p><p><code>LEDS_S3C24XX</code>：配置选项的名称，省略了前缀”CONFIG_”</p><p><code>Tristate</code>：表示该项是否编进内核、编成模块。显示为&lt; &gt; , 假如选择编译成内核模块，则会在.config中生成一个 CONFIG_HELLO_MODULE=m的配置，选择Y就是直接编进内核，会在.config中生成一个 CONFIG_HELLO_MODULE=y的配置项。Tristate后的字符串是make menuconfig时显示的配置项名称。</p><p><code>bool</code>：此类型只能选中或不选中，make menuconfig时显示为[ ]，即无法配置成模块。</p><p><code>dependon</code>:该选项依赖于另一个选项，只有当依赖项被选中时，当前配置项的提示信息才会出现，才能设置当前配置项。</p><p><code>select</code>:反向依赖关系，该选项选中时，同时选中select后面定义的那一项。</p><p><code>help</code>：帮助信息。</p><p><code>目录层次迭代</code>：Kconfig中有类似语句：source “drivers/usb/Kconfig” ，用来包含（或嵌套）新的Kconfig文件，使得各个目录管理各自的配置内容，不必把那些配置都写在同一个文件里，方便修改和管理。</p><h3 id="2-3-config"><a href="#2-3-config" class="headerlink" title="2.3 .config"></a>2.3 .config</h3><p>参考：linux-3.4.2/.config</p><p>通过前俩个文件的分析，.config的含义已经很清晰：内核编译参考文件，查看里面内容可以知道哪些驱动被编译进内核。</p><p>配置内核方式有3种(任选其一)：</p><p>（1）make menuconfig<br>（2）make xxx_defconfig<br>（3）直接修改.config</p><p>注意: 如果直接修改.config，不一定会生效，因为有些配置可能存在依赖关系，make时会根据依赖关系，进行规则的检查，直接修改.config有时无效，所以不推荐直接修改。</p><h2 id="3-demo"><a href="#3-demo" class="headerlink" title="3. demo"></a>3. demo</h2><p>以上可能有点抽象，下面举例说明：<br>写一个简单的入口函数输出hello world的驱动并编译进内核。</p><p>步骤：<br>（1）在drivers目录下新建hello文件夹，里面实现hello.c、Makefile、Kconfig。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">first_drv_init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   printk(<span class="string">"------------------hello world !--------------------"</span>); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">first_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   printk(<span class="string">"------------------exit hello world!--------------------"</span>); </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">module_init(first_drv_init); </span><br><span class="line">module_exit(first_drv_exit); </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Makefile</span><br><span class="line"></span><br><span class="line">obj-<span class="variable">$(CONFIG_HELLO)</span>        += hello.o</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Kconfig</span><br><span class="line"></span><br><span class="line">config HELLO  </span><br><span class="line">   tristate &quot;Hello Worldfor fengyuwuzu&quot;  </span><br><span class="line">   help  </span><br><span class="line">     Hello  forfengyuwuzu</span><br></pre></td></tr></table></figure><p>config HELLO决定名字：CONFIG_HELLO。<br>Hello World for fengyuwuzu：决定了在make menuconfig时显示的名字。</p><p>（2）修改上一级（Linux-3.4.2/drivers下）的Makefile、Kconfig。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Makefile</span><br><span class="line"></span><br><span class="line">obj-y  += hello/</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Kconfig</span><br><span class="line"></span><br><span class="line">source &quot;drivers/hello/Kconfig&quot;</span><br></pre></td></tr></table></figure><p>（3）make menuconfig</p><p><img src="/images/2019/8/3.png" alt></p><hr><p>参考资料：</p><ol><li><a href="https://edsionte.com/techblog/archives/1332" target="_blank" rel="noopener">对Makefile、Kconfig与.config文件的再次理解</a></li><li><a href="https://nanxiao.me/linux-kernel-note-59-kconfig-depends-on-select/" target="_blank" rel="noopener">Kconfig中的“depends on”和“select”</a></li><li><a href="https://jin-yang.github.io/reference/linux/kernel/KBUILD_system.pdf" target="_blank" rel="noopener">KBUILD 系统原理分析</a></li><li><a href="https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt" target="_blank" rel="noopener">Linux Kernel Makefiles</a></li><li><a href="https://stackoverflow.com/questions/29231876/how-does-kbuild-actually-work" target="_blank" rel="noopener">How does kbuild actually work?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/thisway_diy/article/details/76981113&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;内核的Makefile、Kconfig和.config文件&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel notifier chain</title>
    <link href="http://liujunming.github.io/2019/08/06/Linux-kernel-notifier-chain/"/>
    <id>http://liujunming.github.io/2019/08/06/Linux-kernel-notifier-chain/</id>
    <published>2019-08-06T15:02:30.000Z</published>
    <updated>2019-08-07T14:48:21.886Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍Linux内核基础–事件通知链。</p><a id="more"></a><p>内容主要转载自：<a href="https://blog.csdn.net/wuhzossibility/article/details/8079025" target="_blank" rel="noopener">Linux内核基础–事件通知链</a>。</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Linux内核中各个子系统相互依赖，当其中某个子系统状态发生改变时，就必须使用一定的机制告知使用其服务的其他子系统，以便其他子系统采取相应的措施。为满足这样的需求，内核实现了事件通知链机制（notification chain）。</p><p>通知链只能用在各个子系统之间，而不能在内核态和用户态之间进行事件通知。内核的核心代码均位于kernel目录下，通知链表位于kernel/notifier.c中，对应的头文件为include/linux/notifier.h。</p><p>事件通知链是一个事件处理函数的列表，每个通知链都与某个或某些事件有关。当特定的事件发生时，就调用相应的事件通知链中的回调函数，进行相应的处理。</p><p><img src="/images/2019/8/2.png" alt></p><center>图 1  内核通知链</center><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p>如图 1中所示，Linux的网络子系统一共有3个通知链：表示ipv4地址发生变化时的inetaddr_chain；表示ipv6地址发生变化的inet6addr_chain；还有表示设备注册、状态变化的netdev_chain。</p><p>在这些链中都是一个个notifier_block结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> &#123;</span></span><br><span class="line">       <span class="keyword">int</span> (*notifier_call)(struct notifier_block *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">void</span> *);</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> *<span class="title">next</span>;</span></span><br><span class="line">       <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中:</p><ol><li><p><code>notifier_call</code>：当相应事件发生时应该调用的函数，由被通知方提供，如other_subsys_1；</p></li><li><p><code>notifier_block *next</code>：用于链接成链表的指针；</p></li><li><p><code>priority</code>：回调函数的优先级，一般默认为0。</p></li></ol><p>内核代码中一般把通知链命名为xxx_chain, xxx_nofitier_chain这种形式的变量名。围绕核心数据结构<code>notifier_block</code>，内核定义了四种通知链类型：</p><ol><li><p>原子通知链（Atomic notifier chains）：通知链元素的回调函数（当事件发生时要执行的函数）在中断或原子操作上下文中运行，不允许阻塞。对应的链表头结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="keyword">spinlock_t</span>  lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>可阻塞通知链（Blocking notifier chains）：通知链元素的回调函数在进程上下文中运行，允许阻塞。对应的链表头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">blocking_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">rw_semaphore</span>  <span class="title">rwsem</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>   *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>原始通知链（Raw notifierchains）：对通知链元素的回调函数没有任何限制，所有锁和保护机制都由调用者维护。对应的链表头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">raw_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>   *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>SRCU 通知链（ SRCU notifier chains ）：可阻塞通知链的一种变体。对应的链表头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">srcu_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">srcu_struct</span>  <span class="title">srcu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>  *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-运行机理"><a href="#3-运行机理" class="headerlink" title="3. 运行机理"></a>3. 运行机理</h2><p>被通知一方（other_subsys_x）通过notifier_chain_register向特定的chain注册回调函数，并且一般而言特定的子系统会用特定的notifier_chain_register包装函数来注册。</p><h3 id="3-1-子系统向事件通知链注册的步骤"><a href="#3-1-子系统向事件通知链注册的步骤" class="headerlink" title="3.1 子系统向事件通知链注册的步骤"></a>3.1 子系统向事件通知链注册的步骤</h3><ol><li><p>申明struct notifier_block结构</p></li><li><p>编写notifier_call函数</p></li><li><p>调用特定的事件通知链的注册函数，将notifier_block注册到通知链中</p></li></ol><h3 id="3-2-通知子系统有事件发生"><a href="#3-2-通知子系统有事件发生" class="headerlink" title="3.2 通知子系统有事件发生"></a>3.2 通知子系统有事件发生</h3><p>inet_subsys是通过notifier_call_chain来通知其他的子系统（other_subsys_x）的。</p><p>notifier_call_chain会按照通知链上各成员的优先级顺序执行回调函数（notifier_call_x）。</p><h3 id="3-3-事件列表"><a href="#3-3-事件列表" class="headerlink" title="3.3 事件列表"></a>3.3 事件列表</h3><p>对于网络子系统而言，其事件常以NETDEV_XXX命名：描述了网络设备状态（dev-&gt;flags）、传送队列状态（dev-&gt;state）、设备注册状态（dev-&gt;reg_state），以及设备的硬件功能特性（dev-&gt;features）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* netdevice notifier chain */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_UP  0x0001  <span class="comment">/* 激活一个网络设备 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_DOWN  0x0002f <span class="comment">/* 停止一个网络设备，所有对该设备的引用都应释放 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_REBOOT       0x0003       <span class="comment">/* 检查到网络设备接口硬件崩溃，硬件重启 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGE       0x0004  <span class="comment">/* 网络设备的数据包队列状态发生改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_REGISTER  0x0005   <span class="comment">/*一个网络设备事例注册到系统中，但尚未激活 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_UNREGISTER       0x0006       <span class="comment">/*网络设备驱动已卸载 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGEMTU      0x0007  <span class="comment">/*MTU发生了改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGEADDR    0x0008  <span class="comment">/*硬件地址发生了改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_GOING_DOWN   0x0009  <span class="comment">/*网络设备即将注销，有dev-&gt;close报告，通知相关子系统处理 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGENAME   0x000A  <span class="comment">/*网络设备名改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_FEAT_CHANGE    0x000B  <span class="comment">/*feature网络硬件功能改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_BONDING_FAILOVER 0x000C  <span class="comment">/*    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_PRE_UP        0x000D  <span class="comment">/*    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_BONDING_OLDTYPE  0x000E              <span class="comment">/*    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_BONDING_NEWTYPE  0x000F      <span class="comment">/*    */</span></span></span><br></pre></td></tr></table></figure><h2 id="4-demo"><a href="#4-demo" class="headerlink" title="4. demo"></a>4. demo</h2><p>notifier_chain机制只能在内核个子系统间使用，因此，这里使用3个模块：test_notifier_chain_0、test_notifier_chain_1、test_notifier_chain_2。<br>test_notifier_chain_2通过module_init初始化时会发出事件TESTCHAIN_2_INIT；然后 test_notifier_chain_1作出相应的处理(打印 test_notifier_chain_2正在初始化)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test_chain_0.c ：0. 申明一个通知链；1. 向内核注册通知链；2. 定义事件； 3. 导出符号*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;   </span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTCHAIN_INIT 0x52U</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">RAW_NOTIFIER_HEAD</span><span class="params">(test_chain)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* define our own notifier_call_chain */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">call_test_notifiers</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> raw_notifier_call_chain(&amp;test_chain, val, v);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(call_test_notifiers);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* define our own notifier_chain_register func */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_test_notifier</span><span class="params">(struct notifier_block *nb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    err = raw_notifier_chain_register(&amp;test_chain, nb);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">EXPORT_SYMBOL(register_test_notifier);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_chain_0_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"I'm in test_chain_0\n"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_chain_0_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"Goodbye to test_chain_0\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL v2"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fishOnFly"</span>);</span><br><span class="line"> </span><br><span class="line">module_init(test_chain_0_init);</span><br><span class="line">module_exit(test_chain_0_exit);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test_chain_1.c ：1. 定义回调函数；2. 定义notifier_block；3. 向chain_0注册notifier_block；*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;   </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">register_test_notifier</span><span class="params">(struct notifier_block *nb)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTCHAIN_INIT 0x52U</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* realize the notifier_call func */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_init_event</span><span class="params">(struct notifier_block *nb, <span class="keyword">unsigned</span> <span class="keyword">long</span> event,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(event)&#123;</span><br><span class="line">    <span class="keyword">case</span> TESTCHAIN_INIT:</span><br><span class="line">        printk(KERN_DEBUG <span class="string">"I got the chain event: test_chain_2 is on the way of init\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> NOTIFY_DONE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* define a notifier_block */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">test_init_notifier</span> = &#123;</span></span><br><span class="line">    .notifier_call = test_init_event,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_chain_1_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"I'm in test_chain_1\n"</span>);</span><br><span class="line">    register_test_notifier(&amp;test_init_notifier);    <span class="comment">// 由chain_0提供的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_chain_1_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"Goodbye to test_clain_l\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fishOnFly"</span>);</span><br><span class="line"> </span><br><span class="line">module_init(test_chain_1_init);</span><br><span class="line">module_exit(test_chain_1_exit);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test_chain_2.c：发出通知链事件*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;   </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">call_test_notifiers</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTCHAIN_INIT 0x52U</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_chain_2_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"I'm in test_chain_2\n"</span>);</span><br><span class="line">    call_test_notifiers(TESTCHAIN_INIT, <span class="string">"no_use"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_chain_2_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"Goodbye to test_chain_2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL v2"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fishOnFly"</span>);</span><br><span class="line"> </span><br><span class="line">module_init(test_chain_2_init);</span><br><span class="line">module_exit(test_chain_2_exit);</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Comment/uncomment the following line to disable/enable debugging</span></span><br><span class="line"><span class="comment"># DEBUG = y</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Add your debugging flag (or not) to CFLAGS</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,y)</span><br><span class="line">  DEBFLAGS = -O -g -DSCULL_DEBUG <span class="comment"># "-O" is needed to expand inlines</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  DEBFLAGS = -O2</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"><span class="comment"># call from kernel build system</span></span><br><span class="line"> </span><br><span class="line">obj-m   := test_chain_0.o test_chain_1.o test_chain_2.o</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> </span><br><span class="line">KERNELDIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">PWD       := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"> </span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"> </span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br><span class="line"> </span><br><span class="line">depend .depend dep:</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -M *.c &gt; .depend</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">ifeq</span> (.depend,<span class="variable">$(<span class="built_in">wildcard</span> .depend)</span>)</span><br><span class="line"><span class="keyword">include</span> .depend</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insmod test_chain_0.ko</span><br><span class="line">insmod test_chain_1.ko</span><br><span class="line">insmod test_chain_2.ko</span><br><span class="line">rmmod test_chain_2.ko</span><br><span class="line">rmmod test_chain_1.ko</span><br><span class="line">rmmod test_chain_0.ko</span><br></pre></td></tr></table></figure><p><img src="/images/2019/8/1.png" alt></p><hr><p>参考资料：</p><ol><li><p><a href="https://blog.csdn.net/wuhzossibility/article/details/8079025" target="_blank" rel="noopener">Linux内核基础–事件通知链</a></p></li><li><p><a href="https://codingfreak.blogspot.com/2012/02/notification-chains-in-linux-kernel.html" target="_blank" rel="noopener">Notification Chains in Linux Kernel</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍Linux内核基础–事件通知链。&lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>linux ioctl()函数详解</title>
    <link href="http://liujunming.github.io/2019/07/20/linux-ioctl-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://liujunming.github.io/2019/07/20/linux-ioctl-函数详解/</id>
    <published>2019-07-20T02:19:28.000Z</published>
    <updated>2019-07-20T05:54:19.032Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要转载自<a href="https://opensourceforu.com/2011/08/io-control-in-linux/" target="_blank" rel="noopener">I/O Control in Linux</a>。</p><blockquote><p>Most drivers need the ability to perform various types of hardware control via the device driver. Most devices can perform operations beyond simple data transfers; user space must often be able to request, for example, that the device lock its door, eject its media, report error information, change a baud rate, or self destruct. These operations are usually supported via the <code>ioctl</code> method, which implements the system call by the same time.</p></blockquote><a id="more"></a><p>摘录自《Linux Device Drivers》第三版第六章。</p><h2 id="Introducing-ioctl"><a href="#Introducing-ioctl" class="headerlink" title="Introducing ioctl()"></a>Introducing <em>ioctl()</em></h2><p>Input/Output Control (<em>ioctl</em>, in short) is a common operation, or system call, available in most driver categories. It is a one-bill-fits-all kind of system call. If there is no other system call that meets a particular requirement, then <code>ioctl()</code> is the one to use.</p><p>Practical examples include volume control for an audio device, display configuration for a video device, reading device registers, and so on — basically, anything to do with device input/output, or device-specific operations, yet versatile enough for any kind of operation (for example, for debugging a driver by querying driver data structures).</p><p>The question is: how can all this be achieved by a single function prototype? The trick lies in using its two key parameters: <em>command</em> and <em>argument</em>. The <em>command</em> is a number representing an operation. The <em>argument</em> is the corresponding parameter for the operation. The <code>ioctl()</code> function implementation does a switch … <em>case</em> over the commmand to implement the corresponding functionality. The following has been its prototype in the Linux kernel for quite some time:</p><p><code>int ioctl(struct inode *i, struct file *f, unsigned int cmd, unsigned long arg);</code></p><p>However, from kernel 2.6.35, it changed to:</p><p><code>long ioctl(struct file *f, unsigned int cmd, unsigned long arg);</code></p><p>If there is a need for more arguments, all of them are put in a structure, and a pointer to the structure becomes the ‘one’ argument. Whether integer or pointer, the argument is taken as a long integer in kernel-space, and accordingly type-cast and processed.</p><p><code>ioctl()</code> is typically implemented as part of the corresponding driver, and then an appropriate function pointer is initialised with it, exactly as in other system calls like <code>open()</code>, <code>read()</code>, etc. For example, in character drivers, it is the <code>ioctl</code> or <code>unlocked_ioctl</code> (since kernel 2.6.35) function pointer field in the struct <code>file_operations</code> that is to be initialised.</p><p>Again, like other system calls, it can be equivalently invoked from user-space using the <code>ioctl()</code> system call, prototyped in <code>&lt;sys/ioctl.h&gt;</code>as:</p><p><code>int ioctl(int fd, int cmd, ...);</code></p><p>Here, <code>cmd</code> is the same as what is implemented in the driver’s <code>ioctl()</code>, and the variable argument construct (<code>...</code>) is a hack to be able to pass any type of argument (though only one) to the driver’s <code>ioctl()</code>. Other parameters will be ignored.</p><p>Note that both the command and argument type definitions need to be shared across the driver (in kernel-space) and the application (in user-space). Thus, these definitions are commonly put into header files for each space.</p><h2 id="Querying-driver-internal-variables"><a href="#Querying-driver-internal-variables" class="headerlink" title="Querying driver-internal variables"></a>Querying driver-internal variables</h2><p>To better understand the boring theory explained above, here’s the code set for the “debugging a driver” example. This driver has three static global variables: <code>status</code>, <code>dignity</code>, and <code>ego</code>, which need to be queried and possibly operated from an application. The header file <code>query_ioctl.h</code> defines the corresponding commands and argument type. A listing follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUERY_IOCTL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_IOCTL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> status, dignity, ego;</span><br><span class="line">&#125; <span class="keyword">query_arg_t</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_GET_VARIABLES _IOR(<span class="meta-string">'q'</span>, 1, query_arg_t *)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_CLR_VARIABLES _IO(<span class="meta-string">'q'</span>, 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_SET_VARIABLES _IOW(<span class="meta-string">'q'</span>, 3, query_arg_t *)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>Using these, the driver’s <code>ioctl()</code> implementation in <code>query_ioctl.c</code> would be as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"query_ioctl.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIRST_MINOR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR_CNT 1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dev_t</span> dev;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">c_dev</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">cl</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> status = <span class="number">1</span>, dignity = <span class="number">3</span>, ego = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_open</span><span class="params">(struct inode *i, struct file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_close</span><span class="params">(struct inode *i, struct file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,35))</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_ioctl</span><span class="params">(struct inode *i, struct file *f, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">my_ioctl</span><span class="params">(struct file *f, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">query_arg_t</span> q;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> QUERY_GET_VARIABLES:</span><br><span class="line">            q.status = status;</span><br><span class="line">            q.dignity = dignity;</span><br><span class="line">            q.ego = ego;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user((<span class="keyword">query_arg_t</span> *)arg, &amp;q, <span class="keyword">sizeof</span>(<span class="keyword">query_arg_t</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QUERY_CLR_VARIABLES:</span><br><span class="line">            status = <span class="number">0</span>;</span><br><span class="line">            dignity = <span class="number">0</span>;</span><br><span class="line">            ego = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QUERY_SET_VARIABLES:</span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;q, (<span class="keyword">query_arg_t</span> *)arg, <span class="keyword">sizeof</span>(<span class="keyword">query_arg_t</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">            &#125;</span><br><span class="line">            status = q.status;</span><br><span class="line">            dignity = q.dignity;</span><br><span class="line">            ego = q.ego;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">query_fops</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = my_open,</span><br><span class="line">    .release = my_close,</span><br><span class="line">#<span class="keyword">if</span> (LINUX_VERSION_CODE &lt; KERNEL_VERSION(<span class="number">2</span>,<span class="number">6</span>,<span class="number">35</span>))</span><br><span class="line">    .ioctl = my_ioctl</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    .unlocked_ioctl = my_ioctl</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">query_ioctl_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev_ret</span>;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((ret = alloc_chrdev_region(&amp;dev, FIRST_MINOR, MINOR_CNT, <span class="string">"query_ioctl"</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cdev_init(&amp;c_dev, &amp;query_fops);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((ret = cdev_add(&amp;c_dev, dev, MINOR_CNT)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(cl = class_create(THIS_MODULE, <span class="string">"char"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        cdev_del(&amp;c_dev);</span><br><span class="line">        unregister_chrdev_region(dev, MINOR_CNT);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(cl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev_ret = device_create(cl, <span class="literal">NULL</span>, dev, <span class="literal">NULL</span>, <span class="string">"query"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        class_destroy(cl);</span><br><span class="line">        cdev_del(&amp;c_dev);</span><br><span class="line">        unregister_chrdev_region(dev, MINOR_CNT);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(dev_ret);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">query_ioctl_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_destroy(cl, dev);</span><br><span class="line">    class_destroy(cl);</span><br><span class="line">    cdev_del(&amp;c_dev);</span><br><span class="line">    unregister_chrdev_region(dev, MINOR_CNT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(query_ioctl_init);</span><br><span class="line">module_exit(query_ioctl_exit);</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Anil Kumar Pugalia &lt;email_at_sarika-pugs_dot_com&gt;"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Query ioctl() Char Driver"</span>);</span><br></pre></td></tr></table></figure><p>And finally, the corresponding invocation functions from the application <code>query_app.c</code> would be as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"query_ioctl.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_vars</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">query_arg_t</span> q;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, QUERY_GET_VARIABLES, &amp;q) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"query_apps ioctl get"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Status : %d\n"</span>, q.status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Dignity: %d\n"</span>, q.dignity);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Ego    : %d\n"</span>, q.ego);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clr_vars</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, QUERY_CLR_VARIABLES) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"query_apps ioctl clr"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_vars</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">query_arg_t</span> q;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter Status: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">    getchar();</span><br><span class="line">    q.status = v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter Dignity: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">    getchar();</span><br><span class="line">    q.dignity = v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter Ego: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">    getchar();</span><br><span class="line">    q.ego = v;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, QUERY_SET_VARIABLES, &amp;q) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"query_apps ioctl set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *file_name = <span class="string">"/dev/query"</span>;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    &#123;</span><br><span class="line">        e_get,</span><br><span class="line">        e_clr,</span><br><span class="line">        e_set</span><br><span class="line">    &#125; option;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        option = e_get;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-g"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            option = e_get;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-c"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            option = e_clr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-s"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            option = e_set;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s [-g | -c | -s]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s [-g | -c | -s]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = open(file_name, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"query_apps open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (option)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> e_get:</span><br><span class="line">            get_vars(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> e_clr:</span><br><span class="line">            clr_vars(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> e_set:</span><br><span class="line">            set_vars(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    close (fd);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now try out <code>query_app.c</code> and <code>query_ioctl.c</code> with the following operations:</p><ul><li>Build the <code>query_ioctl</code> driver (<code>query_ioctl.ko</code> file) and the application (<code>query_app</code> file) by running <code>make</code>, using the following <code>Makefile</code>:</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If called directly from the command line, invoke the kernel build system.</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"> </span><br><span class="line">    KERNEL_SOURCE := /usr/src/linux</span><br><span class="line">    PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">default: module query_app</span></span><br><span class="line"> </span><br><span class="line"><span class="section">module:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_SOURCE)</span> SUBDIRS=<span class="variable">$(PWD)</span> modules</span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_SOURCE)</span> SUBDIRS=<span class="variable">$(PWD)</span> clean</span><br><span class="line">    $&#123;RM&#125; query_app</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Otherwise KERNELRELEASE is defined; we've been invoked from the</span></span><br><span class="line"><span class="comment"># kernel build system and can use its language.</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> </span><br><span class="line">    obj-m := query_ioctl.o</span><br><span class="line"> </span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><ul><li>Load the driver using insmod <code>query_ioctl.ko</code>.</li><li>With appropriate privileges and command-line arguments, run the application <code>query_app</code>:<ul><li><code>./query_app</code> — to display the driver variables</li><li><code>./query_app -c</code> — to clear the driver variables</li><li><code>./query_app -g</code> — to display the driver variables</li><li><code>./query_app -s</code> — to set the driver variables (not mentioned above)</li></ul></li><li>Unload the driver using <code>rmmod query_ioctl</code>.</li></ul><h2 id="Defining-the-ioctl-commands"><a href="#Defining-the-ioctl-commands" class="headerlink" title="Defining the ioctl() commands"></a>Defining the <em>ioctl()</em> commands</h2><p>You may wondere about <code>_IOR</code>, <code>_IO</code>, etc., which were used in defining commands in <code>query_ioctl.h</code>. These are usual numbers only, as mentioned earlier for an <code>ioctl()</code> command. Just that, now additionally, some useful command related information is also encoded as part of these numbers using various macros, as per the POSIX standard for <code>ioctl</code>. The standard talks about the 32-bit command numbers, formed of four components embedded into the [31:0] bits:</p><ol><li>The direction of command operation [bits 31:30] — read, write, both, or none — filled by the corresponding macro (<code>_IOR</code>, <code>_IOW</code>, <code>_IOWR</code>, <code>_IO</code>).</li><li>The size of the  argument [bits 29:16] — computed using <code>sizeof()</code> with the  argument’s type — the third argument to these macros.</li><li>The 8-bit magic number [bits 15:8] — to render the commands unique enough — typically an ASCII character (the first argument to these macros).</li><li>The original command number [bits 7:0] — the actual command number (1, 2, 3, …), defined as per our requirement — the second argument to these macros.</li></ol><p>Check out the header <a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/ioctl.h" target="_blank" rel="noopener">&lt;asm-generic/ioctl.h&gt;</a> for implementation details.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要转载自&lt;a href=&quot;https://opensourceforu.com/2011/08/io-control-in-linux/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;I/O Control in Linux&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Most drivers need the ability to perform various types of hardware control via the device driver. Most devices can perform operations beyond simple data transfers; user space must often be able to request, for example, that the device lock its door, eject its media, report error information, change a baud rate, or self destruct. These operations are usually supported via the &lt;code&gt;ioctl&lt;/code&gt; method, which implements the system call by the same time.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/categories/I-O%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>程序员眼中的PCI设备</title>
    <link href="http://liujunming.github.io/2019/07/19/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9C%BC%E4%B8%AD%E7%9A%84PCI%E8%AE%BE%E5%A4%87/"/>
    <id>http://liujunming.github.io/2019/07/19/程序员眼中的PCI设备/</id>
    <published>2019-07-19T10:18:52.000Z</published>
    <updated>2019-07-19T14:26:35.687Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文主要内容来自<a href="https://book.douban.com/subject/3619896/" target="_blank" rel="noopener">系统虚拟化</a>，再加上自己的一些理解，希望能将PCI设备的内容解释清楚。</p><p>何为PCI(Peripheral Component Interconnect)总线？PCI总线是CPU与外部设备沟通的桥梁。<a id="more"></a>PCI总线的优点：速度快、具有动态配置功能、独立于CPU架构等，因而迅速被各种平台接受，成为一种通用的总线架构。</p><h3 id="1-PCI总线架构"><a href="#1-PCI总线架构" class="headerlink" title="1. PCI总线架构"></a>1. PCI总线架构</h3><p>PCI总线是一种典型的树结构。把北桥中HOST-PCI桥看作根，总线中其他PCI-PCI桥、PCI-ISA桥等桥设备和直接接PCI总线的设备看作节点，整个PCI架构可以概括为下图所示。<br><img src="/images/2019/7/4.png" alt></p><h4 id="设备标识符"><a href="#设备标识符" class="headerlink" title="设备标识符"></a><strong>设备标识符</strong></h4><p><img src="/images/2019/7/5.png" alt></p><h3 id="2-PCI设备枚举过程"><a href="#2-PCI设备枚举过程" class="headerlink" title="2. PCI设备枚举过程"></a>2. PCI设备枚举过程</h3><p>PCI设备和总线一起构成了树结构，其中桥设备是子树的根节点，设备枚举的过程就是要在内存中建立一颗和实际总线情况相符合的设备树。枚举过程中最关键的步骤就是发现桥设备。<br><a href="https://www.youtube.com/watch?v=qhIHu8mFrdg" target="_blank" rel="noopener">PCI Basics and Bus Enumeration</a>很好地阐述了此动态过程，看完视频之后都理解的话，那么对PCI设备枚举过程也就理解了。</p><h3 id="3-PCI-configeration-space"><a href="#3-PCI-configeration-space" class="headerlink" title="3. PCI configeration space"></a>3. PCI configeration space</h3><p>通过BDF，我们可以唯一标志一个设备。每个设备，都有自己PCI configeration space，而PCI configeration space本质是registers。PCI设备规范规定，设备的配置空间最多为256个字节，其中前64个字节的格式和用途是统一的，如下图所示。<br><img src="/images/2019/7/6.png" alt></p><p><strong>例1：</strong>假设设备1的BDF编号是(0,3,2),当我们需要定位其Expansion ROM Base Address寄存器时，应输入(0,3,2,30h)。</p><p>x86架构把I/O端口地址空间中的0xCF8~0xCFF段预留给了PCI总线，用于访问设备的配置空间。其中，前32位的寄存器为”地址寄存器“，后32位为”值寄存器“。软件通过把设备的BDF和要访问的配置空间的字节偏移量写入”地址寄存器“中，就可以通过”值寄存器“读写该配置空间了。</p><p>BDF占据16bits，而PCI configeration space最多为256个字节，也就是64个DWORD(Double WORD,WORD占16位，DWORD即占32位)，所以Config. Addr只需占用6bits(能定位到64个DWORD)。具体位数含义可参见下图：<br><img src="/images/2019/7/7.png" alt></p><p>如例1所示，我们将(0,3,2,30h)写入pio的0xCF8h，就可以通过读0xCFCh来获取设备1的Expansion ROM Base Address寄存器值了。</p><p>讲完Accessing PCIe Config Registers后，我们需要介绍下程序员最关心的Base Address Registers和Interrupt Line了。</p><ul><li>Base Address Registers:基地址寄存器，也就是常说的PCI Bar。它报告设备寄存器或者设备RAM在I/O端口地址空间（或物理地址空间中）的地址。地址是由软件(BIOS或操作系统)动态设置的。通常枚举PCI设备的软件(BIOS或操作系统)会在获得平台所有PCI设备后，根据设备数量，依照固定的算法为每个设备的PCI Bar分配I/O端口(或物理地址)。设备的电子线路负责把这些端口(或地址)映射到自身的寄存器(设备RAM)上，这样CPU就可以通过端口号(Port I/O方式)、物理地址(MMIO方式)访问到设备了。</li></ul><ul><li>Interupt Line:设备的中断线。BIOS通常用它来保存设备所连的PIC/IOAPIC的管脚号。</li></ul><hr><p>参考资料：</p><ol><li><a href="https://book.douban.com/subject/3619896/" target="_blank" rel="noopener">系统虚拟化</a></li><li><a href="http://cpci.co.kr/eng/download/technote/config-pci.pdf" target="_blank" rel="noopener">PCI configuration mechanism </a></li><li><a href="https://www.youtube.com/watch?v=qhIHu8mFrdg" target="_blank" rel="noopener">PCI Basics and Bus Enumeration</a></li><li><a href="https://www.youtube.com/watch?v=6112AekrsqA" target="_blank" rel="noopener">Accessing PCIe Config Registers</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注：本文主要内容来自&lt;a href=&quot;https://book.douban.com/subject/3619896/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;系统虚拟化&lt;/a&gt;，再加上自己的一些理解，希望能将PCI设备的内容解释清楚。&lt;/p&gt;
&lt;p&gt;何为PCI(Peripheral Component Interconnect)总线？PCI总线是CPU与外部设备沟通的桥梁。
    
    </summary>
    
      <category term="系统" scheme="http://liujunming.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="http://liujunming.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Intel GPU 内存管理</title>
    <link href="http://liujunming.github.io/2019/07/16/Intel-GPU-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://liujunming.github.io/2019/07/16/Intel-GPU-内存管理/</id>
    <published>2019-07-16T13:18:59.000Z</published>
    <updated>2019-07-16T15:07:44.047Z</updated>
    
    <content type="html"><![CDATA[<p>本文将会介绍Intel GPU的内存管理。<a id="more"></a>由于不同GPU的参数可能不一致，本文给出的参数是demo性质的，如果想要查看GPU的具体参数，请参考<a href="https://01.org/zh/linuxgraphics/documentation/hardware-specification-prms" target="_blank" rel="noopener">HARDWARE SPECIFICATION - PRMS</a>。</p><p>PS:到目前为止，我司GPU的memory依然是system memory，而非on-die memory。</p><p>对于GPU的应用而言，GPU的virtual memory address space分为两部分，分别是global graphic memory和local graphic memory。在本文接下来的内容中，我们将global graphic memory和local graphic memory的大小设置为2GB。</p><h2 id="global-graphic-memory"><a href="#global-graphic-memory" class="headerlink" title="global graphic memory"></a>global graphic memory</h2><p>对于GPU的global graphic memory，是所有进程共享的：即所有的进程共用这2GB的虚拟地址空间。</p><p>当GPU访问global graphic memory时，利用global graphics translation table (GGTT) 来完成虚拟地址到物理地址的映射，过程如下图所示（可以将GGTT看作是GPU的页表，同时GGTT是一级页表，而寻址过程是由硬件来完成的）。</p><p><img src="/images/2019/7/1.png" alt></p><p>global graphic memory的部分内存，CPU是可以访问的，这样才能完成GPU与CPU的数据交互。对于CPU能访问的这部分内存，我们称之为<a href="https://www.wikiwand.com/en/Aperture_%28computer_memory%29" target="_blank" rel="noopener">aperture</a>。CPU的虚拟地址空间与GPU的虚拟地址空间是相互独立的，因此，CPU如果想要访问aperture，就需要将aperture mmap到CPU的虚拟地址空间。</p><p><img src="/images/2019/7/2.png" alt></p><p>如上图所示，在GPU的global graphic memory中，0~FFFFFF的内容是aperture，而CPU将aperture内存mmap到C000000~CFFFFFF地址范围内，这样CPU就可以访问aperture了。对于global graphic memory的非aperture部分，CPU是无法访问的。</p><h2 id="local-graphic-memory"><a href="#local-graphic-memory" class="headerlink" title="local graphic memory"></a>local graphic memory</h2><p>对于GPU的local graphic memory，每个进程都有2GB的虚拟地址空间。GPU通过per-process graphics translation table(PPGTT)来完成地址翻译，过程如下图所示。</p><p><img src="/images/2019/7/3.png" alt></p><p>值得注意的是：</p><ul><li>PPGTT是多级页表(具体级数跟GPU的架构相关)</li><li>CPU是无法访问local graphic memory的</li></ul><hr><p>参考资料：</p><ol><li><a href="https://01.org/zh/linuxgraphics/documentation/hardware-specification-prms" target="_blank" rel="noopener">HARDWARE SPECIFICATION - PRMS</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将会介绍Intel GPU的内存管理。
    
    </summary>
    
      <category term="GPU" scheme="http://liujunming.github.io/categories/GPU/"/>
    
    
      <category term="GPU" scheme="http://liujunming.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>计算机启动相关知识点</title>
    <link href="http://liujunming.github.io/2019/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://liujunming.github.io/2019/07/15/计算机启动相关知识点/</id>
    <published>2019-07-15T13:13:37.000Z</published>
    <updated>2019-07-15T13:23:55.504Z</updated>
    
    <content type="html"><![CDATA[<p>附件中将会介绍计算机启动的相关知识点，详细内容见参考链接。</p><p><a href="/pdf/computer_boot.pdf">计算机启动</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;附件中将会介绍计算机启动的相关知识点，详细内容见参考链接。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/pdf/computer_boot.pdf&quot;&gt;计算机启动&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="系统" scheme="http://liujunming.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="http://liujunming.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Paper Notes</title>
    <link href="http://liujunming.github.io/2019/06/23/Paper-Notes/"/>
    <id>http://liujunming.github.io/2019/06/23/Paper-Notes/</id>
    <published>2019-06-23T08:23:36.000Z</published>
    <updated>2019-07-21T02:14:47.926Z</updated>
    
    <content type="html"><![CDATA[<p>论文笔记。<br><a id="more"></a><br><a href="/pdf/paper/xen sosp.pdf">Xen and the Art of Virtualization</a><br><a href="/pdf/paper/Xen_notes.pdf">Notes</a> </p><p><a href="/pdf/paper/gVirt.pdf">A Full GPU Virtualization Solution with Mediated Pass-Through</a><br><a href="/pdf/paper/gVirt_notes.pdf">Notes</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;论文笔记。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Concurrency</title>
    <link href="http://liujunming.github.io/2019/06/08/Concurrency/"/>
    <id>http://liujunming.github.io/2019/06/08/Concurrency/</id>
    <published>2019-06-08T00:53:38.000Z</published>
    <updated>2019-06-23T08:21:38.427Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先介绍Concurrency的相关知识点。</p><a id="more"></a><p>Operating Systems: Three Easy Pieces中Concurrency的相关内容。</p><ol><li><a href="[http://liujunming.top/junming/os/26.threads-intro.pdf](http://liujunming.top/junming/os/26.threads-intro.pdf">Concurrency and Threads</a></li><li><a href="[http://liujunming.top/junming/os/27.threads-api.pdf](http://liujunming.top/junming/os/27.threads-api.pdf">Thread API</a></li><li><a href="[http://liujunming.top/junming/os/28.threads-locks.pdf](http://liujunming.top/junming/os/28.threads-locks.pdf">Locks</a></li><li><a href="[http://liujunming.top/junming/os/29.threads-locks-usage.pdf](http://liujunming.top/junming/os/29.threads-locks-usage.pdf">Locked Data Structures</a></li><li><a href="[http://liujunming.top/junming/os/30.threads-cv.pdf](http://liujunming.top/junming/os/30.threads-cv.pdf">Condition Variables</a></li><li><a href="[http://liujunming.top/junming/os/31.threads-sema.pdf](http://liujunming.top/junming/os/31.threads-sema.pdf">Semaphores</a></li><li><a href="[http://liujunming.top/junming/os/32.threads-bugs.pdf](http://liujunming.top/junming/os/32.threads-bugs.pdf">Concurrency Bugs</a></li><li><a href="[http://liujunming.top/junming/os/33.threads-events.pdf](http://liujunming.top/junming/os/33.threads-events.pdf">Event-based Concurrency</a></li></ol><p><a href="/pdf/Concurrency.pdf">Notes</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先介绍Concurrency的相关知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/categories/Concurrency/"/>
    
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化课程学习</title>
    <link href="http://liujunming.github.io/2019/05/27/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>http://liujunming.github.io/2019/05/27/虚拟化课程学习/</id>
    <published>2019-05-27T06:27:16.000Z</published>
    <updated>2019-05-30T08:21:56.761Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://lettieri.iet.unipi.it/virtualization/" target="_blank" rel="noopener">Concurrent and Distributed Systems</a>课程很好地讲述了虚拟化的相关原理，由浅入深，循序渐进。本文将记录下自己的学习笔记。<br><a id="more"></a></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p><a href="/pdf/Virtualization-Introduction.pdf">Virtualization Introduction</a></p><p><a href="/pdf/intro_virtual.pdf">Notes</a></p><h3 id="Emulation-amp-amp-Binary-Translation"><a href="#Emulation-amp-amp-Binary-Translation" class="headerlink" title="Emulation &amp;&amp; Binary Translation"></a>Emulation &amp;&amp; Binary Translation</h3><p><a href="/pdf/emulation.pdf">Emulation</a></p><p><a href="/pdf/binary-translation.pdf">Binary Translation</a></p><p><a href="/pdf/emulator &amp;&amp; binary translation.pdf">Notes</a></p><h3 id="Hardware-assisted-virtualization"><a href="#Hardware-assisted-virtualization" class="headerlink" title="Hardware assisted virtualization"></a>Hardware assisted virtualization</h3><p><a href="/pdf/hardware-assisted-intro.pdf">Introduction</a>(无需细读)</p><p><a href="/pdf/hardware-assisted-vmm.pdf">The Virtual Machine Monitor</a></p><p><a href="/pdf/hardware-assisted-intel-vmx.pdf">The Intel VMX technology</a></p><p><a href="/pdf/hardware-assisted-virtual-mmu.pdf">Virtualization of virtual memory</a></p><p><a href="/pdf/Hardware assisted virtualization.pdf">Notes</a></p><h3 id="Hardware-passthrough"><a href="#Hardware-passthrough" class="headerlink" title="Hardware passthrough"></a>Hardware passthrough</h3><p><a href="/pdf/passthrough.pdf">Hardware passthrough</a></p><p><a href="/pdf/Hardware passthrough.pdf">Notes</a></p><h3 id="Paravirtualization"><a href="#Paravirtualization" class="headerlink" title="Paravirtualization"></a>Paravirtualization</h3><p><a href="/pdf/paravirtualization.pdf">Introduction</a></p><p><a href="/pdf/20161124-io-paravirtualization-tour.pdf">Virtio networking: A case study of I/O paravirtualization</a></p><p><a href="/pdf/Para-virtualization.pdf">Notes</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://lettieri.iet.unipi.it/virtualization/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Concurrent and Distributed Systems&lt;/a&gt;课程很好地讲述了虚拟化的相关原理，由浅入深，循序渐进。本文将记录下自己的学习笔记。&lt;br&gt;
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>(转)Memory barrier</title>
    <link href="http://liujunming.github.io/2019/05/09/Memory-barrier/"/>
    <id>http://liujunming.github.io/2019/05/09/Memory-barrier/</id>
    <published>2019-05-09T11:56:29.000Z</published>
    <updated>2019-05-11T04:37:14.999Z</updated>
    
    <content type="html"><![CDATA[<p>程序在运行时，内存实际的访问顺序和程序代码编写的访问顺序不一定一致，基于这个前提，Memory barrier 就有存在的必要了。</p><p>Memory barrier 能够保证其之前的内存访问操作先于其后的完成。Memory barrier的主要应用场景如下：</p><ol><li>实现同步原语（synchronization primitives）</li><li>实现无锁数据结构（lock-free data structures）</li><li>驱动程序</li></ol><a id="more"></a><p>本文内容转载自：<a href="http://b2e699b3.wiz03.com/share/s/2OVFCP1_wkXs20LtbT1nXNrj0EqwFC1zZAjT2bCeRi3Tzco2" target="_blank" rel="noopener">Name5566:理解 Memory barrier</a>。</p><h2 id="1-Memory-barrier-简介"><a href="#1-Memory-barrier-简介" class="headerlink" title="1. Memory barrier 简介"></a>1. Memory barrier 简介</h2><p>程序在运行时，内存实际的访问顺序和程序代码编写的访问顺序不一定一致，这就是内存乱序访问。内存乱序访问出现的理由是为了提升程序运行时的性能。内存乱序访问主要发生在两个阶段：</p><ol><li>编译时，编译器优化导致内存乱序访问（指令重排）</li><li>运行时，多个CPU之间的交互引起内存乱序访问</li></ol><p>Memory barrier 能够让 CPU 或编译器在内存访问上有序。一个 Memory barrier 之前的内存访问操作必定先于其之后的完成。Memory barrier 包括两类：</p><ol><li>编译器 barrier</li><li>CPU Memory barrier</li></ol><p>通常情况下，编译器和 CPU 引起的内存乱序访问不会带来什么问题，但在一些特殊情况下，程序逻辑的正确性依赖于内存访问的顺序，此时内存乱序访问会带来逻辑上的错误，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread 1</span></span><br><span class="line"><span class="keyword">while</span> (!ok);</span><br><span class="line"><span class="keyword">do</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread 2</span></span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line">ok = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>此段代码中，ok 初始化为 0，线程 1 等待 ok 被设置为 1 后执行 do 函数。假如说，线程 2 对内存的写操作乱序执行，也就是 x 赋值后于 ok 赋值完成，那么 do 函数接受的实参就很可能不是 42。</p><h3 id="1-1-编译时内存乱序访问"><a href="#1-1-编译时内存乱序访问" class="headerlink" title="1.1 编译时内存乱序访问"></a>1.1 编译时内存乱序访问</h3><p>编译器对代码做出优化时，可能改变指令的执行顺序（例如 gcc 下 O2 或 O3 都可能会改变指令的执行顺序）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="keyword">int</span> x, y, r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = r;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器优化的结果可能导致 y = 1 在 x = r 之前执行完成。首先直接编译此源文件：<br><code>g++ -S test.cpp</code></p><p>得到相关的汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl    r(%rip), %eax</span><br><span class="line">movl    %eax, x(%rip)</span><br><span class="line">movl    $1, y(%rip)</span><br></pre></td></tr></table></figure></p><p>这里可以看到，x = r 和 y = 1 并没有乱序。现使用优化选项 O2（或 O3）编译上面的代码（g++ -O2 -S test.cpp），生成汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl    r(%rip), %eax</span><br><span class="line">movl    $1, y(%rip)</span><br><span class="line">movl    %eax, x(%rip)</span><br></pre></td></tr></table></figure></p><p>我们可以清楚的看到，经过编译器优化之后 ，movl $1, y(%rip) 先于 movl %eax, x(%rip) 执行。避免编译时内存乱序访问的办法就是使用<code>编译器 barrier</code>（又叫<code>优化 barrier</code>）。Linux 内核提供函数 <code>barrier()</code> 用于让编译器保证其之前的内存访问先于其之后的完成。内核实现 <code>barrier()</code>如下（X86-64 架构）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> barrier() __asm__ __volatile__(<span class="meta-string">""</span> ::: <span class="meta-string">"memory"</span>)</span></span><br></pre></td></tr></table></figure></p><p>现在把此编译器 barrier 加入代码中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = r;</span><br><span class="line">    __asm__ __volatile__(<span class="string">""</span> ::: <span class="string">"memory"</span>);</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就避免了编译器优化带来的内存乱序访问的问题了。本例中，我们还可以使用 <code>volatile</code> 这个关键字来避免编译时内存乱序访问（而无法避免后面要说的运行时内存乱序访问）。<code>volatile</code> 关键字能够避免相关的变量在内存访问上乱序访问，这里可以修改 x 和 y 的定义来解决问题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = r;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现加上了 <code>volatile</code> 关键字，这使得 x 相对于 y、y 相对于 x 在内存访问上有序。在 Linux 内核中，提供了一个宏 <code>ACCESS_ONCE</code> 来避免编译器对于连续的 <code>ACCESS_ONCE</code>实例进行指令重排。其实 <code>ACCESS_ONCE</code> 实现源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))</span></span><br></pre></td></tr></table></figure></p><p>此代码只是将变量 x 转换为 <code>volatile</code> 的而已。现在我们就有了第三个修改方案：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ACCESS_ONCE(x) = r;</span><br><span class="line">    ACCESS_ONCE(y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此基本上就阐述完了编译时内存乱序访问的问题。下面开始介绍运行时内存乱序访问。</p><h3 id="1-2-运行时内存乱序访问"><a href="#1-2-运行时内存乱序访问" class="headerlink" title="1.2 运行时内存乱序访问"></a>1.2 运行时内存乱序访问</h3><p>在运行时，CPU 虽然会乱序执行指令，但是在单个 CPU上，硬件能够保证程序执行时,所有的内存访问操作看起来像是按程序代码编写的顺序执行的，这时候 Memory barrier 没有必要使用（不考虑编译器优化的情况下）。这里我们了解一下 CPU 乱序执行的行为。在乱序执行时，一个处理器真正执行指令的顺序由可用的输入数据决定，而非程序员编写的顺序。<br>早期的处理器为有序处理器（In-order processors），有序处理器处理指令通常有以下几步：</p><ol><li>指令获取</li><li>如果指令的输入操作对象（input operands）可用（例如已经在寄存器中了），则将此指令分发到适当的功能单元中。如果一个或者多个操作对象不可用（通常是由于需要从内存中获取），则处理器会等待，直到它们可用</li><li>指令被适当的功能单元执行</li><li>功能单元将结果写回寄存器堆（Register file，一个 CPU 中的一组寄存器）</li></ol><p>相比之下，乱序处理器（Out-of-order processors）处理指令通常有以下几步：</p><ol><li>指令获取</li><li>指令被分发到指令队列</li><li>指令在指令队列中等待，直到输入操作对象可用（一旦输入操作对象可用，指令就可以离开队列，即便更早的指令未被执行）</li><li>指令被分配到适当的功能单元并执行</li><li>执行结果被放入队列（而不立即写入寄存器堆）</li><li>只有所有更早请求执行的指令的执行结果被写入寄存器堆后，指令执行的结果才被写入寄存器堆（执行结果重排序，让执行看起来是有序的）</li></ol><p>从上面的执行过程可以看出，相比有序执行，乱序执行能够避免等待不可用的操作对象（有序执行的第二步），从而提高了效率。处理器运行的速度比内存快很多，在有序处理器花在等待可用数据的时间里，已经可以处理大量指令了。<br>现在思考一下乱序处理器处理指令的过程，我们能得到几个结论：</p><ol><li>对于单个 CPU， 指令获取是有序的（通过队列实现）</li><li>对于单个 CPU，指令执行结果也是有序返回寄存器堆的（通过队列实现）</li></ol><p>由此可知，在单 CPU 上，当不考虑编译器优化导致乱序时，多线程执行不存在内存乱序访问的问题。我们从内核源码中也可以得到类似的结论：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smp_mb() mb()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smp_mb() barrier()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>这里可以看到，如果是 SMP， 则使用 mb，mb 被定义为 CPU Memory barrier（后面会讲到），而非 SMP 时，直接使用编译器 barrier。</p><p>多处理器架构一般采用NUMA，这种架构下的内存操作会有巨大的延时问题。为了缓解这些问题，处理器会采取一些优化措施, 而导致程序顺序被破坏。</p><ul><li><p>情景一: 设想某处理器发出一条某内存位置读的指令，恰好这个内存位置在远端内存，而且处理器本地缓存也没有命中。于是，为了等待这个值，处理器需要空转(stall)。这显然是效率的极大浪费，事实上，现代的处理器都有乱序执行引擎, 指令并不是直接被执行，而是放到等待队列里，等待操作数到位后才执行，而这期间处理器优先处理其他指令。也就是出于效率考虑，处理器会重排指令。</p></li><li><p>情景二: 设想有一个热点全局变量，那么在程序运行一段时间后，很可能很多个处理器的本地缓存都有该变量的一份拷贝。再设想现在有处理器A修改这个全局变量，这个修改会发布一条消息能过网络通知所有其他处理器更新该变量缓存。由于路径的问题，消息不会同时到达所有处理器，那么存在一种可能性，某处理器此时仍观察到旧的值，而采取一些基于该旧值的动作。</p></li></ul><p>有兴趣可以研究<a href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf" target="_blank" rel="noopener">Memory Barriers: a Hardware View for Software Hackers</a>一文，其详细的分析了以上过程。</p><h2 id="2-Memory-barrier的应用场景"><a href="#2-Memory-barrier的应用场景" class="headerlink" title="2. Memory barrier的应用场景"></a>2. Memory barrier的应用场景</h2><p>Memory barrier 常用场合包括：</p><ol><li>实现同步原语（synchronization primitives）</li><li>实现无锁数据结构（lock-free data structures）</li><li>驱动程序</li></ol><p>在应用程序开发中，开发者可能完全不知道 Memory barrier 就可以开发正确的多线程程序，这主要是因为各种同步机制中已经隐含了 Memory barrier（但和实际的 Memory barrier 有细微差别）。但是如果你希望编写诸如无锁数据结构，那么 Memory barrier 还是很有用的。</p><p>在 Linux 内核中，除了前面说到的编译器 barrier — <code>barrier()</code> 和 <code>ACCESS_ONCE()</code>，还有 CPU Memory barrier：</p><ol><li>通用 barrier，保证读写操作有序的，<code>mb()</code>和 <code>smp_mb()</code></li><li>写操作 barrier，仅保证写操作有序的，<code>wmb()</code> 和 <code>smp_wmb()</code></li><li>读操作 barrier，仅保证读操作有序的，<code>rmb()</code> 和 <code>smp_rmb()</code></li></ol><p>注意，以上的CPU Memory barrier都隐含了编译器 barrier。这里以smp 开头的 Memory barrier 会在单处理器上直接使用编译器 barrier，而在 SMP 上才使用 CPU Memory barrier。</p><p>最后需要注意的是，CPU Memory barrier 中某些类型的 Memory barrier 需要成对使用，否则会出错。例如：一个写操作 barrier 需要和读操作barrier 一起使用（当然，通用 barrier 也是可以的），反之依然。</p><h3 id="2-1-Memory-barrier-的示例"><a href="#2-1-Memory-barrier-的示例" class="headerlink" title="2.1 Memory barrier 的示例"></a>2.1 Memory barrier 的示例</h3><p>下面我们通过读内核代码来进一步学习 Memory barrier 的使用。<br>Linux 内核实现的无锁（只有一个读线程和一个写线程时）环形缓冲区 kfifo 就使用到了 Memory barrier，实现源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A simple kernel FIFO implementation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2004 Stelian Pop &lt;stelian@popies.net&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"> * it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span></span><br><span class="line"><span class="comment"> * (at your option) any later version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment"> * GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment"> * along with this program; if not, write to the Free Software</span></span><br><span class="line"><span class="comment"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kfifo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/log2.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_init - allocates a new FIFO using a preallocated buffer</span></span><br><span class="line"><span class="comment"> * @buffer: the preallocated buffer to be used.</span></span><br><span class="line"><span class="comment"> * @size: the size of the internal buffer, this have to be a power of 2.</span></span><br><span class="line"><span class="comment"> * @gfp_mask: get_free_pages mask, passed to kmalloc()</span></span><br><span class="line"><span class="comment"> * @lock: the lock to be used to protect the fifo buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do NOT pass the kfifo to kfifo_free() after use! Simply free the</span></span><br><span class="line"><span class="comment"> * &amp;struct kfifo with kfree().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct kfifo *<span class="title">kfifo_init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> *<span class="title">fifo</span>;</span></span><br><span class="line">    <span class="comment">/* size must be a power of 2 */</span></span><br><span class="line">    BUG_ON(!is_power_of_2(size));</span><br><span class="line">    fifo = kmalloc(<span class="keyword">sizeof</span>(struct kfifo), gfp_mask);</span><br><span class="line">    <span class="keyword">if</span> (!fifo)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    fifo-&gt;buffer = buffer;</span><br><span class="line">    fifo-&gt;size = size;</span><br><span class="line">    fifo-&gt;in = fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line">    fifo-&gt;lock = lock;</span><br><span class="line">    <span class="keyword">return</span> fifo;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfifo_init);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_alloc - allocates a new FIFO and its internal buffer</span></span><br><span class="line"><span class="comment"> * @size: the size of the internal buffer to be allocated.</span></span><br><span class="line"><span class="comment"> * @gfp_mask: get_free_pages mask, passed to kmalloc()</span></span><br><span class="line"><span class="comment"> * @lock: the lock to be used to protect the fifo buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The size will be rounded-up to a power of 2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct kfifo *<span class="title">kfifo_alloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> *<span class="title">ret</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * round up to the next power of 2, since our 'let the indices</span></span><br><span class="line"><span class="comment">     * wrap' technique works only in this case.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_power_of_2(size)) &#123;</span><br><span class="line">        BUG_ON(size &gt; <span class="number">0x80000000</span>);</span><br><span class="line">        size = roundup_pow_of_two(size);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer = kmalloc(size, gfp_mask);</span><br><span class="line">    <span class="keyword">if</span> (!buffer)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    ret = kfifo_init(buffer, size, gfp_mask, lock);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(ret))</span><br><span class="line">        kfree(buffer);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfifo_alloc);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_free - frees the FIFO</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be freed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfifo_free</span><span class="params">(struct kfifo *fifo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kfree(fifo-&gt;buffer);</span><br><span class="line">    kfree(fifo);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfifo_free);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __kfifo_put - puts some data into the FIFO, no locking version</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be used.</span></span><br><span class="line"><span class="comment"> * @buffer: the data to be added.</span></span><br><span class="line"><span class="comment"> * @len: the length of the data to be added.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function copies at most @len bytes from the @buffer into</span></span><br><span class="line"><span class="comment"> * the FIFO depending on the free space, and returns the number of</span></span><br><span class="line"><span class="comment"> * bytes copied.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that with only one concurrent reader and one concurrent</span></span><br><span class="line"><span class="comment"> * writer, you don't need extra locking to use these functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __kfifo_put(struct kfifo *fifo,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line">    len = min(len, fifo-&gt;size - fifo-&gt;in + fifo-&gt;out);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that we sample the fifo-&gt;out index -before- we</span></span><br><span class="line"><span class="comment">     * start putting bytes into the kfifo.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_mb();</span><br><span class="line">    <span class="comment">/* first put the data starting from fifo-&gt;in to buffer end */</span></span><br><span class="line">    l = min(len, fifo-&gt;size - (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">memcpy</span>(fifo-&gt;buffer + (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)), buffer, l);</span><br><span class="line">    <span class="comment">/* then put the rest (if any) at the beginning of the buffer */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(fifo-&gt;buffer, buffer + l, len - l);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that we add the bytes to the kfifo -before-</span></span><br><span class="line"><span class="comment">     * we update the fifo-&gt;in index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_wmb();</span><br><span class="line">    fifo-&gt;in += len;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kfifo_put);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __kfifo_get - gets some data from the FIFO, no locking version</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be used.</span></span><br><span class="line"><span class="comment"> * @buffer: where the data must be copied.</span></span><br><span class="line"><span class="comment"> * @len: the size of the destination buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function copies at most @len bytes from the FIFO into the</span></span><br><span class="line"><span class="comment"> * @buffer and returns the number of copied bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that with only one concurrent reader and one concurrent</span></span><br><span class="line"><span class="comment"> * writer, you don't need extra locking to use these functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __kfifo_get(struct kfifo *fifo,</span><br><span class="line">                         <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line">    len = min(len, fifo-&gt;in - fifo-&gt;out);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that we sample the fifo-&gt;in index -before- we</span></span><br><span class="line"><span class="comment">     * start removing bytes from the kfifo.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_rmb();</span><br><span class="line">    <span class="comment">/* first get the data from fifo-&gt;out until the end of the buffer */</span></span><br><span class="line">    l = min(len, fifo-&gt;size - (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, fifo-&gt;buffer + (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)), l);</span><br><span class="line">    <span class="comment">/* then get the rest (if any) from the beginning of the buffer */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buffer + l, fifo-&gt;buffer, len - l);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that we remove the bytes from the kfifo -before-</span></span><br><span class="line"><span class="comment">     * we update the fifo-&gt;out index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_mb();</span><br><span class="line">    fifo-&gt;out += len;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kfifo_get);</span><br></pre></td></tr></table></figure></p><p>在上述代码中，我们只需关注Memory barrier 即可。代码中，索引 in 和 out 被两个线程访问。in 和 out 指明了缓冲区中实际数据的边界，由于未使用同步机制，那么如果想保证顺序关系的话，就需要使用到 Memory barrier 了。索引in被一个线程修改，被两个线程读取。 索引out被另一个线程修改，被两个线程读取。__kfifo_put 先通过 in 和 out 来确定可以向缓冲区中写入数据量的多少，这时，out 索引应该先被读取后，才能将用户 buffer 中的数据写入缓冲区，因此这里使用到了 <code>smp_mb()</code>，对应的，__kfifo_get 也使用 <code>smp_mb()</code> 来确保在修改 out 索引之前，缓冲区中数据已经被读取到用户的buffer 中了。对于 in 索引，在 __kfifo_put 中，要保证先向缓冲区写入数据后才修改 in 索引，由于这里只需要保证写入操作有序，故选用写操作 barrier，在 __kfifo_get 中，要保证先读取了 in 索引才开始读取缓冲区中数据，由于这里只需要保证读取操作有序，故选用读操作 barrier。</p><hr><p>参考文献：</p><ol><li><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt" target="_blank" rel="noopener">LINUX KERNEL MEMORY BARRIERS</a></li><li><a href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf" target="_blank" rel="noopener">Memory Barriers: a Hardware View for Software Hackers</a></li><li><a href="https://github.com/JianyuZhan/larmbr.github.com/tree/master/_posts" target="_blank" rel="noopener">the-memory-barriers-in-linux-kernel</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序在运行时，内存实际的访问顺序和程序代码编写的访问顺序不一定一致，基于这个前提，Memory barrier 就有存在的必要了。&lt;/p&gt;
&lt;p&gt;Memory barrier 能够保证其之前的内存访问操作先于其后的完成。Memory barrier的主要应用场景如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现同步原语（synchronization primitives）&lt;/li&gt;
&lt;li&gt;实现无锁数据结构（lock-free data structures）&lt;/li&gt;
&lt;li&gt;驱动程序&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/categories/Concurrency/"/>
    
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>CPU Cache一致性问题</title>
    <link href="http://liujunming.github.io/2019/04/29/CPU-cache%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>http://liujunming.github.io/2019/04/29/CPU-cache一致性问题/</id>
    <published>2019-04-29T06:40:48.000Z</published>
    <updated>2019-05-10T06:51:33.896Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先介绍下产生CPU cache一致性问题的原因，然后给出CPU cache一致性的定义，最后给出解决CPU Cache一致性问题的解决方案。<a id="more"></a></p><h2 id="1-为什么会有CPU-cache一致性问题？"><a href="#1-为什么会有CPU-cache一致性问题？" class="headerlink" title="1. 为什么会有CPU cache一致性问题？"></a>1. 为什么会有CPU cache一致性问题？</h2><p>在多处理器架构中，每个处理器都拥有自己的CPU Cache，同时这些处理器共享内存资源。这样会导致多个处理器的CPU cache缓存了相同的内存数据块(以Cache Line为粒度)，此时可能会出现cache不一致问题。为了直观地展示Cache不一致问题，下图给出了一个具体的例子：<br><img src="/images/2019/5/1.gif" alt><br>p1和p2代表两个不同的处理器，在内存中，x的值为5。p1和p2都需要读取x，因而会将x读取到各自的cache中，此时，在cache中，x的值都为5。p1执行x=x+3时，在p1的cache中，x=8。与此同时，p2执行x=x+5，在p2的cache中，x=10。之后，写回p1的cache数据，此时，在内存中，x的值为8。接着，写回p2的cache数据，此时，在内存中，x的值为10。此刻，就出现了cache不一致问题：p1 cache中的x值与p2 cache中的x值不同。</p><p>下图展示了cache一致的结果：<br><img src="/images/2019/5/2.gif" alt></p><blockquote><p>In a shared memory multiprocessor system with a separate cache memory for each processor, it is possible to have many copies of shared data: one copy in the main memory and one in the local cache of each processor that requested it. When one of the copies of data is changed, the other copies must reflect that change. Cache coherence is the discipline which ensures that the changes in the values of shared operands(data) are propagated throughout the system in a timely fashion.</p></blockquote><p>The following are the requirements for cache coherence:</p><ul><li><p>Write Propagation<br>Changes to the data in any cache must be propagated to other copies (of that cache line) in the peer caches.</p></li><li><p>Transaction Serialization<br>Reads/Writes to a single memory location must be seen by all processors in the same order.</p></li></ul><h2 id="2-CPU-cache一致性的定义"><a href="#2-CPU-cache一致性的定义" class="headerlink" title="2. CPU cache一致性的定义"></a>2. CPU cache一致性的定义</h2><p>Coherence defines the behavior of reads and writes to a single address location.</p><p>In a multiprocessor system, consider that more than one processor has cached a copy of the memory location X. The following conditions are necessary to achieve cache coherence:</p><ol><li>In a read made by a processor P to a location X that follows a write by the same processor P to X, with no writes to X by another processor occurring between the write and the read instructions made by P, X must always return the value written by P.</li><li>In a read made by a processor P1 to location X that follows a write by another processor P2 to X, with no other writes to X made by any processor occurring between the two accesses and with the read and write being sufficiently separated, X must always return the value written by P2. This condition defines the concept of coherent view of memory. Propagating the writes to the shared memory location ensures that all the caches have a coherent view of the memory. If processor P1 reads the old value of X, even after the write by P2, we can say that the memory is incoherent.</li></ol><p>The above conditions satisfy the Write Propagation criteria required for cache coherence. However, they are not sufficient as they do not satisfy the Transaction Serialization condition. To illustrate this better, consider the following example:</p><p>A multi-processor system consists of four processors - P1, P2, P3 and P4, all containing cached copies of a shared variable S whose initial value is 0. Processor P1 changes the value of S (in its cached copy) to 10 following which processor P2 changes the value of S in its own cached copy to 20. If we ensure only write propagation, then P3 and P4 will certainly see the changes made to S by P1 and P2. However, P3 may see the change made by P1 after seeing the change made by P2 and hence return 10 on a read to S. P4 on the other hand may see changes made by P1 and P2 in the order in which they are made and hence return 20 on a read to S. The processors P3 and P4 now have an incoherent view of the memory.</p><p>Therefore, in order to satisfy Transaction Serialization, and hence achieve Cache Coherence, the following condition along with the previous two mentioned in this section must be met:</p><ul><li>Writes to the same location must be sequenced. In other words, if location X received two different values A and B, in this order, from any two processors, the processors can never read location X as B and then read it as A. The location X must be seen with values A and B in that order.</li></ul><h2 id="3-CPU-Cache一致性问题的解决方案"><a href="#3-CPU-Cache一致性问题的解决方案" class="headerlink" title="3. CPU Cache一致性问题的解决方案"></a>3. CPU Cache一致性问题的解决方案</h2><p>for bus-based machines，通常采用Snooping based protocols方案。for NUMA machines using a scalable switch，通常采用Directory Based Solutions。</p><blockquote><p>Snooping based protocols tend to be faster, if enough bandwidth is available, since all transactions are a request/response seen by all processors. The drawback is that snooping isn’t scalable. Every request must be broadcast to all nodes in a system, meaning that as the system gets larger, the size of the (logical or physical) bus and the bandwidth it provides must grow. Directories, on the other hand, tend to have longer latencies (with a 3 hop request/forward/respond) but use much less bandwidth since messages are point to point and not broadcast. For this reason, many of the larger systems (&gt;64 processors) use this type of cache coherence.</p></blockquote><h3 id="3-1-Snooping-based-protocols"><a href="#3-1-Snooping-based-protocols" class="headerlink" title="3.1 Snooping based protocols"></a>3.1 Snooping based protocols</h3><p>Snooping is a process where the individual caches monitor address lines for accesses to memory locations that they have cached. </p><p>Write propagation in snoopy protocols can be implemented by either of the following methods:</p><ul><li><p>Write Invalidate<br>When a processor writes into x, all copies of it in other processors are invalidated. These processors have to read a valid copy either from memory, or from the processor that modified the variable.</p></li><li><p>Write Broadcast<br>Instead of invalidating, why not broadcast the updated value to the other processors sharing that copy? </p></li></ul><p>MSI、MESI等protocol是较为常见的Snooping based protocols。<a href="https://www.youtube.com/watch?v=-p9tfMMu1PE" target="_blank" rel="noopener">MESI Cache Coherence Protocol | Vasileios Trigonakis</a>很好了阐述了MESI protocol。</p><p><img src="/images/2019/5/3.png" alt></p><p><img src="/images/2019/5/4.png" alt></p><p>概要地讲：在MESI协议中，每个cache line有四种状态，当遇到不同事件时，会改变cache line的状态，由此构成了一个有限自动机。</p><h3 id="3-2-Directory-Based-Solutions"><a href="#3-2-Directory-Based-Solutions" class="headerlink" title="3.2 Directory Based Solutions"></a>3.2 Directory Based Solutions</h3><p>In a directory-based system, the data being shared is placed in a common directory that maintains the coherence between caches. </p><p><a href="https://www.youtube.com/watch?v=6QZ_XiBEAF4" target="_blank" rel="noopener">Directory Entry</a>与<a href="https://www.youtube.com/watch?v=lZZYILcQ68Y" target="_blank" rel="noopener">Directory Example</a>给出了Directory的具体例子。</p><hr><p>参考资料：</p><ol><li><a href="https://www.wikiwand.com/en/Cache_coherence" target="_blank" rel="noopener">wikiwand Cache coherence</a></li><li><a href="https://www.wikiwand.com/en/Bus_snooping" target="_blank" rel="noopener">wikiwand Bus snooping</a></li><li><a href="https://www.wikiwand.com/en/Directory-based_coherence" target="_blank" rel="noopener">wikiwand Directory-based coherence</a></li><li><a href="https://zhuanlan.zhihu.com/p/25876351" target="_blank" rel="noopener">缓存/内存Coherence模型</a></li><li><a href="http://www.divms.uiowa.edu/~ghosh/4-20-06.pdf" target="_blank" rel="noopener">Multiprocessor Cache Coherence</a></li><li><a href="https://www.youtube.com/watch?v=-p9tfMMu1PE" target="_blank" rel="noopener">MESI Cache Coherence Protocol | Vasileios Trigonakis</a></li><li><a href="https://www.youtube.com/watch?v=lZZYILcQ68Y" target="_blank" rel="noopener">Directory Example - Georgia Tech - HPCA: Part 5</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先介绍下产生CPU cache一致性问题的原因，然后给出CPU cache一致性的定义，最后给出解决CPU Cache一致性问题的解决方案。
    
    </summary>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/categories/Concurrency/"/>
    
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>CPU Cache</title>
    <link href="http://liujunming.github.io/2019/04/20/CPU-cache/"/>
    <id>http://liujunming.github.io/2019/04/20/CPU-cache/</id>
    <published>2019-04-20T10:30:09.000Z</published>
    <updated>2019-05-09T09:42:06.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要有CPU-Cache"><a href="#1-为什么要有CPU-Cache" class="headerlink" title="1. 为什么要有CPU Cache"></a>1. 为什么要有CPU Cache</h2><ol><li>CPU的处理速度和内存的访问速度差距</li><li>内存数据访问的局部性原理<a id="more"></a><img src="/images/2019/4/8.png" alt><center>Cache Performance</center></li></ol><h2 id="2-为什么要有多级CPU-Cache"><a href="#2-为什么要有多级CPU-Cache" class="headerlink" title="2. 为什么要有多级CPU Cache"></a>2. 为什么要有多级CPU Cache</h2><blockquote><p>Soon after the introduction of the cache the system got more complicated. The speed difference between the cache and the main memory increased again, to a point that another level of cache was added, bigger and slower than the first-level cache. Only increasing the size of the first-level cache was not an option for economical reasons.</p></blockquote><p>此外，又由于程序指令和程序数据的行为和热点分布差异很大，因此L1 Cache也被划分成L1i (i for instruction)和L1d (d for data)两种专门用途的缓存。</p><h2 id="3-CPU-Cache-是如何存放数据的"><a href="#3-CPU-Cache-是如何存放数据的" class="headerlink" title="3. CPU Cache 是如何存放数据的"></a>3. CPU Cache 是如何存放数据的</h2><p>如果对这部分知识有些遗忘，可以看下<a href="https://courses.cs.washington.edu/courses/cse378/09wi/lectures/lec15.pdf" target="_blank" rel="noopener">cse378</a>即可。</p><h3 id="3-1-为什么Cache不能做成Direct-Mapped"><a href="#3-1-为什么Cache不能做成Direct-Mapped" class="headerlink" title="3.1 为什么Cache不能做成Direct Mapped"></a>3.1 为什么Cache不能做成Direct Mapped</h3><p><img src="/images/2019/4/7.png" alt></p><blockquote><p>Direct-Mapped Cache is simplier (requires just one comparator and one multiplexer), as a result is cheaper and works faster. Given any address, it is easy to identify the single entry in cache, where it can be. A major drawback when using DM cache is called a conflict miss, when two different addresses correspond to one entry in the cache. Even if the cache is big and contains many stale entries, it can’t simply evict those, because the position within cache is predetermined by the address.</p></blockquote><h3 id="3-2-为什么Cache不能做成Fully-Associative"><a href="#3-2-为什么Cache不能做成Fully-Associative" class="headerlink" title="3.2 为什么Cache不能做成Fully Associative"></a>3.2 为什么Cache不能做成Fully Associative</h3><blockquote><p>Full Associative Cache is much more complex, and it allows to store an address into any entry. There is a price for that. In order to check if a particular address is in the cache, it has to compare all current entries (the tags to be exact).</p></blockquote><p><img src="/images/2019/4/9.png" alt></p><h3 id="3-3-什么是N-Way-Set-Associative"><a href="#3-3-什么是N-Way-Set-Associative" class="headerlink" title="3.3 什么是N-Way Set Associative"></a>3.3 什么是N-Way Set Associative</h3><p><img src="/images/2019/4/10.png" alt></p><p>阅读<a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="noopener">Gallery of Processor Cache Effects</a>和<a href="https://coolshell.cn/articles/10249.html" target="_blank" rel="noopener">7个示例科普CPU CACHE</a>可以加深对N-Way Set Associative的理解。</p><hr><p>参考资料：</p><ol><li><a href="https://courses.cs.washington.edu/courses/cse378/09wi/lectures/lec15.pdf" target="_blank" rel="noopener">cse378</a></li><li><a href="http://cenalulu.github.io/linux/all-about-cpu-cache/" target="_blank" rel="noopener">关于CPU Cache – 程序猿需要知道的那些事</a></li><li><a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="noopener">Gallery of Processor Cache Effects</a></li><li><a href="https://coolshell.cn/articles/10249.html" target="_blank" rel="noopener">7个示例科普CPU CACHE</a></li><li><a href="https://stackoverflow.com/questions/30097648/difference-between-a-direct-mapped-cache-and-fully-associative-cache" target="_blank" rel="noopener">Difference Between a Direct-Mapped Cache and Fully Associative Cache</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-为什么要有CPU-Cache&quot;&gt;&lt;a href=&quot;#1-为什么要有CPU-Cache&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要有CPU Cache&quot;&gt;&lt;/a&gt;1. 为什么要有CPU Cache&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;CPU的处理速度和内存的访问速度差距&lt;/li&gt;
&lt;li&gt;内存数据访问的局部性原理
    
    </summary>
    
      <category term="体系结构" scheme="http://liujunming.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>(转)CPU Cache Line伪共享问题的总结和分析</title>
    <link href="http://liujunming.github.io/2019/04/10/%E8%BD%AC-CPU-Cache-Line%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%88%86%E6%9E%90/"/>
    <id>http://liujunming.github.io/2019/04/10/转-CPU-Cache-Line伪共享问题的总结和分析/</id>
    <published>2019-04-10T08:45:04.000Z</published>
    <updated>2019-05-07T06:39:01.469Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://mp.weixin.qq.com/s/RHIjnQDqC-2AOjjBAoMKMg" target="_blank" rel="noopener">CPU Cache Line伪共享问题的总结和分析</a></p><h2 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1 背景知识"></a>1 背景知识</h2><p>要搞清楚 Cache Line 伪共享的概念及其性能影响，需要对现代理器架构和硬件实现有一个基本的了解。 <a id="more"></a> </p><h3 id="1-1-存储器层次结构"><a href="#1-1-存储器层次结构" class="headerlink" title="1.1 存储器层次结构"></a>1.1 存储器层次结构</h3><p>众所周知，现代计算机体系结构，通过存储器层次结构 (Memory Hierarchy) 的设计，使系统在性能，成本和制造工艺之间作出取舍，从而达到一个平衡。<br>下图给出了不同层次的硬件访问延迟，可以看到，各个层次硬件访问延迟存在数量级上的差异，越高的性能，往往意味着更高的成本和更小的容量：<br><img src="/images/2019/4/1.jpg" alt></p><p>通过上图，可以对各级存储器 Cache Miss 带来的性能惩罚有个大致的概念。</p><h3 id="1-2-多核架构"><a href="#1-2-多核架构" class="headerlink" title="1.2 多核架构"></a>1.2 多核架构</h3><p>随着多核架构的普及，对称多处理器 (SMP) 系统成为主流。例如，一个物理 CPU 可以存在多个物理 Core，而每个 Core 又可以存在多个硬件线程。<br>x86 以下图为例，1 个 x86 CPU 有 4 个物理 Core，每个 Core 有两个 HT (Hyper Thread)，</p><p><img src="/images/2019/4/2.png" alt></p><p>从硬件的角度，上图的 L1 和 L2 Cache 都被两个 HT 共享，且在同一个物理 Core。而 L3 Cache 则在物理 CPU 里，被多个 Core 来共享。<br>而从 OS 内核角度，每个 HT 都是一个逻辑 CPU，因此，这个处理器在 OS 来看，就是一个 8 个 CPU 的 SMP 系统。</p><h3 id="1-3-NUMA-架构"><a href="#1-3-NUMA-架构" class="headerlink" title="1.3 NUMA 架构"></a>1.3 NUMA 架构</h3><p>按照 CPU 和内存的互连方式，可以分为 UMA (均匀内存访问) 和 NUMA (非均匀内存访问) 两种架构。<br>其中，在多个物理 CPU 之间保证 Cache 一致性的 NUMA 架构，又被称做 ccNUMA (Cache Coherent NUMA) 架构。值得注意的是：SMP也被称为UMA。</p><p>以 x86 为例，早期的 x86 就是典型的 UMA 架构。例如下图，四路处理器通过 FSB (前端系统总线) 和主板上的内存控制器芯片 (MCH) 相连，DRAM 是以 UMA 方式组织的，延迟并无访问差异。</p><p><img src="/images/2019/4/3.png" alt></p><p>然而，这种架构带来了严重的内存总线的性能瓶颈，影响了 x86 在多路服务器上的可扩展性和性能。<a href="http://cenalulu.github.io/linux/numa/" target="_blank" rel="noopener">NUMA架构的CPU – 你真的用好了么？</a></p><p>因此，从 Nehalem 架构开始，x86 开始转向 NUMA 架构，内存控制器芯片被集成到处理器内部，多个处理器通过 QPI 链路相连，从此 DRAM 有了远近之分。<br>而 Sandybridge 架构则更近一步，将片外的 IOH 芯片也集成到了处理器内部，至此，内存控制器和 PCIe Root Complex 全部在处理器内部了。 </p><p>下图就是一个典型的 x86 的 NUMA 架构：</p><p><img src="/images/2019/4/4.png" alt></p><p>由于 NUMA 架构的引入，以下主要部件产生了因物理链路的远近带来的延迟差异：</p><ul><li>Cache</li></ul><p>除物理 CPU 有本地的 Cache 的层级结构以外，还存在跨越系统总线 (QPI) 的远程 Cache 命中访问的情况。需要注意的是，远程的 Cache 命中，对发起 Cache 访问的 CPU 来说，还是被记入了 LLC Cache Miss。</p><ul><li>DRAM</li></ul><p>在两路及以上的服务器，远程 DRAM 的访问延迟，远远高于本地 DRAM 的访问延迟，有些系统可以达到 2 倍的差异。<br>需要注意的是，即使服务器 BIOS 里关闭了 NUMA 特性，也只是对 OS 内核屏蔽了这个特性，这种延迟差异还是存在的。</p><ul><li>Device</li></ul><p>对 CPU 访问设备内存，及设备发起 DMA 内存的读写活动而言，存在本地 Device 和远程 Device 的差别，有显著的延迟访问差异。</p><p>因此，对以上 NUMA 系统，一个 NUMA 节点通常可以被认为是一个物理 CPU 加上它本地的 DRAM 和 Device 组成。那么，四路服务器就拥有四个 NUMA 节点。<br>如果 BIOS 打开了 NUMA 支持，Linux 内核则会根据 ACPI 提供的表格，针对 NUMA 节点做一系列的 NUMA 亲和性的优化。</p><p>在 Linux 上，<code>numactl --hardware</code> 可以返回当前系统的 NUMA 节点信息，特别是 CPU 和 NUMA 节点的对应信息。</p><h3 id="1-4-Cache-的结构"><a href="#1-4-Cache-的结构" class="headerlink" title="1.4 Cache 的结构"></a>1.4 Cache 的结构</h3><p>Cache Line 是 CPU 和主存之间数据传输的最小单位。当一行 Cache Line 被从内存拷贝到 Cache 里，Cache 里会为这个 Cache Line 创建一个条目。<br>这个 Cache 条目里既包含了拷贝的内存数据，即 Cache Line，又包含了这行数据在内存里的位置等元数据信息。</p><p>详情可以参考<a href="https://courses.cs.washington.edu/courses/cse378/09wi/lectures/lec15.pdf" target="_blank" rel="noopener">cse378</a></p><p>Cache Line 的大小和处理器硬件架构有关。在 Linux 上，通过 <code>getconf</code> 就可以拿到 CPU 的 Cache Line 的大小。</p><p><img src="/images/2019/4/5.png" alt></p><p>除了 *_LINESIZE 指示了系统的 Cache Line 的大小是 64 字节外，还给出了 Cache 类别，大小。<br>其中 *_ASSOC 则指示了该 Cache 是几路关联 (Way Associative) 的。</p><h3 id="1-5-Cache-一致性"><a href="#1-5-Cache-一致性" class="headerlink" title="1.5 Cache 一致性"></a>1.5 Cache 一致性</h3><p>如前所述，在 SMP 系统里，每个 CPU 都有自己本地的 Cache。因此，同一个变量，或者同一行 Cache Line，有在多个处理器的本地 Cache 里存在多份拷贝的可能性，因此就存在数据一致性问题。<br>通常，处理器都实现了 Cache 一致性 (Cache Coherence）协议。如历史上 x86 曾实现了 MESI 协议以及 MESIF 协议。</p><p>假设两个处理器 A 和 B, 都在各自本地 Cache Line 里有同一个变量的拷贝时，此时该 Cache Line 处于 Shared 状态。当处理器 A 在本地修改了变量，除去把本地变量所属的 Cache Line 置为 Modified 状态以外，<br>还必须在另一个处理器 B 读同一个变量前，对该变量所在的 B 处理器本地 Cache Line 发起 Invaidate 操作，标记 B 处理器的那条 Cache Line 为 Invalidate 状态。<br>随后，若处理器 B 在对变量做读写操作时，如果遇到这个标记为 Invalidate 的状态的 Cache Line，即会引发 Cache Miss，<br>从而将内存中最新的数据拷贝到 Cache Line 里，然后处理器 B 再对此 Cache Line 对变量做读写操作。</p><p>本文中的 Cache Line 伪共享场景，就基于上述场景来讲解，关于 Cache 一致性协议更多的细节，请参考相关文档。</p><h3 id="1-6-Cache-Line-伪共享"><a href="#1-6-Cache-Line-伪共享" class="headerlink" title="1.6 Cache Line 伪共享"></a>1.6 Cache Line 伪共享</h3><p>Cache Line 伪共享问题，就是由多个 CPU 上的多个线程同时修改自己的变量引发的。这些变量表面上是不同的变量，但是实际上却存储在同一条 Cache Line 里。<br>在这种情况下，由于 Cache 一致性协议，两个处理器都存储有相同的 Cache Line 拷贝的前提下，本地 CPU 变量的修改会导致本地 Cache Line 变成 Modified 状态，然后在其它共享此 Cache Line 的 CPU 上，<br>引发 Cache Line 的 Invaidate 操作，导致 Cache Line 变为 Invalidate 状态，从而使 Cache Line 再次被访问时，发生本地 Cache Miss，从而伤害到应用的性能。<br>在此场景下，多个线程在不同的 CPU 上高频反复访问这种 Cache Line 伪共享的变量，则会因 Cache 颠簸引发严重的性能问题。</p><p>下图即为两个线程间的 Cache Line 伪共享问题的示意图。</p><p><img src="/images/2019/4/6.png" alt></p><h2 id="2-Perf-c2c-发现伪共享"><a href="#2-Perf-c2c-发现伪共享" class="headerlink" title="2 Perf c2c 发现伪共享"></a>2 Perf c2c 发现伪共享</h2><p>当应用在 NUMA 环境中运行，或者应用是多线程的，又或者是多进程间有共享内存，满足其中任意一条，那么这个应用就可能因为 Cache Line 伪共享而性能下降。</p><p>但是，要怎样才能知道一个应用是不是受伪共享所害呢？<a href="https://joemario.github.io/blog/2016/09/01/c2c-blog/" target="_blank" rel="noopener">Joe Mario</a> 提交的 patch 能够解决这个问题。Joe 的 patch 是在 Linux 的著名的 perf 工具上，添加了一些新特性，叫做 c2c，意思是“缓存到缓存” (cache-2-cache)。</p><p>Redhat 在很多 Linux 的大型应用上使用了 c2c 的原型，成功地发现了很多热的伪共享的 Cache Line。<br>Joe 在博客里总结了一下 perf c2c 的主要功能：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://mp.weixin.qq.com/s/RHIjnQDqC-2AOjjBAoMKMg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CPU Cache Line伪共享问题的总结和分析&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-背景知识&quot;&gt;&lt;a href=&quot;#1-背景知识&quot; class=&quot;headerlink&quot; title=&quot;1 背景知识&quot;&gt;&lt;/a&gt;1 背景知识&lt;/h2&gt;&lt;p&gt;要搞清楚 Cache Line 伪共享的概念及其性能影响，需要对现代理器架构和硬件实现有一个基本的了解。
    
    </summary>
    
      <category term="体系结构" scheme="http://liujunming.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ppt制作资源集锦</title>
    <link href="http://liujunming.github.io/2019/01/08/ppt%E5%88%B6%E4%BD%9C%E8%B5%84%E6%BA%90%E9%9B%86%E9%94%A6/"/>
    <id>http://liujunming.github.io/2019/01/08/ppt制作资源集锦/</id>
    <published>2019-01-08T04:48:29.000Z</published>
    <updated>2019-01-12T04:02:47.416Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录ppt制作过程中的心得以及遇到的优质资源，将持续更新。</p><a id="more"></a><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>学术、技术报告：</p><p>英文 <code>Arial Unicode MS</code></p><p>中文 <code>微软雅黑</code></p><h2 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h2><p><a href="https://brandcolors.net/" target="_blank" rel="noopener">美国世界知名品牌颜色收集网</a></p><p><img src="/images/2019/1/23.png" alt></p><h2 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h2><p>在说明问题的优缺点时，可以添加下表情。</p><p><a href="https://emojipedia.org/apple/" target="_blank" rel="noopener">emoji表情</a></p><p><img src="/images/2019/1/24.png" alt></p><h2 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h2><ul><li>Google图片</li></ul><p>有时候，ppt中需要添加一些高大上图片，比如需要添加数据中心的图片，此刻，可以去谷歌中搜索<code>datacenter</code>。</p><p><img src="/images/2019/1/25.png" alt></p><ul><li><a href="https://www.pexels.com/" target="_blank" rel="noopener">pexels</a></li></ul><p>  免费高清素材下载网站</p><ul><li><a href="https://pixabay.com/" target="_blank" rel="noopener">pixabay</a></li></ul><p>免费高清矢量图片资源</p><ul><li><a href="https://www.ssyer.com/home" target="_blank" rel="noopener">莎莎野</a></li></ul><p>免费高清素材下载网站</p><ul><li><a href="https://www.flaticon.com/" target="_blank" rel="noopener">flaticon</a></li></ul><p>免费图标下载资源</p><ul><li><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">阿里巴巴图标素材库</a></li></ul><h2 id="ppt排版"><a href="#ppt排版" class="headerlink" title="ppt排版"></a>ppt排版</h2><ul><li><a href="https://www.pinterest.com/a0802725pinyu/ppt-typesetting/" target="_blank" rel="noopener">PPT typesetting</a></li><li><a href="http://huaban.com/boards/19375308/" target="_blank" rel="noopener">观海PPT收集</a></li><li><a href="https://www.zhihu.com/question/47791746/answer/108730202" target="_blank" rel="noopener">如何做好一张包括一段字和几张图片的ppt,应该如何排版?</a></li></ul><h2 id="神器"><a href="#神器" class="headerlink" title="神器"></a>神器</h2><ul><li>PHOTOZOOM PRO</li></ul><p>做PPT时，我们经常需要用到图片，一张清晰出彩的图片可以为演示增分不少，而往往我们找到一张称心的图片，却发现分辨率过低，插入到PPT中变得模糊，着实令人懊恼。PHOTOZOOM PRO，就是为解决这个痛点而生的。</p><ul><li>PPTMinimizer</li></ul><p>PPT压缩软件</p><ul><li>iSlide 插件</li><li>文字云制作工具</li></ul><p><a href="https://wordart.com/" target="_blank" rel="noopener">Word Cloud Art Creator</a>，是一个支持中文的文字云生成工具</p><ul><li>Collagelt</li></ul><p>这款软件就是可以轻松将很多图片拼接在一起的一款工具。</p><h2 id="PPT-模板下载网站"><a href="#PPT-模板下载网站" class="headerlink" title="PPT 模板下载网站"></a>PPT 模板下载网站</h2><ul><li><a href="http://www.officeplus.cn/Template/Home.shtml" target="_blank" rel="noopener">officeplus</a></li><li><a href="https://slidemodel.com/" target="_blank" rel="noopener">slidemodel</a></li><li><a href="https://www.presentationmagazine.com/" target="_blank" rel="noopener">presentationmagazine</a></li><li><a href="https://slidehunter.com/" target="_blank" rel="noopener">slidehunter</a></li><li><a href="https://www.free-powerpoint-templates-design.com/" target="_blank" rel="noopener">AllPPT</a></li></ul><h2 id="keynote"><a href="#keynote" class="headerlink" title="keynote"></a>keynote</h2><p><a href="http://keynotetemplate.com/" target="_blank" rel="noopener">keynote template</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录ppt制作过程中的心得以及遇到的优质资源，将持续更新。&lt;/p&gt;
    
    </summary>
    
      <category term="设计" scheme="http://liujunming.github.io/categories/%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="设计" scheme="http://liujunming.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Understanding the Linux Kernel 读书笔记-The Page Cache</title>
    <link href="http://liujunming.github.io/2019/01/04/Understanding-the-Linux-Kernel-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-The-Page-Cache/"/>
    <id>http://liujunming.github.io/2019/01/04/Understanding-the-Linux-Kernel-读书笔记-The-Page-Cache/</id>
    <published>2019-01-04T02:36:01.000Z</published>
    <updated>2019-01-04T02:44:18.527Z</updated>
    
    <content type="html"><![CDATA[<p>A disk cache is a software mechanism that allows the system to keep in RAM some data that is normally stored on a disk, so that further accesses to that data can be sat- isfied quickly without accessing the disk.<br><a id="more"></a><br>The dentry cache, which stores dentry objects representing filesystem pathnames, and the inode cache, which stores inode objects representing disk inodes. The <em>page cache</em>, which is a disk cache working on whole pages of data.</p><h2 id="1-The-Page-Cache"><a href="#1-The-Page-Cache" class="headerlink" title="1 The Page Cache"></a>1 The Page Cache</h2><p>The <em>page cache</em> is the main disk cache used by the Linux kernel. In most cases, the kernel refers to the page cache when reading from or writing to disk. New pages are added to the page cache to satisfy User Mode processes’s read requests. If the page is not already in the cache, a new entry is added to the cache and filled with the data read from the disk.</p><p>Kernel designers have implemented the page cache to fulfill two main requirements:</p><ul><li>Quickly locate a specific page containing data relative to a given owner. </li><li>Keep track of how every page in the cache should be handled when reading or writing its content.</li></ul><p>A page does not necessarily contain physically adjacent disk blocks, so it cannot be identified by a device number and a block number. Instead, a page in the page cache is identified by an owner and by an index within the owner’s data—usually, an inode and an offset inside the corresponding file.</p><h3 id="1-1-The-address-space-Object"><a href="#1-1-The-address-space-Object" class="headerlink" title="1.1 The address_space Object"></a>1.1 The address_space Object</h3><p><a href="http://liujunming.top/2017/06/25/address-space-%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/" target="_blank" rel="noopener">address_space,页高速缓存</a><br>The core data structure of the page cache is the <code>address_space</code> object, a data structure embedded in the inode object that owns the page. Many pages in the cache may refer to the same owner, thus they may be linked to the same <code>address_space</code> object. This object also establishes a link between the owner’s pages and a set of methods that operate on these pages.</p><h3 id="1-2-The-Radix-Tree"><a href="#1-2-The-Radix-Tree" class="headerlink" title="1.2 The Radix Tree"></a>1.2 The Radix Tree</h3><h3 id="1-3-Page-Cache-Handling-Functions"><a href="#1-3-Page-Cache-Handling-Functions" class="headerlink" title="1.3 Page Cache Handling Functions"></a>1.3 Page Cache Handling Functions</h3><h3 id="1-4-The-Tags-of-the-Radix-Tree"><a href="#1-4-The-Tags-of-the-Radix-Tree" class="headerlink" title="1.4 The Tags of the Radix Tree"></a>1.4 The Tags of the Radix Tree</h3><h2 id="2-Storing-Blocks-in-the-Page-Cache"><a href="#2-Storing-Blocks-in-the-Page-Cache" class="headerlink" title="2 Storing Blocks in the Page Cache"></a>2 Storing Blocks in the Page Cache</h2><p><em>page cache</em> vs <em>buffer cache</em>.</p><p>Starting from stable version 2.4.10, the buffer cache does not really exist anymore. In fact, for reasons of efficiency, block buffers are no longer allocated individually; instead, they are stored in dedicated pages called “buffer pages,” which are kept in the page cache.</p><p>A buffer page is a page of data associated with additional descriptors called “buffer heads,” whose main purpose is to quickly locate the disk address of each individual block in the page. In fact, the chunks of data stored in a page belonging to the page cache are not necessarily adjacent on disk.</p><h3 id="2-1-Block-Buffers-and-Buffer-Heads"><a href="#2-1-Block-Buffers-and-Buffer-Heads" class="headerlink" title="2.1 Block Buffers and Buffer Heads"></a>2.1 Block Buffers and Buffer Heads</h3><h3 id="2-2-Managing-the-Buffer-Heads"><a href="#2-2-Managing-the-Buffer-Heads" class="headerlink" title="2.2 Managing the Buffer Heads"></a>2.2 Managing the Buffer Heads</h3><h3 id="2-3-Buffer-Pages"><a href="#2-3-Buffer-Pages" class="headerlink" title="2.3 Buffer Pages"></a>2.3 Buffer Pages</h3><p><img src="/images/2019/1/21.png" alt></p><p><a href="http://sundayhut.is-programmer.com/posts/62477" target="_blank" rel="noopener">buffer_head理解、解析</a></p><p>bio 相对 buffer_head 的好处有：bio 可以更方便的使用高端内存，因为它只与 page 打交道，并不直接使用地址。bio 可以表示 direct I/O。对向量形式的 I/O支持更好，防止 I/O 被打散。但是 buffer_head 还是需要的，它用于映射磁盘块到内存，因为 bio 中并没有包含 kernel 需要的 buffer 状态的成员以及一些其它信息。</p><h2 id="3-Writing-Dirty-Pages-to-Disk"><a href="#3-Writing-Dirty-Pages-to-Disk" class="headerlink" title="3 Writing Dirty Pages to Disk"></a>3 Writing Dirty Pages to Disk</h2><hr><p>参考资料：</p><ol><li><a href="http://sundayhut.is-programmer.com/posts/62477" target="_blank" rel="noopener">buffer_head理解、解析</a></li><li><a href="http://www.ilinuxkernel.com/files/Linux.Generic.Block.Layer.pdf" target="_blank" rel="noopener">Linux通用块设备层</a></li><li><a href="https://zohead.com/archives/linux-kernel-learning-block-layer/" target="_blank" rel="noopener">Linux kernel学习-block层</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A disk cache is a software mechanism that allows the system to keep in RAM some data that is normally stored on a disk, so that further accesses to that data can be sat- isfied quickly without accessing the disk.&lt;br&gt;
    
    </summary>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/categories/I-O%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="读书笔记" scheme="http://liujunming.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Understanding the Linux Kernel 读书笔记-Block Device Drivers</title>
    <link href="http://liujunming.github.io/2019/01/03/Understanding-the-Linux-Kernel-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Block-Device-Drivers/"/>
    <id>http://liujunming.github.io/2019/01/03/Understanding-the-Linux-Kernel-读书笔记-Block-Device-Drivers/</id>
    <published>2019-01-03T05:12:09.000Z</published>
    <updated>2019-01-03T10:14:56.327Z</updated>
    
    <content type="html"><![CDATA[<p>We start in the first section “Block Devices Handling” to explain the general architecture of the Linux block I/O subsystem. In the sections “The Generic Block Layer,” “The I/O Scheduler,” and “Block Device Drivers,” we will describe the main components of the block I/O subsystem. Finally, in the last section, “Opening a Block Device File,” we will outline the steps performed by the kernel when opening a block device file.<a id="more"></a></p><p><a href="http://www.ilinuxkernel.com/files/IO.Data.Structure.pdf" target="_blank" rel="noopener">Linux内核I/O流程主要数据结构</a></p><p>阅读时注意request的上下文，可能代表普遍意义上的请求，也可能代表<code>request</code>结构体。</p><h2 id="1-Block-Devices-Handling"><a href="#1-Block-Devices-Handling" class="headerlink" title="1 Block Devices Handling"></a>1 Block Devices Handling</h2><p>Each operation on a block device driver involves a large number of kernel components; the most important ones are shown in Figure 14-1.<br><img src="/images/2019/1/16.png" alt><br>Let us suppose, for instance, that a process issued a read() system call on some disk file. Here is what the kernel typically does to service the process request:</p><ol><li>The service routine of the <code>read()</code> system call activates a suitable VFS function, passing to it a file descriptor and an offset inside the file. </li><li>The VFS function determines if the requested data is already available and, if necessary, how to perform the read operation.</li><li>Let’s assume that the kernel must read the data from the block device, thus it must determine the physical location of that data. To do this, the kernel relies on the <em>mapping layer</em>, which typically executes two steps:<ul><li>It determines the block size of the filesystem including the file and computes the extent of the requested data in terms of <em>file block numbers</em>. Essentially, the file is seen as split in many blocks, and the kernel determines the numbers (indices relative to the beginning of file) of the blocks containing the requested data.</li><li>Next, the mapping layer invokes a filesystem-specific function that accesses the file’s disk inode and determines the position of the requested data on disk in terms of <em>logical block numbers</em>. Essentially, the disk is seen as split in blocks, and the kernel determines the numbers (indices relative to the beginning of the disk or partition) corresponding to the blocks storing the requested data. Because a file may be stored in nonadjacent blocks on disk, a data structure stored in the disk inode maps each file block number to a logical block number.</li></ul></li><li>The kernel can now issue the read operation on the block device. It makes use of the <em>generic block layer</em>, which starts the I/O operations that transfer the requested data. In general, each I/O operation involves a group of blocks that are adjacent on disk. Because the requested data is not necessarily adjacent on disk, the generic block layer might start several I/O operations. Each I/O operation is represented by a “block I/O” (in short, “bio”) structure, which collects all information needed by the lower components to satisfy the request.<br>The generic block layer hides the peculiarities of each hardware block device, thus offering an abstract view of the block devices. Because almost all block devices are disks, the generic block layer also provides some general data structures that describe “disks” and “disk partitions.” </li><li>Below the generic block layer, the “I/O scheduler” sorts the pending I/O data transfer requests according to predefined kernel policies. The purpose of the scheduler is to group requests of data that lie near each other on the physical medium.</li><li>Finally, the <em>block device drivers</em> take care of the actual data transfer by sending suitable commands to the hardware interfaces of the disk controllers.</li></ol><p>As you can see, there are many kernel components that are concerned with data stored in block devices; each of them manages the disk data using chunks of different length:</p><ul><li>The controllers of the hardware block devices transfer data in chunks of fixed length called “sectors.” Therefore, the I/O scheduler and the block device drivers must manage sectors of data.</li><li>The Virtual Filesystem, the mapping layer, and the filesystems group the disk data in logical units called “blocks.” A block corresponds to the minimal disk storage unit inside a filesystem.</li><li>Block device drivers should be able to cope with “segments” of data: each segment is a memory page—or a portion of a memory page—including chunks of data that are physically adjacent on disk.</li><li>The disk caches work on “pages” of disk data, each of which fits in a page frame.</li><li>The generic block layer glues together all the upper and lower components, thus it knows about sectors, blocks, segments, and pages of data.</li></ul><p><img src="/images/2019/1/17.png" alt></p><h3 id="1-1-Sectors"><a href="#1-1-Sectors" class="headerlink" title="1.1 Sectors"></a>1.1 Sectors</h3><h3 id="1-2-Blocks"><a href="#1-2-Blocks" class="headerlink" title="1.2 Blocks"></a>1.2 Blocks</h3><h3 id="1-3-Segments"><a href="#1-3-Segments" class="headerlink" title="1.3 Segments"></a>1.3 Segments</h3><h2 id="2-The-Generic-Block-Layer"><a href="#2-The-Generic-Block-Layer" class="headerlink" title="2 The Generic Block Layer"></a>2 The Generic Block Layer</h2><p>The generic block layer is a kernel component that handles the requests for all block devices in the system. Thanks to its functions, the kernel may easily:</p><ul><li>Implement—with some additional effort—a “zero-copy” schema, where disk data is directly put in the User Mode address space without being copied to kernel memory first.</li><li>Manage logical volumes—such as those used by LVM(the Logical Volume Manager) and RAID (Redundant Array of Inexpensive Disks): several disk partitions, even on different block devices, can be seen as a single partition.</li><li>Exploit the advanced features of the most recent disk controllers.</li></ul><h3 id="2-1-The-Bio-Structure"><a href="#2-1-The-Bio-Structure" class="headerlink" title="2.1 The Bio Structure"></a>2.1 The Bio Structure</h3><p>The core data structure of the generic block layer is a descriptor of an ongoing I/O block device operation called <em>bio</em>. Each bio essentially includes an identifier for a disk storage area—the initial sector number and the number of sectors included in the storage area—and one or more segments describing the memory areas involved in the I/O operation. A bio is implemented by the <code>bio</code> data structure.</p><p>Each segment in a bio is represented by a <code>bio_vec</code> data structure.<br><img src="/images/2019/1/18.png" alt></p><h3 id="2-2-Representing-Disks-and-Disk-Partitions"><a href="#2-2-Representing-Disks-and-Disk-Partitions" class="headerlink" title="2.2 Representing Disks and Disk Partitions"></a>2.2 Representing Disks and Disk Partitions</h3><p>A <em>disk</em> is a logical block device that is handled by the generic block layer. Usually a disk corresponds to a hardware block device such as a hard disk, a floppy disk, or a CD-ROM disk. However, a disk can be a virtual device built upon several physical disk partitions, or a storage area living in some dedicated pages of RAM. In any case, the upper kernel components operate on all disks in the same way thanks to the services offered by the generic block layer.</p><p>A disk is represented by the <code>gendisk</code> object.</p><p>Hard disks are commonly split into <em>logical partitions</em>. Each block device file may represent either a whole disk or a partition inside the disk. If a disk is split in partitions, their layout is kept in an array of <code>hd_struct</code> structures whose address is stored in the <code>part</code> field of the <code>gendisk</code> object.</p><h3 id="2-3-Submitting-a-Request"><a href="#2-3-Submitting-a-Request" class="headerlink" title="2.3 Submitting a Request"></a>2.3 Submitting a Request</h3><h2 id="3-The-I-O-Scheduler"><a href="#3-The-I-O-Scheduler" class="headerlink" title="3 The I/O Scheduler"></a>3 The I/O Scheduler</h2><p><img src="/images/2019/1/20.jpg" alt></p><p><img src="/images/2019/1/19.png" alt></p><p>Although block device drivers are able to transfer a single sector at a time, the block I/O layer does not perform an individual I/O operation for each sector to be accessed on disk; this would lead to poor disk performance, because locating the physical position of a sector on the disk surface is quite time-consuming. Instead, the kernel tries, whenever possible, to cluster several sectors and handle them as a whole, thus reducing the average number of head movements.</p><p>When a kernel component wishes to read or write some disk data, it actually creates a block device request. That request essentially describes the requested sectors and the kind of operation to be performed on them (read or write). However, the kernel does not satisfy a request as soon as it is created—the I/O operation is just scheduled and will be performed at a later time.</p><p>Each block device driver maintains its own <em>request queue</em>, which contains the list of pending requests for the device. If the disk controller is handling several disks, there is usually one request queue for each physical block device. I/O scheduling is performed separately on each request queue, thus increasing disk performance.</p><h3 id="3-1-Request-Queue-Descriptors"><a href="#3-1-Request-Queue-Descriptors" class="headerlink" title="3.1 Request Queue Descriptors"></a>3.1 Request Queue Descriptors</h3><p>The <code>backing_dev_info</code> field is a small object of type <code>backing_dev_info</code>, which stores information about the I/O data flow traffic for the underlying hardware block device. For instance, it holds information about read-ahead and about request queue congestion state.</p><h3 id="3-2-Request-Descriptors"><a href="#3-2-Request-Descriptors" class="headerlink" title="3.2 Request Descriptors"></a>3.2 Request Descriptors</h3><p>每个bio到达了磁盘设备的request_queue，接下来需要对该bio进行深加工，提高IO效率。这里的关键在于将bio合并至已存在request内，所谓的合并指的是该bio所请求的io是否与当前已有request在物理磁盘块上连续，如果是，无需分配新的request，直接将该请求添加至已有request，这样一次便可传输更多数据，提升IO效率，这其实也是整个IO系统的核心所在。</p><h3 id="3-3-Activating-the-Block-Device-Driver"><a href="#3-3-Activating-the-Block-Device-Driver" class="headerlink" title="3.3 Activating the Block Device Driver"></a>3.3 Activating the Block Device Driver</h3><h3 id="3-4-I-O-Scheduling-Algorithms"><a href="#3-4-I-O-Scheduling-Algorithms" class="headerlink" title="3.4 I/O Scheduling Algorithms"></a>3.4 I/O Scheduling Algorithms</h3><p>When a new request is added to a request queue, the generic block layer invokes the I/O scheduler to determine that exact position of the new element in the queue. The I/O scheduler tries to keep the request queue sorted sector by sector. If the requests to be processed are taken sequentially from the list, the amount of disk seeking is significantly reduced because the disk head moves in a linear way from the inner track to the outer one (or vice versa) instead of jumping randomly from one track to another.</p><h3 id="3-5-Issuing-a-Request-to-the-I-O-Scheduler"><a href="#3-5-Issuing-a-Request-to-the-I-O-Scheduler" class="headerlink" title="3.5 Issuing a Request to the I/O Scheduler"></a>3.5 Issuing a Request to the I/O Scheduler</h3><h2 id="4-Block-Device-Drivers"><a href="#4-Block-Device-Drivers" class="headerlink" title="4 Block Device Drivers"></a>4 Block Device Drivers</h2><h3 id="4-1-Block-Devices"><a href="#4-1-Block-Devices" class="headerlink" title="4.1 Block Devices"></a>4.1 Block Devices</h3><h3 id="4-2-Device-Driver-Registration-and-Initialization"><a href="#4-2-Device-Driver-Registration-and-Initialization" class="headerlink" title="4.2 Device Driver Registration and Initialization"></a>4.2 Device Driver Registration and Initialization</h3><h3 id="4-3-The-Strategy-Routine"><a href="#4-3-The-Strategy-Routine" class="headerlink" title="4.3 The Strategy Routine"></a>4.3 The Strategy Routine</h3><h3 id="4-4-The-Interrupt-Handler"><a href="#4-4-The-Interrupt-Handler" class="headerlink" title="4.4 The Interrupt Handler"></a>4.4 The Interrupt Handler</h3><h2 id="5-Opening-a-Block-Device-File"><a href="#5-Opening-a-Block-Device-File" class="headerlink" title="5 Opening a Block Device File"></a>5 Opening a Block Device File</h2><hr><p>参考资料：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/39199521" target="_blank" rel="noopener">Linux IO请求处理流程-bio和request</a></li><li><a href="http://sundayhut.is-programmer.com/posts/62921.html" target="_blank" rel="noopener">bio，request，request_queue的学习</a></li><li><a href="http://www.ilinuxkernel.com/files/IO.Data.Structure.pdf" target="_blank" rel="noopener">Linux内核I/O流程主要数据结构</a></li><li><a href="http://ilinuxkernel.com/?p=1693" target="_blank" rel="noopener">Linux内核I/O调度层</a></li><li><a href="http://sundayhut.is-programmer.com/posts/49095.html" target="_blank" rel="noopener">文件系统写浅析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;We start in the first section “Block Devices Handling” to explain the general architecture of the Linux block I/O subsystem. In the sections “The Generic Block Layer,” “The I/O Scheduler,” and “Block Device Drivers,” we will describe the main components of the block I/O subsystem. Finally, in the last section, “Opening a Block Device File,” we will outline the steps performed by the kernel when opening a block device file.
    
    </summary>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/categories/I-O%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="读书笔记" scheme="http://liujunming.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Understanding the Linux Kernel 读书笔记-I/O Architecture and Device Drivers</title>
    <link href="http://liujunming.github.io/2019/01/03/Understanding-the-Linux-Kernel-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-I-O-Architecture-and-Device-Drivers/"/>
    <id>http://liujunming.github.io/2019/01/03/Understanding-the-Linux-Kernel-读书笔记-I-O-Architecture-and-Device-Drivers/</id>
    <published>2019-01-03T01:50:38.000Z</published>
    <updated>2019-01-03T04:59:27.272Z</updated>
    
    <content type="html"><![CDATA[<p>In the section “I/O Architecture,” we give a brief survey of the 80×86 I/O architecture. In the section “The Device Driver Model,” we introduce the Linux device driver model.<a id="more"></a>  Next, in the section “Device Files,” we show how the VFS associates a special file called “device file” with each different hardware device, so that application programs can use all kinds of devices in the same way. We then introduce in the section “Device Drivers” some common characteristics of device drivers. Finally, in the section “Character Device Drivers,” we illustrate the overall organization of character device drivers in Linux.</p><h2 id="1-I-O-Architecture"><a href="#1-I-O-Architecture" class="headerlink" title="1 I/O Architecture"></a>1 I/O Architecture</h2><p>The data path that connects a CPU to an I/O device is generically called an <em>I/O bus</em>. The 80 × 86 microprocessors use 16 of their address pins to address I/O devices and 8, 16, or 32 of their data pins to transfer data. The I/O bus, in turn, is connected to each I/O device by means of a hierarchy of hardware components including up to three elements: I/O ports, interfaces, and device controllers. Figure 13-1 shows the components of the I/O architecture.<br><img src="/images/2019/1/12.png" alt></p><h3 id="1-1-I-O-Ports"><a href="#1-1-I-O-Ports" class="headerlink" title="1.1 I/O Ports"></a>1.1 I/O Ports</h3><p>Each device connected to the I/O bus has its own set of I/O addresses, which are usually called <em>I/O ports</em>.  Four special assembly language instructions called <code>in</code>, <code>ins</code>, <code>out</code>, and <code>outs</code> allow the CPU to read from and write into an I/O port.</p><p>I/O ports may also be mapped into addresses of the physical address space. </p><p>The I/O ports of each device are structured into a set of specialized registers, as shown in Figure 13-2.<br><img src="/images/2019/1/13.png" alt></p><h4 id="1-1-1-Accessing-I-O-ports"><a href="#1-1-1-Accessing-I-O-ports" class="headerlink" title="1.1.1 Accessing I/O ports"></a>1.1.1 Accessing I/O ports</h4><p>The <code>in</code>, <code>out</code>, <code>ins</code>, and <code>outs</code> assembly language instructions access I/O ports. </p><p>While accessing I/O ports is simple, detecting which I/O ports have been assigned to I/O devices may not be easy, in particular, for systems based on an ISA bus. Often a device driver must blindly write into some I/O port to probe the hardware device; if, however, this I/O port is already used by some other hardware device, a system crash could occur. To prevent such situations, the kernel keeps track of I/O ports assigned to each hardware device by means of “resources.”</p><h3 id="1-2-I-O-Interfaces"><a href="#1-2-I-O-Interfaces" class="headerlink" title="1.2 I/O Interfaces"></a>1.2 I/O Interfaces</h3><p>An <em>I/O interface</em> is a hardware circuit inserted between a group of I/O ports and the corresponding device controller. It acts as an interpreter that translates the values in the I/O ports into commands and data for the device. In the opposite direction, it detects changes in the device state and correspondingly updates the I/O port that plays the role of status register. This circuit can also be connected through an IRQ line to a Programmable Interrupt Controller, so that it issues interrupt requests on behalf of the device.</p><p>There are two types of interfaces:</p><ul><li><em>Custom I/O interfaces</em></li><li><em>General-purpose I/O interfaces</em></li></ul><h3 id="1-3-Device-Controllers"><a href="#1-3-Device-Controllers" class="headerlink" title="1.3 Device Controllers"></a>1.3 Device Controllers</h3><p>A complex device may require a <em>device controller</em> to drive it. Essentially, the controller plays two important roles:</p><ul><li>It interprets the high-level commands received from the I/O interface and forces the device to execute specific actions by sending proper sequences of electrical signals to it.</li><li>It converts and properly interprets the electrical signals received from the device and modifies (through the I/O interface) the value of the status register.</li></ul><p>A typical device controller is the <em>disk controller</em>.</p><p>Simpler devices do not have a device controller.</p><p>Several hardware devices include their own memory, which is often called <em>I/O shared memory</em>. </p><h2 id="2-The-Device-Driver-Model"><a href="#2-The-Device-Driver-Model" class="headerlink" title="2 The Device Driver Model"></a>2 The Device Driver Model</h2><p>Recent hardware devices, even of different classes, support similar functionalities. Drivers for such devices should typically take care of:</p><ul><li>Power management </li><li>Plug and play </li><li>Hot-plugging</li></ul><p>Linux 2.6 provides some data structures and helper functions that offer a unifying view of all buses, devices, and device drivers in the system; this framework is called the <em>device driver model</em>.</p><h3 id="2-1-The-sysfs-Filesystem"><a href="#2-1-The-sysfs-Filesystem" class="headerlink" title="2.1 The sysfs Filesystem"></a>2.1 The sysfs Filesystem</h3><p>A goal of the <code>sysfs</code> filesystem is to expose the hierarchical relationships among the components of the device driver model. The related top-level directories of this filesystem are:</p><ul><li><em>block</em></li><li><em>devices</em></li><li><em>bus</em></li><li><em>drivers</em></li><li><em>class</em></li><li><em>power</em></li><li><em>firmware</em></li></ul><h3 id="2-2-Kobjects"><a href="#2-2-Kobjects" class="headerlink" title="2.2 Kobjects"></a>2.2 Kobjects</h3><p>The core data structure of the device driver model is a generic data structure named <em>kobject</em>, which is inherently tied to the <code>sysfs</code> filesystem: each kobject corresponds to a directory in that filesystem.</p><h3 id="2-3-Components-of-the-Device-Driver-Model"><a href="#2-3-Components-of-the-Device-Driver-Model" class="headerlink" title="2.3 Components of the Device Driver Model"></a>2.3 Components of the Device Driver Model</h3><p>The device driver model is built upon a handful of basic data structures, which represent buses, devices, device drivers, etc. </p><h2 id="3-Device-Files"><a href="#3-Device-Files" class="headerlink" title="3 Device Files"></a>3 Device Files</h2><p>I/O devices are treated as special files called <em>device file</em>.</p><p>According to the characteristics of the underlying device drivers, device files can be of two types: <em>block</em> or <em>character</em>.</p><ul><li>The data of a block device can be addressed randomly, and the time needed to transfer a data block is small and roughly the same, at least from the point of view of the human user. Typical examples of block devices are hard disks, floppy disks, CD-ROM drives, and DVD players.</li><li>The data of a character device either cannot be addressed randomly, or they can be addressed randomly, but the time required to access a random datum largely depends on its position inside the device.</li></ul><p>A device file is usually a real file stored in a filesystem. Its inode, however, doesn’t need to include pointers to blocks of data on the disk (the file’s data) because there are none. Instead, the inode must include an identifier of the hardware device corresponding to the character or block device file.</p><p>Traditionally, this identifier consists of the type of device file (character or block) and a pair of numbers. The first number, called the <em>major number</em>, identifies the device type. Traditionally, all device files that have the same major number and the same type share the same set of file operations, because they are handled by the same device driver. The second number, called the <em>minor number</em>, identifies a specific device among a group of devices that share the same major number. For instance, a group of disks managed by the same disk controller have the same major number and different minor numbers.</p><p><img src="/images/2019/1/14.png" alt></p><h3 id="3-1-User-Mode-Handling-of-Device-Files"><a href="#3-1-User-Mode-Handling-of-Device-Files" class="headerlink" title="3.1 User Mode Handling of Device Files"></a>3.1 User Mode Handling of Device Files</h3><h3 id="3-2-VFS-Handling-of-Device-Files"><a href="#3-2-VFS-Handling-of-Device-Files" class="headerlink" title="3.2 VFS Handling of Device Files"></a>3.2 VFS Handling of Device Files</h3><p>Device files live in the system directory tree but are intrinsically different from regular files and directories. When a process accesses a regular file, it is accessing some data blocks in a disk partition through a filesystem; when a process accesses a device file, it is just driving a hardware device. </p><h2 id="4-Device-Drivers"><a href="#4-Device-Drivers" class="headerlink" title="4 Device Drivers"></a>4 Device Drivers</h2><p>A <em>device driver</em> is the set of kernel routines that makes a hardware device respond to the programming interface defined by the canonical set of VFS functions (<code>open</code>, <code>read</code>, <code>lseek</code>, <code>ioctl</code>, and so forth) that control a device. The actual implementation of all these functions is delegated to the device driver. Because each device has a different I/O controller, and thus different commands and different state information, most I/O devices have their own drivers.</p><p>A device driver does not consist only of the functions that implement the device file operations. Before using a device driver, several activities must have taken place.</p><h3 id="4-1-Device-Driver-Registration"><a href="#4-1-Device-Driver-Registration" class="headerlink" title="4.1 Device Driver Registration"></a>4.1 Device Driver Registration</h3><h3 id="4-2-Device-Driver-Initialization"><a href="#4-2-Device-Driver-Initialization" class="headerlink" title="4.2 Device Driver Initialization"></a>4.2 Device Driver Initialization</h3><h3 id="4-3-Monitoring-I-O-Operations"><a href="#4-3-Monitoring-I-O-Operations" class="headerlink" title="4.3 Monitoring I/O Operations"></a>4.3 Monitoring I/O Operations</h3><h3 id="4-4-Accessing-the-I-O-Shared-Memory"><a href="#4-4-Accessing-the-I-O-Shared-Memory" class="headerlink" title="4.4 Accessing the I/O Shared Memory"></a>4.4 Accessing the I/O Shared Memory</h3><h3 id="4-5-Direct-Memory-Access-DMA"><a href="#4-5-Direct-Memory-Access-DMA" class="headerlink" title="4.5 Direct Memory Access (DMA)"></a>4.5 Direct Memory Access (DMA)</h3><p><strong>Bus addresses</strong><br>Every DMA transfer involves (at least) one memory buffer, which contains the data to be read or written by the hardware device. In general, before activating the transfer, the device driver must ensure that the DMA circuit can directly access the RAM locations.</p><p>Until now we have distinguished three kinds of memory addresses: logical and linear addresses, which are used internally by the CPU, and physical addresses, which are the memory addresses used by the CPU to physically drive the data bus. However, there is a fourth kind of memory address: the so-called <em>bus address</em>. It corresponds to the memory addresses used by all hardware devices except the CPU to drive the data bus.</p><p>In the 80×86 architecture, bus addresses coincide with physical addresses.</p><h3 id="4-6-Levels-of-Kernel-Support"><a href="#4-6-Levels-of-Kernel-Support" class="headerlink" title="4.6 Levels of Kernel Support"></a>4.6 Levels of Kernel Support</h3><h2 id="5-Character-Device-Drivers"><a href="#5-Character-Device-Drivers" class="headerlink" title="5 Character Device Drivers"></a>5 Character Device Drivers</h2><p><img src="/images/2019/1/15.png" alt></p><h3 id="5-1-Assigning-Device-Numbers"><a href="#5-1-Assigning-Device-Numbers" class="headerlink" title="5.1 Assigning Device Numbers"></a>5.1 Assigning Device Numbers</h3><h3 id="5-2-Accessing-a-Character-Device-Driver"><a href="#5-2-Accessing-a-Character-Device-Driver" class="headerlink" title="5.2 Accessing a Character Device Driver"></a>5.2 Accessing a Character Device Driver</h3><h3 id="5-3-Buffering-Strategies-for-Character-Devices"><a href="#5-3-Buffering-Strategies-for-Character-Devices" class="headerlink" title="5.3 Buffering Strategies for Character Devices"></a>5.3 Buffering Strategies for Character Devices</h3><hr><p>参考资料：</p><ol><li><a href="https://sysplay.github.io/books/LinuxDrivers/book/Content/Part04.html" target="_blank" rel="noopener">Linux Character Drivers</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;In the section “I/O Architecture,” we give a brief survey of the 80×86 I/O architecture. In the section “The Device Driver Model,” we introduce the Linux device driver model.
    
    </summary>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/categories/I-O%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="读书笔记" scheme="http://liujunming.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Understanding the Linux Kernel 读书笔记-The Virtual Filesystem</title>
    <link href="http://liujunming.github.io/2019/01/02/Understanding-the-Linux-Kernel-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-The-Virtual-Filesystem/"/>
    <id>http://liujunming.github.io/2019/01/02/Understanding-the-Linux-Kernel-读书笔记-The-Virtual-Filesystem/</id>
    <published>2019-01-02T08:20:40.000Z</published>
    <updated>2019-01-02T12:01:00.699Z</updated>
    
    <content type="html"><![CDATA[<p>The idea behind the Virtual Filesystem is to put a wide range of information in the kernel to represent many different types of filesystems.<br><a id="more"></a> </p><h2 id="1-The-Role-of-the-Virtual-Filesystem-VFS"><a href="#1-The-Role-of-the-Virtual-Filesystem-VFS" class="headerlink" title="1 The Role of the Virtual Filesystem (VFS)"></a>1 The Role of the Virtual Filesystem (VFS)</h2><p>The Virtual Filesystem is a kernel software layer that handles all system calls related to a standard Unix filesystem. Its main strength is providing a common interface to several kinds of filesystems.</p><p><img src="/images/2019/1/8.png" alt></p><p>Filesystems supported by the VFS may be grouped into three main classes:</p><ul><li><em>Disk-based filesystems</em></li></ul><p>These manage storage space available in a local disk or in some other device that emulates a disk (such as a USB flash drive).</p><ul><li><em>Network filesystems</em></li></ul><p>These allow easy access to files included in filesystems belonging to other networked computers.</p><ul><li><em>Special filesystems</em></li></ul><p>These do not manage disk space, either locally or remotely.</p><h3 id="1-1-The-Common-File-Model"><a href="#1-1-The-Common-File-Model" class="headerlink" title="1.1 The Common File Model"></a>1.1 The Common File Model</h3><p>The key idea behind the VFS consists of introducing a <em>common file model</em> capable of representing all supported filesystems.</p><p>The common file model consists of the following object types:</p><ul><li><em>The superblock object</em></li><li><em>The inode object</em></li><li><em>The file object</em></li><li><em>The dentry object</em></li></ul><p>Figure 12-2 illustrates with a simple example how processes interact with files. Three different processes have opened the same file, two of them using the same hard link. In this case, each of the three processes uses its own file object, while only two dentry objects are required—one for each hard link. Both dentry objects refer to the same inode object, which identifies the superblock object and, together with the latter, the common disk file.<br><img src="/images/2019/1/9.png" alt></p><h3 id="1-2-System-Calls-Handled-by-the-VFS"><a href="#1-2-System-Calls-Handled-by-the-VFS" class="headerlink" title="1.2 System Calls Handled by the VFS"></a>1.2 System Calls Handled by the VFS</h3><h2 id="2-VFS-Data-Structures"><a href="#2-VFS-Data-Structures" class="headerlink" title="2 VFS Data Structures"></a>2 VFS Data Structures</h2><h3 id="2-1-Superblock-Objects"><a href="#2-1-Superblock-Objects" class="headerlink" title="2.1 Superblock Objects"></a>2.1 Superblock Objects</h3><p>A superblock object consists of a <a href="https://elixir.bootlin.com/linux/v2.6.11/source/include/linux/fs.h#L754" target="_blank" rel="noopener">super_block</a> structure.</p><h3 id="2-2-Inode-Objects"><a href="#2-2-Inode-Objects" class="headerlink" title="2.2 Inode Objects"></a>2.2 Inode Objects</h3><h3 id="2-3-File-Objects"><a href="#2-3-File-Objects" class="headerlink" title="2.3 File Objects"></a>2.3 File Objects</h3><h3 id="2-4-dentry-Objects"><a href="#2-4-dentry-Objects" class="headerlink" title="2.4 dentry Objects"></a>2.4 dentry Objects</h3><h3 id="2-5-The-dentry-Cache"><a href="#2-5-The-dentry-Cache" class="headerlink" title="2.5 The dentry Cache"></a>2.5 The dentry Cache</h3><h3 id="2-6-Files-Associated-with-a-Process"><a href="#2-6-Files-Associated-with-a-Process" class="headerlink" title="2.6 Files Associated with a Process"></a>2.6 Files Associated with a Process</h3><p><img src="/images/2019/1/10.png" alt></p><h2 id="3-Filesystem-Types"><a href="#3-Filesystem-Types" class="headerlink" title="3 Filesystem Types"></a>3 Filesystem Types</h2><h3 id="3-1-Special-Filesystems"><a href="#3-1-Special-Filesystems" class="headerlink" title="3.1 Special Filesystems"></a>3.1 Special Filesystems</h3><p>While network and disk-based filesystems enable the user to handle information stored outside the kernel, special filesystems may provide an easy way for system programs and administrators to manipulate the data structures of the kernel and to implement special features of the operating system. Table 12-8 lists the most common special filesystems used in Linux; for each of them, the table reports its suggested mount point and a short description.<br><img src="/images/2019/1/11.png" alt></p><h3 id="3-2-Filesystem-Type-Registration"><a href="#3-2-Filesystem-Type-Registration" class="headerlink" title="3.2 Filesystem Type Registration"></a>3.2 Filesystem Type Registration</h3><h2 id="4-Filesystem-Handling"><a href="#4-Filesystem-Handling" class="headerlink" title="4 Filesystem Handling"></a>4 Filesystem Handling</h2><h3 id="4-1-Namespaces"><a href="#4-1-Namespaces" class="headerlink" title="4.1 Namespaces"></a>4.1 Namespaces</h3><p>Every process might have its own tree of mounted filesystems—the socalled <em>namespace</em> of the process.</p><h3 id="4-2-Filesystem-Mounting"><a href="#4-2-Filesystem-Mounting" class="headerlink" title="4.2 Filesystem Mounting"></a>4.2 Filesystem Mounting</h3><h3 id="4-3-Mounting-a-Generic-Filesystem"><a href="#4-3-Mounting-a-Generic-Filesystem" class="headerlink" title="4.3 Mounting a Generic Filesystem"></a>4.3 Mounting a Generic Filesystem</h3><h3 id="4-4-Mounting-the-Root-Filesystem"><a href="#4-4-Mounting-the-Root-Filesystem" class="headerlink" title="4.4 Mounting the Root Filesystem"></a>4.4 Mounting the Root Filesystem</h3><h3 id="4-5-Unmounting-a-Filesystem"><a href="#4-5-Unmounting-a-Filesystem" class="headerlink" title="4.5 Unmounting a Filesystem"></a>4.5 Unmounting a Filesystem</h3><h2 id="5-Pathname-Lookup"><a href="#5-Pathname-Lookup" class="headerlink" title="5 Pathname Lookup"></a>5 Pathname Lookup</h2><h3 id="5-1-Standard-Pathname-Lookup"><a href="#5-1-Standard-Pathname-Lookup" class="headerlink" title="5.1 Standard Pathname Lookup"></a>5.1 Standard Pathname Lookup</h3><h3 id="5-2-Parent-Pathname-Lookup"><a href="#5-2-Parent-Pathname-Lookup" class="headerlink" title="5.2 Parent Pathname Lookup"></a>5.2 Parent Pathname Lookup</h3><h3 id="5-3-Lookup-of-Symbolic-Links"><a href="#5-3-Lookup-of-Symbolic-Links" class="headerlink" title="5.3 Lookup of Symbolic Links"></a>5.3 Lookup of Symbolic Links</h3><h2 id="6-Implementations-of-VFS-System-Calls"><a href="#6-Implementations-of-VFS-System-Calls" class="headerlink" title="6 Implementations of VFS System Calls"></a>6 Implementations of VFS System Calls</h2><h3 id="6-1-The-open-System-Call"><a href="#6-1-The-open-System-Call" class="headerlink" title="6.1 The open() System Call"></a>6.1 The open() System Call</h3><h3 id="6-2-The-read-and-write-System-Calls"><a href="#6-2-The-read-and-write-System-Calls" class="headerlink" title="6.2 The read() and write() System Calls"></a>6.2 The read() and write() System Calls</h3><h3 id="6-3-The-close-System-Call"><a href="#6-3-The-close-System-Call" class="headerlink" title="6.3 The close() System Call"></a>6.3 The close() System Call</h3><h2 id="7-File-Locking"><a href="#7-File-Locking" class="headerlink" title="7 File Locking"></a>7 File Locking</h2><p>The POSIX standard requires a file-locking mechanism based on the <code>fcntl()</code>system call. It is possible to lock an arbitrary region of a file (even a single byte) or to lock the whole file (including data appended in the future). Because a process can choose to lock only a part of a file, it can also hold multiple locks on different parts of the file.</p><h3 id="7-1-Linux-File-Locking"><a href="#7-1-Linux-File-Locking" class="headerlink" title="7.1 Linux File Locking"></a>7.1 Linux File Locking</h3><h3 id="7-2-File-Locking-Data-Structures"><a href="#7-2-File-Locking-Data-Structures" class="headerlink" title="7.2 File-Locking Data Structures"></a>7.2 File-Locking Data Structures</h3><h3 id="7-3-FL-FLOCK-Locks"><a href="#7-3-FL-FLOCK-Locks" class="headerlink" title="7.3 FL_FLOCK Locks"></a>7.3 FL_FLOCK Locks</h3><h3 id="7-4-FL-POSIX-Locks"><a href="#7-4-FL-POSIX-Locks" class="headerlink" title="7.4 FL_POSIX Locks"></a>7.4 FL_POSIX Locks</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The idea behind the Virtual Filesystem is to put a wide range of information in the kernel to represent many different types of filesystems.&lt;br&gt;
    
    </summary>
    
      <category term="文件系统" scheme="http://liujunming.github.io/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="读书笔记" scheme="http://liujunming.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="文件系统" scheme="http://liujunming.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>文件系统概述</title>
    <link href="http://liujunming.github.io/2019/01/02/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://liujunming.github.io/2019/01/02/文件系统概述/</id>
    <published>2019-01-02T05:15:06.000Z</published>
    <updated>2019-01-02T08:02:50.058Z</updated>
    
    <content type="html"><![CDATA[<p>文件系统是纯软件。文件系统的具体定位可以参考<a href="https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram" target="_blank" rel="noopener">Linux Storage Stack Diagram</a>和<a href="http://ilinuxkernel.com/?p=1559" target="_blank" rel="noopener">Linux存储I/O栈</a><br><a id="more"></a><br><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf" target="_blank" rel="noopener">File System Implementation</a>很好地阐述了文件系统的实现。</p><p><img src="/images/2019/1/1.png" alt></p><ul><li>data region<br><img src="/images/2019/1/2.png" alt></li><li>inodes<br><img src="/images/2019/1/3.png" alt></li><li>inode bitmap and data bitmap<br><img src="/images/2019/1/4.png" alt></li><li>superblock</li></ul><p>The superblock contains information about this particular file system, including, for example, how many inodes and data blocks are in the file system, where the inode table begins and so forth.<br><img src="/images/2019/1/5.png" alt></p><h2 id="Fast-File-System-FFS"><a href="#Fast-File-System-FFS" class="headerlink" title="Fast File System (FFS)"></a>Fast File System (FFS)</h2><p>详情可参见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-ffs.pdf" target="_blank" rel="noopener">Fast File System</a>.</p><p>The idea was to design the file system structures and allocation policies to be “disk aware” and thus improve performance.</p><p>FFS divides the disk into a number of <strong>cylinder groups</strong>.<br><img src="/images/2019/1/6.png" alt></p><p>Modern file systems (such as Linux ext2, ext3, and ext4) instead organize the drive into <strong>block groups</strong>, each of which is just a consecutive portion of the disk’s address space.<br><img src="/images/2019/1/7.png" alt></p><p>By placing two files within the same group, FFS can ensure that accessing one after the other will not result in long seeks across the disk.</p><p>FFS has to decide what is “related” and place it within the same block group.</p><p>All modern systems account for the main lesson of FFS: treat the disk like it’s a disk.</p><h2 id="crash-consistency-problem"><a href="#crash-consistency-problem" class="headerlink" title="crash-consistency problem"></a>crash-consistency problem</h2><p>详情可参见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-journaling.pdf" target="_blank" rel="noopener">FSCK and Journaling</a>.</p><p>One major challenge faced by a file system is how to update persistent data structures despite the presence of a <strong>power loss</strong> or <strong>system crash</strong>.</p><p>This problem is quite simple to understand. Imagine you have to update two on-disk structures, A and B, in order to complete a particular operation. Because the disk only services a single request at a time, one of these requests will reach the disk first (either A or B). If the system crashes or loses power after one write completes, the on-disk structure will be left in an <strong>inconsistent</strong> state. And thus, we have a problem that all file systems need to solve.</p><p><strong>Journaling</strong> (also known as <strong>write-ahead logging</strong>) is a technique which adds a little bit of overhead to each write but recovers more quickly from crashes or power losses.</p><h2 id="Log-structured-File-Systems"><a href="#Log-structured-File-Systems" class="headerlink" title="Log-structured File Systems"></a>Log-structured File Systems</h2><p>本质上是将随机写转换为顺序写，详情可参见<a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-lfs.pdf" target="_blank" rel="noopener">Log-structured File Systems</a>。</p><p>LFS introduces a new approach to updating the disk. Instead of overwriting files in places, LFS always writes to an unused portion of the disk, and then later reclaims that old space through cleaning. LFS can gather all updates into an in-memory segment and then write them out together sequentially.</p><p>The downside to this approach is that it generates garbage; old copies of the data are scattered throughout the disk, and if one wants to reclaim such space for subsequent usage, one must clean old segments periodically.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件系统是纯软件。文件系统的具体定位可以参考&lt;a href=&quot;https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux Storage Stack Diagram&lt;/a&gt;和&lt;a href=&quot;http://ilinuxkernel.com/?p=1559&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux存储I/O栈&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="文件系统" scheme="http://liujunming.github.io/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="文件系统" scheme="http://liujunming.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
