<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2021-11-21T10:16:17.903Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux MSR tools</title>
    <link href="http://liujunming.github.io/2021/11/21/Linux-MSR-tools/"/>
    <id>http://liujunming.github.io/2021/11/21/Linux-MSR-tools/</id>
    <published>2021-11-21T08:17:28.000Z</published>
    <updated>2021-11-21T10:16:17.903Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about MSR tools in Linux，并结合一个具体的例子，展示其用法。<a id="more"></a>本文大部分内容源于<a href="https://ilinuxkernel.com/?p=255" target="_blank" rel="noopener">Linux读写CPU MSR寄存器命令rdmsr/wrmsr</a>。</p><p>Linux内核源码提供了读写CPU MSR寄存器模块，使得用户空间可以直接读写MSR寄存器。</p><p>开源社区提供msr寄存器读写工具:msr-tools，其中有两个命令，<code>rdmsr</code>/<code>wrmsr</code>。</p><h3 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h3><p>要使<code>rdmsr</code>/<code>wrmsr</code>命令可以读写msr寄存器，系统中必须有msr模块，或将msr模块编译进内核。下面是从内核配置选项中选取的内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Processor type and features  —&gt;</span><br><span class="line">&lt;M&gt; /dev/cpu/*/msr – Model-specific register support</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modprobe msr</span><br><span class="line"></span><br><span class="line">apt-get install -y msr-tools</span><br></pre></td></tr></table></figure><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@kvm:~# rdmsr -h</span><br><span class="line">Usage: rdmsr [options] regno</span><br><span class="line">  --help         -h  Print this help</span><br><span class="line">  --version      -V  Print current version</span><br><span class="line">  --hexadecimal  -x  Hexadecimal output (lower case)</span><br><span class="line">  --capital-hex  -X  Hexadecimal output (upper case)</span><br><span class="line">  --decimal      -d  Signed decimal output</span><br><span class="line">  --unsigned     -u  Unsigned decimal output</span><br><span class="line">  --octal        -o  Octal output</span><br><span class="line">  --c-language   -c  Format output as a C language constant</span><br><span class="line">  --zero-pad     -0  Output leading zeroes</span><br><span class="line">  --raw          -r  Raw binary output</span><br><span class="line">  --all          -a  all processors</span><br><span class="line">  --processor #  -p  Select processor number (default 0)</span><br><span class="line">  --bitfield h:l -f  Output bits [h:l] only</span><br><span class="line">root@kvm:~# wrmsr -h</span><br><span class="line">Usage: wrmsr [options] regno value...</span><br><span class="line">  --help         -h  Print this help</span><br><span class="line">  --version      -V  Print current version</span><br><span class="line">  --all          -a  all processors</span><br><span class="line">  --processor #  -p  Select processor number (default 0)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@kvm:~# rdmsr -p 0 0x1b</span><br><span class="line">fee00d00</span><br><span class="line">root@kvm:~# rdmsr -p 1 0x1b</span><br><span class="line">fee00c00</span><br></pre></td></tr></table></figure><p><img src="/images/2021/11/12.png" alt></p><p>由此可加:</p><ul><li>CPU 0 has set BSP flag, while CPU 1 has cleared BSP flag</li><li>x2APIC mode is enabled</li><li>APIC Global enabled</li><li>…</li></ul><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p><code>/dev/cpu/CPUNUM/msr</code> provides  an interface to read and write the model-specific registers (MSRs) of an x86 CPU. CPUNUM is the number of the CPU to access as listed in /proc/cpuinfo.</p><p>The register access is done by opening the file and seeking to the MSR number as offset in the file, and then reading or writing in chunks  of  8 bytes. </p><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><ul><li><code>man msr</code></li><li><a href="https://github.com/intel/msr-tools" target="_blank" rel="noopener">intel/msr-tools</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about MSR tools in Linux，并结合一个具体的例子，展示其用法。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>binding/unbinding pci&amp;pcie devices</title>
    <link href="http://liujunming.github.io/2021/11/21/binding-unbinding-pci-pcie-devices/"/>
    <id>http://liujunming.github.io/2021/11/21/binding-unbinding-pci-pcie-devices/</id>
    <published>2021-11-21T03:10:27.000Z</published>
    <updated>2021-11-21T04:55:03.569Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about binding/unbinding pci&amp;pcie devices。<a id="more"></a></p><p>当使用vfio pass-thru devices时，个人常用的方式为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpudevice=`cat /sys/bus/pci/devices/0000:00:02.0/device`</span><br><span class="line">echo 0000:00:02.0 &gt; /sys/bus/pci/devices/0000:00:02.0/driver/unbind</span><br><span class="line">echo "8086 $gpudevice" &gt; /sys/bus/pci/drivers/vfio-pci/new_id</span><br></pre></td></tr></table></figure><p>但是被问到了一个问题：为什么没用如下这一步呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0000:00:02.0 &gt; /sys/bus/pci/driver/vfio-pci/bind</span><br></pre></td></tr></table></figure><p>发现自己无法回答该问题，因此，就有了本文。</p><p>对于<code>new_id</code>和<code>bind</code>的权威解释如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">What:/sys/bus/pci/drivers/.../bind</span><br><span class="line">What:/sys/devices/pciX/.../bind</span><br><span class="line">Date:December 2003</span><br><span class="line">Contact:linux-pci@vger.kernel.org</span><br><span class="line">Description:</span><br><span class="line">Writing a device location to this file will cause</span><br><span class="line">the driver to attempt to bind to the device found at</span><br><span class="line">this location.This is useful for overriding default</span><br><span class="line">bindings.  The format for the location is: DDDD:BB:DD.F.</span><br><span class="line">That is Domain:Bus:Device.Function and is the same as</span><br><span class="line">found in /sys/bus/pci/devices/.  For example::</span><br><span class="line"></span><br><span class="line">  # echo 0000:00:19.0 &gt; /sys/bus/pci/drivers/foo/bind</span><br><span class="line"></span><br><span class="line">What:/sys/bus/pci/drivers/.../new_id</span><br><span class="line">What:/sys/devices/pciX/.../new_id</span><br><span class="line">Date:December 2003</span><br><span class="line">Contact:linux-pci@vger.kernel.org</span><br><span class="line">Description:</span><br><span class="line">Writing a device ID to this file will attempt to</span><br><span class="line">dynamically add a new device ID to a PCI device driver.</span><br><span class="line">This may allow the driver to support more hardware than</span><br><span class="line">was included in the driver&apos;s static device ID support</span><br><span class="line">table at compile time.  The format for the device ID is:</span><br><span class="line">VVVV DDDD SVVV SDDD CCCC MMMM PPPP.  That is Vendor ID,</span><br><span class="line">Device ID, Subsystem Vendor ID, Subsystem Device ID,</span><br><span class="line">Class, Class Mask, and Private Driver Data.  The Vendor ID</span><br><span class="line">and Device ID fields are required, the rest are optional.</span><br><span class="line">Upon successfully adding an ID, the driver will probe</span><br><span class="line">for the device and attempt to bind to it.  For example::</span><br><span class="line"></span><br><span class="line">  # echo &quot;8086 10f5&quot; &gt; /sys/bus/pci/drivers/foo/new_id</span><br></pre></td></tr></table></figure><p>信息量还是不够,那只能继续！</p><p>从<a href="https://lore.kernel.org/kvm/1372776365.30572.874.camel@ul30vt.home/" target="_blank" rel="noopener">binding/unbinding devices to vfio-pci</a>可知：</p><p>The driver core will probe any unbound devices as soon as a new_id is added to vfio-pci.</p><p>That can be changed by:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> echo 0 &gt; /sys/bus/pci/drivers_autoprobe</span><br></pre></td></tr></table></figure><hr><p>结论: 写入<code>new_id</code> node，如果<code>drivers_autoprobe</code>开启，就会自动bind,无需写入<code>bind</code> node。否则，还是需要写入<code>bind</code> node。</p><p>若想研究细节，那只能看Linux内核源码了。</p><p>new_id: <a href="https://elixir.bootlin.com/linux/v5.14/source/drivers/pci/pci-driver.c#L173" target="_blank" rel="noopener">new_id_store</a></p><p>drivers_autoprobe: <a href="https://elixir.bootlin.com/linux/v5.14/source/drivers/base/bus.c#L231" target="_blank" rel="noopener">drivers_autoprobe_store</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new_id_store</span><br><span class="line">pci_add_dynid</span><br><span class="line">driver_attach</span><br><span class="line">__driver_attach</span><br><span class="line">driver_probe_device</span><br><span class="line">__driver_probe_device</span><br><span class="line">really_probe</span><br><span class="line">driver_bound</span><br><span class="line">driver_deferred_probe_trigger</span><br><span class="line">deferred_probe_work</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_WORK</span><span class="params">(deferred_probe_work, deferred_probe_work_func)</span></span>;</span><br><span class="line">deferred_probe_work_func</span><br><span class="line">bus_probe_device</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bus_probe_device - probe drivers for a new device</span></span><br><span class="line"><span class="comment"> * @dev: device to probe</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Automatically probe for a driver if the bus allows it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bus_probe_device</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span> = <span class="title">dev</span>-&gt;<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bus-&gt;p-&gt;drivers_autoprobe)</span><br><span class="line">device_initial_probe(dev);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about binding/unbinding pci&amp;amp;pcie devices。
    
    </summary>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/categories/PCI-PCIe/"/>
    
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
  </entry>
  
  <entry>
    <title>How to translate virtual to physical addresses through /proc/pid/pagemap</title>
    <link href="http://liujunming.github.io/2021/11/20/How-to-translate-virtual-to-physical-addresses-through-proc-pid-pagemap/"/>
    <id>http://liujunming.github.io/2021/11/20/How-to-translate-virtual-to-physical-addresses-through-proc-pid-pagemap/</id>
    <published>2021-11-20T11:38:28.000Z</published>
    <updated>2021-11-20T16:22:45.340Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录/proc/pid/pagemap 相关notes，最权威的材料<a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt" target="_blank" rel="noopener">pagemap, from the userspace perspective</a>。<a id="more"></a></p><p>In newer kernels there is a really nice virtual file in the /proc file system to get this information. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGEMAP_ENTRY 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_BIT(X,Y) (X &amp; ((uint64_t)1<span class="meta-string">&lt;&lt;Y)) &gt;&gt; Y</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_PFN(X) X &amp; 0x7FFFFFFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> __endian_bit = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> is_bigendian() ( (*(char*)&amp;__endian_bit) == 0 )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, c, pid, status;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> virt_addr; </span><br><span class="line"><span class="keyword">uint64_t</span> read_val, file_offset;</span><br><span class="line"><span class="keyword">char</span> path_buf [<span class="number">0x100</span>] = &#123;&#125;;</span><br><span class="line">FILE * f;</span><br><span class="line"><span class="keyword">char</span> *end;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_pagemap</span><span class="params">(<span class="keyword">char</span> * path_buf, <span class="keyword">unsigned</span> <span class="keyword">long</span> virt_addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(argc!=<span class="number">3</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Argument number is not correct!\n pagemap PID VIRTUAL_ADDRESS\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(!<span class="built_in">memcmp</span>(argv[<span class="number">1</span>],<span class="string">"self"</span>,<span class="keyword">sizeof</span>(<span class="string">"self"</span>)))&#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(path_buf, <span class="string">"/proc/self/pagemap"</span>);</span><br><span class="line">      pid = <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">         pid = strtol(argv[<span class="number">1</span>],&amp;end, <span class="number">10</span>);</span><br><span class="line">         <span class="keyword">if</span> (end == argv[<span class="number">1</span>] || *end != <span class="string">'\0'</span> || pid&lt;=<span class="number">0</span>)&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"PID must be a positive number or 'self'\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   virt_addr = strtol(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">   <span class="keyword">if</span>(pid!=<span class="number">-1</span>)</span><br><span class="line">      <span class="built_in">sprintf</span>(path_buf, <span class="string">"/proc/%u/pagemap"</span>, pid);</span><br><span class="line">   </span><br><span class="line">   read_pagemap(path_buf, virt_addr);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_pagemap</span><span class="params">(<span class="keyword">char</span> * path_buf, <span class="keyword">unsigned</span> <span class="keyword">long</span> virt_addr)</span></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Big endian? %d\n"</span>, is_bigendian());</span><br><span class="line">   f = fopen(path_buf, <span class="string">"rb"</span>);</span><br><span class="line">   <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Error! Cannot open %s\n"</span>, path_buf);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//Shifting by virt-addr-offset number of bytes</span></span><br><span class="line">   <span class="comment">//and multiplying by the size of an address (the size of an entry in pagemap file)</span></span><br><span class="line">   file_offset = virt_addr / getpagesize() * PAGEMAP_ENTRY;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Vaddr: 0x%lx, Page_size: %d, Entry_size: %d\n"</span>, virt_addr, getpagesize(), PAGEMAP_ENTRY);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Reading %s at 0x%llx\n"</span>, path_buf, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) file_offset);</span><br><span class="line">   status = fseek(f, file_offset, SEEK_SET);</span><br><span class="line">   <span class="keyword">if</span>(status)&#123;</span><br><span class="line">      perror(<span class="string">"Failed to do fseek!"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   errno = <span class="number">0</span>;</span><br><span class="line">   read_val = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> c_buf[PAGEMAP_ENTRY];</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; PAGEMAP_ENTRY; i++)&#123;</span><br><span class="line">      c = getc(f);</span><br><span class="line">      <span class="keyword">if</span>(c==EOF)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\nReached end of the file\n"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(is_bigendian())</span><br><span class="line">           c_buf[i] = c;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">           c_buf[PAGEMAP_ENTRY - i - <span class="number">1</span>] = c;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"[%d]0x%x "</span>, i, c);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; PAGEMAP_ENTRY; i++)&#123;</span><br><span class="line">      read_val = (read_val &lt;&lt; <span class="number">8</span>) + c_buf[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Result: 0x%llx\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) read_val);</span><br><span class="line">   <span class="keyword">if</span>(GET_BIT(read_val, <span class="number">63</span>))</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"PFN: 0x%llx\n"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) GET_PFN(read_val));</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Page not present\n"</span>);</span><br><span class="line">   <span class="keyword">if</span>(GET_BIT(read_val, <span class="number">62</span>))</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Page swapped\n"</span>);</span><br><span class="line">   fclose(f);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And now how you use it. It’s very simple. Of course you need to compile it. Then you need to find out what mapping your target process does have. You can do that by reading /proc/pid/maps file. Fortunately that file is human readable.</p><p>When you know a valid virtual address, you can pass it to our tool to get actual value from pagemap, including physical frame number. Here is an example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo su</span><br><span class="line"><span class="meta">$</span> # disable aslr</span><br><span class="line"><span class="meta">$</span> echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> cat /proc/self/maps</span><br><span class="line">555555554000-55555555c000 r-xp 00000000 103:02 14286873                  /bin/cat</span><br><span class="line">55555575b000-55555575c000 r--p 00007000 103:02 14286873                  /bin/cat</span><br><span class="line">55555575c000-55555575d000 rw-p 00008000 103:02 14286873                  /bin/cat</span><br><span class="line">55555575d000-55555577e000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7ffff7013000-7ffff79e2000 r--p 00000000 103:02 10623634                  /usr/lib/locale/locale-archive</span><br><span class="line">7ffff79e2000-7ffff7bc9000 r-xp 00000000 103:02 4980818                   /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">7ffff7bc9000-7ffff7dc9000 ---p 001e7000 103:02 4980818                   /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">7ffff7dc9000-7ffff7dcd000 r--p 001e7000 103:02 4980818                   /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">7ffff7dcd000-7ffff7dcf000 rw-p 001eb000 103:02 4980818                   /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">7ffff7dcf000-7ffff7dd3000 rw-p 00000000 00:00 0</span><br><span class="line">7ffff7dd3000-7ffff7dfc000 r-xp 00000000 103:02 4980742                   /lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">7ffff7fc0000-7ffff7fe4000 rw-p 00000000 00:00 0</span><br><span class="line">7ffff7ff8000-7ffff7ffb000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffff7ffb000-7ffff7ffc000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">7ffff7ffc000-7ffff7ffd000 r--p 00029000 103:02 4980742                   /lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">7ffff7ffd000-7ffff7ffe000 rw-p 0002a000 103:02 4980742                   /lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0</span><br><span class="line">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line"><span class="meta">$</span> #so let's pick 0x555555554000. Now we run our program. </span><br><span class="line"><span class="meta">$</span> #First argument is pid, "self" is a legal option too, the second is virtual address</span><br><span class="line"><span class="meta">$</span> ./pagemap self 0x555555554000</span><br><span class="line">Big endian? 0</span><br><span class="line">Vaddr: 0x555555554000, Page_size: 4096, Entry_size: 8</span><br><span class="line">Reading /proc/self/pagemap at 0x2aaaaaaaa0</span><br><span class="line">[0]0x68 [1]0x65 [2]0x1e [3]0x0 [4]0x0 [5]0x0 [6]0x80 [7]0xa1</span><br><span class="line">Result: 0xa1800000001e6568</span><br><span class="line">PFN: 0x1e6568</span><br></pre></td></tr></table></figure><p>We got  <strong>0x1e6568</strong> as a result. There are some bits showing that the page is valid, along with the size of the page. You can read more in Linux documentation: <a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt" target="_blank" rel="noopener">pagemap, from the userspace perspective</a>. Basically, the physical page number is 0x1e6568.</p><p>The kernel implementation for /proc/pid/pagemap: <a href="https://elixir.bootlin.com/linux/v5.14/source/fs/proc/task_mmu.c#L1579" target="_blank" rel="noopener">pagemap_read</a></p><hr><p>参考资料:</p><ol><li><a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt" target="_blank" rel="noopener">pagemap, from the userspace perspective</a></li><li><a href="http://fivelinesofcode.blogspot.com/2014/03/how-to-translate-virtual-to-physical.html" target="_blank" rel="noopener">How to translate virtual to physical addresses through /proc/pid/pagemap</a></li><li><a href="https://askubuntu.com/questions/318315/how-can-i-temporarily-disable-aslr-address-space-layout-randomization" target="_blank" rel="noopener">How can I temporarily disable ASLR (Address space layout randomization)?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录/proc/pid/pagemap 相关notes，最权威的材料&lt;a href=&quot;https://www.kernel.org/doc/Documentation/vm/pagemap.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pagemap, from the userspace perspective&lt;/a&gt;。
    
    </summary>
    
      <category term="内存管理" scheme="http://liujunming.github.io/categories/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="内存管理" scheme="http://liujunming.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第24期</title>
    <link href="http://liujunming.github.io/2021/11/19/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC24%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/11/19/每周分享第24期/</id>
    <published>2021-11-19T04:58:21.000Z</published>
    <updated>2021-11-19T09:27:45.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="scatter-gather"><a href="#scatter-gather" class="headerlink" title="scatter/gather"></a>scatter/gather</h3><p>In computing, scatter/gather I/O, is a method of input and output by which a single procedure call sequentially reads data from multiple buffers and writes it to a single data stream, or reads data from a data stream and writes it to multiple buffers, as defined in a vector of buffers. Scatter/gather refers to the process of gathering data from, or scattering data into, the given set of buffers.  <a id="more"></a></p><p><a href="https://en.wikipedia.org/wiki/Vectored_I/O" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Vectored_I/O</a></p><h3 id="PXE"><a href="#PXE" class="headerlink" title="PXE"></a>PXE</h3><p>Preboot execution environment (PXE) is a set of standards that enables a computer to load an operating system (OS) over a network connection.</p><p>PXE提供了一种使用网络接口启动计算机的机制。这种机制让计算机的启动可以不依赖本地数据存储设备（如硬盘）或本地已安装的操作系统。</p><h3 id="Video-Live-captions-amp-subtitles"><a href="#Video-Live-captions-amp-subtitles" class="headerlink" title="Video: Live captions &amp; subtitles"></a>Video: Live captions &amp; subtitles</h3><p>PowerPoint for Microsoft 365 and PowerPoint for the web now offer captions or subtitles shown live on the big screen as you present to your audience.</p><p><a href="https://support.microsoft.com/en-us/office/video-live-captions-subtitles-371bd124-855f-46a9-a923-5371c10f36c5" target="_blank" rel="noopener">https://support.microsoft.com/en-us/office/video-live-captions-subtitles-371bd124-855f-46a9-a923-5371c10f36c5</a></p><h3 id="Arjian不是Arjan：樱桃司这八年"><a href="#Arjian不是Arjan：樱桃司这八年" class="headerlink" title="Arjian不是Arjan：樱桃司这八年"></a>Arjian不是Arjan：樱桃司这八年</h3><p><a href="https://blog.csdn.net/bjchenxu/article/details/107036093" target="_blank" rel="noopener">https://blog.csdn.net/bjchenxu/article/details/107036093</a></p><h3 id="知识，经验，能力，潜力"><a href="#知识，经验，能力，潜力" class="headerlink" title="知识，经验，能力，潜力"></a>知识，经验，能力，潜力</h3><p>知识：看一本书<br>经验：做事情用到书里的知识<br>能力：总结经验，并可以复制<br>潜力：基于能力，面对未知可以从容解决 </p><h3 id="世界观和方法论"><a href="#世界观和方法论" class="headerlink" title="世界观和方法论"></a>世界观和方法论</h3><ol><li>世界观是人们对世界（宇宙）总的根本的观点。</li><li>方法论是指导人们认识世界、改造世界的最一般、最根本的思维方式和思维理念。</li><li>世界观与方法论是一致的。有什么样的世界观就有什么样的方法论。</li><li>世界观指导方法论，方法论贯彻世界观。世界观更根本。</li></ol><p><a href="https://www.zhihu.com/question/64917144/answer/225552583" target="_blank" rel="noopener">https://www.zhihu.com/question/64917144/answer/225552583</a></p><h3 id="C-if-statement-with-amp-amp-Which-function-will-execute-first"><a href="#C-if-statement-with-amp-amp-Which-function-will-execute-first" class="headerlink" title="C if statement with &amp;&amp; - Which function will execute first?"></a>C if statement with &amp;&amp; - Which function will execute first?</h3><p><a href="https://stackoverflow.com/questions/8300519/c-if-statement-with-which-function-will-execute-first" target="_blank" rel="noopener">https://stackoverflow.com/questions/8300519/c-if-statement-with-which-function-will-execute-first</a></p><h3 id="gerrit"><a href="#gerrit" class="headerlink" title="gerrit"></a>gerrit</h3><p>Gerrit is a highly extensible and configurable tool for web-based code review and repository management for projects using the Git version control system.</p><p><a href="https://www.youtube.com/watch?v=Wxx8XndqZ7A" target="_blank" rel="noopener">Using Gerrit to enhance your Git</a></p><h3 id="EfiRom-Utility"><a href="#EfiRom-Utility" class="headerlink" title="EfiRom Utility"></a>EfiRom Utility</h3><p>Use the <code>EfiRom</code> utility to build PCI Option ROM Images containing UEFI Drivers, PC BIOS legacy option ROM images, or both, in a format conforming to the <em>PCI 2.3 Specification and PCI 3.0 Specification</em>. </p><p>输入: UEFI Drivers + VendorId + DeviceId<br>输出：PCI Option ROM Images</p><p><a href="https://edk2-docs.gitbook.io/edk-ii-basetools-user-guides/efirom" target="_blank" rel="noopener">EfiRom.exe</a><br><a href="https://edk2-docs.gitbook.io/edk-ii-uefi-driver-writer-s-guide/18_pci_driver_design_guidelines/readme.7/1871_efirom_utility" target="_blank" rel="noopener">EfiRom Utility</a></p><h3 id="英特尔的安腾-Itanium-架构处理器是怎么失败的？"><a href="#英特尔的安腾-Itanium-架构处理器是怎么失败的？" class="headerlink" title="英特尔的安腾 (Itanium) 架构处理器是怎么失败的？"></a>英特尔的安腾 (Itanium) 架构处理器是怎么失败的？</h3><p><a href="https://www.zhihu.com/question/22666196" target="_blank" rel="noopener">https://www.zhihu.com/question/22666196</a></p><h3 id="如何评价蚂蚁金服新推出的知识平台-语雀？"><a href="#如何评价蚂蚁金服新推出的知识平台-语雀？" class="headerlink" title="如何评价蚂蚁金服新推出的知识平台 - 语雀？"></a>如何评价蚂蚁金服新推出的知识平台 - 语雀？</h3><p><a href="https://www.yuque.com/" target="_blank" rel="noopener">https://www.yuque.com/</a></p><p>语雀是一个企业级协作服务，提供文档、表格、项目管理等协作工具，帮助企业沉淀、整理内部信息和知识。</p><p>语雀的愿景是让个人和企业都拥有自己的线上知识中心。<br><a href="https://www.zhihu.com/question/264707678" target="_blank" rel="noopener">https://www.zhihu.com/question/264707678</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;scatter-gather&quot;&gt;&lt;a href=&quot;#scatter-gather&quot; class=&quot;headerlink&quot; title=&quot;scatter/gather&quot;&gt;&lt;/a&gt;scatter/gather&lt;/h3&gt;&lt;p&gt;In computing, scatter/gather I/O, is a method of input and output by which a single procedure call sequentially reads data from multiple buffers and writes it to a single data stream, or reads data from a data stream and writes it to multiple buffers, as defined in a vector of buffers. Scatter/gather refers to the process of gathering data from, or scattering data into, the given set of buffers.
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Live Migration With Hardware Acceleration</title>
    <link href="http://liujunming.github.io/2021/11/18/Live-Migration-With-Hardware-Acceleration/"/>
    <id>http://liujunming.github.io/2021/11/18/Live-Migration-With-Hardware-Acceleration/</id>
    <published>2021-11-18T12:15:30.000Z</published>
    <updated>2021-11-19T09:27:45.090Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about Live Migration With Hardware Acceleration.<br><a href="https://static.sched.com/hosted_files/kvmforum2020/6e/Oct%2030_Live%20Migration%20with%20Hardware%20Acceleration_Wei%20Wang%20.pdf" target="_blank" rel="noopener">slides</a><br><a href="https://www.youtube.com/watch?v=c_DyiOmJdtI" target="_blank" rel="noopener">video</a><br><a id="more"></a></p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><ul><li>Live migration pain points<ul><li>VMs with memory write intensive workloads are difficult to migrate</li><li>VMs with large memory size takes long time to migrate</li><li>May consume large network bandwidth</li></ul></li><li>Existing solution: compression with CPUs<ul><li>Slow</li><li>Consumes too many CPUs from host</li></ul></li><li>Our solution<ul><li>Offload the compression part to Intel QAT with efficient approaches<ul><li>Higher migration throughput</li><li>Lower CPU utilization</li></ul></li><li>A common design ready for future more accelerators to join in<ul><li>Data Streaming Accelerator (DSA) and Intel Analytics Accelerator (IAX) coming on Sapphire Rapids CPUs</li><li>Smart Selection</li></ul></li></ul></li></ul><h3 id="QAT"><a href="#QAT" class="headerlink" title="QAT"></a>QAT</h3><p>QuickAssist Technology (QAT) accelerates cryptographic and compression workloads by offloading the data to hardware capable of optimizing those functions.</p><h3 id="IAX"><a href="#IAX" class="headerlink" title="IAX"></a>IAX</h3><p>(Intel Analytics Accelerator)</p><p>Has compression capability</p><h3 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h3><p>(Data Streaming Accelerator)</p><p>DSA is a high-performance data copy and transformation accelerator that will be integrated in future Intel® processors, targeted for optimizing streaming data movement and transformation operations common with applications for high-performance storage, networking, persistent memory, and various data processing applications.</p><p>Intel® DSA replaces the Intel® QuickData Technology, which is a part of Intel® I/O Acceleration Technology.</p><p>The goal is to provide higher overall system performance for data mover and transformation operations, while freeing up CPU cycles for higher level functions. </p><h3 id="Smart-Acceleration-Support"><a href="#Smart-Acceleration-Support" class="headerlink" title="Smart Acceleration Support"></a>Smart Acceleration Support</h3><ul><li>DSA compares the dirty memory, and sends the “diff” to the destination only<ul><li>Good when the guest only modifies a small part of a page</li><li>Bad when the entire pages are changed</li></ul></li><li>Smart Acceleration<ul><li>Dynamically switch to use QAT/IAX compression or DSA diff during live migration using a prediction based on the compression ratio history and diff ratio history</li></ul></li></ul><hr><p>参考资料:</p><ol><li><a href="https://kb.vmware.com/s/article/84039" target="_blank" rel="noopener">Information for the Intel® QuickAssist Technology (Intel® QAT) Single Root I/O Virtualization (SR-IOV) driver for VMware ESXi (84039)</a></li><li><a href="https://01.org/blogs/2019/introducing-intel-data-streaming-accelerator" target="_blank" rel="noopener">INTRODUCING THE INTEL® DATA STREAMING ACCELERATOR (INTEL® DSA)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about Live Migration With Hardware Acceleration.&lt;br&gt;&lt;a href=&quot;https://static.sched.com/hosted_files/kvmforum2020/6e/Oct%2030_Live%20Migration%20with%20Hardware%20Acceleration_Wei%20Wang%20.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;slides&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=c_DyiOmJdtI&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;video&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>VT-x Posted Interrupt Code Analysis</title>
    <link href="http://liujunming.github.io/2021/11/14/VT-x-Posted-Interrupt-Code-Analysis/"/>
    <id>http://liujunming.github.io/2021/11/14/VT-x-Posted-Interrupt-Code-Analysis/</id>
    <published>2021-11-14T02:38:26.000Z</published>
    <updated>2021-11-14T10:39:17.727Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2020/10/07/Introduction-to-Posted-interrupt/">Introduction to VT-x Posted-interrupt</a>介绍了原理，本文将结合KVM代码，介绍VT-x Posted Interrupt的实现细节。<a id="more"></a></p><p>source code:<br><a href="https://elixir.bootlin.com/linux/v5.14/source" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.14/source</a></p><h3 id="vmx-deliver-posted-interrupt"><a href="#vmx-deliver-posted-interrupt" class="headerlink" title="vmx_deliver_posted_interrupt"></a>vmx_deliver_posted_interrupt</h3><p>假设guest运行在x2APIC mode下，当source vCPU写ICR寄存器时，会发生VM Exit。</p><p>KVM的函数调用链如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kvm_emulate_wrmsr</span><br><span class="line">kvm_set_msr</span><br><span class="line">kvm_set_msr_ignored_check</span><br><span class="line">__kvm_set_msr</span><br><span class="line">static_call(kvm_x86_set_msr)[vmx_set_msr]</span><br><span class="line">kvm_set_msr_common</span><br><span class="line">kvm_x2apic_msr_write</span><br><span class="line">kvm_lapic_reg_write</span><br><span class="line">kvm_apic_send_ipi</span><br><span class="line">kvm_irq_delivery_to_apic</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kvm_irq_delivery_to_apic</span><br><span class="line">kvm_irq_delivery_to_apic_fast</span><br><span class="line">kvm_apic_set_irq</span><br><span class="line">__apic_accept_irq</span><br><span class="line">kvm_x86_deliver_posted_interrupt[vmx_deliver_posted_interrupt]</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Send interrupt to vcpu via posted interrupt way.</span></span><br><span class="line"><span class="comment"> * 1. If target vcpu is running(non-root mode), send posted interrupt</span></span><br><span class="line"><span class="comment"> * notification to vcpu and hardware will sync PIR to vIRR atomically.</span></span><br><span class="line"><span class="comment"> * 2. If target vcpu isn't running(root mode), kick it to pick up the</span></span><br><span class="line"><span class="comment"> * interrupt from PIR in next vmentry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vmx_deliver_posted_interrupt</span><span class="params">(struct kvm_vcpu *vcpu, <span class="keyword">int</span> <span class="built_in">vector</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vcpu_vmx</span> *<span class="title">vmx</span> = <span class="title">to_vmx</span>(<span class="title">vcpu</span>);</span></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!vcpu-&gt;arch.apicv_active)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pi_test_and_set_pir(<span class="built_in">vector</span>, &amp;vmx-&gt;pi_desc))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If a previous notification has sent the IPI, nothing to do.  */</span></span><br><span class="line"><span class="keyword">if</span> (pi_test_and_set_on(&amp;vmx-&gt;pi_desc))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vcpu != kvm_get_running_vcpu() &amp;&amp;</span><br><span class="line">    !kvm_vcpu_trigger_posted_interrupt(vcpu, <span class="literal">false</span>))</span><br><span class="line"><span class="comment">// Kick a sleeping VCPU, or a guest VCPU in guest mode, into host kernel mode.</span></span><br><span class="line">kvm_vcpu_kick(vcpu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">kvm_vcpu_trigger_posted_interrupt</span><span class="params">(struct kvm_vcpu *vcpu,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">bool</span> nested)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="keyword">int</span> pi_vec = POSTED_INTR_VECTOR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vcpu-&gt;mode == IN_GUEST_MODE) &#123;</span><br><span class="line"><span class="comment">// 给vCPU所在的physical CPU发送一个Notification Event</span></span><br><span class="line">apic-&gt;send_IPI_mask(get_cpu_mask(vcpu-&gt;cpu), pi_vec);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If target vcpu isn’t running(root mode), kick it(<code>kvm_vcpu_kick(vcpu)</code>) to pick up the interrupt from PIR in next vmentry.</p><h3 id="vmx-sync-pir-to-irr"><a href="#vmx-sync-pir-to-irr" class="headerlink" title="vmx_sync_pir_to_irr"></a>vmx_sync_pir_to_irr</h3><p>pick up the interrupt from PIR in the next vmentry这一步的代码解析如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vcpu_enter_guest</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This handles the case where a posted interrupt was</span></span><br><span class="line"><span class="comment"> * notified with kvm_vcpu_kick.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (kvm_lapic_enabled(vcpu) &amp;&amp; vcpu-&gt;arch.apicv_active)</span><br><span class="line"><span class="comment">// vmx_sync_pir_to_irr(vcpu) is called</span></span><br><span class="line">static_call(kvm_x86_sync_pir_to_irr)(vcpu);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vmx_sync_pir_to_irr</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vcpu_vmx</span> *<span class="title">vmx</span> = <span class="title">to_vmx</span>(<span class="title">vcpu</span>);</span></span><br><span class="line"><span class="keyword">int</span> max_irr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pi_test_on(&amp;vmx-&gt;pi_desc)) &#123;</span><br><span class="line">pi_clear_on(&amp;vmx-&gt;pi_desc);</span><br><span class="line">kvm_apic_update_irr(vcpu, vmx-&gt;pi_desc.pir, &amp;max_irr);</span><br><span class="line">kvm_make_request(KVM_REQ_EVENT, vcpu);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">max_irr = kvm_lapic_find_highest_irr(vcpu);</span><br><span class="line">&#125;</span><br><span class="line">vmx_set_rvi(max_irr);</span><br><span class="line"><span class="keyword">return</span> max_irr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kvm_apic_update_irr</span><br><span class="line">__kvm_apic_update_irr</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> __kvm_apic_update_irr(u32 *pir, <span class="keyword">void</span> *regs, <span class="keyword">int</span> *max_irr)</span><br><span class="line">&#123;</span><br><span class="line">u32 i, vec;</span><br><span class="line">u32 pir_val, irr_val, prev_irr_val;</span><br><span class="line"><span class="keyword">int</span> max_updated_irr;</span><br><span class="line"></span><br><span class="line">max_updated_irr = <span class="number">-1</span>;</span><br><span class="line">*max_irr = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = vec = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i++, vec += <span class="number">32</span>) &#123;</span><br><span class="line">pir_val = READ_ONCE(pir[i]);</span><br><span class="line">irr_val = *((u32 *)(regs + APIC_IRR + i * <span class="number">0x10</span>));</span><br><span class="line"><span class="keyword">if</span> (pir_val) &#123;</span><br><span class="line">prev_irr_val = irr_val;</span><br><span class="line">irr_val |= xchg(&amp;pir[i], <span class="number">0</span>);</span><br><span class="line">*((u32 *)(regs + APIC_IRR + i * <span class="number">0x10</span>)) = irr_val;</span><br><span class="line"><span class="keyword">if</span> (prev_irr_val != irr_val) &#123;</span><br><span class="line">max_updated_irr =</span><br><span class="line">__fls(irr_val ^ prev_irr_val) + vec;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (irr_val)</span><br><span class="line">*max_irr = __fls(irr_val) + vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ((max_updated_irr != <span class="number">-1</span>) &amp;&amp;</span><br><span class="line">(max_updated_irr == *max_irr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一言以蔽之: <code>vmx_sync_pir_to_irr</code>所做的工作就是下图绿框中标注的步骤。区别在于：如果target vcpu is running(root mode)，上述步骤由硬件来完成；否则，需要调用<code>vmx_sync_pir_to_irr</code>由软件来完成。</p><p><img src="/images/2021/11/11.png" alt></p><hr><p>推荐材料:</p><ul><li><p><a href="https://elixir.bootlin.com/linux/v5.14/source/arch/x86/kvm/vmx/posted_intr.h" target="_blank" rel="noopener">posted_intr.h</a>定义了posted interrupt会用到的一些基本数据结构和常用函数，可结合着spec阅读</p></li><li><p><a href="https://lore.kernel.org/kvm/1365679516-13125-1-git-send-email-yang.z.zhang@intel.com/" target="_blank" rel="noopener">[PATCH v10 0/7] KVM: VMX: Add Posted Interrupt supporting</a>包含更多的实现细节，值得深挖</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2020/10/07/Introduction-to-Posted-interrupt/&quot;&gt;Introduction to VT-x Posted-interrupt&lt;/a&gt;介绍了原理，本文将结合KVM代码，介绍VT-x Posted Interrupt的实现细节。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Notes about XSAVE feature set</title>
    <link href="http://liujunming.github.io/2021/11/12/Notes-about-XSAVE-feature-set/"/>
    <id>http://liujunming.github.io/2021/11/12/Notes-about-XSAVE-feature-set/</id>
    <published>2021-11-12T01:52:28.000Z</published>
    <updated>2021-11-12T10:29:59.805Z</updated>
    
    <content type="html"><![CDATA[<p>mark下个人对XSAVE feature set的一点理解。本文大部分内容源于组内同学的知识分享，并非作者个人原创。<a id="more"></a><br>读者若想深入研究XSAVE feature set，Intel SDM Vol1 “MANAGING STATE USING THE XSAVE FEATURE SET”这章的内容就是极佳的材料。</p><h2 id="1-Why"><a href="#1-Why" class="headerlink" title="1. Why?"></a>1. Why?</h2><p>一言以蔽之：Support the saving and restoring of processor state by hardware instead of software.</p><p>线程可能会用到X87,SSE,AVX512等feature，这些feature会包含很多的寄存器。如果每次线程切换时，系统软件都需要手动save and restore这些寄存器，那样开销会很大。为此，XSAVE feature set应运而生，系统软件只需要调用XSAVE feature set提供的指令，即可让硬件来完成X87,SSE,AVX512等寄存器的save与restore功能！</p><h2 id="2-Overview"><a href="#2-Overview" class="headerlink" title="2. Overview"></a>2. Overview</h2><p>The XSAVE feature set supports the saving and restoring of <strong>state components</strong>, each of which is a discrete set of processor registers (or parts of registers). Each such state component corresponds to an XSAVE-supported feature. The XSAVE feature set organizes the state components of the XSAVE-supported features using state component bitmaps. A state-component bitmap comprises 64 bits; each bit in such a bitmap corresponds to a single state component. Some state components are supervisor state components. The XSAVE feature supports supervisor state components with only the XSAVES and XRSTORS instructions.</p><ul><li>For User state components, Specified by XCR0</li><li>For Supervisor state components, Specified by IA32_XSS MSR</li></ul><p><strong>XSAVE-enabled</strong> features (those features that require use of the XSAVE feature set for their enabling) .</p><p><img src="/images/2021/11/10.png" alt></p><p><img src="/images/2021/11/5.png" alt></p><h2 id="3-XSAVE-Area"><a href="#3-XSAVE-Area" class="headerlink" title="3. XSAVE Area"></a>3. XSAVE Area</h2><p>The XSAVE feature set allows saving and loading processor state from a region of memory called  XSAVE area.</p><p><img src="/images/2021/11/6.png" alt></p><h3 id="3-1-Legacy-Region"><a href="#3-1-Legacy-Region" class="headerlink" title="3.1 Legacy Region"></a>3.1 Legacy Region</h3><p><img src="/images/2021/11/7.png" alt></p><h3 id="3-2-XSAVE-Header"><a href="#3-2-XSAVE-Header" class="headerlink" title="3.2 XSAVE Header"></a>3.2 XSAVE Header</h3><p><img src="/images/2021/11/8.png" alt></p><p><strong>XCOMP_BV[63]</strong> indicates the format of the extended region of the XSAVE area (see Section 13.4.3). </p><ul><li>If it is clear, the standard format is used. </li><li>If it is set, the compacted format is used; XCOMP_BV[62:0] provide format specifics as specified in Section 13.4.3.</li></ul><p>为什么需要区分standard format与compacted format呢？其实就是为了节省内存。例如，某线程没用使用AVX512 feature，那么，compacted format就不会在Extended Region里存储AVX512相关的寄存器状态。</p><h3 id="3-3-Extended-Region"><a href="#3-3-Extended-Region" class="headerlink" title="3.3 Extended Region"></a>3.3 Extended Region</h3><p>The XSAVE feature set uses the <u>extended area</u> for <u>each state component i, where i ≥ 2</u>.</p><p>All state components other than X87 and SSE are using the extended region.</p><p>Format of extended region:</p><ul><li>Standard format</li><li>Compacted format</li></ul><h4 id="3-3-1-Standard-Format"><a href="#3-3-1-Standard-Format" class="headerlink" title="3.3.1 Standard Format"></a>3.3.1 Standard Format</h4><p>Supported by all processors that support the XSAVE feature set.</p><p>Location of each state component i (i ≥ 2) is determined by CPUID.</p><ul><li>Offset: CPUID.(EAX=0DH,ECX=i):EBX</li><li>Size: CPUID.(EAX=0DH,ECX=i):EAX</li></ul><h4 id="3-3-2-Compacted-Format"><a href="#3-3-2-Compacted-Format" class="headerlink" title="3.3.2 Compacted Format"></a>3.3.2 Compacted Format</h4><p>Supported by those processors that support the compaction extensions CPUID.(EAX=0DH,ECX=1):EAX[1]</p><p>Location of each state component i (i ≥ 2) is determined by <u>CPUID</u> and <u>XCOMP_BV</u> field in the XSAVE header.</p><ul><li>Offset: refer to section 13.4.3, Vol.1, SDM</li><li>Size: CPUID.(EAX=0DH,ECX=i):EAX</li></ul><h2 id="4-Optimization"><a href="#4-Optimization" class="headerlink" title="4. Optimization"></a>4. Optimization</h2><p>The <strong>XSAVEOPT, XSAVEC, and XSAVES</strong> instructions use two optimizations to <u>reduce the amount of data that they write to memory</u>.</p><h3 id="4-1-The-init-optimization"><a href="#4-1-The-init-optimization" class="headerlink" title="4.1 The init optimization"></a>4.1 The init optimization</h3><p>Avoid writing data for any state component known to be in its <u>initial configuration</u>.</p><h3 id="4-2-The-modified-optimization"><a href="#4-2-The-modified-optimization" class="headerlink" title="4.2 The modified optimization"></a>4.2 The modified optimization</h3><p>If either XSAVEOPT or XSAVES is using the <u>same XSAVE area</u> as that used by the <u>most recent execution of XRSTOR or XRSTORS</u>, it may avoid writing data for any state component whose configuration is known <u>not to have been modified since then</u>.</p><h2 id="5-Instructions-Summary"><a href="#5-Instructions-Summary" class="headerlink" title="5. Instructions Summary"></a>5. Instructions Summary</h2><p><img src="/images/2021/11/9.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mark下个人对XSAVE feature set的一点理解。本文大部分内容源于组内同学的知识分享，并非作者个人原创。
    
    </summary>
    
      <category term="体系结构" scheme="http://liujunming.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Notes about ivshmem</title>
    <link href="http://liujunming.github.io/2021/11/11/Notes-about-ivshmem/"/>
    <id>http://liujunming.github.io/2021/11/11/Notes-about-ivshmem/</id>
    <published>2021-11-11T13:32:45.000Z</published>
    <updated>2021-11-12T10:29:59.805Z</updated>
    
    <content type="html"><![CDATA[<p>mark下ivshmem相关笔记。<a id="more"></a></p><p>ivshmem是QEMU提供的一种宿主机与虚拟机之间或多个虚拟机之间共享内存的特殊设备。它有两种形式:</p><ul><li><strong>ivshmem-plain</strong>: 简单的共享内存区域</li><li><strong>ivshmem-doorbel</strong>: 除了共享内存，还能提供基于中断的通信机制</li></ul><p>这种设备在虚拟机内部表现为PCI设备，共享的内存区域则以PCI BAR的形式存在。ivshmem PCI设备提供3个BAR:</p><ul><li>BAR0: 设备寄存器</li><li>BAR1: MSI-X表</li><li>BAR2: 共享内存区域</li></ul><p>简单的共享内存场景只使用BAR2。如果需要基于中断实现额外通信，需要用到BAR0和BAR1。</p><p>只考虑共享内存这个场景，是如何做到内存共享的呢？在不同的虚拟机(这些虚拟机会共享内存)内，ivshmem device的BAR2地址(GPA)可能不同，但是对应的HPA是一样的，hypervisor会为不同虚拟机的ivshmem device的BAR2内存区域建立EPT映射，因此就达到共享内存的目的！<br>即:</p><ul><li>GPA1-&gt;HPA1</li><li>GPA2-&gt;HPA1</li></ul><p>Evidence on ACRN hypervisor:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hypervisor code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ivshmem_vbar_map</span><span class="params">(struct pci_vdev *vdev, <span class="keyword">uint32_t</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acrn_vm</span> *<span class="title">vm</span> = <span class="title">vpci2vm</span>(<span class="title">vdev</span>-&gt;<span class="title">vpci</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_vbar</span> *<span class="title">vbar</span> = &amp;<span class="title">vdev</span>-&gt;<span class="title">vbars</span>[<span class="title">idx</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivshmem_device</span> *<span class="title">ivs_dev</span> = (<span class="title">struct</span> <span class="title">ivshmem_device</span> *) <span class="title">vdev</span>-&gt;<span class="title">priv_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((idx == IVSHMEM_SHM_BAR) &amp;&amp; (vbar-&gt;base_hpa != INVALID_HPA) &amp;&amp; (vbar-&gt;base_gpa != <span class="number">0U</span>L)) &#123;</span><br><span class="line"><span class="comment">//ept_add_mr is called to build EPT mapping for ivshmem BAR2!</span></span><br><span class="line">ept_add_mr(vm, (<span class="keyword">uint64_t</span> *)vm-&gt;arch_vm.nworld_eptp, vbar-&gt;base_hpa,</span><br><span class="line">vbar-&gt;base_gpa, vbar-&gt;size, EPT_RD | EPT_WR | EPT_WB | EPT_IGNORE_PAT);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//device model code</span></span><br><span class="line">create_ivshmem_from_dm(struct vmctx *ctx, struct pci_vdev *vdev,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">addr = (<span class="keyword">void</span> *)mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE,</span><br><span class="line">MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">bar_addr = pci_get_cfgdata32(vdev, PCIR_BAR(IVSHMEM_MEM_BAR));</span><br><span class="line">bar_addr |= ((<span class="keyword">uint64_t</span>)pci_get_cfgdata32(vdev, PCIR_BAR(IVSHMEM_MEM_BAR + <span class="number">1</span>)) &lt;&lt; <span class="number">32</span>);</span><br><span class="line">bar_addr &amp;= PCIM_BAR_MEM_BASE;</span><br><span class="line">pr_dbg(<span class="string">"shm configuration, vma 0x%lx, ivshmem bar 0x%lx, size 0x%x\n"</span>,</span><br><span class="line">(<span class="keyword">uint64_t</span>)addr, bar_addr, size);</span><br><span class="line"><span class="comment">//vm_map_memseg_vma is called to build EPT mapping for ivshmem BAR2!</span></span><br><span class="line"><span class="keyword">if</span> (!addr || vm_map_memseg_vma(ctx, size, bar_addr,</span><br><span class="line">(<span class="keyword">uint64_t</span>)addr, PROT_RW) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">pr_warn(<span class="string">"failed to map shared memory\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ul><li><a href="https://git.qemu.org/?p=qemu.git;a=blob_plain;f=docs/specs/ivshmem-spec.txt;hb=HEAD" target="_blank" rel="noopener">Device Specification for Inter-VM shared memory device</a></li><li><a href="https://projectacrn.github.io/latest/developer-guides/hld/ivshmem-hld.html" target="_blank" rel="noopener">ACRN Shared Memory Based Inter-VM Communication</a></li><li><a href="https://www.researchgate.net/publication/345933128_Real_Time_Communication_Between_Two_Hypervised_Operating_Systems" target="_blank" rel="noopener">Real Time Communication Between Two Hypervised Operating Systems</a></li><li><a href="http://just4coding.com/2021/09/12/qemu-ivshmem/" target="_blank" rel="noopener">QEMU虚拟机内识别ivshmem设备</a></li><li><a href="https://drive.google.com/drive/folders/1ffFpbw_FlWrEqSmD8x8tQ_NHAgYd3M37" target="_blank" rel="noopener">Inter-VM Communication Introduction (DM land)</a></li><li><a href="https://drive.google.com/drive/folders/1rgfTZqETjCq2wCuiCwAGadgKIPom9lAr" target="_blank" rel="noopener">Inter-VM Communication Introduction (Hv-Land)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mark下ivshmem相关笔记。
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
  </entry>
  
  <entry>
    <title>Notes about PASID (Process Address Space ID)</title>
    <link href="http://liujunming.github.io/2021/11/09/Notes%20about-PASID-Process-Address-Space-ID/"/>
    <id>http://liujunming.github.io/2021/11/09/Notes about-PASID-Process-Address-Space-ID/</id>
    <published>2021-11-09T14:22:25.000Z</published>
    <updated>2021-11-11T13:10:18.964Z</updated>
    
    <content type="html"><![CDATA[<p>PASID (Process Address Space ID) is an optional feature that enables sharing of a single Endpoint device across multiple processes(multiple address spaces per device) while providing each process a complete 64-bit virtual address space.  <a id="more"></a> PASID is used to identify process address space.</p><p>A PASID is a PCIe-defined Transaction Layer Packet (TLP) prefix. A PASID is a 20-bit number allocated and managed by the OS. PASID is included in all transactions between the platform and the device.</p><p>The IOMMU driver allocates a PASID and the device uses it in DMA transactions.</p><p>总结:（考虑非虚拟化的情况）在Intel平台下，由设备发起的I/O虚拟地址(IOVA，可以认为是host virtual address)需要IOMMU转化为host physical address。</p><p>IOMMU PASID Table: Per-device table by hardware design!</p><p><img src="/images/2021/11/4.png" alt></p><p>上图中，红框标注的即为IOMMU PASID table。</p><p><img src="/images/2021/11/1.png" alt></p><p><img src="/images/2021/11/2.png" alt></p><p><img src="/images/2021/11/3.png" alt></p><hr><p>参考资料:</p><ol><li><a href="https://www.plda.com/pcie-glossary/pasid" target="_blank" rel="noopener">pcie-glossary/pasid</a></li><li><a href="https://www.kernel.org/doc/html/latest/x86/sva.html" target="_blank" rel="noopener">Shared Virtual Addressing (SVA) with ENQCMD</a></li><li><a href="https://www.youtube.com/watch?v=xTwA3kC7ShA" target="_blank" rel="noopener">PASID Management in KVM - Yi Liu &amp; Jacob Pan</a></li><li><a href="https://events19.linuxfoundation.cn/wp-content/uploads/2017/11/Intel%C2%AE-Scalable-I_O-Virtualization_Kevin-Tian.pdf" target="_blank" rel="noopener">Intel®-Scalable-I_O-Virtualization</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PASID (Process Address Space ID) is an optional feature that enables sharing of a single Endpoint device across multiple processes(multiple address spaces per device) while providing each process a complete 64-bit virtual address space.
    
    </summary>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/categories/PCI-PCIe/"/>
    
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
  </entry>
  
  <entry>
    <title>Dive into irqfd(KVM side) mechanism</title>
    <link href="http://liujunming.github.io/2021/10/27/Dive-into-irqfd-KVM-side-mechanism/"/>
    <id>http://liujunming.github.io/2021/10/27/Dive-into-irqfd-KVM-side-mechanism/</id>
    <published>2021-10-27T01:53:42.000Z</published>
    <updated>2021-10-28T10:05:35.381Z</updated>
    
    <content type="html"><![CDATA[<p>本文将深入理解irqfd机制，偏向于KVM side。为了便于理清irqfd机制，本文只介绍patch <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=721eecbf4fe995ca94a9edec0c9843b1cc0eaaf3" target="_blank" rel="noopener">KVM: irqfd</a>中的内容。<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>irqfd in KVM is implemented based on eventfd in Linux.</p><p>As its name shows, irqfd is basically a fd that is bound to an interrupt in the virtual machine. Here the fd must be an eventfd. The delivery path is single direction, say, interrupt is delivered from outside world into the guest. </p><p>With irqfd, if we want to trigger an interrupt we have setup, what we need to do is only write to that corresponding eventfd. To write it in userspace, a simple <code>write()</code> syscall would suffice (actually there is a libc call named <code>eventfd_write()</code>, however that’s merely a wrapper of the <code>write()</code> system call). To do it in kernel, we can use <code>eventfd_signal()</code> instead.</p><h3 id="2-Overview"><a href="#2-Overview" class="headerlink" title="2. Overview"></a>2. Overview</h3><p><img src="/images/2021/10/16.png" alt></p><p>irqfd基于eventfd机制，qemu中将一个gsi(全局系统中断号)与eventfd捆绑后，向kvm发送注册irqfd请求，kvm收到请求后将带有gsi信息的eventfd加入到与irqfd有关的等待队列中，一旦有进程向该eventfd写入，等待队列中的元素就会唤醒，并调用相应的唤醒函数(<code>irqfd_wakeup</code>)向guest注入中断(<code>irqfd_inject</code>)。</p><h3 id="3-Details"><a href="#3-Details" class="headerlink" title="3. Details"></a>3. Details</h3><p><img src="/images/2021/10/17.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_irqfd_assign</span><span class="params">(struct kvm *kvm, struct kvm_irqfd *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_kernel_irqfd</span> *<span class="title">irqfd</span>;</span></span><br><span class="line">...</span><br><span class="line">irqfd = kzalloc(<span class="keyword">sizeof</span>(*irqfd), GFP_KERNEL_ACCOUNT);</span><br><span class="line">irqfd-&gt;kvm = kvm;</span><br><span class="line">irqfd-&gt;gsi = args-&gt;gsi;</span><br><span class="line">INIT_LIST_HEAD(&amp;irqfd-&gt;<span class="built_in">list</span>);</span><br><span class="line">INIT_WORK(&amp;irqfd-&gt;inject, irqfd_inject);</span><br><span class="line">INIT_WORK(&amp;irqfd-&gt;shutdown, irqfd_shutdown);</span><br><span class="line">...</span><br><span class="line">irqfd-&gt;eventfd = eventfd;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Install our own custom wake-up handling so we are notified via</span></span><br><span class="line"><span class="comment"> * a callback whenever someone signals the underlying eventfd</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">init_waitqueue_func_entry(&amp;irqfd-&gt;wait, irqfd_wakeup);</span><br><span class="line">...</span><br><span class="line">init_poll_funcptr(&amp;irqfd-&gt;pt, irqfd_ptable_queue_proc);</span><br><span class="line">events = vfs_poll(f.file, &amp;irqfd-&gt;pt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kvm_kernel_irqfd结构中有2个work_struct，inject和shutdown，分别负责触发中断和关闭中断，这两个work_struct各自对应的操作函数分别为irqfd_inject和irqfd_shutdown。</p><p>kvm_irqfd_assign调用init_waitqueue_func_entry将<strong>irqfd_wakeup</strong>函数注册为irqfd中<strong>wait queue entry</strong>激活时的处理函数。<strong>这样任何写入该irqfd对应的eventfd的行为都将触发这个函数。</strong></p><p>kvm_irqfd_assign利用init_poll_funcptr将irqfd_ptable_queue_proc函数注册为irqfd中的poll table的处理函数。<strong>irqfd_ptable_queue_proc会将poll table中对应的wait queue entry加入到waitqueue中去。</strong></p><p>kvm_irq_assign以irqfd-&gt;pt为参数，调用eventfd的poll函数，也就是eventfd_poll；eventfd_poll会调用poll_wait函数；poll_wait会回调之前为poll table注册的irqfd_ptable_queue_proc函数。</p><hr><p>参考资料:</p><ol><li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=721eecbf4fe995ca94a9edec0c9843b1cc0eaaf3" target="_blank" rel="noopener">KVM: irqfd</a></li><li><a href="https://blog.csdn.net/LoyenWang/article/details/115805007?spm=1001.2014.3001.5501" target="_blank" rel="noopener">Linux虚拟化KVM-Qemu分析（十二）之ioeventfd与irqfd</a></li><li><a href="https://www.cnblogs.com/haiyonghao/p/14440723.html" target="_blank" rel="noopener">qemu-kvm的irqfd机制</a></li><li><a href="http://xzpeter.org/htmls/2017_12_07_kvm_irqfd/kvm_irqfd_implementation.html" target="_blank" rel="noopener">KVM Irqfd Introduction</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将深入理解irqfd机制，偏向于KVM side。为了便于理清irqfd机制，本文只介绍patch &lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=721eecbf4fe995ca94a9edec0c9843b1cc0eaaf3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;KVM: irqfd&lt;/a&gt;中的内容。
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>Dive into ioeventfd(KVM side) mechanism</title>
    <link href="http://liujunming.github.io/2021/10/26/Dive-into-ioeventfd(kvm%20side)-mechanism/"/>
    <id>http://liujunming.github.io/2021/10/26/Dive-into-ioeventfd(kvm side)-mechanism/</id>
    <published>2021-10-26T07:07:25.000Z</published>
    <updated>2021-10-26T15:12:22.036Z</updated>
    
    <content type="html"><![CDATA[<p>本文将深入理解ioeventfd机制，偏向于KVM side。<a id="more"></a></p><h3 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h3><p><a href="/2021/10/25/eventfd-system-call内核实现/">eventfd system call内核实现</a></p><h3 id="2-Introduction-and-Motivation"><a href="#2-Introduction-and-Motivation" class="headerlink" title="2. Introduction and Motivation"></a>2. Introduction and Motivation</h3><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d34e6b175e61821026893ec5298cc8e7558df43a" target="_blank" rel="noopener">KVM: add ioeventfd support</a>中的commit message很好地阐述了ioeventfd的motivation。</p><p>ioeventfd is a mechanism to <strong>register PIO/MMIO regions to trigger an eventfd signal when written to by a guest</strong>.  Host userspace can register any arbitrary IO address with a corresponding eventfd and then pass the eventfd to a specific end-point of interest for handling.</p><p>Normal IO requires a blocking round-trip since the operation may cause side-effects in the emulated model or may return data to the caller. Therefore, an IO in KVM traps from the guest to the host, causes a VMX/SVM “heavy-weight” exit back to userspace, and is ultimately serviced by qemu’s device model <strong>synchronously</strong> before returning control back to the vcpu.</p><p>However, there is a subclass of IO which acts purely as a trigger for other IO (such as to kick off an out-of-band DMA request, etc).  For these patterns, the synchronous call is particularly expensive since we really only want to simply get our notification transmitted <strong>asychronously</strong> and return as quickly as possible.  All the sychronous infrastructure to ensure proper data-dependencies are met in the normal IO case are just unecessary overhead for signalling.  This adds additional computational load on the system, as well as latency to the signalling path.</p><p>Therefore, we provide a mechanism for registration of an in-kernel trigger point that allows the VCPU to only require a very brief, lightweight exit just long enough to signal an eventfd.  This also means that any clients compatible with the eventfd interface (which includes userspace and kernelspace equally well) can now register to be notified. The end result should be a more flexible and higher performance notification API for the backend KVM hypervisor and perhipheral components.</p><p>读者如果对<em>kick off an out-of-band DMA request</em>这句话不够理解，可以阅读:<a href="/2021/09/12/深入理解DMA-part1/">深入理解DMA part1</a>和<a href="/2021/09/13/深入理解DMA-part2/">深入理解DMA part2</a></p><h3 id="3-Overview"><a href="#3-Overview" class="headerlink" title="3. Overview"></a>3. Overview</h3><p><img src="/images/2021/10/15.jpeg" alt></p><p>Sequences:</p><ol><li>QEMU将一段PIO/MMIO region与eventfd绑定(具体来说，就是填好<code>struct kvm_ioeventfd</code>)，并设置好notification的handler;</li><li>通过ioctl将<code>struct kvm_ioeventfd</code>结构体传给KVM;</li><li>KVM根据信息，注册PIO/MMIO region的handler为<code>ioeventfd_ops</code>;</li><li>Guest写PIO/MMIO region时，会发生VM Exit，KVM最终会调用<code>ioeventfd_write</code> to trigger an event to QEMU;</li><li>QEMU监测到ioeventfd上出现了event，调用相应的handler处理IO.</li></ol><h3 id="4-Details"><a href="#4-Details" class="headerlink" title="4. Details"></a>4. Details</h3><p>用户态传入的参数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_ioeventfd</span> &#123;</span></span><br><span class="line">    __u64 datamatch;<span class="comment">/* 1 */</span></span><br><span class="line">    __u64 addr;        <span class="comment">/* legal pio/mmio address */</span></span><br><span class="line">    __u32 len;         <span class="comment">/* 0, 1, 2, 4, or 8 bytes    */</span></span><br><span class="line">    __s32 fd;<span class="comment">/* 2 */</span></span><br><span class="line">    __u32 flags;</span><br><span class="line">    __u8  pad[<span class="number">36</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果<code>flags</code>设置了<code>KVM_IOEVENTFD_FLAG_DATAMATCH</code>，只有当guest向addr地址写入的值与<code>datamatch</code>值相等时，才会触发event。</p><p>用户态信息<code>kvm_ioeventfd</code>需要转化成内核态存放。ioeventfd内核态结构体基于eventfd，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * --------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * ioeventfd: translate a PIO/MMIO memory write to an eventfd signal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * userspace can register a PIO/MMIO address with an eventfd for receiving</span></span><br><span class="line"><span class="comment"> * notification when the memory has been touched.</span></span><br><span class="line"><span class="comment"> * --------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ioeventfd</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>     <span class="title">list</span>;</span></span><br><span class="line">u64                  addr;</span><br><span class="line"><span class="keyword">int</span>                  length;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventfd_ctx</span>  *<span class="title">eventfd</span>;</span></span><br><span class="line">u64                  datamatch;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_io_device</span> <span class="title">dev</span>;</span></span><br><span class="line">u8                   bus_idx;</span><br><span class="line"><span class="keyword">bool</span>                 wildcard;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>list用于将当前ioeventfd链接到kvm的ioeventfd链表中去.</p></li><li><p>addr是ioeventfd对应的IO地址.</p></li><li><p>length是eventfd关联的长度.</p></li><li><p>eventfd是该ioeventfd对应的eventfd.</p></li><li><p>datamatch上文已经介绍过了.</p></li><li><p>dev用于将该ioeventfd与guest关联起来(通过注册该dev到guest).</p></li><li><p>bus_idx是该ioeventfd要注册到kvm的哪个总线上.</p><ul><li>kvm中将ioeventfd注册的地址分为4类，可以认为每类地址有独立的地址空间，它们被抽象成4个bus上的地址。分别是kvm_bus所列出的MMIO，PIO，VIRTIO_CCW_NOTIFY，FAST_MMIO。MMIO和FAST_MMIO的区别是，MMIO需要检查写入地址的值长度是否和ioeventfd指定的长度相等，FAST_MMIO则不需要检查长度。</li></ul></li><li>wildcard与datamatch互斥，如果kvm_ioeventfd中datamatch为false，则_ioeventfd-&gt;wildcard设为true.</li></ul><p>所以<code>_ioeventfd</code>描述了一个ioeventfd要注册到kvm中的所有信息，其中包含了ioeventfd信息和需要注册到guest的总线和设备信息。</p><hr><p>KVM中的函数调用链如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kvm_ioeventfd</span><br><span class="line">kvm_assign_ioeventfd</span><br><span class="line">kvm_assign_ioeventfd_idx</span><br><span class="line">kvm_iodevice_init(&amp;p-&gt;dev, &amp;ioeventfd_ops)</span><br><span class="line">kvm_io_bus_register_dev</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kvm_io_bus_write</span><br><span class="line">__kvm_io_bus_write</span><br><span class="line">kvm_iodevice_write</span><br><span class="line">dev-&gt;ops-&gt;write(ioeventfd_write)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kvm_io_device_ops</span> <span class="title">ioeventfd_ops</span> = &#123;</span></span><br><span class="line">.write      = ioeventfd_write,</span><br><span class="line">.destructor = ioeventfd_destructor,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，ioeventfd对应的文件操作只有write操作，而没有read操作。</p><p>write操作对应guest中写入ioeventfd对应的IO地址时触发的操作，也就是guest执行OUT类汇编指令时触发的操作，相反read操作就是guest执行IN类汇编指令时触发的操作，OUT类指令只是简单向外部输出数据，无需等待QEMU处理完成即可继续运行guest，但IN指令需要从外部获取数据，必须要等待QEMU处理完成IO请求再继续运行guest。</p><p>ioeventfd设计的初衷就是节省guest运行OUT类指令时的时间，IN类指令执行时间无法节省，因此这里的ioeventfd 文件操作中只有write而没有read。</p></blockquote><p>剩下的事情就留给读者了，结合着源码与参考资料，去发现更多的细节吧!</p><hr><p>参考资料:</p><ol><li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d34e6b175e61821026893ec5298cc8e7558df43a" target="_blank" rel="noopener">KVM: add ioeventfd support</a></li><li><a href="https://www.cnblogs.com/haiyonghao/p/14440743.html" target="_blank" rel="noopener">qemu-kvm的ioeventfd机制</a></li><li><a href="https://blog.csdn.net/huang987246510/article/details/105618557" target="_blank" rel="noopener">qemu中的eventfd——ioeventfd</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将深入理解ioeventfd机制，偏向于KVM side。
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>eventfd system call内核实现</title>
    <link href="http://liujunming.github.io/2021/10/25/eventfd-system-call%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://liujunming.github.io/2021/10/25/eventfd-system-call内核实现/</id>
    <published>2021-10-25T00:55:15.000Z</published>
    <updated>2021-10-25T10:06:37.351Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍<code>eventfd</code>这个system call的内核实现。<a id="more"></a></p><h3 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h3><ul><li><code>man eventfd</code></li><li><a href="/2019/08/24/linux-kernel中eventfd的使用/">linux kernel中eventfd的使用</a></li></ul><p>summary(仅考虑eventfd的flags为0 ，同时eventfd counter 没有 exceed the maximum):</p><ol><li>the eventfd counter has a nonzero value, then a <code>read</code> returns 8 bytes containing that value, and the counter’s value is reset to zero;</li><li>If the eventfd counter is zero at the time of the call to <code>read</code>, then the call blocks until the counter becomes nonzero;</li><li>A  <code>write</code>  call  adds  the 8-byte integer value supplied in its buffer to the counter;</li><li><code>eventfd_signal(struct eventfd_ctx *ctx, __u64 n)</code>: Adds @n to the eventfd counter.</li></ol><h3 id="2-Data-struct"><a href="#2-Data-struct" class="headerlink" title="2. Data struct"></a>2. Data struct</h3><p><code>eventfd_ctx</code>结构的形式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventfd_ctx</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> wqh;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Every time that a write(2) is performed on an eventfd, the</span></span><br><span class="line"><span class="comment"> * value of the __u64 being written is added to "count" and a</span></span><br><span class="line"><span class="comment"> * wakeup is performed on "wqh". A read(2) will return the "count"</span></span><br><span class="line"><span class="comment"> * value to userspace, and will reset "count" to zero. The kernel</span></span><br><span class="line"><span class="comment"> * side eventfd_signal() also, adds to the "count" counter and</span></span><br><span class="line"><span class="comment"> * issue a wakeup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__u64 count;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在一个eventfd上执行<code>write</code>系统调用，会向<code>count</code>加上被写入的值，并唤醒等待队列<code>wqh</code>中的元素。内核中的<code>eventfd_signal</code>函数也会增加<code>count</code>的值并唤醒<code>wqh</code>中的元素。</p><p>在eventfd上执行<code>read</code>系统调用，会向用户空间返回<code>count</code>的值，并且该eventfd对应的<code>eventfd_ctx</code>结构中的<code>count</code>会被清0。</p><p><code>kref</code>是一个内核中的通用变量，一般插入到结构体中，用于记录该结构体被内核各处引用的次数，当<code>kref-&gt;refcount</code>为0时，该结构体不再被引用，需要进行释放。</p><p><code>flags</code>由调用者传入，可能取值为<code>EFD_CLOEXEC</code>、<code>EFD_NONBLOCK</code>、<code>EFD_SEMAPHORE</code>三者的任意或组合。</p><p><code>id</code>即eventfd的id，用于唯一标识一个eventfd。</p><h3 id="3-Core-function"><a href="#3-Core-function" class="headerlink" title="3. Core function"></a>3. Core function</h3><h4 id="3-1-系统调用的定义"><a href="#3-1-系统调用的定义" class="headerlink" title="3.1 系统调用的定义"></a>3.1 系统调用的定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(eventfd, <span class="keyword">unsigned</span> <span class="keyword">int</span>, count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> do_eventfd(count, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_eventfd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> count, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventfd_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">...</span><br><span class="line">ctx = kmalloc(<span class="keyword">sizeof</span>(*ctx), GFP_KERNEL);</span><br><span class="line">...</span><br><span class="line">kref_init(&amp;ctx-&gt;kref);</span><br><span class="line">init_waitqueue_head(&amp;ctx-&gt;wqh);</span><br><span class="line">ctx-&gt;count = count;</span><br><span class="line">ctx-&gt;flags = flags;</span><br><span class="line">ctx-&gt;id = ida_simple_get(&amp;eventfd_ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">fd = anon_inode_getfd(<span class="string">"[eventfd]"</span>, &amp;eventfd_fops, ctx,</span><br><span class="line">      O_RDWR | (flags &amp; EFD_SHARED_FCNTL_FLAGS));</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>分配一个eventfd_ctx结构用于存储eventfd相关信息</li><li>设置eventfd_ctx-&gt;kref中的值为1，表明内核正在引用该eventfd</li><li>初始化eventfd_ctx结构中的等待队列</li><li>为eventfd_ctx结构中的count(读写eventfd时要操作的量)赋上系统调用传入的count</li><li>通过Linux提供的<strong>ida机制</strong>为eventfd_ctx结构中的id申请一个id</li><li>通过anon_inode_getfd创建一个文件实例，该文件的操作方法为eventfd_fops，fd-&gt;private_data为eventfd_ctx，文件实例名为eventfd。</li><li>返回该文件实例的文件描述符</li></ol><h4 id="3-2-eventfd-read"><a href="#3-2-eventfd-read" class="headerlink" title="3.2 eventfd_read"></a>3.2 eventfd_read</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">eventfd_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventfd_ctx</span> *<span class="title">ctx</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">ssize_t</span> res;</span><br><span class="line">__u64 ucnt = <span class="number">0</span>;</span><br><span class="line">DECLARE_WAITQUEUE(wait, current);</span><br><span class="line"></span><br><span class="line">res = -EAGAIN;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;count &gt; <span class="number">0</span>)</span><br><span class="line">res = <span class="keyword">sizeof</span>(ucnt);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!(file-&gt;f_flags &amp; O_NONBLOCK)) &#123;</span><br><span class="line"><span class="comment">/*add to wait queue*/</span></span><br><span class="line">__add_wait_queue(&amp;ctx-&gt;wqh, &amp;wait);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">res = <span class="keyword">sizeof</span>(ucnt);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*触发调度器，执行调度*/</span></span><br><span class="line">schedule();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*remove from the wait queue*/</span></span><br><span class="line">__remove_wait_queue(&amp;ctx-&gt;wqh, &amp;wait);</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (likely(res &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">eventfd_ctx_do_read(ctx, &amp;ucnt);</span><br><span class="line"><span class="comment">/*judge whether wait queue is empty*/</span></span><br><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ctx-&gt;wqh)) <span class="comment">//在该eventfd上write阻塞的进程</span></span><br><span class="line">wake_up_locked_poll(&amp;ctx-&gt;wqh, EPOLLOUT); <span class="comment">//唤醒对应的进程</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eventfd_ctx_do_read</span><span class="params">(struct eventfd_ctx *ctx, __u64 *cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*cnt = (ctx-&gt;flags &amp; EFD_SEMAPHORE) ? <span class="number">1</span> : ctx-&gt;count;</span><br><span class="line">ctx-&gt;count -= *cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>只有eventfd_ctx-&gt;count大于0时，eventfd才是可读的，此时调用eventfd_ctx_do_read对eventfd_ctx的count进行处理，如果eventfd_ctx-&gt;flags中的EFD_SEMAPHORE为0，就将count变量置0，并激活在等待队列中EPOLLOUT(write阻塞)的进程。</p></li><li><p>如果eventfd_ctx-&gt;count等于0，即该eventfd当前不可读，如果eventfd_ctx-&gt;flags中的O_NONBLOCK没有置位，那么将发起读eventfd动作的进程放入eventfd_ctx中的等待队列，并重新调度新的进程运行。</p></li></ul><h4 id="3-3-eventfd-write"><a href="#3-3-eventfd-write" class="headerlink" title="3.3 eventfd_write"></a>3.3 eventfd_write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">eventfd_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventfd_ctx</span> *<span class="title">ctx</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">ssize_t</span> res;</span><br><span class="line">__u64 ucnt;</span><br><span class="line">DECLARE_WAITQUEUE(wait, current);</span><br><span class="line"></span><br><span class="line">copy_from_user(&amp;ucnt, buf, <span class="keyword">sizeof</span>(ucnt));</span><br><span class="line">...</span><br><span class="line">res = -EAGAIN;</span><br><span class="line"><span class="keyword">if</span> (ULLONG_MAX - ctx-&gt;count &gt; ucnt)</span><br><span class="line">res = <span class="keyword">sizeof</span>(ucnt);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!(file-&gt;f_flags &amp; O_NONBLOCK)) &#123;</span><br><span class="line">__add_wait_queue(&amp;ctx-&gt;wqh, &amp;wait);</span><br><span class="line"><span class="keyword">for</span> (res = <span class="number">0</span>;;) &#123;</span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="keyword">if</span> (ULLONG_MAX - ctx-&gt;count &gt; ucnt) &#123;</span><br><span class="line">res = <span class="keyword">sizeof</span>(ucnt);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">schedule();</span><br><span class="line">&#125;</span><br><span class="line">__remove_wait_queue(&amp;ctx-&gt;wqh, &amp;wait);</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (likely(res &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">ctx-&gt;count += ucnt;</span><br><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ctx-&gt;wqh)) <span class="comment">//在该eventfd上read阻塞的进程</span></span><br><span class="line">wake_up_locked_poll(&amp;ctx-&gt;wqh, EPOLLIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将想要写入eventfd的value赋值到ucnt，判断ULLONG_MAX - eventfd_ctx-&gt;count 与ucnt的大小，确认eventfd中是否还有足够空间用于写入。</p><ul><li><p>如果有足够空间用于写入，ctx-&gt;count += ucnt，并激活在等待队列中EPOLLIN(read阻塞)的进程。</p></li><li><p>如果没有足够空间用于写入，则将发起写eventfd动作的进程放入eventfd_ctx中的等待队列，并重新调度新的进程运行。</p></li></ul><h4 id="3-4-eventfd-signal"><a href="#3-4-eventfd-signal" class="headerlink" title="3.4 eventfd_signal"></a>3.4 eventfd_signal</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * eventfd_signal - Adds @n to the eventfd counter.</span></span><br><span class="line"><span class="comment"> * @ctx: [in] Pointer to the eventfd context.</span></span><br><span class="line"><span class="comment"> * @n: [in] Value of the counter to be added to the eventfd internal counter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__<span class="function">u64 <span class="title">eventfd_signal</span><span class="params">(struct eventfd_ctx *ctx, __u64 n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (ULLONG_MAX - ctx-&gt;count &lt; n)</span><br><span class="line">n = ULLONG_MAX - ctx-&gt;count;</span><br><span class="line">ctx-&gt;count += n;</span><br><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ctx-&gt;wqh)) <span class="comment">//在该eventfd上read阻塞的进程</span></span><br><span class="line">wake_up_locked_poll(&amp;ctx-&gt;wqh, EPOLLIN);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.cnblogs.com/haiyonghao/p/14440737.html" target="_blank" rel="noopener">Linux的eventfd机制</a></li><li><a href="https://huazq.github.io/2019/08/08/eventfd%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">eventfd分析</a></li><li><a href="https://www.cnblogs.com/ck1020/p/7214310.html" target="_blank" rel="noopener">Linux eventfd分析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍&lt;code&gt;eventfd&lt;/code&gt;这个system call的内核实现。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>x86-64 Instruction Encoding</title>
    <link href="http://liujunming.github.io/2021/10/22/x86-64-Instruction-Encoding/"/>
    <id>http://liujunming.github.io/2021/10/22/x86-64-Instruction-Encoding/</id>
    <published>2021-10-22T03:20:48.000Z</published>
    <updated>2021-10-22T07:16:48.160Z</updated>
    
    <content type="html"><![CDATA[<p>本文将借鉴<a href="https://www.systutorials.com/beginners-guide-x86-64-instruction-encoding/" target="_blank" rel="noopener">A Beginners’ Guide to x86-64 Instruction Encoding</a>，并补充相关材料，以一个具体的例子来介绍Intel Instruction Encoding。<br><a id="more"></a></p><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><p>以一个典型的memory reference来引入Instruction Encoding。<br><code>[base + index*scale + disp]</code></p><p><code>base</code>和<code>index</code>是寄存器，<code>disp</code>是偏移量，<code>scale</code>是系数。<br><img src="/images/2021/10/09.png" alt></p><p><center>Figure1</center><br>Figure1中，SIB中的Scale，Index，Base与<code>scale</code>,<code>index</code>,<code>base</code>相对应。 Displacement与<code>disp</code>相对应。</p><h3 id="2-Tools-and-tips-for-finding-out-an-x86-64-instruction’s-encoding"><a href="#2-Tools-and-tips-for-finding-out-an-x86-64-instruction’s-encoding" class="headerlink" title="2. Tools and tips for finding out an x86-64 instruction’s encoding"></a>2. Tools and tips for finding out an x86-64 instruction’s encoding</h3><p>To quickly find out the encoding of an instruction, you can use the GNU assembler  <code>as</code> and the <code>objdump</code> tool together. For example, to find out the encoding of the instruction <code>addq 10(%rdi), %r8</code>, you can do it as follows.</p><p>First, create a file add.s containing one line<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addq 10(%rdi), %r8</span><br></pre></td></tr></table></figure></p><p>Second, assemble the add.s to object file by<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ as add.s -o add.o</span><br></pre></td></tr></table></figure></p><p>Last, deassemble the object file by</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d add.o</span><br></pre></td></tr></table></figure><p>It will print out</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   4c 03 47 0a             add    0xa(%rdi),%r8</span><br></pre></td></tr></table></figure><p>Here <code>4c 03 47 0a</code> is the 4-byte encoding of the <code>addq</code> instruction.</p><h3 id="3-Brief-introduction-to-x86-64-instruction-encoding"><a href="#3-Brief-introduction-to-x86-64-instruction-encoding" class="headerlink" title="3. Brief introduction to x86-64 instruction encoding"></a>3. Brief introduction to x86-64 instruction encoding</h3><p>The x86-64 instructions are encoded one by one as a variable number of bytes for each. Each instruction’s encoding consists of:</p><ul><li>an opcode</li><li>a register and/or address mode specifier consisting of the ModR/M byte and sometimes the scale-index-base (SIB) byte (if required)</li><li>a displacement and an immediate data field (if required)</li></ul><p>Please refer to Figure1 for more information.</p><h3 id="4-An-example-manually-encode-an-x86-64-instruction"><a href="#4-An-example-manually-encode-an-x86-64-instruction" class="headerlink" title="4. An example: manually encode an x86-64 instruction"></a>4. An example: manually encode an x86-64 instruction</h3><p>Let’s take a look at the encoding of an instruction <code>add r8,QWORD PTR [rdi+0xa]</code> (in Intel syntax) in the previous part. Let’s see how it is encoded to <code>4c 03 47 0a</code>.</p><p>From the “add” instruction reference from “ADD”, “INSTRUCTION SET REFERENCE” in the ISA reference Volume 2A., find the line for the encoding of the <code>ADD r64, r/m64</code> corresponding to this instruction</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Opcode      Instruction     Op/  64-bit Compat/   Description</span><br><span class="line">                            En   Mode   Leg Mode</span><br><span class="line">REX.W+03/r  ADD r64,r/m64   RM   Valid  N.E.      Add r/m64 to r64.</span><br></pre></td></tr></table></figure><p>REX info:</p><p><img src="/images/2021/10/13.png" alt></p><p>and, from the REX description</p><blockquote><p>In 64-bit mode, the instruction’s default operation size is 32 bits. … Using a REX prefix in the form of REX.W promotes operation to 64 bits.</p></blockquote><p>So, we get</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REX.W = 1</span><br></pre></td></tr></table></figure><p>The ‘R’, ‘X’ and ‘B’ bits are related to the operand encoding (check “Table 2-4. REX Prefix Fields [BITS: 0100WRXB]” of the reference volume 2A).</p><blockquote><p>REX.X bit modifies the SIB index field.</p></blockquote><p>SIB is not used in this instruction. Hence,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REX.X = 0</span><br></pre></td></tr></table></figure><p>Let’s further look at the encoding of the operands. From the “Instruction Operand Encoding” for the <code>add</code> instruction:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Op/En Operand 1      Operand 2    Operand 3 Operand 4</span><br><span class="line">RM    ModRM:reg(r,w) ModRM:r/m(r) NA        NA</span><br></pre></td></tr></table></figure><p>There will be 2 operand parts for the <code>RM</code> encoding. The first part will be <code>ModRM:reg(r,w)</code> and the second part will be <code>ModRM:r/m(r)</code>. “Figure 2-4. Memory Addressing Without an SIB Byte; REX.X Not Used” from Volume 2 shows the encoding for this case.</p><p><img src="/images/2021/10/12.jpg" alt></p><p><img src="/images/2021/10/14.png" alt></p><p>The REX.R and REX.B bits and the ModeRM byte will be decided accordingly. There are 3 parts in the ModRM byte: ‘mod’, ‘reg’ and ‘r/m’.</p><p>There is a table “Table 2-2. 32-Bit Addressing Forms with the ModR/M Byte” (it is for 32-bit operands. But from 2.2.1.1, “In 64-bit mode, these formats do not change. Bits needed to<br>define fields in the 64-bit context are provided by the addition of REX prefixes” and hence the same value can be used) in Volume 2 which shows mapping of the operands combinations to the bits values of ‘mod’.</p><p>Although the table applies to 64-bit modes too, it does not show the additional registers like <code>r8</code>. Hence, we only use it to find out bits for ‘Mod’ only for the <code>addq</code> instruction we are encoding it. As <code>0xa</code> can be encoded in a byte, we can use <code>disp8</code> to keep the instruction encoding short. From the row of <code>[EDI]+disp8</code> (actually, all <code>disp8</code> ones share the same ‘Mod’ bits),</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mod = 01 (in bits)</span><br></pre></td></tr></table></figure><p>For the encoding of the registers, I compiled a table for the general purpose 64-bit registers for your reference:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_.Reg  Register</span><br><span class="line">----------------</span><br><span class="line">0.000   RAX</span><br><span class="line">0.001   RCX</span><br><span class="line">0.010   RDX</span><br><span class="line">0.011   RBX</span><br><span class="line">0.100   RSP</span><br><span class="line">0.101   RBP</span><br><span class="line">0.110   RSI</span><br><span class="line">0.111   RDI</span><br><span class="line">1.000   R8</span><br><span class="line">1.001   R9</span><br><span class="line">1.010   R10</span><br><span class="line">1.011   R11</span><br><span class="line">1.100   R12</span><br><span class="line">1.101   R13</span><br><span class="line">1.110   R14</span><br><span class="line">1.111   R15</span><br></pre></td></tr></table></figure><p>The ‘_‘ in the ‘_.Reg’ are usually a bit in the REX prefix, such as REX.B and REX.R, depending on specific instructions and operand combinations.</p><p>For the <code>addq</code> instruction in this case, <code>r8</code> is <code>1.000</code> and <code>rdi</code> is <code>0.111</code>. Hence, in bits, we get</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reg = 000</span><br><span class="line">r/m = 111</span><br><span class="line">REX.B = 0 (from `rdi`)</span><br><span class="line">REX.R = 1 (from `r8`)</span><br></pre></td></tr></table></figure><p>Now, let’s put them together.</p><p>By putting the ‘WRXB’ bits (<code>[BITS: 0100WRXB]</code>) together, we get the REX prefix for this instruction is</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0100 1100</span><br></pre></td></tr></table></figure><p>Together with the <code>03</code> in <code>REX.W+03/r</code> from the reference for the <code>ADD</code> instruction, the opcode part, in hexadecimal, is</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4c 03</span><br></pre></td></tr></table></figure><p>By putting the <code>mod</code>, <code>reg</code> and <code>r/m</code> together, we get the ModRM byte (in bits)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01 000 111</span><br></pre></td></tr></table></figure><p>which is, in hexadecimal,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">47</span><br></pre></td></tr></table></figure><p>Following the ModRM byte is the displacement is <code>0xa</code>(<code>10</code>‘s hexadecimal representation) in one byte (<code>disp8</code>).</p><p>Putting all these together, we finally get the encoding of <code>add r8,[rdi+0xa]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4c 03 47 0a</span><br></pre></td></tr></table></figure><p>In this example, to show the process, I have shown how to manually do an instruction’s encoding which is usually done by the assembler. You may use the same method to encode all other instruction by checking the reference documents for details of every instruction/operand combinations’ cases.</p><h3 id="5-Tips"><a href="#5-Tips" class="headerlink" title="5. Tips"></a>5. Tips</h3><ul><li><a href="https://wiki.osdev.org/X86-64_Instruction_Encoding" target="_blank" rel="noopener">X86-64 Instruction Encoding</a> </li></ul><p>is a very good page from OSDev as a quick reference.</p><ul><li><a href="https://events.static.linuxfound.org/sites/events/files/slides/bpetkov-x86-hacks.pdf" target="_blank" rel="noopener">x86 Instruction Encoding</a> </li></ul><p>可以快速扫一下内容，例如:</p><p><img src="/images/2021/10/10.png" alt></p><p>有些内容还是比较形象直观的。</p><ul><li>Intel SDM vol2 2.1 INSTRUCTION FORMAT FOR PROTECTED MODE, REAL-ADDRESS MODE,<br>AND VIRTUAL-8086 MODE </li></ul><p><img src="/images/2021/10/11.png" alt></p><p>以上内容是对Figure1的补充说明。</p><ul><li>Intel SDM vol2 3.1 INTERPRETING THE INSTRUCTION REFERENCE PAGES</li></ul><p>Intel SDM vol2中有具体的指令说明，需要先扫一下3.1 INTERPRETING THE INSTRUCTION REFERENCE PAGES中的内容。This section describes the format of information contained in the instruction reference pages in this chapter. It explains notational conventions and abbreviations used in these sections.</p><p>For example:</p><p><img src="/images/2021/10/8.png" alt></p><hr><p>参考资料:</p><ol><li><a href="https://www.systutorials.com/beginners-guide-x86-64-instruction-encoding/" target="_blank" rel="noopener">A Beginners’ Guide to x86-64 Instruction Encoding</a></li><li><a href="https://wiki.osdev.org/X86-64_Instruction_Encoding" target="_blank" rel="noopener">X86-64 Instruction Encoding</a></li><li><a href="https://events.static.linuxfound.org/sites/events/files/slides/bpetkov-x86-hacks.pdf" target="_blank" rel="noopener">x86 Instruction Encoding</a></li><li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf" target="_blank" rel="noopener">Intel SDM</a></li><li><a href="https://sourceware.org/binutils/docs/as/i386_002dMemory.html" target="_blank" rel="noopener">Memory References</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将借鉴&lt;a href=&quot;https://www.systutorials.com/beginners-guide-x86-64-instruction-encoding/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A Beginners’ Guide to x86-64 Instruction Encoding&lt;/a&gt;，并补充相关材料，以一个具体的例子来介绍Intel Instruction Encoding。&lt;br&gt;
    
    </summary>
    
      <category term="体系结构" scheme="http://liujunming.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PIO virtualization in QEMU/KVM</title>
    <link href="http://liujunming.github.io/2021/10/19/PIO-virtualization-in-QEMU-KVM/"/>
    <id>http://liujunming.github.io/2021/10/19/PIO-virtualization-in-QEMU-KVM/</id>
    <published>2021-10-19T05:56:31.000Z</published>
    <updated>2021-10-20T22:10:04.052Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍：当guest执行<code>in</code>或<code>out</code>指令时，QEMU与KVM源码中的实现细节。<a id="more"></a></p><h3 id="1-PIO-background"><a href="#1-PIO-background" class="headerlink" title="1. PIO background"></a>1. PIO background</h3><p>Intel的I/O指令使得处理器可以访问I/O端口，以便从外设输入数据，或者向外设发送数据。这些指令有一个指定I/O空间端口地址的操作数。有两类的I/O指令：</p><ol><li>在寄存器指定的地址传送一个数据（字节、字、双字）。</li><li>传送指定内存中的一串数据（字节串、字串、双字串）。这些被称作为“串 I/O指令”或者说“块I/O指令”。</li></ol><p>有<code>IN</code>/<code>OUT</code> <code>INS</code>/<code>OUTS</code>指令</p><h3 id="2-PIO-configuration-in-VMCS"><a href="#2-PIO-configuration-in-VMCS" class="headerlink" title="2. PIO configuration in VMCS"></a>2. PIO configuration in VMCS</h3><p>SDM中的description如下:</p><p><img src="/images/2021/10/06.png" alt></p><p>KVM在Primary Processor-Based VM-Execution Controls 设置了Unconditional I/O exiting位，并且没有设置Use I/O bitmaps 位。因此，一旦guest执行了PIO指令，一定会发生VM Exit。</p><p>详情请阅读patch <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8eb73e2d410f00d383023fe41c0c25c6195b7389" target="_blank" rel="noopener">KVM: VMX: drop I/O permission bitmaps</a> </p><h3 id="3-Warm-up"><a href="#3-Warm-up" class="headerlink" title="3. Warm-up"></a>3. Warm-up</h3><h4 id="3-1-VM-Exit-Qualification-for-I-O-Instructions"><a href="#3-1-VM-Exit-Qualification-for-I-O-Instructions" class="headerlink" title="3.1 VM Exit Qualification for I/O Instructions"></a>3.1 VM Exit Qualification for I/O Instructions</h4><p>当guest执行PIO指令时，触发<a href="https://github.com/torvalds/linux/blob/v5.10/arch/x86/kvm/vmx/vmx.c#L5931" target="_blank" rel="noopener">vmx_handle_exit</a>，根据<a href="https://github.com/torvalds/linux/blob/v5.10/arch/x86/kvm/vmx/vmx.c#L5633" target="_blank" rel="noopener">EXIT_REASON_IO_INSTRUCTION</a>执行<a href="https://github.com/torvalds/linux/blob/v5.10/arch/x86/kvm/vmx/vmx.c#L4899" target="_blank" rel="noopener">handle_io</a>函数。</p><p><img src="/images/2021/10/07.png" alt></p><p><code>handle_io</code>会解析Exit Qualification，代码如下: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handle_io</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> exit_qualification;</span><br><span class="line"><span class="keyword">int</span> size, in, <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">unsigned</span> port;</span><br><span class="line"></span><br><span class="line">exit_qualification = vmx_get_exit_qual(vcpu);</span><br><span class="line"><span class="built_in">string</span> = (exit_qualification &amp; <span class="number">16</span>) != <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">port = exit_qualification &gt;&gt; <span class="number">16</span>;</span><br><span class="line">size = (exit_qualification &amp; <span class="number">7</span>) + <span class="number">1</span>;</span><br><span class="line">in = (exit_qualification &amp; <span class="number">8</span>) != <span class="number">0</span>;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">return</span> kvm_fast_pio(vcpu, size, port, in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-misc"><a href="#3-2-misc" class="headerlink" title="3.2 misc"></a>3.2 misc</h4><ul><li>本文只讨论guest执行<code>in</code>或<code>out</code>指令时的情况，guest执行串 I/O指令这一情况不做介绍；</li><li>本文不考虑KVM模拟I/O指令的情况，即假设<code>kernel_pio</code>的返回值不为0。</li></ul><h3 id="4-PIO中out的处理流程"><a href="#4-PIO中out的处理流程" class="headerlink" title="4.  PIO中out的处理流程"></a>4.  PIO中out的处理流程</h3><p>KVM函数调用链如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kvm_fast_pio</span><br><span class="line">kvm_fast_pio_out</span><br><span class="line">emulator_pio_out_emulated</span><br><span class="line">emulator_pio_in_out</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_fast_pio_out</span><span class="params">(struct kvm_vcpu *vcpu, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> val = kvm_rax_read(vcpu); <span class="comment">//获取vcpu中rax寄存器的值</span></span><br><span class="line">    <span class="keyword">int</span> ret = emulator_pio_out_emulated(&amp;vcpu-&gt;arch.emulate_ctxt,</span><br><span class="line">    size, port, &amp;val, <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">    vcpu-&gt;arch.pio.linear_rip = kvm_get_linear_rip(vcpu);<span class="comment">//获取guest中rip寄存器的值</span></span><br><span class="line">    vcpu-&gt;arch.complete_userspace_io = complete_fast_pio_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>complete_userspace_io</code>的细节后面再描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">emulator_pio_out_emulated</span><span class="params">(struct x86_emulate_ctxt *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">short</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">const</span> <span class="keyword">void</span> *val, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> = <span class="title">emul_to_vcpu</span>(<span class="title">ctxt</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(vcpu-&gt;arch.pio_data, val, size * count);</span><br><span class="line"><span class="keyword">return</span> emulator_pio_in_out(vcpu, size, port, (<span class="keyword">void</span> *)val, count, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">emulator_pio_in_out</span><span class="params">(struct kvm_vcpu *vcpu, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">unsigned</span> <span class="keyword">short</span> port, <span class="keyword">void</span> *val,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">unsigned</span> <span class="keyword">int</span> count, <span class="keyword">bool</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vcpu-&gt;arch.pio.port = port;</span><br><span class="line">vcpu-&gt;arch.pio.in = in;</span><br><span class="line">vcpu-&gt;arch.pio.count  = count;</span><br><span class="line">vcpu-&gt;arch.pio.size = size;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_IO;</span><br><span class="line">vcpu-&gt;run-&gt;io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;</span><br><span class="line">vcpu-&gt;run-&gt;io.size = size;</span><br><span class="line">vcpu-&gt;run-&gt;io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;</span><br><span class="line">vcpu-&gt;run-&gt;io.count = count;</span><br><span class="line">vcpu-&gt;run-&gt;io.port = port;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>vcpu-&gt;run-&gt;io.data_offset</code>被设置为4096了，<code>emulator_pio_out_emulated</code>已经把guest向端口写的值拷贝到了<code>vpuc-&gt;arch.pio_data</code>中去了。 <code>vcpu-&gt;arch.pio_data</code>就在<code>kvm_run</code>后面一个页的位置，这可以从<code>kvm_vcpu_init</code>中看出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_vcpu_init</span><span class="params">(struct kvm_vcpu *vcpu, struct kvm *kvm, <span class="keyword">unsigned</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    page = alloc_page(GFP_KERNEL | __GFP_ZERO);</span><br><span class="line">    vcpu-&gt;run = page_address(page);</span><br><span class="line">    ...</span><br><span class="line">    kvm_arch_vcpu_init(vcpu);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_arch_vcpu_init</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    page = alloc_page(GFP_KERNEL | __GFP_ZERO);</span><br><span class="line">    vcpu-&gt;arch.pio_data = page_address(page);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KVM处理完后，返回到QEMU。此时，QEMU的执行代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_cpu_exec</span><span class="params">(CPUState *cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">switch</span> (run-&gt;exit_reason) &#123;</span><br><span class="line"><span class="keyword">case</span> KVM_EXIT_IO:</span><br><span class="line">            DPRINTF(<span class="string">"handle_io\n"</span>);</span><br><span class="line">            <span class="comment">/* Called outside BQL */</span></span><br><span class="line">            kvm_handle_io(run-&gt;io.port, attrs,</span><br><span class="line">                (<span class="keyword">uint8_t</span> *)run + run-&gt;io.data_offset,</span><br><span class="line">                run-&gt;io.direction,</span><br><span class="line">                run-&gt;io.size,</span><br><span class="line">                run-&gt;io.count);</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QEMU处理完后，返回到KVM。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_arch_vcpu_ioctl_run</span><span class="params">(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (unlikely(vcpu-&gt;arch.complete_userspace_io)) &#123;</span><br><span class="line"><span class="keyword">int</span> (*cui)(struct kvm_vcpu *) = vcpu-&gt;arch.complete_userspace_io;</span><br><span class="line">vcpu-&gt;arch.complete_userspace_io = <span class="literal">NULL</span>;</span><br><span class="line">   r = cui(vcpu);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">vcpu_run(vcpu);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>kvm_fast_pio_out</code>已将<code>complete_userspace_io</code> 赋值为<code>complete_fast_pio_out</code>;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int complete_fast_pio_out(struct kvm_vcpu *vcpu)</span><br><span class="line">&#123;</span><br><span class="line">vcpu-&gt;arch.pio.count = 0;</span><br><span class="line">...</span><br><span class="line">return kvm_skip_emulated_instruction(vcpu);//主要功能是让guest的RIP跳过一个指令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-PIO中in的处理流程"><a href="#5-PIO中in的处理流程" class="headerlink" title="5.  PIO中in的处理流程"></a>5.  PIO中in的处理流程</h3><p>KVM函数调用链如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kvm_fast_pio</span><br><span class="line">kvm_fast_pio_in</span><br><span class="line">emulator_pio_in_emulated</span><br><span class="line">emulator_pio_in_out</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_fast_pio_in</span><span class="params">(struct kvm_vcpu *vcpu, <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> val;</span><br><span class="line">...</span><br><span class="line">emulator_pio_in_emulated(&amp;vcpu-&gt;arch.emulate_ctxt, size, port,</span><br><span class="line">       &amp;val, <span class="number">1</span>);</span><br><span class="line">   ...</span><br><span class="line">vcpu-&gt;arch.pio.linear_rip = kvm_get_linear_rip(vcpu);</span><br><span class="line">vcpu-&gt;arch.complete_userspace_io = complete_fast_pio_in;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">emulator_pio_in_emulated</span><span class="params">(struct x86_emulate_ctxt *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">short</span> port, <span class="keyword">void</span> *val,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> = <span class="title">emul_to_vcpu</span>(<span class="title">ctxt</span>);</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vcpu-&gt;arch.pio.count)</span><br><span class="line"><span class="keyword">goto</span> data_avail;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(vcpu-&gt;arch.pio_data, <span class="number">0</span>, size * count);</span><br><span class="line"></span><br><span class="line">ret = emulator_pio_in_out(vcpu, size, port, val, count, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">data_avail:</span><br><span class="line"><span class="built_in">memcpy</span>(val, vcpu-&gt;arch.pio_data, size * count);</span><br><span class="line">vcpu-&gt;arch.pio.count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>emulator_pio_in_emulated</code>中，由于<code>vcpu-&gt;arch.pio.count</code>此时还没有数据（需要QEMU提供），所以会执行 <code>emulator_pio_in_out</code>，之前已经看过这个函数了，就是设置<code>kvm_run</code>的相关数据，然后由QEMU来填充。</p><p>回到QEMU后，QEMU会往<code>kvm_run</code>填入数据。</p><p>回到KVM后，<code>kvm_arch_vcpu_ioctl_run</code>会回调<code>complete_fast_pio_in</code>函数。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">complete_fast_pio_in</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We should only ever be called with arch.pio.count equal to 1 */</span></span><br><span class="line">BUG_ON(vcpu-&gt;arch.pio.count != <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Since vcpu-&gt;arch.pio.count == 1 let emulator_pio_in_emulated perform</span></span><br><span class="line"><span class="comment"> * the copy and tracing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">emulator_pio_in_emulated(&amp;vcpu-&gt;arch.emulate_ctxt, vcpu-&gt;arch.pio.size,</span><br><span class="line"> vcpu-&gt;arch.pio.port, &amp;val, <span class="number">1</span>);</span><br><span class="line">kvm_rax_write(vcpu, val);<span class="comment">//将值写入到vcpu的rax寄存器中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kvm_skip_emulated_instruction(vcpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最终的<code>emulator_pio_in_emulated</code>中，由于这个时候<code>vcpu-&gt;arch.pio.count</code>已经有值了，表示数据可用了。</p><p><code>emulator_pio_in_emulated</code>中的执行代码为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">emulator_pio_in_emulated</span><span class="params">(struct x86_emulate_ctxt *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">short</span> port, <span class="keyword">void</span> *val,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">memcpy</span>(val, vcpu-&gt;arch.pio_data, size * count);<span class="comment">//拷贝QEMU填充的值</span></span><br><span class="line">    vcpu-&gt;arch.pio.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2017/07/10/kvm-pio" target="_blank" rel="noopener">QEMU-KVM中的PIO处理</a></li><li><a href="https://oenhan.com/kvm-src-5-io-pio" target="_blank" rel="noopener">KVM源代码分析5:IO虚拟化之PIO</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍：当guest执行&lt;code&gt;in&lt;/code&gt;或&lt;code&gt;out&lt;/code&gt;指令时，QEMU与KVM源码中的实现细节。
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>KVM MMIO Emulation</title>
    <link href="http://liujunming.github.io/2021/10/17/KVM-MMIO-Emulation/"/>
    <id>http://liujunming.github.io/2021/10/17/KVM-MMIO-Emulation/</id>
    <published>2021-10-17T05:04:06.000Z</published>
    <updated>2021-10-17T07:37:34.474Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要汇总KVM中MMIO Emulation的过程。<a id="more"></a></p><h3 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h3><p><a href="/2020/07/12/Introduction-to-ept-misconfig/">Introduction to ept misconfig</a></p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>For a summary, the following shows the process of MMIO implementation:</p><ol><li>QEMU declares a memory region(but not allocate ram or commit it to kvm)</li><li>Guest first access the MMIO address, cause a EPT violation VM-exit</li><li>KVM construct the EPT page table and marks the page table entry with special mark(110b)</li><li>Later the guest access these MMIO, it will be processed by EPT misconfig VM-exit handler</li></ol><h3 id="QEMU-part"><a href="#QEMU-part" class="headerlink" title="QEMU part"></a>QEMU part</h3><p>这里以e1000网卡模拟为例，设备初始化MMIO时候时候注册的MemoryRegion为IO类型（不是RAM类型）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">e1000_mmio_setup(E1000State *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> excluded_regs[] = &#123;</span><br><span class="line">        E1000_MDIC, E1000_ICR, E1000_ICS, E1000_IMS,</span><br><span class="line">        E1000_IMC, E1000_TCTL, E1000_TDT, PNPMMIO_SIZE</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 这里注册MMIO，调用memory_region_init_io，mr-&gt;ram = false！！！</span></span><br><span class="line">    memory_region_init_io(&amp;d-&gt;mmio, OBJECT(d), &amp;e1000_mmio_ops, d,</span><br><span class="line">                          <span class="string">"e1000-mmio"</span>, PNPMMIO_SIZE);</span><br><span class="line">    memory_region_add_coalescing(&amp;d-&gt;mmio, <span class="number">0</span>, excluded_regs[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; excluded_regs[i] != PNPMMIO_SIZE; i++)</span><br><span class="line">        memory_region_add_coalescing(&amp;d-&gt;mmio, excluded_regs[i] + <span class="number">4</span>,</span><br><span class="line">                                     excluded_regs[i+<span class="number">1</span>] - excluded_regs[i] - <span class="number">4</span>);</span><br><span class="line">    memory_region_init_io(&amp;d-&gt;io, OBJECT(d), &amp;e1000_io_ops, d, <span class="string">"e1000-io"</span>, IOPORT_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>QEMU uses function <code>memory_region_init_io</code> to declare a MMIO region. Here we can see the <code>mr-&gt;ram</code> is false so no really memory is allocated.</p><p>QEMU调用<code>kvm_set_phys_mem</code>注册虚拟机的物理内存到KVM相关的数据结构中的时候，会调用<code>memory_region_is_ram</code>来判断该段物理地址空间是否是RAM设备， 如果不是RAM设备直接return了．</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_set_phys_mem</span><span class="params">(KVMMemoryListener *kml,</span></span></span><br><span class="line"><span class="function"><span class="params">                             MemoryRegionSection *section, <span class="keyword">bool</span> add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!memory_region_is_ram(mr)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (writeable || !kvm_readonly_mem_allowed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;     <span class="comment">// 设备MR不是RAM但可以写，那么这里直接return不注册到kvm里面</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mr-&gt;romd_mode) &#123;</span><br><span class="line">            <span class="comment">/* If the memory device is not in romd_mode, then we actually want</span></span><br><span class="line"><span class="comment">             * to remove the kvm memory slot so all accesses will trap. */</span></span><br><span class="line">            add = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KVM-part"><a href="#KVM-part" class="headerlink" title="KVM part"></a>KVM part</h3><p>In <code>vmx_init</code>, when ept enabled, it calls <code>ept_set_mmio_spte_mask</code>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ept_set_mmio_spte_mask</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * EPT Misconfigurations can be generated if the value of bits 2:0</span></span><br><span class="line"><span class="comment"> * of an EPT paging-structure entry is 110b (write/execute).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">kvm_mmu_set_mmio_spte_mask(VMX_EPT_RWX_MASK,</span><br><span class="line">   VMX_EPT_MISCONFIG_WX_VALUE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvm_mmu_set_mmio_spte_mask</span><span class="params">(u64 mmio_mask, u64 mmio_value, u64 access_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">shadow_mmio_mask = mmio_mask | SPTE_SPECIAL_MASK;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Here set <code>shadow_mmio_mask</code>.</p><p>We the guest access the MMIO address, the VM will exit caused by ept violation and <code>tdp_page_fault</code> will be called. <code>__direct_map</code> will be called to construct the EPT page table.</p><p>After the long call-chain, the final function <code>mark_mmio_spte</code> will be called to set the spte with <code>shadow_mmio_mask</code> which as we already know is set when the vmx initialization.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__direct_map</span><br><span class="line">mmu_set_spte</span><br><span class="line">set_spte</span><br><span class="line">set_mmio_spte</span><br><span class="line">mark_mmio_spte</span><br></pre></td></tr></table></figure></p><p>The condition to call <code>mark_mmio_spte</code> is <code>is_noslot_pfn</code>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">set_mmio_spte</span><span class="params">(struct kvm *kvm, u64 *sptep, <span class="keyword">gfn_t</span> gfn,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">pfn_t</span> pfn, <span class="keyword">unsigned</span> access)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(is_noslot_pfn(pfn))) &#123;</span><br><span class="line">mark_mmio_spte(kvm, sptep, gfn, access);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_noslot_pfn</span><span class="params">(<span class="keyword">pfn_t</span> pfn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> pfn == KVM_PFN_NOSLOT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>As we know the QEMU doesn’t commit the MMIO memory region, so pfn is <code>KVM_PFN_NOSLOT</code> and then mark the spte with <code>shadow_mmio_mask</code>.</p><p>When the guest later access this MMIO page, as it’s ept page table entry is 110b, this will cause the VM exit by EPT misconfig, any how can a page be write/execute but no read permission. In the handler <code>handle_ept_misconfig</code> it first process the MMIO case, this will dispatch to the QEMU part.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vcpu_run</span><br><span class="line">vcpu_enter_guest</span><br><span class="line">kvm_x86_ops-&gt;run(vcpu) (run the guest!)</span><br><span class="line">handle_exit_irqoff()</span><br><span class="line">       handle_exit() which is vmx_handle_exit</span><br><span class="line">                    handle all the vmexit, fill in the KVM_EXIT reasons</span><br><span class="line">                    (kvm_vmx_exit_handlers[exit_reason](vcpu))</span><br><span class="line">                        handle_ept_misconfig (just one of many handlers!)</span><br><span class="line">                            kvm_mmu_page_fault</span><br><span class="line">                                x86_emulate_instruction</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x86_emulate_instruction</span><br><span class="line">x86_emulate_insn</span><br><span class="line">writeback</span><br><span class="line">segmented_write</span><br><span class="line">write_emulated[emulator_write_emulated]</span><br><span class="line">emulator_read_write</span><br><span class="line">emulator_read_write_onepage</span><br><span class="line">ops-&gt;read_write_mmio[write_mmio]</span><br><span class="line">vcpu_mmio_write</span><br><span class="line">kvm_io_bus_write</span><br><span class="line">__kvm_io_bus_write</span><br><span class="line">kvm_iodevice_write</span><br><span class="line">ops-&gt;write[ioeventfd_write]</span><br></pre></td></tr></table></figure><p>最后会调用到<code>ioeventfd_write</code>，写eventfd给QEMU发送通知事件。</p><hr><p>参考资料:</p><ol><li><a href="https://kernelgo.org/mmio.html" target="_blank" rel="noopener">MMIO Emulation</a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/09/03/kvm-mmio" target="_blank" rel="noopener">KVM MMIO implementation</a></li><li><a href="http://lastweek.io/pubs/virt_note.pdf" target="_blank" rel="noopener">Notes on Virtualization Stack</a></li><li><a href="https://blog.csdn.net/lpstc123/article/details/45111949" target="_blank" rel="noopener">Qemu-kvm的ioeventfd创建与触发的大致流程</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要汇总KVM中MMIO Emulation的过程。
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>KVM notes - part2</title>
    <link href="http://liujunming.github.io/2021/10/10/KVM-notes-part2/"/>
    <id>http://liujunming.github.io/2021/10/10/KVM-notes-part2/</id>
    <published>2021-10-10T01:47:05.000Z</published>
    <updated>2021-10-27T10:02:05.210Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about using the KVM API.<a id="more"></a></p><h3 id="kvm-hello-world"><a href="#kvm-hello-world" class="headerlink" title="kvm-hello-world"></a>kvm-hello-world</h3><p>首先建议研究下<a href="https://github.com/dpw/kvm-hello-world" target="_blank" rel="noopener">kvm-hello-world</a>这一项目。运行并研究其代码。<br>整体来说比较简单，就是对<code>ioctl(vm-&gt;fd, KVM_SET_TSS_ADDR, 0xfffbd000)</code>这行代码有困惑。搜了下资料，<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt" target="_blank" rel="noopener">Documentation/virtual/kvm/api.txt</a>解释如下:</p><blockquote><p>Capability: KVM_CAP_SET_TSS_ADDR<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: unsigned long tss_address (in)<br>Returns: 0 on success, -1 on error</p><p>This ioctl defines the physical address of a three-page region in the guest physical address space.  The region must be within the first 4GB of the guest physical address space and must not conflict with any memory slot or any mmio address.  The guest may malfunction if it accesses this memory region.</p><p>This ioctl is required on Intel-based hosts.  This is needed on Intel hardware because of a quirk in the virtualization implementation (see the internals documentation when it pops into existence).</p></blockquote><h3 id="LWN-Using-the-KVM-API"><a href="#LWN-Using-the-KVM-API" class="headerlink" title="LWN: Using the KVM API"></a>LWN: Using the KVM API</h3><p><a href="https://lwn.net/Articles/658511/" target="_blank" rel="noopener">LWN: Using the KVM API</a></p><p>好文。值得细细品读。</p><p>Notes 如下:</p><ul><li><a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt" target="_blank" rel="noopener">Documentation/virtual/kvm/api.txt</a></li><li><a href="https://lwn.net/Articles/658512/" target="_blank" rel="noopener">fully functional sample program</a></li><li><code>KVM_EXIT_FAIL_ENTRY</code>: in particular, shows up often when changing the initial conditions of the VM; it indicates that the underlying hardware virtualization mechanism (VT in this case) can’t start the VM because the initial conditions don’t match its requirements.</li><li><code>KVM_EXIT_INTERNAL_ERROR</code> indicates an error from the Linux KVM subsystem rather than from the hardware. </li></ul><h4 id="Additional-KVM-API-features"><a href="#Additional-KVM-API-features" class="headerlink" title="Additional KVM API features"></a>Additional KVM API features</h4><p>Prospective implementers of memory-mapped I/O devices will want to look at the <code>exit_reason</code> <code>KVM_EXIT_MMIO</code>, as well as the <code>KVM_CAP_COALESCED_MMIO</code> extension to reduce vmexits, and the <code>ioeventfd</code> mechanism to process I/O asynchronously.</p><p>For hardware interrupts, see the <code>irqfd</code> mechanism, using the <code>KVM_CAP_IRQFD</code> extension capability. This provides a file descriptor that can inject a hardware interrupt into the KVM virtual machine without stopping it first. A virtual machine may thus write to this from a separate event loop or device-handling thread, and threads running <code>KVM_RUN</code> for a virtual CPU will process that interrupt at the next available opportunity.</p><p>x86 virtual machines will likely want to support <a href="https://en.wikipedia.org/wiki/CPUID" target="_blank" rel="noopener">CPUID</a> and <a href="https://en.wikipedia.org/wiki/Model-specific_register" target="_blank" rel="noopener">model-specific registers (MSRs)</a>, both of which have architecture-specific <code>ioctl()</code>s that minimize vmexits.</p><h4 id="Applications-of-the-KVM-API"><a href="#Applications-of-the-KVM-API" class="headerlink" title="Applications of the KVM API"></a>Applications of the KVM API</h4><p>Other than learning, debugging a virtual machine implementation, or as a party trick, why use <code>/dev/kvm</code> directly?</p><p>Virtual machines like <code>qemu-kvm</code> or <code>kvmtool</code> typically emulate the standard hardware of the target architecture; for instance, a standard x86 PC. While they can support other devices and <a href="https://lwn.net/Articles/580186/" target="_blank" rel="noopener">virtio</a> hardware, if you want to emulate a completely different type of system that shares little more than the instruction set architecture, you might want to implement a new VM instead. And even within an existing virtual machine implementation, authors of a new class of virtio hardware device will want a clear understanding of the KVM API.</p><p>Efforts like <a href="https://github.com/google/novm" target="_blank" rel="noopener">novm</a> and <a href="https://git.kernel.org/cgit/linux/kernel/git/will/kvmtool.git/" target="_blank" rel="noopener">kvmtool</a> use the KVM API to construct a lightweight VM, dedicated to running Linux rather than an arbitrary OS. More recently, the Clear Containers project uses kvmtool to <a href="https://lwn.net/Articles/644675/" target="_blank" rel="noopener">run containers using hardware virtualization</a>.</p><p>Alternatively, a VM need not run an OS at all. A KVM-based VM could instead implement a hardware-assisted sandbox with no virtual hardware devices and no OS, providing arbitrary virtual “hardware” devices as the API between the sandbox and the sandboxing VM.</p><p>While running a full virtual machine remains the primary use case for hardware virtualization, we’ve seen many innovative uses of the KVM API recently, and we can certainly expect more in the future.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about using the KVM API.
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>KVM notes - part1</title>
    <link href="http://liujunming.github.io/2021/10/07/KVM-notes-part1/"/>
    <id>http://liujunming.github.io/2021/10/07/KVM-notes-part1/</id>
    <published>2021-10-07T04:17:17.000Z</published>
    <updated>2021-09-20T16:54:13.524Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about KVM in the full picture.<a id="more"></a></p><h3 id="How-VT-x-KVM-and-QEMU-Work-Together"><a href="#How-VT-x-KVM-and-QEMU-Work-Together" class="headerlink" title="How VT-x, KVM and QEMU Work Together"></a>How VT-x, KVM and QEMU Work Together</h3><p><a href="https://binarydebt.wordpress.com/2018/10/14/intel-virtualisation-how-vt-x-kvm-and-qemu-work-together/" target="_blank" rel="noopener">How VT-x, KVM and QEMU Work Together</a></p><p><img src="/images/2021/10/01.png" alt></p><h3 id="kvm-the-Linux-Virtual-Machine-Monitor"><a href="#kvm-the-Linux-Virtual-Machine-Monitor" class="headerlink" title="kvm: the Linux Virtual Machine Monitor"></a>kvm: the Linux Virtual Machine Monitor</h3><p><a href="https://www.kernel.org/doc/ols/2007/ols2007v1-pages-225-230.pdf" target="_blank" rel="noopener">kvm: the Linux Virtual Machine Monitor</a></p><p><img src="/images/2021/10/04.png" alt></p><p><img src="/images/2021/10/2.png" alt></p><p><img src="/images/2021/10/3.png" alt></p><h3 id="Architecture-of-the-Kernel-based-Virtual-Machine-KVM-2010"><a href="#Architecture-of-the-Kernel-based-Virtual-Machine-KVM-2010" class="headerlink" title="Architecture of the Kernel-based Virtual Machine (KVM), 2010"></a>Architecture of the Kernel-based Virtual Machine (KVM), 2010</h3><p><a href="http://www.linux-kongress.org/2010/slides/KVM-Architecture-LK2010.pdf" target="_blank" rel="noopener">Architecture of the Kernel-based Virtual Machine (KVM), 2010</a></p><p><img src="/images/2021/10/05.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about KVM in the full picture.
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解DMA part2</title>
    <link href="http://liujunming.github.io/2021/09/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3DMA-part2/"/>
    <id>http://liujunming.github.io/2021/09/13/深入理解DMA-part2/</id>
    <published>2021-09-13T11:06:35.000Z</published>
    <updated>2021-09-13T11:55:25.945Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍DMA controller的相关知识点。<br><a id="more"></a></p><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><h4 id="1-1-Third-party"><a href="#1-1-Third-party" class="headerlink" title="1.1 Third-party"></a>1.1 Third-party</h4><p>Standard DMA, also called third-party DMA, uses a DMA controller. A DMA controller can generate memory addresses and initiate memory read or write cycles. It contains several hardware registers that can be written and read by the CPU. These include a memory address register, a byte count register, and one or more control registers. Depending on what features the DMA controller provides, these control registers might specify some combination of the source, the destination, the direction of the transfer (reading from the I/O device or writing to the I/O device), the size of the transfer unit, and/or the number of bytes to transfer in one burst.</p><p>To carry out an input, output or memory-to-memory operation, the host processor initializes the DMA controller with a count of the number of words to transfer, and the memory address to use. The CPU then commands the peripheral device to initiate a data transfer. The DMA controller then provides addresses and read/write control lines to the system memory. Each time a byte of data is ready to be transferred between the peripheral device and memory, the DMA controller increments its internal address register until the full block of data is transferred.</p><h4 id="1-2-Bus-mastering"><a href="#1-2-Bus-mastering" class="headerlink" title="1.2 Bus mastering"></a>1.2 Bus mastering</h4><p>In a bus mastering system, also known as a first-party DMA system, the CPU and peripherals can each be granted control of the memory bus. Where a peripheral can become a bus master, it can directly write to system memory without the involvement of the CPU, providing memory address and control signals as required. Some measures must be provided to put the processor into a hold condition so that bus contention does not occur</p><h3 id="2-Real-world-DMA-Controllers"><a href="#2-Real-world-DMA-Controllers" class="headerlink" title="2. Real-world DMA Controllers"></a>2. Real-world DMA Controllers</h3><p><img src="/images/2021/09/15.png" alt><br>DMA channels are system pathways used by many devices to transfer information directly to and from memory.</p><h4 id="2-1-DMA-channels"><a href="#2-1-DMA-channels" class="headerlink" title="2.1 DMA channels"></a>2.1 DMA channels</h4><p>To find out what DMA channels your system uses, you can use the cat <code>/proc/dma</code> command:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/dma</span><br><span class="line"> 4: cascade</span><br></pre></td></tr></table></figure></p><p><img src="/images/2021/09/14.png" alt><br>这里的DMA channels可不用深究，了解即可。</p><h3 id="3-Bus-Mastering-DMA"><a href="#3-Bus-Mastering-DMA" class="headerlink" title="3. Bus Mastering DMA"></a>3. Bus Mastering DMA</h3><p><img src="/images/2021/09/16.png" alt></p><p><img src="/images/2021/09/17.png" alt></p><hr><p>参考资料:</p><ol><li><a href="https://ucilnica.fri.uni-lj.si/pluginfile.php/168345/mod_resource/content/0/ORS_book-DMA.pdf" target="_blank" rel="noopener">Basic Components Of a Computer System</a></li><li><a href="https://en.wikipedia.org/wiki/Direct_memory_access" target="_blank" rel="noopener">Direct memory access wikipedia</a></li><li><a href="https://www.angelfire.com/scifi/hardware/ref/sys-dma.htm" target="_blank" rel="noopener">Direct Memory Access (DMA) Channels</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍DMA controller的相关知识点。&lt;br&gt;
    
    </summary>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/categories/I-O%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解DMA part1</title>
    <link href="http://liujunming.github.io/2021/09/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3DMA-part1/"/>
    <id>http://liujunming.github.io/2021/09/12/深入理解DMA-part1/</id>
    <published>2021-09-12T08:06:21.000Z</published>
    <updated>2021-09-12T10:38:12.354Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍DMA的基础概念和use interface from system programmer’s perspective。<br><a id="more"></a></p><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><p><img src="/images/2021/09/12.png" alt><br><img src="/images/2021/09/11.png" alt><br><img src="/images/2021/09/13.png" alt></p><h3 id="2-Overview"><a href="#2-Overview" class="headerlink" title="2. Overview"></a>2. Overview</h3><p>Let’s review how a DMA transfer takes place, considering only input transfers to simplify the discussion.</p><p>Data transfer can be triggered in two ways: either the software asks for data (via a function such as <em>read</em>) or the hardware asynchronously pushes data to the system.</p><p>In the first case, the steps involved can be summarized as follows:</p><ol><li>When a process calls <em>read</em>, the driver method allocates a DMA buffer and instructs the hardware to transfer its data into that buffer. The process is put to sleep.</li><li>The hardware writes data to the DMA buffer and raises an interrupt when it’s done.</li><li>The interrupt handler gets the input data, acknowledges the interrupt, and awakens the process, which is now able to read data.</li></ol><p>The second case comes about when DMA is used asynchronously. This happens, for example, with data acquisition devices that go on pushing data even if nobody is reading them. In this case, the driver should maintain a buffer so that a subsequent <em>read</em> call will return all the accumulated data to user space. The steps involved in this kind of transfer are slightly different:</p><ol><li>The hardware raises an interrupt to announce that new data has arrived.</li><li>The interrupt handler allocates a buffer and tells the hardware where to transfer its data.</li><li>The peripheral device writes the data to the buffer and raises another interrupt when it’s done.</li><li>The handler dispatches the new data, wakes any relevant process, and takes care of housekeeping.</li></ol><h3 id="3-A-simple-PCI-DMA-example"><a href="#3-A-simple-PCI-DMA-example" class="headerlink" title="3. A simple PCI DMA example"></a>3. A simple PCI DMA example</h3><p>As an example of how the DMA mappings might be used, we present a simple example of DMA coding for a PCI device. The actual form of DMA operations on the PCI bus is very dependent on the device being driven. Thus, this example does not apply to any real device; instead, it is part of a hypothetical driver called <em>dad</em> (DMA Acquisition Device). A driver for this device might define a transfer function like this:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dad_transfer</span><span class="params">(struct dad_dev *dev, <span class="keyword">int</span> write, <span class="keyword">void</span> *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">dma_addr_t</span> bus_addr;</span><br><span class="line">    <span class="comment">/* Map the buffer for DMA */</span></span><br><span class="line">    dev-&gt;dma_dir = (write ? DMA_TO_DEVICE : DMA_FROM_DEVICE);</span><br><span class="line">    dev-&gt;dma_size = count;</span><br><span class="line">    bus_addr = dma_map_single(&amp;dev-&gt;pci_dev-&gt;dev, buffer, count,</span><br><span class="line">    dev-&gt;dma_dir);</span><br><span class="line">    dev-&gt;dma_addr = bus_addr;</span><br><span class="line">    <span class="comment">/* Set up the device */</span></span><br><span class="line">    writeb(dev-&gt;registers.command, DAD_CMD_DISABLEDMA);</span><br><span class="line">    writeb(dev-&gt;registers.command, write ? DAD_CMD_WR : DAD_CMD_RD);</span><br><span class="line">    writel(dev-&gt;registers.addr, cpu_to_le32(bus_addr));</span><br><span class="line">    writel(dev-&gt;registers.len, cpu_to_le32(count));</span><br><span class="line">    <span class="comment">/* Start the operation */</span></span><br><span class="line">    writeb(dev-&gt;registers.command, DAD_CMD_ENABLEDMA);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>This function maps the buffer to be transferred and starts the device operation. The other half of the job must be done in the interrupt service routine, which looks something like this:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dad_interrupt</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dad_dev</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">dad_dev</span> *) <span class="title">dev_id</span>;</span></span><br><span class="line">    <span class="comment">/* Make sure it's really our device interrupting */</span></span><br><span class="line">    <span class="comment">/* Unmap the DMA buffer */</span></span><br><span class="line">    dma_unmap_single(dev-&gt;pci_dev-&gt;dev, dev-&gt;dma_addr,</span><br><span class="line">    dev-&gt;dma_size, dev-&gt;dma_dir);</span><br><span class="line">    <span class="comment">/* Only now it is safe to access the buffer, copy to user, etc. */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-1-more-detailed-explanation"><a href="#3-1-more-detailed-explanation" class="headerlink" title="3.1 more detailed explanation"></a>3.1 more detailed explanation</h4><p>The steps involved to transfer the data to the device could be summarized as follows :</p><ol><li>Assume that you have the data in a buffer.</li><li>The driver creates a DMA mapping for this buffer (say using <code>pci_alloc_consistent()</code> or the newer <code>dma_alloc_coherent()</code>), and returns the corresponding DMA bus address(physical address).</li><li>This DMA bus address is to be informed to the device. This is done by writing into the correct DMA registers of the device through <code>writel()</code> (assuming that the device registers are memory mapped).</li><li>The device also needs to be informed about the amount of data that is being transferred and such (by writing to the appropriate registers of the device using <code>writel()</code>)</li><li>Now issue the command to the device to start the DMA transactions by writing to one of its control registers (again possibly using <code>writel()</code>).</li><li>Once the data transaction is completed, the device issues an interrupt.</li><li>In the interrupt handler, the driver may unallocate the buffer which was used for transaction and might as well perform DMA unmapping.</li></ol><p>And there you have it. The data is transferred to the device!</p><hr><p>参考资料:</p><ol><li><a href="https://softwareengineering.stackexchange.com/questions/272470/how-does-a-dma-controller-work" target="_blank" rel="noopener">How does a DMA controller work?</a></li><li><a href="https://stackoverflow.com/questions/25161555/dma-and-i-o-memory-region-under-linux" target="_blank" rel="noopener">DMA and I/O memory region under Linux</a></li><li>Linux Device Drivers, Third Edition</li><li>MODERN OPERATING SYSTEMS, FOURTH EDITION by ANDREW S. TANENBAUM</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍DMA的基础概念和use interface from system programmer’s perspective。&lt;br&gt;
    
    </summary>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/categories/I-O%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>How to use Power Management capability to reset PCI device function</title>
    <link href="http://liujunming.github.io/2021/09/12/How-to-use-Power-Management-capability-to-reset-PCI-device-function/"/>
    <id>http://liujunming.github.io/2021/09/12/How-to-use-Power-Management-capability-to-reset-PCI-device-function/</id>
    <published>2021-09-11T17:26:28.000Z</published>
    <updated>2021-09-11T12:51:18.330Z</updated>
    
    <content type="html"><![CDATA[<p>本文将结合spec与kernel代码来介绍：利用Power Management capability to reset PCI device function。<a id="more"></a></p><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>PCIe设备的PM状态:</p><p><img src="/images/2021/09/10.png" alt></p><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><p>核心思想: Put device into D3 state and back into D0 state.</p><p><img src="/images/2021/09/7.PNG" alt></p><ul><li><a href="https://elixir.bootlin.com/linux/v5.10.63/source/drivers/pci/pci.c#L4664" target="_blank" rel="noopener">检查PMCSR的No_Soft_Reset bit</a></li></ul><p><img src="/images/2021/09/8.PNG" alt></p><ul><li><a href="https://elixir.bootlin.com/linux/v5.10.63/source/drivers/pci/pci.c#L4675" target="_blank" rel="noopener">Put device into D3 state</a></li></ul><p><img src="/images/2021/09/9.PNG" alt></p><ul><li><a href="https://elixir.bootlin.com/linux/v5.10.63/source/drivers/pci/pci.c#L4680" target="_blank" rel="noopener">Put device back into D0 state</a></li></ul><hr><p>参考资料:</p><ol><li><a href="http://blog.chinaaet.com/justlxy/p/5100061872" target="_blank" rel="noopener">PCIe扫盲——Power Management概述</a></li><li><a href="https://lekensteyn.nl/files/docs/PCI_Power_Management_12.pdf" target="_blank" rel="noopener">PCI Bus Power Management Interface Specification Revision 1.2 </a></li><li><a href="https://elixir.bootlin.com/linux/v5.10.63/source/drivers/pci/pci.c#L4656" target="_blank" rel="noopener">pci_pm_reset</a></li><li><a href="https://static.lwn.net/2001/0704/a/pcipm-doc.php3" target="_blank" rel="noopener">RFC: PCI Power Management Documentation</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将结合spec与kernel代码来介绍：利用Power Management capability to reset PCI device function。
    
    </summary>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/categories/PCI-PCIe/"/>
    
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
  </entry>
  
</feed>
