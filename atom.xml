<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2022-10-16T13:27:43.233Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>posted interrupt的一些思考</title>
    <link href="http://liujunming.github.io/2022/10/16/posted-interrupt%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://liujunming.github.io/2022/10/16/posted-interrupt的一些思考/</id>
    <published>2022-10-16T10:36:36.000Z</published>
    <updated>2022-10-16T13:27:43.233Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录一些对posted interrupt的思考。<a id="more"></a> </p><p>本文参考的内核版为<a href="https://elixir.bootlin.com/linux/v5.18/source" target="_blank" rel="noopener">v5.18</a></p><h3 id="1-irqfd亦可使用posted-interrupt"><a href="#1-irqfd亦可使用posted-interrupt" class="headerlink" title="1. irqfd亦可使用posted interrupt"></a>1. irqfd亦可使用posted interrupt</h3><p><a href="/2021/10/27/Dive-into-irqfd-KVM-side-mechanism/">irqfd</a>其实也可以使用VT-x posted interrupt来避免interrupt acceptance的一次VM Exit。</p><h4 id="1-1-kvm-arch-set-irq-inatomic"><a href="#1-1-kvm-arch-set-irq-inatomic" class="headerlink" title="1.1 kvm_arch_set_irq_inatomic"></a>1.1 kvm_arch_set_irq_inatomic</h4><blockquote><p>QEMU写了<code>irqfd</code>后，KVM内核模块中的irqfd poll就收到一个<code>POLL_IN</code>事件，然后将MSIx中断自动投递给对应的LAPIC。 大致流程是：<code>POLL_IN</code> -&gt; <code>kvm_arch_set_irq_inatomic</code> -&gt; <code>kvm_set_msi_irq</code>, <code>kvm_irq_delivery_to_apic_fast</code></p></blockquote><p><a href="https://elixir.bootlin.com/linux/v5.18/source/arch/x86/kvm/irq_comm.c#L157" target="_blank" rel="noopener">kvm_arch_set_irq_inatomic</a>最终会调用<a href="https://elixir.bootlin.com/linux/v5.18/source/arch/x86/kvm/lapic.c#L1015" target="_blank" rel="noopener">kvm_irq_delivery_to_apic_fast</a>来给guest注入interrupt。</p><h4 id="1-2-kvm-irq-delivery-to-apic-fast"><a href="#1-2-kvm-irq-delivery-to-apic-fast" class="headerlink" title="1.2 kvm_irq_delivery_to_apic_fast"></a>1.2 kvm_irq_delivery_to_apic_fast</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kvm_irq_delivery_to_apic_fast</span><br><span class="line">        kvm_apic_set_irq</span><br><span class="line">                __apic_accept_irq</span><br><span class="line">                        vmx_deliver_interrupt</span><br><span class="line">                                vmx_deliver_posted_interrupt</span><br><span class="line">                                        kvm_vcpu_trigger_posted_interrupt</span><br></pre></td></tr></table></figure><h3 id="2-为什么要设置WNV-in-VT-d-posted-interrupt"><a href="#2-为什么要设置WNV-in-VT-d-posted-interrupt" class="headerlink" title="2. 为什么要设置WNV in VT-d posted interrupt"></a>2. 为什么要设置WNV in VT-d posted interrupt</h3><p><a href="https://elixir.bootlin.com/linux/v5.18/source/arch/x86/kvm/vmx/posted_intr.c#L163" target="_blank" rel="noopener">new.nv = POSTED_INTR_WAKEUP_VECTOR</a></p><p>在vCPU调度的过程中，vCPU会有如下三种状态:</p><ol><li>当vCPU被scheduler选中来运行的时候，此时vCPU的状态为’active’。</li><li>当vCPU被抢占（Preempted），例如时间片到期了，此时vCPU的状态为’ready-to-run’。</li><li>当vCPU执行了hlt指令或者触发了ple，hv也会干预进来将vCPU给block出来，此时vCPU状态为’halted ‘。</li></ol><p>hv需要为每个vCPU分配物理中断vector:<br>第一个称作Active Notification Vector（ANV），该Vector对应到vCPU的状态为active时，Notification Event所使用的中断vector(需要设置VMCS的posted-interrupt notification vector为ANV)。</p><p>第二个称作Wake-up Notification Vector（WNV），该Vector对应到目标vCPU不在当前物理CPU上执行时，由于Urgent被置起来产生的Notification Event所使用的中断Vector。</p><blockquote><p>在active状态下，PID.NV的值就是ANV。在ready-to-run或者halted状态下，PID.NV的值就是WNV。这里的ANV和WNV可以是同一个值。</p></blockquote><p>当vCPU处于ready-to-run或者halted状态时，物理中断来了，此时IOMMU会发生WNV来唤醒vCPU来运行。<br>值得注意的是: WNV是IOMMU发送的，而非软件。</p><h3 id="3-在虚拟化下，lapic-timer可以用VT-x-posted-interrupt呢？"><a href="#3-在虚拟化下，lapic-timer可以用VT-x-posted-interrupt呢？" class="headerlink" title="3. 在虚拟化下，lapic timer可以用VT-x posted interrupt呢？"></a>3. 在虚拟化下，lapic timer可以用VT-x posted interrupt呢？</h3><p>在虚拟化场景下，假设vCPU与pCPU一一绑定，那么，lapic timer可以使用VT-x posted interrupt吗？<br>在KVM架构下，答案是否定的，分析如下:<br><img src="/images/2022/10/12.jpg" alt><br>当前是设置了External-interrupt exiting这个位的。当vCPU在non-root mode，此时物理的lapic timer的中断来了，那么就会导致VM Exit，此时使用VT-x posted interrupt已经没有意义了。</p><p><a href="/2022/09/11/LAPIC-Implement-Exitless-Timer/">Injection Exitless LAPIC Timer</a>的Idea是offload lapic timer to housekeeping cpus，然后由housekeeping cpu利用VT-x posted interrupt为vCPU注入中断！</p><h3 id="4-apic-accept-irq"><a href="#4-apic-accept-irq" class="headerlink" title="4. __apic_accept_irq"></a>4. __apic_accept_irq</h3><p><a href="https://elixir.bootlin.com/linux/v5.18/source/arch/x86/kvm/lapic.c#L1098" target="_blank" rel="noopener">__apic_accept_irq</a>其实就会使用VT-x的posted interrupt完成中断的注入。</p><p><code>KVM_SIGNAL_MSI</code>、<code>KVM_IRQ_LINE</code>等ioctl其实会在KVM中调用<code>__apic_accept_irq</code>函数，因此，最终会使用到posted interrupt来完成虚拟中断的注入。</p><p>根据我的理解(待实验验证)，在VNC中的鼠标键盘操作，其实本质上是给虚拟机注入中断，对于这种中断，也是可以使用posted interrupt的。</p><hr><p>参考资料:</p><ol><li><a href="https://kernelgo.org/virtio-overview.html" target="_blank" rel="noopener">Virtio Spec Overview</a></li><li><a href="https://biscuitos.github.io/blog/Broiler-vInterrupt/" target="_blank" rel="noopener">Broiler Interrupt Virtualization Technology</a></li><li><a href="https://martins3.github.io/qemu/interrupt.html" target="_blank" rel="noopener">QEMU 如何模拟中断</a></li><li><a href="https://www.binss.me/blog/qemu-note-of-interrupt/" target="_blank" rel="noopener">QEMU学习笔记——中断</a></li><li><a href="https://blog.csdn.net/weixin_43780260/article/details/110224589" target="_blank" rel="noopener">QEMU 如何处理PCI设备的中断（二）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录一些对posted interrupt的思考。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>bytedance trace-irqoff tool</title>
    <link href="http://liujunming.github.io/2022/10/15/bytedance-trace-irqoff-tool/"/>
    <id>http://liujunming.github.io/2022/10/15/bytedance-trace-irqoff-tool/</id>
    <published>2022-10-15T11:44:40.000Z</published>
    <updated>2022-10-16T10:56:59.862Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/ByteDanceTech/article/details/105632131" target="_blank" rel="noopener">Trace-irqoff</a><br><a href="https://github.com/bytedance/trace-irqoff/tree/master" target="_blank" rel="noopener">Open Source Repo</a><br><a id="more"></a> </p><p><img src="/images/2022/10/10.jpg" alt></p><p><img src="/images/2022/10/11.jpg" alt></p><p>个人总结: </p><ul><li>对于hardirq的关闭检测，是通过定期的hrtimer来判断的，hrtimer执行的上下文就是hardirq，利用相邻两次hrtimer的时间间隔来评估hardirq的关闭时间</li><li>对于softirq，是利用普通的定时器timer(执行的上下文就是softirq)两次执行的时间间隔来采样两次相邻softirq之间的时间间隔，因此检测的不仅仅是softirq的关闭时间。当第二次的timer执行在ksoftirqd进程时，打印出的堆栈就没有意义了，此时，利用hrtimer(在hardirq上下文中)来记录softirq多长时间没有得到执行</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ByteDanceTech/article/details/105632131&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Trace-irqoff&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/bytedance/trace-irqoff/tree/master&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Open Source Repo&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Notes about linux swapper task</title>
    <link href="http://liujunming.github.io/2022/10/09/Notes-about-linux-swapper-task/"/>
    <id>http://liujunming.github.io/2022/10/09/Notes-about-linux-swapper-task/</id>
    <published>2022-10-09T10:13:02.000Z</published>
    <updated>2022-10-11T13:44:01.051Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about linux swapper task.<a id="more"></a> </p><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>The swapper task is the task running, if no other task is runnable. It has the lowest possible priority, so that’s why it’s running if no other task is runnable.</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><h4 id="Programmatic-reason"><a href="#Programmatic-reason" class="headerlink" title="Programmatic reason"></a>Programmatic reason</h4><p>This simplifies process scheduling a lot, because you don’t have to care about the special case: “What happens if no task is runnable?”, because there always is at least one task runnable, the idle task. Also you can count the amount of cpu time used per task. Without the idle task, which task gets the cpu-time accounted no one needs?</p><h4 id="Historical-reason"><a href="#Historical-reason" class="headerlink" title="Historical reason"></a>Historical reason</h4><p>Before we had cpus which are able to step-down or go into power saving modes, it had to run on full speed at any time. It ran a series of NOP-instructions, if no tasks were runnable. Today the scheduling of the idle task usually steps down the cpu by using HLT-instructions (halt), so power is saved. So there is a functionality somehow in the idle task in our days.</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>How can you believe that swapper (PID 0) even exists? if you can’t see it using <code>ps</code>. I am going to use <code>bpftrace</code> for demonstrating that. In the demo I am going to trace the kernel function <code>hrtimer_wakeup</code> which is responsible for waking up a process and move it to the set of runnable processes. During the trace I am going to print the pid of the calling process and the executable name (the comm field of the task_struct [/include/linux/sched.h]). Here is the command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bpftrace -e ‘kfunc:hrtimer_wakeup &#123; printf(“%s:%d\n”,curtask-&gt;comm,curtask-&gt;pid); &#125;’</span><br></pre></td></tr></table></figure><p>From the output we can see we have 3 instances of swapper: swapper/0, swapper/1 and swapper/2 all of them with PID 0. The reason we have three is because my VM has 3 virtual CPUs and there is a swapper process for each one of them — see the output of the command in the image below.</p><p><img src="/images/2022/10/09.jpeg" alt></p><hr><p>参考资料:</p><ol><li><a href="https://stackoverflow.com/questions/464483/why-do-we-need-a-swapper-task-in-linux" target="_blank" rel="noopener">Why do we need a swapper task in linux?</a></li><li><a href="https://programming.vip/docs/deep-understanding-of-swapper-processes-in-perf-reports.html" target="_blank" rel="noopener">Deep understanding of swapper processes in perf reports</a></li><li><a href="https://medium.com/@boutnaru/the-linux-process-journey-pid-0-swapper-7868d1131316" target="_blank" rel="noopener">The Linux Process Journey — PID 0 (swapper)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about linux swapper task.
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel dump_pagetable function</title>
    <link href="http://liujunming.github.io/2022/10/06/Linux-kernel-dump-pagetable-function/"/>
    <id>http://liujunming.github.io/2022/10/06/Linux-kernel-dump-pagetable-function/</id>
    <published>2022-10-06T12:26:48.000Z</published>
    <updated>2022-10-06T12:58:10.525Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux内核中，可以使用<code>dump_pagetable</code>函数来dump虚拟地址对应的页表信息。</p><p><a href="https://elixir.bootlin.com/linux/v5.19/source/arch/x86/mm/fault.c#L348" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.19/source/arch/x86/mm/fault.c#L348</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux内核中，可以使用&lt;code&gt;dump_pagetable&lt;/code&gt;函数来dump虚拟地址对应的页表信息。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://elixir.bootlin.com/linux/v5.19/source/arch/x86/mm/fa
      
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>如何获得内核函数地址</title>
    <link href="http://liujunming.github.io/2022/10/06/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80/"/>
    <id>http://liujunming.github.io/2022/10/06/如何获得内核函数地址/</id>
    <published>2022-10-06T11:38:23.000Z</published>
    <updated>2022-10-11T13:44:01.052Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容主要转载自<a href="https://blog.csdn.net/gatieme/article/details/78310036" target="_blank" rel="noopener">获得内核函数地址的四种方法</a>。<a id="more"></a> </p><p>本文以获取内核函数<code>vfs_read()</code>的地址为例。</p><h2 id="1-从-System-map-文件中直接得到地址"><a href="#1-从-System-map-文件中直接得到地址" class="headerlink" title="1. 从 System.map 文件中直接得到地址"></a>1. 从 System.map 文件中直接得到地址</h2><p>内核镜像的<code>System.map</code>文件存储了内核符号表的信息, 可以通过此文件获取到具体的信息。</p><p>查看内核函数的地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grep vfs_read /boot/System.map-`uname -r`</span><br></pre></td></tr></table></figure></p><h2 id="2-从-proc-kallsyms-文件获得地址"><a href="#2-从-proc-kallsyms-文件获得地址" class="headerlink" title="2. 从 /proc/kallsyms 文件获得地址"></a>2. 从 /proc/kallsyms 文件获得地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms | grep vfs_read</span><br></pre></td></tr></table></figure><p><img src="/images/2022/10/08.jpg" alt></p><h2 id="3-使用内核函数接口"><a href="#3-使用内核函数接口" class="headerlink" title="3. 使用内核函数接口"></a>3. 使用内核函数接口</h2><h3 id="3-1-已知内核符号，获取内核符号地址"><a href="#3-1-已知内核符号，获取内核符号地址" class="headerlink" title="3.1 已知内核符号，获取内核符号地址"></a>3.1 已知内核符号，获取内核符号地址</h3><p>使用 <code>kallsyms_lookup_name()</code>。</p><p>该函数在 <code>kernel/kallsyms.c</code> 文件中定义的, 要使用它必须启用 <code>CONFIG_KALLSYMS</code> 编译内核.</p><p><code>kallsyms_lookup_name()</code> 接受一个字符串格式内核函数名, 返回那个内核函数的地址.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kallsyms_lookup_name(<span class="string">"函数名"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="3-2-已知内核符号地址-获取内核符号名"><a href="#3-2-已知内核符号地址-获取内核符号名" class="headerlink" title="3.2 已知内核符号地址, 获取内核符号名"></a>3.2 已知内核符号地址, 获取内核符号名</h3><p>使用 <code>sprint_symbol</code> 内核函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kallsyms.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprint_symbol</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br></pre></td></tr></table></figure></p><p>该函数根据一个内存中的地址 <code>address</code> 查找一个内核符号, 并将该符号的基本信息, 如符号名 <code>name</code>, 它在内核符号表中的偏移 <code>offset</code> 和大小 <code>size</code>, 所属的模块名(如果有的话)等信息连接成字符串赋值给文本缓冲区 <code>buffer</code>. 其中所查找的内核符号可以是原本就存在于内核中的符号, 也可以是位于动态插入的模块中的符号.</p><hr><p>参考资料:</p><ol><li><a href="https://blog.csdn.net/gatieme/article/details/78310036" target="_blank" rel="noopener">获得内核函数地址的四种方法</a></li><li><a href="https://blog.csdn.net/qq_34258344/article/details/103547971" target="_blank" rel="noopener">如何使用Linux内核中没有被导出的变量或函数</a></li><li><a href="http://kerneltravel.net/blog/2020/syscall_ljr_1/" target="_blank" rel="noopener">LINUX使用内核模块添加系统调用的方法（无需编译内核）</a></li><li><a href="https://developer.aliyun.com/article/53679" target="_blank" rel="noopener">linux内核符号表kallsyms简介</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容主要转载自&lt;a href=&quot;https://blog.csdn.net/gatieme/article/details/78310036&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;获得内核函数地址的四种方法&lt;/a&gt;。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux watch命令</title>
    <link href="http://liujunming.github.io/2022/10/05/Linux-watch-command/"/>
    <id>http://liujunming.github.io/2022/10/05/Linux-watch-command/</id>
    <published>2022-10-05T13:10:29.000Z</published>
    <updated>2022-10-05T13:59:49.981Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark watch命令相关notes。<a id="more"></a> </p><p>watch命令以周期性的方式执行给定的指令，指令输出以全屏方式显示。watch是一个非常实用的命令，基本所有的Linux发行版都带有这个小工具，如同名字一样，watch可以帮你监测一个命令的运行结果，省得你一遍遍的手动运行。</p><p>下面将介绍下watch命令的一个用例。</p><p>在虚拟化环境下，如何确认TLB shootdown是引起性能下降的因素之一？<br>在 Guest 中执行：<br><code>watch -d -n 1 &quot;cat /proc/interrupts | grep TLB&quot;</code></p><p>如果看到数据上涨比较厉害，那么基本就可以看到问题了。</p><hr><p>参考资料:</p><ol><li><a href="https://man7.org/linux/man-pages/man1/watch.1.html" target="_blank" rel="noopener">man</a></li><li><a href="https://wangchujiang.com/linux-command/c/watch.html" target="_blank" rel="noopener">watch</a></li><li><a href="https://blog.csdn.net/ByteDanceTech/article/details/104765810" target="_blank" rel="noopener">深入理解 Linux 内核–jemalloc 引起的 TLB shootdown 及优化</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark watch命令相关notes。
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 中 2＞&amp;1 详解</title>
    <link href="http://liujunming.github.io/2022/10/05/Linux-%E4%B8%AD-2%EF%BC%9E-1-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://liujunming.github.io/2022/10/05/Linux-中-2＞-1-详解/</id>
    <published>2022-10-05T08:20:30.000Z</published>
    <updated>2022-10-05T08:37:46.919Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自: <a href="https://blog.csdn.net/icanlove/article/details/38018169" target="_blank" rel="noopener">Linux 中 2＞&amp;1 详解</a><a id="more"></a> </p><h3 id="1和2在Linux中的含义"><a href="#1和2在Linux中的含义" class="headerlink" title="1和2在Linux中的含义"></a>1和2在Linux中的含义</h3><p>在Linux系统中0 1 2是一个文件描述符：<br>标准的输入，输出和错误输出分别表示为STDIN,STDOUT,STDERR，也可以用0，1，2来表示。<br>整理成表格如下：<br><img src="/images/2022/10/06.jpg" alt></p><p>其中0表示键盘输入 1表示屏幕输出 2表示错误输出。</p><h3 id="2-gt-amp-1的含义"><a href="#2-gt-amp-1的含义" class="headerlink" title="2&gt;&amp;1的含义"></a>2&gt;&amp;1的含义</h3><p>2&gt;&amp;1的含义：将标准错误输出重定向到标准输出。<br>注意：符号&gt;&amp;是一个整体，不可分开，分开后就不是上述含义了。</p><p><code>strace -f -p 1510 2&gt;&amp;1 | grep madvise</code></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/images/2022/10/07.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自: &lt;a href=&quot;https://blog.csdn.net/icanlove/article/details/38018169&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux 中 2＞&amp;amp;1 详解&lt;/a&gt;
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Notes about strace</title>
    <link href="http://liujunming.github.io/2022/10/05/Notes-about-strace/"/>
    <id>http://liujunming.github.io/2022/10/05/Notes-about-strace/</id>
    <published>2022-10-05T02:20:51.000Z</published>
    <updated>2022-10-05T08:13:42.572Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录strace相关笔记。<a id="more"></a> </p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>strace is a diagnostic, debugging and instructional userspace utility for Linux. It is used to monitor and tamper with interactions between processes and the Linux kernel, which include system calls, signal deliveries, and changes of process state.</p><p>System administrators, diagnosticians and trouble-shooters will find it invaluable for solving problems with programs for which the source is not readily available since they do not need to be recompiled in order to trace them.</p><p>The operation of strace is made possible by the kernel feature known as <code>ptrace</code>.</p><p><img src="/images/2022/10/05.jpg" alt></p><blockquote><p>strace解决的问题都是关于寻找程序依赖的文件、找出程序卡住或慢的原因、或者找出程序失败的原因。</p></blockquote><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p><a href="https://man7.org/linux/man-pages/man1/strace.1.html" target="_blank" rel="noopener">man strace</a><br><a href="https://nanxiao.github.io/strace-little-book/" target="_blank" rel="noopener">Strace little book</a></p><p><img src="/images/2022/10/04.jpg" alt></p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><ul><li><p>Print stack trace of every system call<br><code>-k</code> option is used to print stack trace of every system call.<br><a href="https://nanxiao.github.io/strace-little-book/posts/print-stack-trace-of-every-system-call.html" target="_blank" rel="noopener">Print stack trace of every system call</a></p></li><li><p><code>-f</code>跟踪目标进程，以及目标进程创建的所有子进程</p></li><li><p><code>-t</code> 在输出中的每一行前加上时间信息(<code>-tt</code> 表示微秒级)</p></li><li><p><code>-T</code> 显示每个系统调用所耗的时间</p></li><li><p><code>-o</code> filename: Write the trace output to the file filename rather than to stderr.</p></li><li><p><code>-c</code> Count time, calls, and errors for each system call and report a summary on program exit, suppressing the regular output. </p></li></ul><h3 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h3><ul><li><a href="https://blog.csdn.net/joeyon1985/article/details/72986412" target="_blank" rel="noopener">手把手教你用Strace诊断问题</a></li><li><a href="https://zhuanlan.zhihu.com/p/180053751" target="_blank" rel="noopener">Linux神器strace的使用方法及实践</a></li><li><a href="https://zhuanlan.zhihu.com/p/362348075" target="_blank" rel="noopener">strace 可以解决什么问题?</a><ul><li>配置文件在哪里？</li><li>这个程序还依赖什么文件？</li><li>为什么这个程序会挂掉？</li><li>这个程序卡住了吗？</li><li>为什么这个程序很慢？</li><li>隐藏的权限错误</li><li>正在使用什么命令行参数？</li><li>为什么这个网络连接失败？</li><li>为什么这个程序以一种方式运行时成功，以另一种方式运行时失败？</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><a href="https://blog.packagecloud.io/how-does-strace-work/" target="_blank" rel="noopener">How does strace work?</a></li></ul><hr><p>参考资料:</p><ol><li><a href="https://www.cnblogs.com/chenxinshuo/p/11986858.html" target="_blank" rel="noopener">Debug 利器：pstack &amp; strace</a></li><li><a href="https://blog.csdn.net/joeyon1985/article/details/72986412" target="_blank" rel="noopener">Linux strace、pstack 命令 使用详解</a></li><li><a href="https://blog.csdn.net/ByteDanceTech/article/details/104765810" target="_blank" rel="noopener">深入理解 Linux 内核–jemalloc 引起的 TLB shootdown 及优化</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录strace相关笔记。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第32期</title>
    <link href="http://liujunming.github.io/2022/10/04/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC32%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2022/10/04/每周分享第32期/</id>
    <published>2022-10-04T08:25:23.000Z</published>
    <updated>2022-10-04T09:35:39.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="七千字详解阿里云新一代云计算体系架构-CIPU"><a href="#七千字详解阿里云新一代云计算体系架构-CIPU" class="headerlink" title="七千字详解阿里云新一代云计算体系架构 CIPU"></a>七千字详解阿里云新一代云计算体系架构 CIPU</h3><p><a href="https://mp.weixin.qq.com/s/OX4Iyu_rOekNiP9hUMzGew" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OX4Iyu_rOekNiP9hUMzGew</a><a id="more"></a> </p><h3 id="Linux-如何测量函数的执行时间"><a href="#Linux-如何测量函数的执行时间" class="headerlink" title="Linux - 如何测量函数的执行时间"></a>Linux - 如何测量函数的执行时间</h3><p><a href="https://zhuanlan.zhihu.com/p/476264071" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/476264071</a></p><ul><li>bpftrace</li><li>bcc-tools</li><li>systemtap</li></ul><h3 id="In-which-conditions-the-ioctl-KVM-RUN-returns"><a href="#In-which-conditions-the-ioctl-KVM-RUN-returns" class="headerlink" title="In which conditions the ioctl KVM_RUN returns?"></a>In which conditions the ioctl KVM_RUN returns?</h3><p><a href="https://stackoverflow.com/questions/65194712/in-which-conditions-the-ioctl-kvm-run-returns" target="_blank" rel="noopener">https://stackoverflow.com/questions/65194712/in-which-conditions-the-ioctl-kvm-run-returns</a><br><img src="/images/2022/10/03.jpg" alt></p><h3 id="陈海波：面向-2030-的操作系统架构与演进思考"><a href="#陈海波：面向-2030-的操作系统架构与演进思考" class="headerlink" title="陈海波：面向 2030 的操作系统架构与演进思考"></a>陈海波：面向 2030 的操作系统架构与演进思考</h3><p><a href="https://mp.weixin.qq.com/s/3k8ro-QahNHsQQXa183VOw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3k8ro-QahNHsQQXa183VOw</a></p><h3 id="英伟达高管交流纪要"><a href="#英伟达高管交流纪要" class="headerlink" title="英伟达高管交流纪要"></a>英伟达高管交流纪要</h3><p><a href="https://xueqiu.com/6846564531/223664454?sharetime=2" target="_blank" rel="noopener">https://xueqiu.com/6846564531/223664454?sharetime=2</a></p><h3 id="他是世界上最杰出的程序员，一个月写了个操作系统，退休后去做飞行员！"><a href="#他是世界上最杰出的程序员，一个月写了个操作系统，退休后去做飞行员！" class="headerlink" title="他是世界上最杰出的程序员，一个月写了个操作系统，退休后去做飞行员！"></a>他是世界上最杰出的程序员，一个月写了个操作系统，退休后去做飞行员！</h3><p><a href="https://mp.weixin.qq.com/s/fUKv2Nfznf5-uExSh3XTfw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fUKv2Nfznf5-uExSh3XTfw</a></p><h3 id="80岁还在写代码！Hello-World发明人、UNIX命名者项目登上GitHub热榜"><a href="#80岁还在写代码！Hello-World发明人、UNIX命名者项目登上GitHub热榜" class="headerlink" title="80岁还在写代码！Hello World发明人、UNIX命名者项目登上GitHub热榜"></a>80岁还在写代码！Hello World发明人、UNIX命名者项目登上GitHub热榜</h3><p><a href="https://mp.weixin.qq.com/s/9HA8a7dQ_xhT0cx4rB5FXg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/9HA8a7dQ_xhT0cx4rB5FXg</a></p><h3 id="github-copilot"><a href="#github-copilot" class="headerlink" title="github copilot"></a>github copilot</h3><p>GitHub Copilot（以下简称Copilot）是近期发布的代码智能生成插件，目前支持VSCode、JetBrains等IDE平台，不同于其他代码补全工具只提供最多一行的补全结果，Copilot能通过代码上下文以及语言描述，生成整个代码片段，无疑是开发者的编码利器。<br><a href="https://www.pc-daily.com/jichu/105890.html" target="_blank" rel="noopener">https://www.pc-daily.com/jichu/105890.html</a></p><h3 id="阿里云张伟丰：基于小芯片的计算架构正在演进成为一个大趋势"><a href="#阿里云张伟丰：基于小芯片的计算架构正在演进成为一个大趋势" class="headerlink" title="阿里云张伟丰：基于小芯片的计算架构正在演进成为一个大趋势"></a>阿里云张伟丰：基于小芯片的计算架构正在演进成为一个大趋势</h3><p><a href="https://mp.weixin.qq.com/s/PwZ4c4ezZXxMIpamuBnM0A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PwZ4c4ezZXxMIpamuBnM0A</a></p><h3 id="deepl"><a href="#deepl" class="headerlink" title="deepl"></a>deepl</h3><p><a href="https://www.deepl.com/translator" target="_blank" rel="noopener">https://www.deepl.com/translator</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;七千字详解阿里云新一代云计算体系架构-CIPU&quot;&gt;&lt;a href=&quot;#七千字详解阿里云新一代云计算体系架构-CIPU&quot; class=&quot;headerlink&quot; title=&quot;七千字详解阿里云新一代云计算体系架构 CIPU&quot;&gt;&lt;/a&gt;七千字详解阿里云新一代云计算体系架构 CIPU&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/OX4Iyu_rOekNiP9hUMzGew&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/OX4Iyu_rOekNiP9hUMzGew&lt;/a&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>perf-tools funcgraph</title>
    <link href="http://liujunming.github.io/2022/10/04/perf-tools-funcgraph/"/>
    <id>http://liujunming.github.io/2022/10/04/perf-tools-funcgraph/</id>
    <published>2022-10-04T05:18:31.000Z</published>
    <updated>2022-10-04T08:17:08.727Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何利用perf-tools的funcgraph traces a graph of kernel function calls, showing children and times。既有助于学习内核源码，也有助于debug。<a id="more"></a> </p><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><p><a href="https://github.com/brendangregg/perf-tools#prerequisites" target="_blank" rel="noopener">https://github.com/brendangregg/perf-tools#prerequisites</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://github.com/brendangregg/perf-tools#install" target="_blank" rel="noopener">https://github.com/brendangregg/perf-tools#install</a></p><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>官方文档:<a href="https://github.com/brendangregg/perf-tools/blob/master/examples/funcgraph_example.txt" target="_blank" rel="noopener">funcgraph_example.txt</a></p><p>文档值得好好研究!</p><p><img src="/images/2022/10/02.jpg" alt></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><a href="https://github.com/brendangregg/perf-tools/blob/master/kernel/funcgraph" target="_blank" rel="noopener">script</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ ./funcgraph </span><br><span class="line">USAGE: funcgraph [-aCDhHPtT] [-m maxdepth] [-p PID] [-L TID] [-d secs] funcstring</span><br><span class="line">                 -a              # all info (same as -HPt)</span><br><span class="line">                 -C              # measure on-CPU time only</span><br><span class="line">                 -d seconds      # trace duration, and use buffers</span><br><span class="line">                 -D              # do not show function duration</span><br><span class="line">                 -h              # this usage message</span><br><span class="line">                 -H              # include column headers</span><br><span class="line">                 -m maxdepth     # max stack depth to show</span><br><span class="line">                 -p PID          # trace when this pid is on-CPU</span><br><span class="line">                 -L TID          # trace when this thread is on-CPU</span><br><span class="line">                 -P              # show process names &amp; PIDs</span><br><span class="line">                 -t              # show timestamps</span><br><span class="line">                 -T              # comment function tails</span><br><span class="line">  eg,</span><br><span class="line">       funcgraph do_nanosleep    # trace do_nanosleep() and children</span><br><span class="line">       funcgraph -m 3 do_sys_open # trace do_sys_open() to 3 levels only</span><br><span class="line">       funcgraph -a do_sys_open    # include timestamps and process name</span><br><span class="line">       funcgraph -p 198 do_sys_open # trace vfs_read() for PID 198 only</span><br><span class="line">       funcgraph -d 1 do_sys_open &gt;out # trace 1 sec, then write to file</span><br><span class="line"></span><br><span class="line">See the man page and example file for more info.</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.ebpf.top/post/no_space_left_on_devices/" target="_blank" rel="noopener">eBPF+Ftrace 合璧剑指：no space left on device?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍如何利用perf-tools的funcgraph traces a graph of kernel function calls, showing children and times。既有助于学习内核源码，也有助于debug。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel task work机制</title>
    <link href="http://liujunming.github.io/2022/10/03/Linux-kernel-task-work%E6%9C%BA%E5%88%B6/"/>
    <id>http://liujunming.github.io/2022/10/03/Linux-kernel-task-work机制/</id>
    <published>2022-10-03T08:11:00.000Z</published>
    <updated>2022-10-03T11:42:28.174Z</updated>
    
    <content type="html"><![CDATA[<p>task work机制可以在内核中向指定的进程添加一些任务函数，这些任务函数会在进程返回用户态时执行，使用的是该进程的上下文。<a id="more"></a> </p><p>本文部分转载自:<a href="https://www.cnblogs.com/lailailai/p/4510982.html" target="_blank" rel="noopener">Linux:task work 机制</a>，内核代码的版本是v4.18。</p><h2 id="1-definition"><a href="#1-definition" class="headerlink" title="1. definition"></a>1. definition</h2><p>进程对象<a href="https://elixir.bootlin.com/linux/v4.18/source/include/linux/sched.h#L874" target="_blank" rel="noopener">task_struct</a>中有个字段用来存储这些待进行的任务列表头即task_works，这个结构体包含一个next指针和需要执行的函数指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct callback_head - callback structure for use with RCU and task_work</span></span><br><span class="line"><span class="comment"> * @next: next update requests in a list</span></span><br><span class="line"><span class="comment"> * @func: actual update function to call after the grace period.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> (*func)(struct callback_head *head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="2-task-work-add"><a href="#2-task-work-add" class="headerlink" title="2. task_work_add"></a>2. task_work_add</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> <span class="title">work_exited</span>;</span> <span class="comment">/* all we need is -&gt;next == NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * task_work_add - ask the @task to execute @work-&gt;func()</span></span><br><span class="line"><span class="comment"> * @task: the task which should run the callback</span></span><br><span class="line"><span class="comment"> * @work: the callback to run</span></span><br><span class="line"><span class="comment"> * @notify: send the notification if true</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Queue @work for task_work_run() below and notify the @task if @notify.</span></span><br><span class="line"><span class="comment"> * Fails if the @task is exiting/exited and thus it can't process this @work.</span></span><br><span class="line"><span class="comment"> * Otherwise @work-&gt;func() will be called when the @task returns from kernel</span></span><br><span class="line"><span class="comment"> * mode or exits.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is like the signal handler which runs in kernel mode, but it doesn't</span></span><br><span class="line"><span class="comment"> * try to wake up the @task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: there is no ordering guarantee on works queued here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURNS:</span></span><br><span class="line"><span class="comment"> * 0 if succeeds or -ESRCH.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">task_work_add(struct task_struct *task, struct callback_head *work, <span class="keyword">bool</span> notify)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">head = READ_ONCE(task-&gt;task_works);</span><br><span class="line"><span class="keyword">if</span> (unlikely(head == &amp;work_exited))</span><br><span class="line"><span class="keyword">return</span> -ESRCH;</span><br><span class="line">work-&gt;next = head;</span><br><span class="line">&#125; <span class="keyword">while</span> (cmpxchg(&amp;task-&gt;task_works, head, work) != head);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (notify)</span><br><span class="line">set_notify_resume(task);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要工作：</p><ol><li>通过CAS以无锁的形式添加了一个链表元素。（新元素排在原有链表头部）</li><li><code>set_notify_resume</code>函数向指定的进程设置了一个<code>_TIF_NOTIFY_RESUME</code>标记。</li></ol><h2 id="3-task-work-run执行时机"><a href="#3-task-work-run执行时机" class="headerlink" title="3. task_work_run执行时机"></a>3. task_work_run执行时机</h2><h3 id="3-1-with-TIF-NOTIFY-RESUME-flag"><a href="#3-1-with-TIF-NOTIFY-RESUME-flag" class="headerlink" title="3.1 with _TIF_NOTIFY_RESUME flag"></a>3.1 with <code>_TIF_NOTIFY_RESUME</code> flag</h3><h4 id="3-1-1-exit-to-usermode-loop"><a href="#3-1-1-exit-to-usermode-loop" class="headerlink" title="3.1.1 exit_to_usermode_loop"></a>3.1.1 <code>exit_to_usermode_loop</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit_to_usermode_loop</span><span class="params">(struct pt_regs *regs, u32 cached_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (cached_flags &amp; _TIF_NOTIFY_RESUME) &#123;</span><br><span class="line">                clear_thread_flag(TIF_NOTIFY_RESUME);</span><br><span class="line">                tracehook_notify_resume(regs);</span><br><span class="line">                rseq_handle_notify_resume(<span class="literal">NULL</span>, regs);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h4 id="3-1-2-tracehook-notify-resume"><a href="#3-1-2-tracehook-notify-resume" class="headerlink" title="3.1.2 tracehook_notify_resume"></a>3.1.2 <code>tracehook_notify_resume</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tracehook_notify_resume - report when about to return to user mode</span></span><br><span class="line"><span class="comment"> * @regs:user-mode registers of @current task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is called when %TIF_NOTIFY_RESUME has been set.  Now we are</span></span><br><span class="line"><span class="comment"> * about to return to user mode, and the user state in @regs can be</span></span><br><span class="line"><span class="comment"> * inspected or adjusted.  The caller in arch code has cleared</span></span><br><span class="line"><span class="comment"> * %TIF_NOTIFY_RESUME before the call.  If the flag gets set again</span></span><br><span class="line"><span class="comment"> * asynchronously, this will be called again before we return to</span></span><br><span class="line"><span class="comment"> * user mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Called without locks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tracehook_notify_resume</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The caller just cleared TIF_NOTIFY_RESUME. This barrier</span></span><br><span class="line"><span class="comment"> * pairs with task_work_add()-&gt;set_notify_resume() after</span></span><br><span class="line"><span class="comment"> * hlist_add_head(task-&gt;task_works);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">smp_mb__after_atomic();</span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;task_works))</span><br><span class="line">task_work_run();</span><br><span class="line"></span><br><span class="line">mem_cgroup_handle_over_high();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进程对象的task_works不为null的情况下才有任务需要执行。</p><h3 id="3-2-without-TIF-NOTIFY-RESUME-flag"><a href="#3-2-without-TIF-NOTIFY-RESUME-flag" class="headerlink" title="3.2 without _TIF_NOTIFY_RESUME flag"></a>3.2 without <code>_TIF_NOTIFY_RESUME</code> flag</h3><ul><li><code>get_signal</code>执行<code>task_work_run</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行task work机制中的work</span></span><br><span class="line"><span class="comment">// 这是和信号无关的机制，属于搭便车在ret_to_user时刻去执行的机制</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_signal</span><span class="params">(struct ksignal *ksig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (unlikely(current-&gt;task_works))</span><br><span class="line">task_work_run();</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-task-work-run"><a href="#4-task-work-run" class="headerlink" title="4. task_work_run"></a>4. task_work_run</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * task_work_run - execute the works added by task_work_add()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Flush the pending works. Should be used by the core kernel code.</span></span><br><span class="line"><span class="comment"> * Called before the task returns to the user-mode or stops, or when</span></span><br><span class="line"><span class="comment"> * it exits. In the latter case task_work_add() can no longer add the</span></span><br><span class="line"><span class="comment"> * new work after task_work_run() returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_work_run</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> = <span class="title">current</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">work</span>, *<span class="title">head</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * work-&gt;func() can do task_work_add(), do not set</span></span><br><span class="line"><span class="comment"> * work_exited unless the list is empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">raw_spin_lock_irq(&amp;task-&gt;pi_lock);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">work = READ_ONCE(task-&gt;task_works);</span><br><span class="line">head = !work &amp;&amp; (task-&gt;flags &amp; PF_EXITING) ?</span><br><span class="line">&amp;work_exited : <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (cmpxchg(&amp;task-&gt;task_works, work, head) != work);</span><br><span class="line">raw_spin_unlock_irq(&amp;task-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!work)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">next = work-&gt;next;</span><br><span class="line">work-&gt;func(work);</span><br><span class="line">work = next;</span><br><span class="line">cond_resched();</span><br><span class="line">&#125; <span class="keyword">while</span> (work);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过CAS，以无锁的方式取得<code>task_works</code>链表</li><li>因为原链表是按元素添加到链表的时间逆序排列的（见<code>task_work_add</code>），先把链表反转一遍</li><li>反转链表后，遍历链表，执行各个元素的任务函数即<code>work-&gt;func(work)</code></li></ol><hr><p>参考资料:</p><ol><li><a href="https://www.cnblogs.com/lailailai/p/4510982.html" target="_blank" rel="noopener">Linux:task work 机制</a></li><li><a href="https://kernel.meizu.com/linux-signal.html" target="_blank" rel="noopener">Linux Signal</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;task work机制可以在内核中向指定的进程添加一些任务函数，这些任务函数会在进程返回用户态时执行，使用的是该进程的上下文。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel preempt_notifier</title>
    <link href="http://liujunming.github.io/2022/10/03/Linux-kernel-preempt-notifier/"/>
    <id>http://liujunming.github.io/2022/10/03/Linux-kernel-preempt-notifier/</id>
    <published>2022-10-03T05:05:34.000Z</published>
    <updated>2022-10-03T07:56:11.534Z</updated>
    
    <content type="html"><![CDATA[<p>preempt_notifier本质上是一种<a href="/2019/08/06/Linux-kernel-notifier-chain/">Linux kernel notifier chain</a>，监听的事件是线程被调度出去(例如时间片用完了或者被强占)、线程被重新调度。<a id="more"></a> </p><h2 id="1-线程sched-out"><a href="#1-线程sched-out" class="headerlink" title="1. 线程sched out"></a>1. 线程sched out</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">schedule</span><br><span class="line">        __schedule</span><br><span class="line">                context_switch</span><br><span class="line">                        prepare_task_switch</span><br><span class="line">                                fire_sched_out_preempt_notifiers</span><br><span class="line">                                        __fire_sched_out_preempt_notifiers:</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__fire_sched_out_preempt_notifiers(struct task_struct *curr,</span><br><span class="line">                   struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">preempt_notifier</span> *<span class="title">notifier</span>;</span></span><br><span class="line">    <span class="comment">/*调用curr注册的notifier，通知当前线程被sched out */</span></span><br><span class="line">    hlist_for_each_entry(notifier, &amp;curr-&gt;preempt_notifiers, link)</span><br><span class="line">        notifier-&gt;ops-&gt;sched_out(notifier, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-线程sched-in"><a href="#2-线程sched-in" class="headerlink" title="2. 线程sched in"></a>2. 线程sched in</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">schedule</span><br><span class="line">        __schedule</span><br><span class="line">                context_switch</span><br><span class="line">                        finish_task_switch</span><br><span class="line">                                fire_sched_in_preempt_notifiers</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __fire_sched_in_preempt_notifiers(struct task_struct *curr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">preempt_notifier</span> *<span class="title">notifier</span>;</span></span><br><span class="line">    <span class="comment">/*通知线程sched in  */</span></span><br><span class="line">    hlist_for_each_entry(notifier, &amp;curr-&gt;preempt_notifiers, link)</span><br><span class="line">        notifier-&gt;ops-&gt;sched_in(notifier, raw_smp_processor_id());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-notifier注册"><a href="#3-notifier注册" class="headerlink" title="3. notifier注册"></a>3. notifier注册</h2><p>Linux内核提供API为当前线程注册调度notifier<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_register</span><span class="params">(struct preempt_notifier *notifier)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_unregister</span><span class="params">(struct preempt_notifier *notifier)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_inc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_dec</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * preempt_notifier_register - tell me when current is being preempted &amp; rescheduled</span></span><br><span class="line"><span class="comment"> * @notifier: notifier struct to register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_register</span><span class="params">(struct preempt_notifier *notifier)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!static_key_false(&amp;preempt_notifier_key))</span><br><span class="line">WARN(<span class="number">1</span>, <span class="string">"registering preempt_notifier while notifiers disabled\n"</span>);</span><br><span class="line"></span><br><span class="line">hlist_add_head(&amp;notifier-&gt;link, &amp;current-&gt;preempt_notifiers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-KVM-Example"><a href="#4-KVM-Example" class="headerlink" title="4. KVM Example"></a>4. KVM Example</h2><p>原始<a href="https://lore.kernel.org/kvm/1184169333786-git-send-email-avi@qumranet.com/" target="_blank" rel="noopener">patch</a></p><p><img src="/images/2022/10/01.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __read_mostly <span class="class"><span class="keyword">struct</span> <span class="title">preempt_ops</span> <span class="title">kvm_preempt_ops</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kvm_vm_ioctl_create_vcpu</span><span class="params">(struct kvm *kvm, u32 id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        preempt_notifier_init(&amp;vcpu-&gt;preempt_notifier, &amp;kvm_preempt_ops);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_init</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">unsigned</span> vcpu_size, <span class="keyword">unsigned</span> vcpu_align,</span></span></span><br><span class="line"><span class="function"><span class="params">  struct <span class="keyword">module</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        kvm_preempt_ops.sched_in = kvm_sched_in;</span><br><span class="line">        kvm_preempt_ops.sched_out = kvm_sched_out;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_sched_in</span><span class="params">(struct preempt_notifier *pn, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> = <span class="title">preempt_notifier_to_vcpu</span>(<span class="title">pn</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vcpu-&gt;preempted)</span><br><span class="line">vcpu-&gt;preempted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">kvm_arch_sched_in(vcpu, cpu);</span><br><span class="line"></span><br><span class="line">kvm_arch_vcpu_load(vcpu, cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_sched_out</span><span class="params">(struct preempt_notifier *pn,</span></span></span><br><span class="line"><span class="function"><span class="params">  struct task_struct *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> = <span class="title">preempt_notifier_to_vcpu</span>(<span class="title">pn</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current-&gt;state == TASK_RUNNING)</span><br><span class="line">vcpu-&gt;preempted = <span class="literal">true</span>;</span><br><span class="line">kvm_arch_vcpu_put(vcpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vcpu_load</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        preempt_notifier_register(&amp;vcpu-&gt;preempt_notifier);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.codenong.com/cs105341245/" target="_blank" rel="noopener">Linux内核线程实时获取调度状态的方法</a></li><li><a href="http://www.luo666.com/?p=196" target="_blank" rel="noopener">Linux 内核 schedule时的preemption notify机制</a></li><li><a href="https://elixir.bootlin.com/linux/v4.8/source/include/linux/preempt.h#L255" target="_blank" rel="noopener">Linux kernel preempt_ops</a></li><li><a href="https://lore.kernel.org/kvm/11841693333159-git-send-email-avi@qumranet.com/" target="_blank" rel="noopener">SCHED: Generic hooks for trapping task preemption</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;preempt_notifier本质上是一种&lt;a href=&quot;/2019/08/06/Linux-kernel-notifier-chain/&quot;&gt;Linux kernel notifier chain&lt;/a&gt;，监听的事件是线程被调度出去(例如时间片用完了或者被强占)、线程被重新调度。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Notes about VFIO-User</title>
    <link href="http://liujunming.github.io/2022/09/25/Notes-about-VFIO-User/"/>
    <id>http://liujunming.github.io/2022/09/25/Notes-about-VFIO-User/</id>
    <published>2022-09-25T08:42:41.000Z</published>
    <updated>2022-10-03T07:56:11.535Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark下VFIO-User相关笔记。<a id="more"></a> 建议先观看视频<a href="https://www.bilibili.com/video/BV1t44y177T3/" target="_blank" rel="noopener">刘长鹏-SPDK高性能NVMe虚拟化方案</a>。<br><img src="/images/2022/09/16.jpg" alt></p><p><a href="/pdf/SPDK VFIO-USER虚拟化方案实现介绍.pdf">SPDK VFIO-USER虚拟化方案实现介绍</a></p><p><a href="https://static.sched.com/hosted_files/kvmforum2021/6a/Johnson_Raman_Ufimtseva_Vfio-user.pdf" target="_blank" rel="noopener">VFIO-User:Remote Device Emulation using VFIO</a></p><hr><p>参考资料:</p><ol><li><a href="https://mp.weixin.qq.com/s/vMxm98bQrHhhuBIHyy0aeA" target="_blank" rel="noopener">SPDK VFIO-USER虚拟化方案实现介绍</a></li><li><a href="https://www.youtube.com/watch?v=NBT8rImx3VE" target="_blank" rel="noopener">VFIO User - Using VFIO as the IPC Protocol in Multi-process QEMU - John Johnson &amp; Jagannathan Raman</a></li><li><a href="https://www.bilibili.com/video/BV1t44y177T3/" target="_blank" rel="noopener">刘长鹏-SPDK高性能NVMe虚拟化方案</a></li><li><a href="https://github.com/nutanix/libvfio-user" target="_blank" rel="noopener">libvfio-user</a></li><li><a href="https://spdk.io/news/2021/05/04/vfio-user/" target="_blank" rel="noopener">VFIO-USER: A new virtualization protocol</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark下VFIO-User相关笔记。
    
    </summary>
    
      <category term="VFIO" scheme="http://liujunming.github.io/categories/VFIO/"/>
    
    
      <category term="VFIO" scheme="http://liujunming.github.io/tags/VFIO/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Intel&#39;s Linear Address Masking</title>
    <link href="http://liujunming.github.io/2022/09/12/Notes-about-Intel-s-Linear-Address-Masking/"/>
    <id>http://liujunming.github.io/2022/09/12/Notes-about-Intel-s-Linear-Address-Masking/</id>
    <published>2022-09-12T13:35:56.000Z</published>
    <updated>2022-09-12T14:37:40.988Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about Intel’s Linear Address Masking(LAM).<a id="more"></a> </p><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><p>A 64-bit pointer can address a lot of memory — far more than just about any application could ever need. As a result, there are bits within that pointer that are not really needed to address memory, and which might be put to other needs. Storing a few bits of metadata within a pointer is a common enough use case.</p><h3 id="2-Motivation"><a href="#2-Motivation" class="headerlink" title="2. Motivation"></a>2. Motivation</h3><p>In Intel CPU, 假设使用64 bit pointer(虚拟地址)的57位到62位存放metadata，当想要<a href="https://stackoverflow.com/questions/4955198/what-does-dereferencing-a-pointer-mean" target="_blank" rel="noopener">dereferencing a pointer</a>时：</p><ul><li>Without LAM，软件需要显示地unmask掉pointer的57位到62位，说白了，每次dereferencing时，软件都需要做一个<code>与</code>操作</li><li>With LAM，软件无需unmask掉pointer的57位到62位，硬件直接完成unmask的功能，这样，每次dereferencing时，软件无需<code>与</code>操作了</li></ul><p>通俗地说，LAM的作用是将软件unmask pointer meatadata的功能offload到硬件上了。</p><h3 id="3-Details"><a href="#3-Details" class="headerlink" title="3. Details"></a>3. Details</h3><p>Intel’s LAM feature offers two modes:</p><ul><li><code>LAM_U57</code> allows six bits of metadata in bits 62 to 57.</li><li><code>LAM_U48</code> allows 15 bits of metadata in bits 62 to 48.</li></ul><h4 id="3-1-Why-not-use-bit-64-as-metadata"><a href="#3-1-Why-not-use-bit-64-as-metadata" class="headerlink" title="3.1 Why not use bit 64 as metadata"></a>3.1 Why not use bit 64 as metadata</h4><p>可以带着这个问题去<a href="https://lwn.net/Articles/902094/" target="_blank" rel="noopener">Support for Intel’s Linear Address Masking</a>中寻找答案。</p><h4 id="3-2-LAM-U48与five-level-page-tables的配合使用"><a href="#3-2-LAM-U48与five-level-page-tables的配合使用" class="headerlink" title="3.2 LAM_U48与five-level page tables的配合使用"></a>3.2 <code>LAM_U48</code>与five-level page tables的配合使用</h4><p>说白了，五级页表会使用到<code>LAM_U48</code>中的bit 48到56，因而可能会产生冲突。如何解决这个冲突呢？可以带着这个问题去<a href="https://lwn.net/Articles/902094/" target="_blank" rel="noopener">Support for Intel’s Linear Address Masking</a>中寻找答案。</p><hr><p>参考资料:</p><ol><li><a href="https://lwn.net/Articles/902094/" target="_blank" rel="noopener">Support for Intel’s Linear Address Masking</a></li><li><a href="https://mp.weixin.qq.com/s/xnEGKub5iGacr76tsNhSHg" target="_blank" rel="noopener">LWN：支持Intel线性地址屏蔽功能！</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about Intel’s Linear Address Masking(LAM).
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Injection Exitless LAPIC Timer</title>
    <link href="http://liujunming.github.io/2022/09/11/LAPIC-Implement-Exitless-Timer/"/>
    <id>http://liujunming.github.io/2022/09/11/LAPIC-Implement-Exitless-Timer/</id>
    <published>2022-09-11T03:56:04.000Z</published>
    <updated>2022-09-12T11:14:31.684Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2022/09/13.jpg" alt></p><p><img src="/images/2022/09/14.jpg" alt></p><p><img src="/images/2022/09/15.jpg" alt><br><a id="more"></a><br>建议先阅读<a href="/2022/09/06/Linux中的tick模式/">Linux中的tick模式</a>和<a href="/2022/09/07/isolated-CPU-vs-housekeeping-CPU/">isolated CPU vs housekeeping CPU</a>。</p><p>Dedicated instances are currently disturbed by unnecessary jitter due  to the emulated lapic timers fire on the same pCPUs which vCPUs resident. There is no hardware virtual timer on Intel for guest like ARM. Both  programming timer in guest and the emulated timer fires incur vmexits. This patchset tries to avoid vmexit which is incurred by the emulated  timer fires in dedicated instance scenario. </p><p>When nohz_full is enabled in dedicated instances scenario, the unpinned  timer will be moved to the nearest busy housekeepers after commit 9642d18eee2cd (nohz: Affine unpinned timers to housekeepers) and commit  444969223c8 (“sched/nohz: Fix affine unpinned timers mess”). However, KVM always makes lapic timer pinned to the pCPU which vCPU residents, the reason is explained by commit 61abdbe0 (kvm: x86: make lapic hrtimer pinned). Actually, these emulated timers can be offload to the housekeeping cpus since APICv is really common in recent years. The guest timer interrupt is injected by posted-interrupt which is delivered by housekeeping cpu once the emulated timer fires. </p><p>The host admin should fine tuned, e.g. dedicated instances scenario w/ nohz_full cover the pCPUs which vCPUs resident, several pCPUs surplus for busy housekeeping, disable mwait/hlt/pause vmexits to keep in non-root mode, ~3% redis performance benefit can be observed on Skylake server.</p><hr><p>参考资料:</p><ol><li><a href="https://lore.kernel.org/all/1562376411-3533-1-git-send-email-wanpengli@tencent.com/" target="_blank" rel="noopener">KVM: LAPIC: Implement Exitless Timer</a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/10/01/kvm-performance-2" target="_blank" rel="noopener">Exitless timer</a></li><li><a href="https://static.sched.com/hosted_files/kvmforum2019/e3/Boosting%20Dedicated%20Instances%20by%20KVM%20Tax%20Cut.pdf" target="_blank" rel="noopener">Boosting Dedicated Instance via KVM Tax Cut</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2022/09/13.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2022/09/14.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2022/09/15.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>isolated CPU vs housekeeping CPU</title>
    <link href="http://liujunming.github.io/2022/09/07/isolated-CPU-vs-housekeeping-CPU/"/>
    <id>http://liujunming.github.io/2022/09/07/isolated-CPU-vs-housekeeping-CPU/</id>
    <published>2022-09-07T03:47:39.000Z</published>
    <updated>2022-09-12T11:14:31.684Z</updated>
    
    <content type="html"><![CDATA[<p>An isolated CPU incurs reduced jitter and reduced interruptions by  the  kernel. <a id="more"></a> This  is achived   by   clearing  the  CPU  from  user-space  processes,  movable  kernel  threads, interruption handlers, kernel timers, etc. The only fixed source of interruptions  is  the 1Hz  tick  maintained  by the kernel to keep CPU usage statistics. Otherwise, the incurred jitter and interruptions, if any, depend on the kernel services used by the thread running on  the  isolated  CPU.  Threads  that run a busy loop without doing system calls, such as user-space drivers that access the hardware directly, are only expected to be  interrupted once a second by the 1Hz tick.</p><p>A  housekeeping CPU is the opposite of an isolated CPU. Housekeeping CPUs run all daemons, shell processes, kernel threads, interruption handlers and work  that  can  be  dispatched from isolated CPUs such as disk I/O, RCU work, timers, etc.</p><hr><p>参考资料;</p><ol><li><a href="https://manpages.ubuntu.com/manpages/focal/en/man7/tuned-profiles-cpu-partitioning.7.html" target="_blank" rel="noopener">tuned-profiles-cpu-partitioning</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;An isolated CPU incurs reduced jitter and reduced interruptions by  the  kernel.
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的tick模式</title>
    <link href="http://liujunming.github.io/2022/09/06/Linux%E4%B8%AD%E7%9A%84tick%E6%A8%A1%E5%BC%8F/"/>
    <id>http://liujunming.github.io/2022/09/06/Linux中的tick模式/</id>
    <published>2022-09-06T02:14:19.000Z</published>
    <updated>2022-09-12T11:14:31.684Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<br>Linux中的tick模式 - 兰新宇的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/133211285" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/133211285</a><a id="more"></a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>tick就是周期性的时钟中断，作为OS的心跳，它可以驱动scheduler运转，并且统计相关的运行信息（比如”utime”和”stime”的计算）。<br><img src="/images/2022/09/08.jpg" alt></p><p>根据硬件频率的不同，tick发生的间隔有所不同，比如x86支持100 Hz, 250 Hz和1000 Hz，则对应的间隔分别是10ms, 4ms和1ms。具体选用的数值可通过<code>grep CONFIG_HZ /boot/config-$(uname -r)</code>命令查看。<br><img src="/images/2022/09/09.jpg" alt></p><p>从系统开始启动后经过的ticks被记作”jiffies”，每发生一次时钟中断，jiffies的数值就加上1。<br><img src="/images/2022/09/10.jpg" alt></p><h3 id="dyntick-idle-模式"><a href="#dyntick-idle-模式" class="headerlink" title="dyntick-idle 模式"></a>dyntick-idle 模式</h3><p>当CPU进入idle低功耗模式时，其实是不希望被tick打断的。为此，自2007年的2.6.21版本，可通过<code>CONFIG_NO_HZ_IDLE</code>配置选项（曾用名<code>CONFIG_NO_HZ</code>），于idle模式时关闭tick（不需要HZ）。<br><img src="/images/2022/09/11.jpg" alt></p><p>这种方式有很多种叫法，主流的是”dyntick-idle”，其他还有”nohz”啦，”tickless”啦等等。其带来的收益是功耗的减少，付出的代价则是进入和退出dyntick-idle模式的指令开销，以及需重新填充clock相关的寄存器信息等。<br><img src="/images/2022/09/12.jpg" alt></p><p>除非workload中idle的次数少、时间短，或者不在乎功耗，又对延迟敏感，否则对于大多数场景来说，dyntick-idle的使用都是利大于弊的，因此是目前内核默认采用的tick模式。</p><h3 id="adaptive-ticks-模式"><a href="#adaptive-ticks-模式" class="headerlink" title="adaptive-ticks 模式"></a>adaptive-ticks 模式</h3><p>更进一步，如果一个CPU上只有一个runnable的任务，同样也是不需要tick的。这种需求在2013年的3.10版本被支持，称为”adaptive-ticks”模式，对应的配置选项为<code>CONFIG_NO_HZ_FULL</code>，”full”可理解为1个task在一段时间内完全地占有一个CPU。</p><p>对于需要开启这项功能的CPU，应在内核启动参数中设置，比如<code>nohz_full=1,6-8</code>，就表明CPU 1, 6, 7, 8是adaptive-ticks的，系统运行后不可再动态更改（想更改只能reboot）。</p><p>但要注意的是，即便系统的每个CPU上都只有一个runnable的任务，也不能把全部CPU都设为nohz full模式。这是因为对于处在adaptive-ticks状态的CPU，还是存在任务运行，还是需要使用jiffies或者walltime，因此系统应该至少保留一个CPU来承担timekeeping的工作，被选择作为timekeeper的是负责boot的那个CPU。</p><p>一旦CPU上有新的任务加入进来，那么就又需要tick了，只有一个任务运行的限制似乎显得有些理想化。不过，在一些高性能计算和realtime的场景中，将一个CPU单独拿给一个线程用是完全可能的（就连现在的手机不也动辄都是4核8核么）。</p><p>此外，一个CPU上虽然有多个runnable的任务，但包含的是一个高优先级的SCHED_FIFO任务和多个低优先级的SCHED_OTHER任务，除非这个SCHED_FIFO的任务block，否则它会一直运行，这种情况其实也可以不使用tick。还有就是任务获得的timeslice比较长，也可以考虑在这段时间内暂时关闭tick。</p><p>“dyntick-idle”模式需额外付出的effort对”adaptive-ticks”模式也是存在的，而后者还有一些其他方面的问题。当CPU上唯一runnable的线程从用户态进入内核态执行后，并不会发生task切换，依然满足adaptive-ticks的条件，这就对线程”utime”和”stime”的统计造成了困难。目前，”nohz full”的配置默认是关闭的。</p><hr><p>参考资料:</p><ol><li><a href="https://blog.linuxplumbersconf.org/2013/ocw/system/presentations/1143/original/dynticks-lpc.pdf" target="_blank" rel="noopener">Status of Linux dynticks</a></li><li><a href="https://lwn.net/Articles/549580/" target="_blank" rel="noopener">(Nearly) full tickless operation in 3.10</a></li><li><a href="https://www.kernel.org/doc/Documentation/timers/NO_HZ.txt" target="_blank" rel="noopener">Documentation/timers/NO_HZ.txt</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;br&gt;Linux中的tick模式 - 兰新宇的文章 - 知乎&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/133211285&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/133211285&lt;/a&gt;
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>The relationship between LAPIC timer and TSC</title>
    <link href="http://liujunming.github.io/2022/09/05/The-relationship-between-LAPIC-timer-and-TSC/"/>
    <id>http://liujunming.github.io/2022/09/05/The-relationship-between-LAPIC-timer-and-TSC/</id>
    <published>2022-09-05T11:59:35.000Z</published>
    <updated>2022-09-05T13:20:15.236Z</updated>
    
    <content type="html"><![CDATA[<p>LAPIC timer支持三种mode，TSC是其中的一种mode。<br><a id="more"></a><br><img src="/images/2022/09/05.jpg" alt></p><p><img src="/images/2022/09/06.jpg" alt></p><p><img src="/images/2022/09/07.jpg" alt></p><hr><p>参考资料:</p><ol><li><a href="https://lzz5235.github.io/2016/01/09/apic-timer.html" target="_blank" rel="noopener">浅谈APIC timer</a></li><li><a href="https://wiki.osdev.org/APIC_timer" target="_blank" rel="noopener">APIC timer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LAPIC timer支持三种mode，TSC是其中的一种mode。&lt;br&gt;
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>Notes about ktime accessors</title>
    <link href="http://liujunming.github.io/2022/09/04/Notes-about-ktime-accessors/"/>
    <id>http://liujunming.github.io/2022/09/04/Notes-about-ktime-accessors/</id>
    <published>2022-09-04T02:54:46.000Z</published>
    <updated>2022-09-04T03:00:56.010Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://elixir.bootlin.com/linux/v5.19/source/include/linux/timekeeping.h" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.19/source/include/linux/timekeeping.h</a></p><p><a href="https://www.kernel.org/doc/html/latest/core-api/timekeeping.html" target="_blank" rel="noopener">https://www.kernel.org/doc/html/latest/core-api/timekeeping.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://elixir.bootlin.com/linux/v5.19/source/include/linux/timekeeping.h&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://elixir.bootlin
      
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>How Linux userspace programs get time information</title>
    <link href="http://liujunming.github.io/2022/09/03/How-Linux-userspace-program-get-time-information/"/>
    <id>http://liujunming.github.io/2022/09/03/How-Linux-userspace-program-get-time-information/</id>
    <published>2022-09-03T03:43:30.000Z</published>
    <updated>2022-09-04T10:24:14.706Z</updated>
    
    <content type="html"><![CDATA[<p>本文将汇总Linux用户态程序获取时间的接口，本文内容主要转载自<a href="https://www.cnblogs.com/krythur/archive/2013/02/25/2932647.html?spm=a2c6h.12873639.article-detail.5.50a91861j79vJU" target="_blank" rel="noopener">clock()、time()、clock_gettime()和gettimeofday()函数的用法和区别</a>。<a id="more"></a></p><h3 id="1-clock"><a href="#1-clock" class="headerlink" title="1. clock()"></a>1. clock()</h3><p><a href="https://man7.org/linux/man-pages/man3/clock.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/clock.3.html</a></p><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p><code>clock</code>函数的返回值类型是<code>clock_t</code>,它除以<code>CLOCKS_PER_SEC</code>来得出时间,一般用两次<code>clock</code>函数来计算进程自身运行的时间.</p><p><code>clock</code>有三个问题:</p><ol><li>如果超过一个小时,将要导致溢出.</li><li>函数<code>clock</code>没有考虑CPU被子进程使用的情况.</li><li>也不能区分用户空间和内核空间.</li></ol><p>所以<code>clock</code>函数在linux系统上变得没有意义.</p><h4 id="1-2-测试"><a href="#1-2-测试" class="headerlink" title="1.2 测试"></a>1.2 测试</h4><p>编写程序,测试采用<code>clock</code>函数的输出与<code>time</code>程序的区别.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> i=<span class="number">1000L</span>;</span><br><span class="line">   <span class="keyword">clock_t</span> start, finish;</span><br><span class="line">   <span class="keyword">double</span>  duration;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Time to do %ld empty loops is "</span>, i );</span><br><span class="line">   start = clock();</span><br><span class="line">   <span class="keyword">while</span> (--i)&#123;</span><br><span class="line">    system(<span class="string">"cd"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   finish = clock();</span><br><span class="line">   duration = (<span class="keyword">double</span>)(finish - start) / CLOCKS_PER_SEC;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"%f seconds\n"</span>, duration );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test1.c -o test1</span><br><span class="line">$ time ./test1</span><br><span class="line">Time to do 1000 empty loops is 0.180000 seconds</span><br><span class="line"></span><br><span class="line">real    0m3.492s</span><br><span class="line">user    0m0.512s</span><br><span class="line">sys     0m2.972s</span><br></pre></td></tr></table></figure><h4 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h4><ol><li>程序调用<code>system(&quot;cd&quot;)</code>，这里主要是子进程的消耗,test1程序不能体现这一点.</li><li>0.180000 seconds秒的消耗是两次<code>clock()</code>函数调用除以<code>CLOCKS_PER_SEC</code>.</li><li><code>clock()</code>函数返回值是一个相对时间，而不是绝对时间.</li><li><code>CLOCKS_PER_SEC</code>是系统定义的宏，由GNU标准库定义为1000000.</li></ol><h3 id="2-times"><a href="#2-times" class="headerlink" title="2. times()"></a>2. times()</h3><p><a href="https://man7.org/linux/man-pages/man2/times.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/times.2.html</a></p><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>原型如下：<br><code>clock_t times(struct tms *buf);</code></p><p>tms结构体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span>&#123;</span></span><br><span class="line"> <span class="keyword">clock_t</span> tms_utime;</span><br><span class="line"> <span class="keyword">clock_t</span> tms_stime;</span><br><span class="line"> <span class="keyword">clock_t</span> tms_cutime;</span><br><span class="line"> <span class="keyword">clock_t</span> tms_cstime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>tms_utime</code>记录的是进程执行用户代码的时间.<br><code>tms_stime</code>记录的是进程执行内核代码的时间.<br><code>tms_cutime</code>记录的是子进程执行用户代码的时间.<br><code>tms_cstime</code>记录的是子进程执行内核代码的时间.</p><h4 id="2-2-测试"><a href="#2-2-测试" class="headerlink" title="2.2 测试"></a>2.2 测试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_cmd</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pr_times</span><span class="params">(<span class="keyword">clock_t</span>, struct tms *, struct tms *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; argv[i]!=<span class="literal">NULL</span>; i++)&#123;</span><br><span class="line">                do_cmd(argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_cmd</span><span class="params">(<span class="keyword">char</span> *cmd)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">tmsstart</span>, <span class="title">tmsend</span>;</span></span><br><span class="line">        <span class="keyword">clock_t</span> start, end;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">if</span>((start=times(&amp;tmsstart))== <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"times error"</span>);</span><br><span class="line">        <span class="keyword">if</span>((status=system(cmd))&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"system error"</span>);</span><br><span class="line">        <span class="keyword">if</span>((end=times(&amp;tmsend))== <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"times error"</span>);</span><br><span class="line">        pr_times(end-start, &amp;tmsstart, &amp;tmsend);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pr_times</span><span class="params">(<span class="keyword">clock_t</span> real, struct tms *tmsstart, struct tms *tmsend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">long</span> clktck=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == clktck)</span><br><span class="line">                <span class="keyword">if</span>((clktck=sysconf(_SC_CLK_TCK))&lt;<span class="number">0</span>)</span><br><span class="line">                           <span class="built_in">puts</span>(<span class="string">"sysconf err"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"real:%7.2f\n"</span>, real/(<span class="keyword">double</span>)clktck);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"user-cpu:%7.2f\n"</span>, (tmsend-&gt;tms_utime - tmsstart-&gt;tms_utime)/(<span class="keyword">double</span>)clktck);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"system-cpu:%7.2f\n"</span>, (tmsend-&gt;tms_stime - tmsstart-&gt;tms_stime)/(<span class="keyword">double</span>)clktck);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child-user-cpu:%7.2f\n"</span>, (tmsend-&gt;tms_cutime - tmsstart-&gt;tms_cutime)/(<span class="keyword">double</span>)clktck);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child-system-cpu:%7.2f\n"</span>, (tmsend-&gt;tms_cstime - tmsstart-&gt;tms_cstime)/(<span class="keyword">double</span>)clktck);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test2.c -o test2</span><br><span class="line">$ time ./test2 &quot;dd if=/dev/zero f=/dev/null bs=1M count=10000&quot;</span><br><span class="line">10000+0 records in</span><br><span class="line">10000+0 records out</span><br><span class="line">10485760000 bytes (10 GB) copied, 4.93028 s, 2.1 GB/s</span><br><span class="line">real:   4.94</span><br><span class="line">user-cpu:   0.00</span><br><span class="line">system-cpu:   0.00</span><br><span class="line">child-user-cpu:   0.01</span><br><span class="line">child-system-cpu:   4.82</span><br><span class="line"></span><br><span class="line">real    0m4.943s</span><br><span class="line">user    0m0.016s</span><br><span class="line">sys     0m4.828s</span><br></pre></td></tr></table></figure><h4 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h4><ol><li>通过这个测试,系统的<code>time</code>程序与test2程序输出基本一致了.</li><li><code>(double)clktck</code>是通过<code>clktck=sysconf(_SC_CLK_TCK)</code>来取的,也就是要得到user-cpu所占用的时间,就要用<code>(tmsend-&gt;tms_utime - tmsstart-&gt;tms_utime)/(double)clktck)</code></li><li><code>clock_t times(struct tms *buf)</code>返回值是过去一段时间内时钟嘀嗒的次数.</li><li><code>times()</code>函数返回值也是一个相对时间.</li></ol><h3 id="3-gettimeofday"><a href="#3-gettimeofday" class="headerlink" title="3. gettimeofday()"></a>3. gettimeofday()</h3><p><a href="https://man7.org/linux/man-pages/man2/gettimeofday.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/gettimeofday.2.html</a></p><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p><code>gettimeofday()</code>可以获得当前系统的时间,是一个绝对值</p><p>原型如下：<br><code>int gettimeofday (struct timeval * tv , struct timezone * tz)</code></p><p><code>timeval</code>结型体的原型如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">               <span class="keyword">time_t</span>      tv_sec;    </span><br><span class="line">               <span class="keyword">suseconds_t</span> tv_usec;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>所以它可以精确到微秒</p><h4 id="3-2-测试"><a href="#3-2-测试" class="headerlink" title="3.2 测试"></a>3.2 测试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main()&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">10000000</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tvs</span>,<span class="title">tve</span>;</span></span><br><span class="line">        gettimeofday(&amp;tvs,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span> (--i);</span><br><span class="line">        gettimeofday(&amp;tve,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">double</span> span = tve.tv_sec-tvs.tv_sec + (tve.tv_usec-tvs.tv_usec)/<span class="number">1000000.0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"time: %.12f\n"</span>,span);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test5.c</span><br><span class="line">$ ./a.out</span><br><span class="line">time: 0.041239000000</span><br></pre></td></tr></table></figure><h3 id="4-clock-gettime"><a href="#4-clock-gettime" class="headerlink" title="4. clock_gettime()"></a>4. clock_gettime()</h3><p><a href="https://www.man7.org/linux/man-pages/man3/clock_gettime.3.html" target="_blank" rel="noopener">https://www.man7.org/linux/man-pages/man3/clock_gettime.3.html</a></p><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>原型如下：<br><code>int clock_gettime(clockid_t clk_id, struct timespec *tp);</code></p><p>有以下特点:</p><ol><li><p>有一个时间结构体:<code>timespec</code>,<code>timespec</code>计算时间的精度是ns.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>&#123;</span></span><br><span class="line">        <span class="keyword">time_t</span> tv_sec;</span><br><span class="line">        <span class="keyword">long</span> tv_nsec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>clockid_t</code>确定哪个时钟类型.<br><code>CLOCK_REALTIME</code><br><img src="/images/2022/09/02.jpg" alt><br><code>CLOCK_MONOTONIC</code><br><img src="/images/2022/09/03.jpg" alt><br><code>CLOCK_PROCESS_CPUTIME_ID</code>和<code>CLOCK_THREAD_CPUTIME_ID</code>.<br><img src="/images/2022/09/04.jpg" alt></p></li></ol><h4 id="4-2-测试"><a href="#4-2-测试" class="headerlink" title="4.2 测试:"></a>4.2 测试:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MILLION 1000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">int</span> loop = <span class="number">1000</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tpstart</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tpend</span>;</span></span><br><span class="line">        <span class="keyword">long</span> timedif;</span><br><span class="line"></span><br><span class="line">        clock_gettime(CLOCK_MONOTONIC, &amp;tpstart);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (--loop)&#123;</span><br><span class="line">                system(<span class="string">"cd"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        clock_gettime(CLOCK_MONOTONIC, &amp;tpend);</span><br><span class="line">        timedif = MILLION*(tpend.tv_sec-tpstart.tv_sec)+(tpend.tv_nsec-tpstart.tv_nsec)/<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"it took %ld microseconds\n"</span>, timedif);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test3.c -lrt -o test3</span><br><span class="line"></span><br><span class="line">$ time ./test3</span><br><span class="line">it took 3463843 microseconds</span><br><span class="line"></span><br><span class="line">real    0m3.467s</span><br><span class="line">user    0m0.512s</span><br><span class="line">sys     0m2.936s</span><br></pre></td></tr></table></figure><h3 id="5-比较"><a href="#5-比较" class="headerlink" title="5. 比较"></a>5. 比较</h3><h4 id="5-1-精度"><a href="#5-1-精度" class="headerlink" title="5.1 精度"></a>5.1 精度</h4><ul><li><code>clock()</code>的精度是10毫秒(ms)</li><li><code>times()</code>的精度是10毫秒(ms)</li><li><code>gettimofday()</code>的精度是微秒(μs)</li><li><code>clock_gettime()</code>的精度是纳秒(ns)</li></ul><h4 id="5-2-测试"><a href="#5-2-测试" class="headerlink" title="5.2 测试"></a>5.2 测试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WAIT for(i=0;i&lt;298765432;i++);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MILLION    1000000</span></span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">main ( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> ttt;</span><br><span class="line">    <span class="keyword">clock_t</span> s,e;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">aaa</span>;</span></span><br><span class="line"></span><br><span class="line">    s=clock();</span><br><span class="line">    WAIT;</span><br><span class="line">    e=clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"clock time : %.12f\n"</span>,(e-s)/(<span class="keyword">double</span>)CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> tps = sysconf(_SC_CLK_TCK);</span><br><span class="line">    s=times(&amp;aaa);</span><br><span class="line">    WAIT;</span><br><span class="line">    e=times(&amp;aaa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"times time : %.12f\n"</span>,(e-s)/(<span class="keyword">double</span>)tps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tvs</span>,<span class="title">tve</span>;</span></span><br><span class="line">    gettimeofday(&amp;tvs,<span class="literal">NULL</span>);</span><br><span class="line">    WAIT;</span><br><span class="line">    gettimeofday(&amp;tve,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">double</span> span = tve.tv_sec-tvs.tv_sec + (tve.tv_usec-tvs.tv_usec)/<span class="number">1000000.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"gettimeofday time: %.12f\n"</span>,span);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tpstart</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tpend</span>;</span></span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;tpstart);</span><br><span class="line">    WAIT;</span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;tpend);</span><br><span class="line">    <span class="keyword">double</span> timedif = (tpend.tv_sec-tpstart.tv_sec)+(tpend.tv_nsec-tpstart.tv_nsec)/<span class="number">1000000000.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"clock_gettime time: %.12f\n"</span>, timedif);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -lrt test4.c -o test4</span><br><span class="line">$ ./test4</span><br><span class="line">clock time : 1.190000000000</span><br><span class="line">times time : 1.180000000000</span><br><span class="line">gettimeofday time: 1.186477000000</span><br><span class="line">clock_gettime time: 1.179271718000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将汇总Linux用户态程序获取时间的接口，本文内容主要转载自&lt;a href=&quot;https://www.cnblogs.com/krythur/archive/2013/02/25/2932647.html?spm=a2c6h.12873639.article-detail.5.50a91861j79vJU&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clock()、time()、clock_gettime()和gettimeofday()函数的用法和区别&lt;/a&gt;。
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
