<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2022-07-24T08:22:39.582Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Introduction to userfaultfd mechanism</title>
    <link href="http://liujunming.github.io/2022/07/24/Introduction-to-userfaultfd-mechanism/"/>
    <id>http://liujunming.github.io/2022/07/24/Introduction-to-userfaultfd-mechanism/</id>
    <published>2022-07-24T05:13:22.000Z</published>
    <updated>2022-07-24T08:22:39.582Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容主要转载自<a href="http://brieflyx.me/2020/linux-tools/userfaultfd-internals/" target="_blank" rel="noopener">Linux Kernel Userfaultfd 内部机制探究</a>，看代码的时候结合<a href="https://man7.org/linux/man-pages/man2/userfaultfd.2.html" target="_blank" rel="noopener">man userfaultfd</a>和<a href="https://man7.org/linux/man-pages/man2/ioctl_userfaultfd.2.html" target="_blank" rel="noopener">man ioctl_userfaultfd</a>，方便查询。<br><a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>Userfaults allow the implementation of on-demand paging from userland and more generally they allow userland to take control of various memory page faults, something otherwise only the kernel code could do.</p><p>userfaultfd是kernel中提供的一种特殊的处理page fault的机制，能够让用户态程序自行处理自己的page fault。</p><p>它的调用方式是通过一个userfaultfd的syscall新建一个 fd，然后用ioctl等syscall来调用相关的API。该机制的初衷是为了方便虚拟机的post-copy live migration。</p><h3 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h3><p><img src="/images/2022/07/01.png" alt><br>左侧的 Faulting thread，mm core，userfaultfd 是属于同一个（内核）线程，右边的 uffd monitor 是属于另一（内核）线程，它们在用户态应该表现为共享地址空间的2个线程。</p><p>在开始时，faulting 线程读取了一块未分配物理页的内存，触发了page fault，此时进到内核中进行处理，内核调用了 <code>handle_userfault</code> 交给 userfaultfd 相关的代码进行处理，此时该线程将被挂起进入阻塞状态。同时一个待处理的消息 <code>uffd_msg</code> 结构通过该 fd 发送到了另一个 monitor 线程，该线程可以调用相关 API 进行处理 （ <code>UFFDIO_COPY</code> 或 <code>UFFDIO_ZEROPAGE</code>）并告知内核唤醒 faulting 线程。</p><p>从这个例子中我们能看出这里面涉及到2个线程之间的交互，我们也不能免俗地要介绍一下具体用法，阅读 <code>userfaultfd</code> man page 里给出的例子，里面大概分为5步。</p><h3 id="3-用法"><a href="#3-用法" class="headerlink" title="3. 用法"></a>3. 用法</h3><h4 id="3-1-分配一个-userfault-fd-并检查-API"><a href="#3-1-分配一个-userfault-fd-并检查-API" class="headerlink" title="3.1 分配一个 userfault fd 并检查 API"></a>3.1 分配一个 userfault fd 并检查 API</h4><p>由于 glibc 没有对应的 syscall wrapper，直接使用 syscall 函数分配。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Create and enable userfaultfd object */</span></span><br><span class="line"></span><br><span class="line">uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"userfaultfd"</span>);</span><br><span class="line"></span><br><span class="line">uffdio_api.api = UFFD_API;</span><br><span class="line">uffdio_api.features = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"ioctl-UFFDIO_API"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="3-2-注册需要进行-userfault-的内存区域"><a href="#3-2-注册需要进行-userfault-的内存区域" class="headerlink" title="3.2 注册需要进行 userfault 的内存区域"></a>3.2 注册需要进行 userfault 的内存区域</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register the memory range of the mapping we just created for</span></span><br><span class="line"><span class="comment">          handling by the userfaultfd object. In mode, we request to track</span></span><br><span class="line"><span class="comment">          missing pages (i.e., pages that have not yet been faulted in). */</span></span><br><span class="line"></span><br><span class="line">uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">uffdio_register.range.len = len;</span><br><span class="line">uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line"><span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"ioctl-UFFDIO_REGISTER"</span>);</span><br></pre></td></tr></table></figure><h4 id="3-3-创建-monitor-线程，（子线程）监听-fd-的事件"><a href="#3-3-创建-monitor-线程，（子线程）监听-fd-的事件" class="headerlink" title="3.3 创建 monitor 线程，（子线程）监听 fd 的事件"></a>3.3 创建 monitor 线程，（子线程）监听 fd 的事件</h4><p>在一个 for 循环中，不断使用 pool 来等待这个 fd ，然后读取一个 msg，这里读取的 msg 就是 <code>uffd_msg</code> 结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* See what poll() tells us about the userfaultfd */</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">   <span class="keyword">int</span> nready;</span><br><span class="line">   pollfd.fd = uffd;</span><br><span class="line">   pollfd.events = POLLIN;</span><br><span class="line">   nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">   <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">       errExit(<span class="string">"poll"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\nfault_handler_thread():\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"    poll() returns: nready = %d; "</span></span><br><span class="line">           <span class="string">"POLLIN = %d; POLLERR = %d\n"</span>, nready,</span><br><span class="line">           (pollfd.revents &amp; POLLIN) != <span class="number">0</span>,</span><br><span class="line">           (pollfd.revents &amp; POLLERR) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Read an event from the userfaultfd */</span></span><br><span class="line"></span><br><span class="line">   nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">   <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"EOF on userfaultfd!\n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">       errExit(<span class="string">"read"</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h4 id="3-4-主线程触发指定区域的-page-fault"><a href="#3-4-主线程触发指定区域的-page-fault" class="headerlink" title="3.4 主线程触发指定区域的 page fault"></a>3.4 主线程触发指定区域的 page fault</h4><p>读一下该区域的内存即可</p><h4 id="3-5（子线程）处理-fault"><a href="#3-5（子线程）处理-fault" class="headerlink" title="3.5（子线程）处理 fault"></a>3.5（子线程）处理 fault</h4><p>调用 <code>UFFDIO_COPY</code>为新映射的页提供数据，并唤醒主线程，子线程自身会进入到下一轮循环中继续 poll 等待输入。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Copy the page pointed to by 'page' into the faulting</span></span><br><span class="line"><span class="comment">  region. Vary the contents that are copied in, so that it</span></span><br><span class="line"><span class="comment">  is more obvious that each fault is handled separately. */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(page, <span class="string">'A'</span> + fault_cnt % <span class="number">20</span>, page_size);</span><br><span class="line">fault_cnt++;</span><br><span class="line"></span><br><span class="line">uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We need to handle page faults in units of pages(!).</span></span><br><span class="line"><span class="comment">  So, round faulting address down to page boundary */</span></span><br><span class="line"></span><br><span class="line">uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                  ~(page_size - <span class="number">1</span>);</span><br><span class="line">uffdio_copy.len = page_size;</span><br><span class="line">uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"ioctl-UFFDIO_COPY"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="4-Example"><a href="#4-Example" class="headerlink" title="4. Example"></a>4. Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* userfaultfd_demo.c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Licensed under the GNU General Public License version 2 or later.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> errExit(msg)    do &#123; perror(msg); exit(EXIT_FAILURE); \</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">fault_handler_thread(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span>   <span class="comment">/* Data read from userfaultfd */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;     <span class="comment">/* Number of faults so far handled */</span></span><br><span class="line">    <span class="keyword">long</span> uffd;                    <span class="comment">/* userfaultfd file descriptor */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *page = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a page that will be copied into the faulting region. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        page = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE,</span><br><span class="line">                    MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">            errExit(<span class="string">"mmap"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop, handling incoming events on the userfaultfd</span></span><br><span class="line"><span class="comment">       file descriptor. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* See what poll() tells us about the userfaultfd. */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"poll"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nfault_handler_thread():\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"    poll() returns: nready = %d; "</span></span><br><span class="line">                <span class="string">"POLLIN = %d; POLLERR = %d\n"</span>, nready,</span><br><span class="line">                (pollfd.revents &amp; POLLIN) != <span class="number">0</span>,</span><br><span class="line">                (pollfd.revents &amp; POLLERR) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read an event from the userfaultfd. */</span></span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"EOF on userfaultfd!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"read"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We expect only one kind of event; verify that assumption. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Unexpected event on userfaultfd\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Display info about the page-fault event. */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"    UFFD_EVENT_PAGEFAULT event: "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"flags = %"</span>PRIx64<span class="string">"; "</span>, msg.arg.pagefault.flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"address = %"</span>PRIx64<span class="string">"\n"</span>, msg.arg.pagefault.address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Copy the page pointed to by 'page' into the faulting</span></span><br><span class="line"><span class="comment">           region. Vary the contents that are copied in, so that it</span></span><br><span class="line"><span class="comment">           is more obvious that each fault is handled separately. */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="string">'A'</span> + fault_cnt % <span class="number">20</span>, page_size);</span><br><span class="line">        fault_cnt++;</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We need to handle page faults in units of pages(!).</span></span><br><span class="line"><span class="comment">           So, round faulting address down to page boundary. */</span></span><br><span class="line"></span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                           ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"ioctl-UFFDIO_COPY"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"        (uffdio_copy.copy returned %"</span>PRId64<span class="string">")\n"</span>,</span><br><span class="line">                uffdio_copy.copy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> uffd;          <span class="comment">/* userfaultfd file descriptor */</span></span><br><span class="line">    <span class="keyword">char</span> *addr;         <span class="comment">/* Start of region handled by userfaultfd */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len;       <span class="comment">/* Length of region handled by userfaultfd */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thr;      <span class="comment">/* ID of thread that handles page faults */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s num-pages\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line">    len = strtoull(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>) * page_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create and enable userfaultfd object. */</span></span><br><span class="line"></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"userfaultfd"</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_api.api = UFFD_API;</span><br><span class="line">    uffdio_api.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"ioctl-UFFDIO_API"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a private anonymous mapping. The memory will be</span></span><br><span class="line"><span class="comment">       demand-zero paged--that is, not yet allocated. When we</span></span><br><span class="line"><span class="comment">       actually touch the memory, it will be allocated via</span></span><br><span class="line"><span class="comment">       the userfaultfd. */</span></span><br><span class="line"></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE,</span><br><span class="line">                MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)</span><br><span class="line">        errExit(<span class="string">"mmap"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address returned by mmap() = %p\n"</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register the memory range of the mapping we just created for</span></span><br><span class="line"><span class="comment">       handling by the userfaultfd object. In mode, we request to track</span></span><br><span class="line"><span class="comment">       missing pages (i.e., pages that have not yet been faulted in). */</span></span><br><span class="line"></span><br><span class="line">    uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"ioctl-UFFDIO_REGISTER"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a thread that will process the userfaultfd events. */</span></span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;thr, <span class="literal">NULL</span>, fault_handler_thread, (<span class="keyword">void</span> *) uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">        errno = s;</span><br><span class="line">        errExit(<span class="string">"pthread_create"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Main thread now touches memory in the mapping, touching</span></span><br><span class="line"><span class="comment">       locations 1024 bytes apart. This will trigger userfaultfd</span></span><br><span class="line"><span class="comment">       events for all pages in the region. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    l = <span class="number">0xf</span>;    <span class="comment">/* Ensure that faulting address is not on a page</span></span><br><span class="line"><span class="comment">                   boundary, in order to test that we correctly</span></span><br><span class="line"><span class="comment">                   handle that case in fault_handling_thread(). */</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; len) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = addr[l];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Read address %p in main(): "</span>, addr + l);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, c);</span><br><span class="line">        l += <span class="number">1024</span>;</span><br><span class="line">        usleep(<span class="number">100000</span>);         <span class="comment">/* Slow things down a little */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ ./userfaultfd_demo 3</span><br><span class="line">Address returned by mmap() = 0x7fd30106c000</span><br><span class="line"></span><br><span class="line">fault_handler_thread():</span><br><span class="line">    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0</span><br><span class="line">    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106c00f</span><br><span class="line">        (uffdio_copy.copy returned 4096)</span><br><span class="line">Read address 0x7fd30106c00f in main(): A</span><br><span class="line">Read address 0x7fd30106c40f in main(): A</span><br><span class="line">Read address 0x7fd30106c80f in main(): A</span><br><span class="line">Read address 0x7fd30106cc0f in main(): A</span><br><span class="line"></span><br><span class="line">fault_handler_thread():</span><br><span class="line">    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0</span><br><span class="line">    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106d00f</span><br><span class="line">        (uffdio_copy.copy returned 4096)</span><br><span class="line">Read address 0x7fd30106d00f in main(): B</span><br><span class="line">Read address 0x7fd30106d40f in main(): B</span><br><span class="line">Read address 0x7fd30106d80f in main(): B</span><br><span class="line">Read address 0x7fd30106dc0f in main(): B</span><br><span class="line"></span><br><span class="line">fault_handler_thread():</span><br><span class="line">    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0</span><br><span class="line">    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106e00f</span><br><span class="line">        (uffdio_copy.copy returned 4096)</span><br><span class="line">Read address 0x7fd30106e00f in main(): C</span><br><span class="line">Read address 0x7fd30106e40f in main(): C</span><br><span class="line">Read address 0x7fd30106e80f in main(): C</span><br><span class="line">Read address 0x7fd30106ec0f in main(): C</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="http://brieflyx.me/2020/linux-tools/userfaultfd-internals/" target="_blank" rel="noopener">Linux Kernel Userfaultfd 内部机制探究</a></li><li><a href="https://man7.org/linux/man-pages/man2/userfaultfd.2.html" target="_blank" rel="noopener">man userfaultfd</a></li><li><a href="https://man7.org/linux/man-pages/man2/ioctl_userfaultfd.2.html" target="_blank" rel="noopener">man ioctl_userfaultfd</a></li><li><a href="https://www.slideshare.net/kerneltlv/userfaultfd-current-features-limitations-and-future-development" target="_blank" rel="noopener">Userfaultfd: Current Features, Limitations and Future Development</a></li><li><a href="https://www.kernel.org/doc/Documentation/vm/userfaultfd.txt" target="_blank" rel="noopener">kernel userfaultfd.txt</a></li><li><a href="http://lastweek.io/notes/userfaultfd/" target="_blank" rel="noopener">shanyizhou:Linux Userfaultfd</a></li><li><a href="https://blog.linuxplumbersconf.org/2017/ocw/system/presentations/4699/original/userfaultfd_%20post-copy%20VM%20migration%20and%20beyond.pdf" target="_blank" rel="noopener">userfaultfd_ post-copy VM migration and beyond.pdf</a></li><li><a href="https://noahdesu.github.io/2016/10/10/userfaultfd-hello-world.html" target="_blank" rel="noopener">userfaultfd hello world</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容主要转载自&lt;a href=&quot;http://brieflyx.me/2020/linux-tools/userfaultfd-internals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux Kernel Userfaultfd 内部机制探究&lt;/a&gt;，看代码的时候结合&lt;a href=&quot;https://man7.org/linux/man-pages/man2/userfaultfd.2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;man userfaultfd&lt;/a&gt;和&lt;a href=&quot;https://man7.org/linux/man-pages/man2/ioctl_userfaultfd.2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;man ioctl_userfaultfd&lt;/a&gt;，方便查询。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>eBPF资料合集</title>
    <link href="http://liujunming.github.io/2022/07/10/eBPF%E8%B5%84%E6%96%99%E5%90%88%E9%9B%86/"/>
    <id>http://liujunming.github.io/2022/07/10/eBPF资料合集/</id>
    <published>2022-07-10T04:10:12.000Z</published>
    <updated>2022-07-24T08:22:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>个人整理的eBPF资料合集。<a id="more"></a></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><a href="https://blog.csdn.net/hjkfcz/article/details/104916719" target="_blank" rel="noopener">ebpf原理分析</a></li><li><a href="https://tinylab.org/ebpf-part2/" target="_blank" rel="noopener">eBPF 程序装载、翻译与运行过程详解</a></li><li><a href="https://mp.weixin.qq.com/s/pKDn9DrvKYwDlu88Ojg5Pg" target="_blank" rel="noopener">揭秘 BPF map 前生今世</a></li><li><a href="https://mp.weixin.qq.com/s/afDcXoh0YfRlics22kucQw" target="_blank" rel="noopener">高效入门eBPF</a></li></ul><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ul><li><a href="https://mp.weixin.qq.com/s/9NtEmY0K861v9tHvmTOvWw" target="_blank" rel="noopener">eBPF Tracing 入门教程与实例</a></li><li><a href="https://mp.weixin.qq.com/s/LaoNpE5MNMrEeKzOFb_lYA" target="_blank" rel="noopener">深入浅出 eBPF｜你要了解的 7 个核心问题</a></li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li><a href="https://mp.weixin.qq.com/s/wn_hdcGPXOnzEZNj_-baJw" target="_blank" rel="noopener">宋宝华：用eBPF/bcc分析系统性能的一个简单案例</a></li><li><a href="https://mp.weixin.qq.com/s/6vw_HepdR76w_6vSmHuIVA" target="_blank" rel="noopener">基于eBPF监控和排查云原生环境中的磁盘IO性能问题</a></li><li><a href="https://mp.weixin.qq.com/s/meHBnFphRi9Kz-bf5QrONg" target="_blank" rel="noopener">高性能BPF内存分析工具解析</a></li><li><a href="https://www.ebpf.top/post/no_space_left_on_devices/" target="_blank" rel="noopener">eBPF+Ftrace 合璧剑指：no space left on device</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人整理的eBPF资料合集。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>bpftrace资料合集</title>
    <link href="http://liujunming.github.io/2022/07/10/bpftrace%E8%B5%84%E6%96%99%E5%90%88%E9%9B%86/"/>
    <id>http://liujunming.github.io/2022/07/10/bpftrace资料合集/</id>
    <published>2022-07-10T03:12:54.000Z</published>
    <updated>2022-07-24T08:22:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>个人整理的bpftrace资料合集。<a id="more"></a></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ul><li><a href="https://opensource.com/article/19/8/introduction-bpftrace" target="_blank" rel="noopener">An introduction to bpftrace for Linux</a></li><li><a href="https://www.brendangregg.com/ebpf.html#bpftrace" target="_blank" rel="noopener">Linux Extended BPF (eBPF) Tracing Tools:bpftrace</a></li><li><a href="https://github.com/iovisor/bpftrace/blob/master/man/adoc/bpftrace.adoc" target="_blank" rel="noopener">Manual</a></li><li><a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md" target="_blank" rel="noopener">Reference Guide</a></li><li><a href="https://github.com/iovisor/bpftrace/blob/master/docs/tutorial_one_liners.md" target="_blank" rel="noopener">One-Liner Tutorial</a></li><li><a href="https://github.com/iovisor/bpftrace" target="_blank" rel="noopener">github bpftrace</a></li></ul><h2 id="精读"><a href="#精读" class="headerlink" title="精读"></a>精读</h2><ul><li><a href="https://mp.weixin.qq.com/s/eZySfbqwOzG5EW7YL6enSw" target="_blank" rel="noopener">从bpftrace看如何利用eBPF实现内核追踪</a><ul><li><a href="/pdf/bpftrace_tutorial.pdf">archive</a></li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/476264071" target="_blank" rel="noopener">Linux - 如何测量函数的执行时间</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人整理的bpftrace资料合集。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Notes about eBPF</title>
    <link href="http://liujunming.github.io/2022/07/09/Notes-about-eBPF/"/>
    <id>http://liujunming.github.io/2022/07/09/Notes-about-eBPF/</id>
    <published>2022-07-09T07:53:10.000Z</published>
    <updated>2022-07-24T08:22:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>eBPF does to Linux what JavaScript does to HTML. (Sort of.) So instead of a static HTML website, JavaScript lets you define mini programs that run on events like mouse clicks, which are run in a safe virtual machine in the browser. And with eBPF, instead of a fixed kernel, you can now write mini programs that run on events like disk I/O, which are run in a safe virtual machine in the kernel. In reality, eBPF is more like the v8 virtual machine that runs JavaScript, rather than JavaScript itself. eBPF is part of the Linux kernel.</p><p>Programming in eBPF directly is incredibly hard, the same as coding in v8 bytecode. But no one codes in v8: they code in JavaScript, or often a framework on top of JavaScript (jQuery, Angular, React, etc). It’s the same with eBPF. People will use it and code in it via frameworks. For tracing, the main ones are bcc and bpftrace. These don’t live in the kernel code base, they live in a Linux Foundation project on github called iovisor.[1]<a id="more"></a></p><p>本文内容转载自：<a href="https://www.brendangregg.com/ebpf.html" target="_blank" rel="noopener">Linux Extended BPF (eBPF) Tracing Tools</a></p><h2 id="1-History"><a href="#1-History" class="headerlink" title="1. History"></a>1. History</h2><p>BPF originated as a technology for optimizing packet filters. If you run tcpdump with an expression (matching on a host or port), it gets compiled into optimal BPF bytecode which is executed by an in-kernel sandboxed virtual machine. Extended BPF extended what this BPF virtual machine could do: allowing it to run on events other than packets, and do actions other than filtering.</p><h2 id="2-Introduction"><a href="#2-Introduction" class="headerlink" title="2. Introduction"></a>2. Introduction</h2><p>eBPF can be used to for software defined networks, DDoS mitigation (early packet drop), improving network performance (eXpress Data Path), intrusion detection, and more. It is used as shown in the following workflow:<br><img src="https://www.brendangregg.com/eBPF/linux_ebpf_internals.png" alt></p><p>Our observability tool has BPF code to perform certain actions: measure latency, summarize as a histogram, grab stack traces, etc. That BPF code is compiled to BPF byte code and then sent to the kernel, where a verifier may reject it if it is deemed unsafe (which includes not allowing loops or backwards branches). If the BPF bytecode is accepted, it can then be attached to different event sources:</p><ul><li><strong>kprobes</strong>: kernel dynamic tracing.</li><li><strong>uprobes</strong>: user level dynamic tracing.</li><li><strong>tracepoints</strong>: kernel static tracing.</li><li><strong>perf_events</strong>: timed sampling and PMCs.</li></ul><p>The BPF program has two ways to pass measured data back to user space: either per-event details, or via a BPF map. BPF maps can implement arrays, associative arrays, and histograms, and are suited for passing summary statistics.</p><h2 id="3-Prerequisites"><a href="#3-Prerequisites" class="headerlink" title="3. Prerequisites"></a>3. Prerequisites</h2><p>A Linux kernel compiled with CONFIG_BPF_SYSCALL (eg, Ubuntu does this), and at least the 4.4 kernel (eg, Ubuntu Xenial) so that histogram, statistic, and per-event tracing is supported. The following diagram shows other features with the Linux version eBPF supported arrived in green:<br><img src="https://www.brendangregg.com/eBPF/linux_ebpf_support.png" alt></p><h2 id="4-Front-Ends"><a href="#4-Front-Ends" class="headerlink" title="4. Front Ends"></a>4. Front Ends</h2><p>There are multiple different front-ends for eBPF. Here’s a summary, I’d recommend trying out bcc and bpftrace (highlighted).<br><img src="/images/2022/06/06.jpg" alt><br>I’ve previously summarized these on three dimensions: ease of use, scope &amp; capability, and stage of development. Here are the BPF front-ends vs the standard built-in Linux tracers (ftrace and perf):<br><img src="https://www.brendangregg.com/eBPF/ebpf_tracing_landscape_jan2019.png" alt></p><hr><p>Reference:<br>[1] <a href="https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html" target="_blank" rel="noopener">https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;eBPF does to Linux what JavaScript does to HTML. (Sort of.) So instead of a static HTML website, JavaScript lets you define mini programs that run on events like mouse clicks, which are run in a safe virtual machine in the browser. And with eBPF, instead of a fixed kernel, you can now write mini programs that run on events like disk I/O, which are run in a safe virtual machine in the kernel. In reality, eBPF is more like the v8 virtual machine that runs JavaScript, rather than JavaScript itself. eBPF is part of the Linux kernel.&lt;/p&gt;
&lt;p&gt;Programming in eBPF directly is incredibly hard, the same as coding in v8 bytecode. But no one codes in v8: they code in JavaScript, or often a framework on top of JavaScript (jQuery, Angular, React, etc). It’s the same with eBPF. People will use it and code in it via frameworks. For tracing, the main ones are bcc and bpftrace. These don’t live in the kernel code base, they live in a Linux Foundation project on github called iovisor.[1]
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Notes about ACPI Platform Error Interface(APEI)</title>
    <link href="http://liujunming.github.io/2022/07/03/Notes-about-ACPI-Platform-Error-Interface-APEI/"/>
    <id>http://liujunming.github.io/2022/07/03/Notes-about-ACPI-Platform-Error-Interface-APEI/</id>
    <published>2022-07-03T07:28:01.000Z</published>
    <updated>2022-07-24T08:22:39.583Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录ACPI Platform Error Interface(APEI)相关笔记。<a id="more"></a></p><p><a href="/pdf/apei.pdf">A_Tour_beyond_BIOS_Implementing_APEI_with_UEFI_White_Paper</a></p><p>如果不想了解UEFI实现细节的话，阅读下图红框中标注的内容即可！<br><img src="/images/2022/06/04.jpg" alt></p><hr><p>参考资料：</p><ol><li><a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.466.5363&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">A_Tour_beyond_BIOS_Implementing_APEI_with_UEFI_White_Paper</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录ACPI Platform Error Interface(APEI)相关笔记。
    
    </summary>
    
      <category term="RAS" scheme="http://liujunming.github.io/categories/RAS/"/>
    
    
      <category term="ACPI" scheme="http://liujunming.github.io/tags/ACPI/"/>
    
      <category term="RAS" scheme="http://liujunming.github.io/tags/RAS/"/>
    
  </entry>
  
  <entry>
    <title>Notes about APEI Error INJection</title>
    <link href="http://liujunming.github.io/2022/06/28/Notes-about-APEI-Error-INJection/"/>
    <id>http://liujunming.github.io/2022/06/28/Notes-about-APEI-Error-INJection/</id>
    <published>2022-06-28T13:26:17.000Z</published>
    <updated>2022-07-24T08:22:39.583Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2022/06/05.jpg" alt><br>APEI (ACPI Platform Error Interface) EINJ provides a hardware error injection mechanism. It is very useful for debugging and testing APEI and RAS features in general.<a id="more"></a></p><p><img src="/images/2022/06/03.jpg" alt></p><p>An error injection example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># cd /sys/kernel/debug/apei/einj</span><br><span class="line"># cat available_error_type            # See which errors can be injected</span><br><span class="line">0x00000002    Processor Uncorrectable non-fatal</span><br><span class="line">0x00000008    Memory Correctable</span><br><span class="line">0x00000010    Memory Uncorrectable non-fatal</span><br><span class="line"># echo 0x12345000 &gt; param1            # Set memory address for injection</span><br><span class="line"># echo $((-1 &lt;&lt; 12)) &gt; param2         # Mask 0xfffffffffffff000 - anywhere in this page</span><br><span class="line"># echo 0x8 &gt; error_type                       # Choose correctable memory error</span><br><span class="line"># echo 1 &gt; error_inject                       # Inject now</span><br></pre></td></tr></table></figure></p><p>You should see something like this in dmesg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[22715.830801] EDAC sbridge MC3: HANDLING MCE MEMORY ERROR</span><br><span class="line">[22715.834759] EDAC sbridge MC3: CPU 0: Machine Check Event: 0 Bank 7: 8c00004000010090</span><br><span class="line">[22715.834759] EDAC sbridge MC3: TSC 0</span><br><span class="line">[22715.834759] EDAC sbridge MC3: ADDR 12345000 EDAC sbridge MC3: MISC 144780c86</span><br><span class="line">[22715.834759] EDAC sbridge MC3: PROCESSOR 0:306e7 TIME 1422553404 SOCKET 0 APIC 0</span><br><span class="line">[22716.616173] EDAC MC3: 1 CE memory read error on CPU_SrcID#0_Channel#0_DIMM#0 (channel:0 slot:0 page:0x12345 offset:0x0 grain:32 syndrome:0x0 -  area:DRAM err_code:0001:0090 socket:0 channel_mask:1 rank:0)</span><br></pre></td></tr></table></figure></p><hr><p>参考资料：</p><ol><li><a href="https://www.kernel.org/doc/html/latest/firmware-guide/acpi/apei/einj.html" target="_blank" rel="noopener">APEI Error INJection</a></li><li><a href="https://lwn.net/Articles/384825/" target="_blank" rel="noopener">ACPI, APEI support</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2022/06/05.jpg&quot; alt&gt;&lt;br&gt;APEI (ACPI Platform Error Interface) EINJ provides a hardware error injection mechanism. It is very useful for debugging and testing APEI and RAS features in general.
    
    </summary>
    
      <category term="ACPI" scheme="http://liujunming.github.io/categories/ACPI/"/>
    
    
      <category term="ACPI" scheme="http://liujunming.github.io/tags/ACPI/"/>
    
  </entry>
  
  <entry>
    <title>Notes about pstack and /proc/[pid]/stack</title>
    <link href="http://liujunming.github.io/2022/06/19/Notes-about-pstack-and-proc-stacks/"/>
    <id>http://liujunming.github.io/2022/06/19/Notes-about-pstack-and-proc-stacks/</id>
    <published>2022-06-19T02:51:34.000Z</published>
    <updated>2022-07-24T08:22:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录pstack与/proc/[pid]/stack相关笔记。<a id="more"></a></p><h3 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h3><p>pstack显示user-space stack，/proc/[pid]/stack显示kernel stack。</p><h3 id="2-pstack"><a href="#2-pstack" class="headerlink" title="2. pstack"></a>2. pstack</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ man pstack</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       gstack - print a stack trace of a running process</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       gstack pid</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       gstack  attaches  to the active process named by the pid on the command line,</span><br><span class="line">       and prints out an execution stack trace.</span><br><span class="line">       If ELF symbols exist in the binary, then symbolic addresses are printed as well.</span><br><span class="line"></span><br><span class="line">       If the process is part of a thread group,</span><br><span class="line">       then gstack will print out a stack trace for each of the threads in the group.</span><br></pre></td></tr></table></figure><h3 id="3-proc-pid-stack"><a href="#3-proc-pid-stack" class="headerlink" title="3. /proc/[pid]/stack"></a>3. /proc/[pid]/stack</h3><p>权威教程：<a href="https://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">man proc</a></p><p><img src="/images/2022/06/01.jpg" alt></p><p><img src="/images/2022/06/02.jpg" alt></p><hr><p>参考资料：</p><ol><li><a href="https://stackoverflow.com/questions/33429376/how-to-understand-proc-pid-stack" target="_blank" rel="noopener">How to understand “/proc/[pid]/stack”?</a></li><li><a href="https://unix.stackexchange.com/questions/23232/what-is-the-difference-between-proc-self-stack-and-output-from-pstack" target="_blank" rel="noopener">What is the difference between /proc/self/stack and output from pstack?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录pstack与/proc/[pid]/stack相关笔记。
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第31期</title>
    <link href="http://liujunming.github.io/2022/06/13/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC31%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2022/06/13/每周分享第31期/</id>
    <published>2022-06-13T14:47:32.000Z</published>
    <updated>2022-07-24T08:22:39.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ventoy"><a href="#Ventoy" class="headerlink" title="Ventoy"></a>Ventoy</h3><p><a href="https://4sysops.com/archives/ventoy-boot-multiple-iso-images-from-a-single-usb-stick/" target="_blank" rel="noopener">Ventoy: Boot multiple ISO images from a single USB stick</a></p><a id="more"></a><h3 id="打入BAT字节数据中心！这家创企硬刚英特尔，5nm芯片已送样"><a href="#打入BAT字节数据中心！这家创企硬刚英特尔，5nm芯片已送样" class="headerlink" title="打入BAT字节数据中心！这家创企硬刚英特尔，5nm芯片已送样"></a>打入BAT字节数据中心！这家创企硬刚英特尔，5nm芯片已送样</h3><p><a href="https://mp.weixin.qq.com/s/Y3SbMohPkICDEPMnFNqUJQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Y3SbMohPkICDEPMnFNqUJQ</a></p><p>考虑到x86处理器体系强大的生态壁垒，在云端数据中心市场，以Ampere为代表的Arm服务器芯片设计公司们，仍有较长的一段路要走。<br>无论如何，更多Arm芯片创业者的涌入，正令围绕云端数据中心计算平台的竞争变得更加有趣。</p><h3 id="苹果发布M2处理器"><a href="#苹果发布M2处理器" class="headerlink" title="苹果发布M2处理器"></a>苹果发布M2处理器</h3><p><a href="https://www.bilibili.com/video/BV11Y4y1x7VK?vd_source=bb66ccea153753895eb854bf770dff82" target="_blank" rel="noopener">https://www.bilibili.com/video/BV11Y4y1x7VK?vd_source=bb66ccea153753895eb854bf770dff82</a></p><h3 id="Asahi-Linux"><a href="#Asahi-Linux" class="headerlink" title="Asahi Linux"></a>Asahi Linux</h3><p><a href="https://asahilinux.org/about/" target="_blank" rel="noopener">https://asahilinux.org/about/</a></p><p>Asahi Linux is a project and community with the goal of porting Linux to Apple Silicon Macs, starting with the 2020 M1 Mac Mini, MacBook Air, and MacBook Pro.</p><h3 id="elephant-flow"><a href="#elephant-flow" class="headerlink" title="elephant flow"></a>elephant flow</h3><p>In computer networking, an elephant flow is an extremely large (in total bytes) continuous flow set up by a TCP (or other protocol) flow measured over a network link.<br><a href="https://en.wikipedia.org/wiki/Elephant_flow" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Elephant_flow</a></p><h3 id="Why-You-Should-Read-Books-The-Benefits-of-Reading-More-animated"><a href="#Why-You-Should-Read-Books-The-Benefits-of-Reading-More-animated" class="headerlink" title="Why You Should Read Books - The Benefits of Reading More (animated)"></a>Why You Should Read Books - The Benefits of Reading More (animated)</h3><p><a href="https://www.youtube.com/watch?v=pRTWFqhEDeo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=pRTWFqhEDeo</a></p><h3 id="阿里云张建锋：Back-to-Basic，定义下一代的云"><a href="#阿里云张建锋：Back-to-Basic，定义下一代的云" class="headerlink" title="阿里云张建锋：Back to Basic，定义下一代的云"></a>阿里云张建锋：Back to Basic，定义下一代的云</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4NjI4MzM4MQ==&amp;mid=2660225957&amp;idx=1&amp;sn=48b9c71e0c16ebb98416297d56484bf0&amp;chksm=84b076bfb3c7ffa90ca524a9fa18d2d6d9c33017af1a45ad4ab620629cfc5da8d99f48ec0b4c&amp;token=2053767401&amp;lang=zh_CN#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4NjI4MzM4MQ==&amp;mid=2660225957&amp;idx=1&amp;sn=48b9c71e0c16ebb98416297d56484bf0&amp;chksm=84b076bfb3c7ffa90ca524a9fa18d2d6d9c33017af1a45ad4ab620629cfc5da8d99f48ec0b4c&amp;token=2053767401&amp;lang=zh_CN#rd</a></p><p>阿里云发布了一款云数据中心专用处理器CIPU（Cloud infrastructure Processing Units），将替代CPU成为云时代IDC的处理核心。</p><h3 id="无影"><a href="#无影" class="headerlink" title="无影"></a>无影</h3><p><a href="https://www.aliyun.com/product/ecs/wuying" target="_blank" rel="noopener">https://www.aliyun.com/product/ecs/wuying</a><br>云电脑。</p><p>无影是阿里云打造的云端一体、安全高效的一站式云上办公空间。无影的云桌面、云应用、应用中心、安全浏览器等一系列的云办公能力，通过流化的技术，提供给终端用户，在算力、安全、成本、敏捷、开放等方面，无影具有超越传统PC的优势。</p><h3 id="ASP协议"><a href="#ASP协议" class="headerlink" title="ASP协议"></a>ASP协议</h3><p><a href="https://help.aliyun.com/apsara/enterprise/v_3_14_0_20210519/appstreaming/enterprise-product-introduction/what-is-the-asp-protocol.html?spm=a2c4g.14484438.10004.1" target="_blank" rel="noopener">https://help.aliyun.com/apsara/enterprise/v_3_14_0_20210519/appstreaming/enterprise-product-introduction/what-is-the-asp-protocol.html?spm=a2c4g.14484438.10004.1</a></p><p>无影宣布升级全新ASP云流协议，支持开发者打造8K画质体验，并将时延控制在20毫秒内。</p><p>ASP（Adaptive Streaming Protocol）是阿里云自主研发的面向应用流的一种新型端云协同协议，旨在为无影产品提供端云一体的协议支撑，为终端用户提供低时延高画质的实时交互体验。通过ASP协议用户在不同服务器和客户端配置需求中、不同的工作场景下以及不同的网络条件时均能得到最佳的用户体验。</p><p>ASP协议在TCP/UDP网络协议上运行，借助于当前高效的编解码技术，将云上的图形化交互界面进行编码，以视频流（Streaming）的方式推送到客户端，客户端执行解码并显示图形化界面。ASP协议通过虚拟传输通道技术，将客户端侧的鼠标、键盘等外设事件重定向到服务端，从而实现端和云的交互事件输入。</p><h3 id="VDI桌面虚拟化四大协议"><a href="#VDI桌面虚拟化四大协议" class="headerlink" title="VDI桌面虚拟化四大协议"></a>VDI桌面虚拟化四大协议</h3><ul><li>ICA：ICA协议属于Citrix，它的英文全称是Independent Computing Architecture</li><li>PCoIP：PCoIP是Vmware的</li><li>RDP：RDP英方全称是Remote Desktop Protocol</li><li>SPICE：是一个开源协议，英文全称是Simple Protocol for Independent Computing Environment</li></ul><h3 id="Citrix"><a href="#Citrix" class="headerlink" title="Citrix"></a>Citrix</h3><p>思杰系统公司是一家软件和云端运算的科技公司。它的跨国业绩包括提供服务器、软件及桌面虚拟化、网络连结、以及软件即服务等产品。<br><a href="https://zh.wikipedia.org/zh-cn/%E6%80%9D%E6%9D%B0%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/%E6%80%9D%E6%9D%B0%E7%B3%BB%E7%BB%9F</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Ventoy&quot;&gt;&lt;a href=&quot;#Ventoy&quot; class=&quot;headerlink&quot; title=&quot;Ventoy&quot;&gt;&lt;/a&gt;Ventoy&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://4sysops.com/archives/ventoy-boot-multiple-iso-images-from-a-single-usb-stick/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ventoy: Boot multiple ISO images from a single USB stick
&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Virtio 虚拟化技术趋势与 DPU 实践</title>
    <link href="http://liujunming.github.io/2022/05/29/Virtio-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF%E4%B8%8E-DPU-%E5%AE%9E%E8%B7%B5/"/>
    <id>http://liujunming.github.io/2022/05/29/Virtio-虚拟化技术趋势与-DPU-实践/</id>
    <published>2022-05-29T04:17:30.000Z</published>
    <updated>2022-07-24T08:22:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：龙蜥大讲堂第16期</p><ul><li><a href="https://openanolis.cn/video/566837307090997810" target="_blank" rel="noopener">video</a></li><li><a href="https://www.yuque.com/anolis-docs/courses" target="_blank" rel="noopener">slides</a><a id="more"></a></li></ul><h3 id="Virtio简介"><a href="#Virtio简介" class="headerlink" title="Virtio简介"></a>Virtio简介</h3><p>概述、演进、关键技术</p><p><img src="/images/2022/05/21.jpg" alt></p><p><img src="/images/2022/05/22.jpg" alt></p><p><img src="/images/2022/05/23.jpg" alt></p><p><img src="/images/2022/05/24.jpg" alt></p><p><img src="/images/2022/05/25.jpg" alt></p><p><img src="/images/2022/05/26.jpg" alt></p><h3 id="Virtio与DPU"><a href="#Virtio与DPU" class="headerlink" title="Virtio与DPU"></a>Virtio与DPU</h3><p>Virtio硬化</p><p><img src="/images/2022/05/27.jpg" alt><br>BM指的是BareMetal<br><img src="/images/2022/05/28.jpg" alt></p><p><img src="/images/2022/05/29.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：龙蜥大讲堂第16期&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://openanolis.cn/video/566837307090997810&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;video&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.yuque.com/anolis-docs/courses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;slides&lt;/a&gt;
    
    </summary>
    
      <category term="virtio" scheme="http://liujunming.github.io/categories/virtio/"/>
    
    
      <category term="virtio" scheme="http://liujunming.github.io/tags/virtio/"/>
    
      <category term="DPU" scheme="http://liujunming.github.io/tags/DPU/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第30期</title>
    <link href="http://liujunming.github.io/2022/05/27/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC30%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2022/05/27/每周分享第30期/</id>
    <published>2022-05-27T09:29:03.000Z</published>
    <updated>2022-07-24T08:22:39.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Express-Design-in-Power-Apps"><a href="#Express-Design-in-Power-Apps" class="headerlink" title="Express Design in Power Apps"></a>Express Design in Power Apps</h3><p>Express Design in <a href="https://powerapps.microsoft.com/en-us/blog/" target="_blank" rel="noopener">Power Apps</a>, which allows you to upload a PDF, PowerPoint or even a hand-drawn sketch that Express Design will convert into a working app within seconds.<br><a id="more"></a></p><h3 id="回顾AMD微处理器发展史的内幕"><a href="#回顾AMD微处理器发展史的内幕" class="headerlink" title="回顾AMD微处理器发展史的内幕"></a>回顾AMD微处理器发展史的内幕</h3><p><a href="https://mp.weixin.qq.com/s/uN9rz26QzPe96l-8r_ZViA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uN9rz26QzPe96l-8r_ZViA</a></p><h3 id="最接近事物本質的思考方式：第一性原理｜硅谷牛人馬斯克的思維方式"><a href="#最接近事物本質的思考方式：第一性原理｜硅谷牛人馬斯克的思維方式" class="headerlink" title="最接近事物本質的思考方式：第一性原理｜硅谷牛人馬斯克的思維方式"></a>最接近事物本質的思考方式：第一性原理｜硅谷牛人馬斯克的思維方式</h3><p><a href="https://www.youtube.com/watch?v=9kRSJdU2ht8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=9kRSJdU2ht8</a></p><h3 id="grammarly"><a href="#grammarly" class="headerlink" title="grammarly"></a>grammarly</h3><p>检查语法错误的工具，有chrome插件</p><h3 id="博通同意以610亿美元收购VMware"><a href="#博通同意以610亿美元收购VMware" class="headerlink" title="博通同意以610亿美元收购VMware"></a>博通同意以610亿美元收购VMware</h3><p><a href="https://news.cnstock.com/news,bwkx-202205-4889639.htm" target="_blank" rel="noopener">https://news.cnstock.com/news,bwkx-202205-4889639.htm</a></p><h3 id="Why-does-mmap-use-MAP-FAILED-instead-of-NULL"><a href="#Why-does-mmap-use-MAP-FAILED-instead-of-NULL" class="headerlink" title="Why does mmap() use MAP_FAILED instead of NULL?"></a>Why does mmap() use MAP_FAILED instead of NULL?</h3><p><a href="https://stackoverflow.com/questions/24562691/why-does-mmap-use-map-failed-instead-of-null" target="_blank" rel="noopener">https://stackoverflow.com/questions/24562691/why-does-mmap-use-map-failed-instead-of-null</a></p><p>There are some rare situations where <code>mmap()</code> will actually create a mapping at address 0x0. These days, it typically requires root privileges (or for the <code>mmap_min_addr</code> sysctl to be set to zero on Linux systems) but it is possible. If such a mapping is created, it becomes possible to write to this address.</p><p><code>MAP_FAILED</code>, on the other hand, is never a valid return value from <code>mmap()</code>, so it’s usable as a sentinel.</p><h3 id="怎样提高自己的不可替代性？"><a href="#怎样提高自己的不可替代性？" class="headerlink" title="怎样提高自己的不可替代性？"></a>怎样提高自己的不可替代性？</h3><p><a href="https://mp.weixin.qq.com/s/qCSFGs5W7HBHJCFgewGQgA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qCSFGs5W7HBHJCFgewGQgA</a></p><ol><li>一定要培养一技之长，并且练到极致</li><li>通过不断持续学习，让自己多几个标签</li><li>为公司创造价值</li><li>拥有解决问题的能力</li></ol><h3 id="阿里云刘洪强：通往山顶的路各不相同"><a href="#阿里云刘洪强：通往山顶的路各不相同" class="headerlink" title="阿里云刘洪强：通往山顶的路各不相同"></a>阿里云刘洪强：通往山顶的路各不相同</h3><p><a href="https://mp.weixin.qq.com/s/2YU2QX8HTsoSBteYBEdY-g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2YU2QX8HTsoSBteYBEdY-g</a></p><ul><li>个人主页：<a href="https://www.aminer.cn/profile/53f4a511dabfaedce5633b9d" target="_blank" rel="noopener">https://www.aminer.cn/profile/53f4a511dabfaedce5633b9d</a></li><li>必读论文：<a href="https://www.aminer.cn/topic/628317ec7376380a6a7405c9" target="_blank" rel="noopener">https://www.aminer.cn/topic/628317ec7376380a6a7405c9</a></li></ul><h3 id="回归课本、课本是精华中的精华"><a href="#回归课本、课本是精华中的精华" class="headerlink" title="回归课本、课本是精华中的精华"></a>回归课本、课本是精华中的精华</h3><p><a href="https://www.ixigua.com/7098913476193619237?wid_try=1" target="_blank" rel="noopener">https://www.ixigua.com/7098913476193619237?wid_try=1</a></p><h3 id="乘众人之智，则无不任也；用众人之力，则无不胜也"><a href="#乘众人之智，则无不任也；用众人之力，则无不胜也" class="headerlink" title="乘众人之智，则无不任也；用众人之力，则无不胜也"></a>乘众人之智，则无不任也；用众人之力，则无不胜也</h3><p><a href="https://www.kekeshici.com/mingyanmingju/guoxuejuian/129370.html" target="_blank" rel="noopener">https://www.kekeshici.com/mingyanmingju/guoxuejuian/129370.html</a><br>语出《淮南子·主术训》。利用众人的智慧，那么就没有做不好的事情;凭借众人的力量，那么就没有取不得的成功。说明只要注意发挥集体的智慧和力量，就能百为百成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Express-Design-in-Power-Apps&quot;&gt;&lt;a href=&quot;#Express-Design-in-Power-Apps&quot; class=&quot;headerlink&quot; title=&quot;Express Design in Power Apps&quot;&gt;&lt;/a&gt;Express Design in Power Apps&lt;/h3&gt;&lt;p&gt;Express Design in &lt;a href=&quot;https://powerapps.microsoft.com/en-us/blog/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Power Apps&lt;/a&gt;, which allows you to upload a PDF, PowerPoint or even a hand-drawn sketch that Express Design will convert into a working app within seconds.&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>A Perfect Solution for Live Migration with Pass-through Devices by Quan Xu </title>
    <link href="http://liujunming.github.io/2022/05/21/A-Perfect-Solution-for-Live-Migration-with-Pass-through-Devices-by-Quan-Xu/"/>
    <id>http://liujunming.github.io/2022/05/21/A-Perfect-Solution-for-Live-Migration-with-Pass-through-Devices-by-Quan-Xu/</id>
    <published>2022-05-21T10:05:38.000Z</published>
    <updated>2022-07-24T08:22:39.582Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=8eeLhzQvtpY" target="_blank" rel="noopener">A Perfect Solution for Live Migration with Pass-through Devices by Quan Xu</a></p><p>From KVM forum’2018.<a id="more"></a></p><p>Several efforts have been made on enabling live migration with pass-through devices, however, it is inevitable to modify device driver to save and restore device states, and mark a page as dirty after DMA memory access. These ‘ugly’ modifications are not compatible with legacy drivers or Windows virtual machine.<br>We design new virtio hardware devices (virtio-net based Nic and virtio-blk based storage). These devices can be pass-through with VFIO, then the legacy virtio-net/virtio-blk drivers are working without any modification in virtual machine, including Windows. We also extend the capability of devices to support live migration, including being aware of live migration, logging the page of DMA memory access, saving and restoring device states on run-time. And then we extend the migration and VFIO code to support live migration with pass-through these devices as QEMU ‘emulated’ devices.</p><p><img src="/images/2022/05/20.jpg" alt><br><img src="/images/2022/05/05.jpg" alt><br><img src="/images/2022/05/06.jpg" alt><br><img src="/images/2022/05/07.jpg" alt><br><img src="/images/2022/05/08.jpg" alt><br><img src="/images/2022/05/09.jpg" alt><br>For RO(Read Only) registers, they can be read by source host, but it couldn’t be restored on the destination host(Because the restore operations need the write of these registers, while RO registers couldn’t be wroten).<br><img src="/images/2022/05/10.jpg" alt><br><img src="/images/2022/05/11.jpg" alt><br><img src="/images/2022/05/12.jpg" alt><br><img src="/images/2022/05/13.jpg" alt><br><img src="/images/2022/05/14.jpg" alt><br><img src="/images/2022/05/15.jpg" alt><br><img src="/images/2022/05/16.jpg" alt><br><img src="/images/2022/05/17.jpg" alt><br><img src="/images/2022/05/18.jpg" alt><br><img src="/images/2022/05/19.jpg" alt></p><p>If the pass-thru devices support live migration, then all registers are R/W.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=8eeLhzQvtpY&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A Perfect Solution for Live Migration with Pass-through Devices by Quan Xu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From KVM forum’2018.
    
    </summary>
    
      <category term="live migration" scheme="http://liujunming.github.io/categories/live-migration/"/>
    
    
      <category term="live migration" scheme="http://liujunming.github.io/tags/live-migration/"/>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第29期</title>
    <link href="http://liujunming.github.io/2022/05/21/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC29%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2022/05/21/每周分享第29期/</id>
    <published>2022-05-21T08:17:14.000Z</published>
    <updated>2022-07-24T08:22:39.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。用通俗的话讲：就是针对一个操作，不管做多少次，产生效果或返回的结果都是一样的。</p><ol><li>前端对同一表单数据的重复提交，后台应该只会产生一个结果</li><li>我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱</li><li>发送消息，也应该只发一次，同样的短信如果多次发给用户，用户会崩溃</li><li>创建业务订单，一次业务请求只能创建一个，不能出现创建多个订单</li></ol><a id="more"></a><p><a href="https://gongfukangee.github.io/2019/03/25/Idempotence/" target="_blank" rel="noopener">如何保证业务的幂等性</a></p><h3 id="Potential-new-Zen-3-instructions"><a href="#Potential-new-Zen-3-instructions" class="headerlink" title="Potential new Zen 3 instructions"></a>Potential new Zen 3 instructions</h3><p>Anyway, the interesting bit for me were the new instructions, particularly INVLPGB and TLBSYNC.</p><p>The one that I found interesting was “Invalidate TLB Entry(s) with Broadcast” INVLPGB. It is supposed to be used together with “Synchronize TLB Invalidations” TLBSYNC.</p><p><a href="https://www.reddit.com/r/hardware/comments/gf2ooy/potential_new_zen_3_instructions/" target="_blank" rel="noopener">Potential new Zen 3 instructions</a></p><h3 id="一文读懂CDN"><a href="#一文读懂CDN" class="headerlink" title="一文读懂CDN"></a>一文读懂CDN</h3><p><a href="https://mp.weixin.qq.com/s/O2exHSnXnr765faeeFjvaA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/O2exHSnXnr765faeeFjvaA</a></p><h3 id="OTT"><a href="#OTT" class="headerlink" title="OTT"></a>OTT</h3><p>OTT (over-the-top) is a means of providing television and film content over the internet at the request and to suit the requirements of the individual consumer.</p><p>OTT 是“Over The Top”的缩写，指的是通过互联网传输流媒体的服务。“Over The Top” 原指篮球运动中的过顶传球，而 OTT 服务的传输过程“越过”了另外一种平台，因此而得名。</p><h3 id="有利于提高xenomai-实时性的一些配置建议"><a href="#有利于提高xenomai-实时性的一些配置建议" class="headerlink" title="有利于提高xenomai 实时性的一些配置建议"></a>有利于提高xenomai 实时性的一些配置建议</h3><p><a href="https://mp.weixin.qq.com/s/p7AhaRD90sND6CoxTlA8Xg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/p7AhaRD90sND6CoxTlA8Xg</a></p><h3 id="Cherry-（电子产品制造商）"><a href="#Cherry-（电子产品制造商）" class="headerlink" title="Cherry （电子产品制造商）"></a>Cherry （电子产品制造商）</h3><p>Cherry公司是全球专业的键盘制造厂商，专注于电子产品品牌，所在地为德国，以机械键盘闻名世界。</p><h3 id="overleaf"><a href="#overleaf" class="headerlink" title="overleaf"></a>overleaf</h3><p><a href="https://www.overleaf.com/" target="_blank" rel="noopener">https://www.overleaf.com/</a></p><p>The easy to use, online, collaborative LaTeX editor</p><h3 id="《蓝色星球2》"><a href="#《蓝色星球2》" class="headerlink" title="《蓝色星球2》"></a>《蓝色星球2》</h3><p>每一帧都值得截图当桌面</p><p><a href="https://movie.douban.com/subject/26979545/" target="_blank" rel="noopener">https://movie.douban.com/subject/26979545/</a><br><a href="https://mp.weixin.qq.com/s/_tPGE_3UPhjJrP8YgTsabg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_tPGE_3UPhjJrP8YgTsabg</a></p><h3 id="樱桃OTC前工程师感恩自白"><a href="#樱桃OTC前工程师感恩自白" class="headerlink" title="樱桃OTC前工程师感恩自白"></a>樱桃OTC前工程师感恩自白</h3><p><a href="https://mp.weixin.qq.com/s/Lh5xT6u19DyvTTgFjB183A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Lh5xT6u19DyvTTgFjB183A</a></p><h3 id="逐梦天河"><a href="#逐梦天河" class="headerlink" title="逐梦天河"></a>逐梦天河</h3><p><a href="https://www.bilibili.com/video/BV1W5411P73b/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1W5411P73b/</a><br>银河筑梦波澜阔，天河飞渡擎巨擘。由天津海河传媒中心推出的纪录片《逐梦天河》共分三集，通过讲述中国超算的发展历程，深刻诠释科学家精神的内涵。从北国冰城到湘江之畔，从哈军工到国防科大，中国的超级计算事业从萌芽、起步到登顶世界第一，广泛服务于国家科技创新的各个领域，背后是一代代以祖国需要为己任的计算机科技攻关队伍，在接续奋斗。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;幂等性&quot;&gt;&lt;a href=&quot;#幂等性&quot; class=&quot;headerlink&quot; title=&quot;幂等性&quot;&gt;&lt;/a&gt;幂等性&lt;/h3&gt;&lt;p&gt;在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。用通俗的话讲：就是针对一个操作，不管做多少次，产生效果或返回的结果都是一样的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前端对同一表单数据的重复提交，后台应该只会产生一个结果&lt;/li&gt;
&lt;li&gt;我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱&lt;/li&gt;
&lt;li&gt;发送消息，也应该只发一次，同样的短信如果多次发给用户，用户会崩溃&lt;/li&gt;
&lt;li&gt;创建业务订单，一次业务请求只能创建一个，不能出现创建多个订单&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>浅谈IOMMU寻址方式</title>
    <link href="http://liujunming.github.io/2022/05/14/%E6%B5%85%E8%B0%88IOMMU-pageing-structures/"/>
    <id>http://liujunming.github.io/2022/05/14/浅谈IOMMU-pageing-structures/</id>
    <published>2022-05-14T04:38:23.000Z</published>
    <updated>2022-07-24T08:22:39.588Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录个人对于IOMMU寻址方式的理解。<a id="more"></a></p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p><img src="/images/2022/05/04.jpg" alt></p><ul><li>1st level translation</li><li>2nd level translation</li><li>Nested translation</li><li>Pass-through translation</li></ul><p>如果没有太多背景知识的话，对于这四种IOMMU寻址方式，读者可能很难理解。因此，在接下来的内容中，将用MMU、EPT中的寻址方式与IOMMU做类比，便于读者理解。</p><h2 id="2-IOMMU寻址方式"><a href="#2-IOMMU寻址方式" class="headerlink" title="2. IOMMU寻址方式"></a>2. IOMMU寻址方式</h2><h3 id="Pass-through-translation"><a href="#Pass-through-translation" class="headerlink" title="Pass-through translation"></a>Pass-through translation</h3><p>在host上，传统的DMA不用IOMMU，指定的地址即为HPA。</p><p>这个case类比于host刚刚启动，进入实模式时，CPU不用MMU，指定的地址即为HPA。</p><h3 id="2nd-level-translation"><a href="#2nd-level-translation" class="headerlink" title="2nd level translation"></a>2nd level translation</h3><p>将device pass-thru给guest时，guest中的DMA并未使用IOMMU，因此，在guest中，DMA指定的地址即为GPA。此时，Hypervisor需要在IOMMU页表中建立GPA到HPA的映射。</p><p>这个case类比于vCPU在non-root中进入实模式时，CPU寻址用的就是GPA，Hypervisor需要在EPT页表中建立GPA到HPA的映射。</p><h3 id="1st-level-translation"><a href="#1st-level-translation" class="headerlink" title="1st level translation"></a>1st level translation</h3><p>在host上的DPDK或者SPDK用户态驱动（基于VFIO框架），DMA中指定的地址是HVA，IOMMU页表中填充的是HVA到HPA的映射。</p><p>这个case类比于host上已经开启了paging，CPU寻址用的是HVA，MMU页表中填充的是HVA到HPA的映射。</p><h3 id="Nested-translation"><a href="#Nested-translation" class="headerlink" title="Nested translation"></a>Nested translation</h3><p>将device pass-thru给guest时，guest运行了DPDK这样的用户态驱动，此时，在guest中，DMA指定的地址是GVA。此刻，IOMMU寻址用到的就是Nested translation了，1st level translation完成GVA到GPA的映射，2nd level translation完成GPA到HPA的映射。</p><p>这个case类比于vCPU在non-root下寻址时，已经开启了paging，此时CPU指定的地址是GVA。CPU寻址用的也是嵌套页表，guest中的页表完成GVA到GPA的映射，EPT页表完成GPA到HPA的映射。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>安利下<a href="https://zhuanlan.zhihu.com/p/64566042" target="_blank" rel="noopener">类比思维</a>:通过相似事物之间的对比，可以让我们能够更好地理解新的事物和概念。</p><p>假设读者对MMU、EPT页表有着很深的理解，此刻，将它们与IOMMU的页表进行类比，读者就能很快理解IOMMU页表了！抓住关键要点：MMU、EPT页表解决的是CPU侧的寻址，而IOMMU页表解决的是device侧（即DMA）的寻址！</p><hr><p>参考资料：</p><ol><li><a href="https://events19.linuxfoundation.org/wp-content/uploads/2017/12/Hardware-Assisted-Mediated-Pass-Through-with-VFIO-Kevin-Tian-Intel.pdf" target="_blank" rel="noopener">Hardware-Assisted-Mediated-Pass-Through-with-VFIO-Kevin-Tian-Intel</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录个人对于IOMMU寻址方式的理解。
    
    </summary>
    
      <category term="IOMMU" scheme="http://liujunming.github.io/categories/IOMMU/"/>
    
    
      <category term="IOMMU" scheme="http://liujunming.github.io/tags/IOMMU/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第28期</title>
    <link href="http://liujunming.github.io/2022/05/13/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC28%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2022/05/13/每周分享第28期/</id>
    <published>2022-05-13T11:31:53.000Z</published>
    <updated>2022-07-24T08:22:39.586Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DMA-gt-RDMA-gt-eRDMA"><a href="#DMA-gt-RDMA-gt-eRDMA" class="headerlink" title="DMA -&gt; RDMA -&gt; eRDMA"></a>DMA -&gt; RDMA -&gt; eRDMA</h3><p><a href="https://mp.weixin.qq.com/s/L-HKnWP-4y3kSQLDcyi8xA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/L-HKnWP-4y3kSQLDcyi8xA</a></p><p>实现了RDMA上云，有“弹性”，随开随用， 所以叫做eRDMA。<a id="more"></a><br><img src="/images/2022/05/03.jpg" alt></p><h3 id="Junjie-YYDS"><a href="#Junjie-YYDS" class="headerlink" title="Junjie, YYDS"></a>Junjie, YYDS</h3><p><a href="https://www.youtube.com/watch?v=ddzlyOLMEF8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ddzlyOLMEF8</a></p><h3 id="BiscuitOS"><a href="#BiscuitOS" class="headerlink" title="BiscuitOS"></a>BiscuitOS</h3><p><a href="https://biscuitos.github.io/blog/BiscuitOS_Catalogue/" target="_blank" rel="noopener">https://biscuitos.github.io/blog/BiscuitOS_Catalogue/</a></p><h3 id="GitHub-要求所有账户开启双因素身份验证！"><a href="#GitHub-要求所有账户开启双因素身份验证！" class="headerlink" title="GitHub 要求所有账户开启双因素身份验证！"></a>GitHub 要求所有账户开启双因素身份验证！</h3><p><a href="https://mp.weixin.qq.com/s/KigguzTN8BoM_-hGBsDBWw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KigguzTN8BoM_-hGBsDBWw</a></p><h3 id="董耀祖：云原生是趋势，多云、边缘云也变得很热"><a href="#董耀祖：云原生是趋势，多云、边缘云也变得很热" class="headerlink" title="董耀祖：云原生是趋势，多云、边缘云也变得很热"></a>董耀祖：云原生是趋势，多云、边缘云也变得很热</h3><p><a href="https://mp.weixin.qq.com/s/uCuefcGJQWEWSq1IsNT5Fg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uCuefcGJQWEWSq1IsNT5Fg</a></p><h3 id="Kata-Containers-详细介绍及入门指南"><a href="#Kata-Containers-详细介绍及入门指南" class="headerlink" title="Kata Containers 详细介绍及入门指南"></a>Kata Containers 详细介绍及入门指南</h3><p><a href="https://mp.weixin.qq.com/s/lMXR2N7a_zKJpEbMxnw5Qg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/lMXR2N7a_zKJpEbMxnw5Qg</a></p><h3 id="专访魏星达，Dennis-M-Ritchie-Award-Honorable-Mention亚太首位获奖者"><a href="#专访魏星达，Dennis-M-Ritchie-Award-Honorable-Mention亚太首位获奖者" class="headerlink" title="专访魏星达，Dennis M. Ritchie Award Honorable Mention亚太首位获奖者"></a>专访魏星达，Dennis M. Ritchie Award Honorable Mention亚太首位获奖者</h3><p><a href="https://mp.weixin.qq.com/s/NOX_ebHqJ2JicJmNrPUj8Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/NOX_ebHqJ2JicJmNrPUj8Q</a></p><h3 id="Linux下的图形库curses写贪吃蛇，酷"><a href="#Linux下的图形库curses写贪吃蛇，酷" class="headerlink" title="Linux下的图形库curses写贪吃蛇，酷"></a>Linux下的图形库curses写贪吃蛇，酷</h3><p><a href="https://mp.weixin.qq.com/s/k25yEMEQY4YpVWO6SH1-VQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/k25yEMEQY4YpVWO6SH1-VQ</a></p><h3 id="Linux-启动时间优化实战，2-41-秒启动应用！"><a href="#Linux-启动时间优化实战，2-41-秒启动应用！" class="headerlink" title="Linux 启动时间优化实战，2.41 秒启动应用！"></a>Linux 启动时间优化实战，2.41 秒启动应用！</h3><p><a href="https://mp.weixin.qq.com/s/PeYpdtFH5u9MTWPkusT-Lw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PeYpdtFH5u9MTWPkusT-Lw</a></p><h3 id="《HelloGitHub》第-61-期"><a href="#《HelloGitHub》第-61-期" class="headerlink" title="《HelloGitHub》第 61 期"></a>《HelloGitHub》第 61 期</h3><p><a href="https://mp.weixin.qq.com/s/BXfDsUnm1GWZNMQ9YzEioQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/BXfDsUnm1GWZNMQ9YzEioQ</a></p><h3 id="阿里云张献涛：如何修炼云计算的弹指神通"><a href="#阿里云张献涛：如何修炼云计算的弹指神通" class="headerlink" title="阿里云张献涛：如何修炼云计算的弹指神通"></a>阿里云张献涛：如何修炼云计算的弹指神通</h3><p><a href="https://mp.weixin.qq.com/s/rxsdL11vHZQdRk81K_rDAA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rxsdL11vHZQdRk81K_rDAA</a></p><h3 id="尼采：《我为什么这么聪明》"><a href="#尼采：《我为什么这么聪明》" class="headerlink" title="尼采：《我为什么这么聪明》"></a>尼采：《我为什么这么聪明》</h3><p><a href="http://www.xiaohongshu.com/discovery/item/60fbc632000000000102577a" target="_blank" rel="noopener">http://www.xiaohongshu.com/discovery/item/60fbc632000000000102577a</a></p><blockquote><p>尼采曾说过：我为什么这么聪明，是因为我从来没有思考过那些不是问题的问题，我没有对此浪费过精力。<br>这句话透露着些许自大，但更多的是生活真理。人的精力都是有限的，管理好自己的精力，把有限的精力时间集中起来办一件事，这样成功的机率就会变大。人生路远，你必须精力饱满，不然，哪经得起风吹雨打，这是一种难得的能力，也是生活的智慧。<br>如果自己没有尽力，就没有资格批评别人不用心。开口抱怨很容易，但是闭嘴努力的人，更加值得尊敬。真正的强者，懂得欣赏别人，也会不断修炼自己。他们知道什么是共赢，懂得合作的重要，为人处世会多为他人考虑，待人接物真诚稳重。这样的人，在帮助别人的同时，也在不断丰富自己。<br>“进化”是我们永恒的使命，认请未来趋势，主动求进，方能化得正确的进步！快乐是可遇不可求的，但是充实是可求而不可遇的。所有想要的东西都不会空降。唯有让自己先搞起来，步履不停，走在路上，美好才会逐渐靠拢，生活才会慢慢向阳。</p></blockquote><h3 id="微软最受欢迎的开源项目"><a href="#微软最受欢迎的开源项目" class="headerlink" title="微软最受欢迎的开源项目"></a>微软最受欢迎的开源项目</h3><p><a href="https://mp.weixin.qq.com/s/4Fk6W4BY6OO2jGDDYwSkHA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/4Fk6W4BY6OO2jGDDYwSkHA</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;DMA-gt-RDMA-gt-eRDMA&quot;&gt;&lt;a href=&quot;#DMA-gt-RDMA-gt-eRDMA&quot; class=&quot;headerlink&quot; title=&quot;DMA -&amp;gt; RDMA -&amp;gt; eRDMA&quot;&gt;&lt;/a&gt;DMA -&amp;gt; RDMA -&amp;gt; eRDMA&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/L-HKnWP-4y3kSQLDcyi8xA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/L-HKnWP-4y3kSQLDcyi8xA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实现了RDMA上云，有“弹性”，随开随用， 所以叫做eRDMA。
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>MDev-NVMe: A NVMe Storage Virtualization Solution with Mediated Pass-Through</title>
    <link href="http://liujunming.github.io/2022/05/05/MDev-NVMe-A-NVMe-Storage-Virtualization-Solution-with-Mediated-Pass-Through/"/>
    <id>http://liujunming.github.io/2022/05/05/MDev-NVMe-A-NVMe-Storage-Virtualization-Solution-with-Mediated-Pass-Through/</id>
    <published>2022-05-05T13:18:13.000Z</published>
    <updated>2022-07-24T08:22:39.583Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/liujunming/paper_reading_notes/issues/13" target="_blank" rel="noopener">https://github.com/liujunming/paper_reading_notes/issues/13</a></p><p>Notes about ATC’18 paper. <a id="more"></a></p><p>个人对Mediated Pass-Through的理解是软件版的SR-IOV。看了这篇论文，有助于理解NVMe SR-IOV的一些实现细节吧。Mediated Pass-Through软件模拟的一部分操作，SR-IOV是用硬件来实现的。比如文章中的DMA translation，在SR-IOV中，由IOMMU的DMA Remapping来完成；SLBA的translation由SSD的firmware或者硬件来完成，反正不需要Hypervisor去做转换！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/liujunming/paper_reading_notes/issues/13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/liujunming/paper_reading_notes/issues/13&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Notes about ATC’18 paper.
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="存储" scheme="http://liujunming.github.io/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第27期</title>
    <link href="http://liujunming.github.io/2022/05/04/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC27%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2022/05/04/每周分享第27期/</id>
    <published>2022-05-04T02:39:48.000Z</published>
    <updated>2022-07-24T08:22:39.586Z</updated>
    
    <content type="html"><![CDATA[<h3 id="热插拔、热迁移和热升级"><a href="#热插拔、热迁移和热升级" class="headerlink" title="热插拔、热迁移和热升级"></a>热插拔、热迁移和热升级</h3><p><a href="https://www.jaguarmicro.com/n4.html" target="_blank" rel="noopener">https://www.jaguarmicro.com/n4.html</a><br><a id="more"></a></p><h3 id="qboot"><a href="#qboot" class="headerlink" title="qboot"></a>qboot</h3><p><a href="https://github.com/bonzini/qboot" target="_blank" rel="noopener">https://github.com/bonzini/qboot</a><br>A simple x86 firmware that can boot Linux.</p><h3 id="Xnip"><a href="#Xnip" class="headerlink" title="Xnip"></a>Xnip</h3><p>Mac下的截图小软件</p><h3 id="service-vs-systemctl"><a href="#service-vs-systemctl" class="headerlink" title="service vs systemctl"></a>service vs systemctl</h3><p><a href="https://serverfault.com/questions/867322/what-is-the-difference-between-service-and-systemctl" target="_blank" rel="noopener">https://serverfault.com/questions/867322/what-is-the-difference-between-service-and-systemctl</a><br><a href="https://stackoverflow.com/questions/43537851/difference-between-systemctl-and-service-command" target="_blank" rel="noopener">https://stackoverflow.com/questions/43537851/difference-between-systemctl-and-service-command</a></p><p><code>service</code> operates on the files in <em>/etc/init.d</em> and was used in conjunction with the old init system. <code>systemctl</code> operates on the files in <em>/lib/systemd</em>. If there is a file for your service in <em>/lib/systemd</em> it will use that first and if not it will fall back to the file in <em>/etc/init.d</em>. Also If you are using OS like ubuntu-14.04 only service command will be available.</p><p><code>service</code> is adequate for basic service management, while directly calling <code>systemctl</code> give greater control options.So if <code>systemctl</code> is available ,it will be better to use it.</p><h3 id="SSH免密登录"><a href="#SSH免密登录" class="headerlink" title="SSH免密登录"></a>SSH免密登录</h3><p><a href="https://blog.csdn.net/jeikerxiao/article/details/84105529" target="_blank" rel="noopener">https://blog.csdn.net/jeikerxiao/article/details/84105529</a></p><ul><li>上传公钥到服务器</li></ul><p>这里测试用的服务器地址为：192.168.235.22，用户为：root<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.235.22</span><br></pre></td></tr></table></figure></p><p>上面这条命令是写到服务器上的ssh目录下去了:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">vim authorized_keys</span><br></pre></td></tr></table></figure></p><p>可以看到客户端写入到服务器的 id_rsa.pub （公钥）内容。</p><h3 id="听悟"><a href="#听悟" class="headerlink" title="听悟"></a>听悟</h3><p><a href="https://www.sohu.com/a/496586977_114930" target="_blank" rel="noopener">https://www.sohu.com/a/496586977_114930</a><br>阿里推出会议AI助理“听悟”，可秒速生成智能会议纪要。</p><h3 id="Computer-Organization-and-Design-RISC-V-edition"><a href="#Computer-Organization-and-Design-RISC-V-edition" class="headerlink" title="Computer Organization and Design RISC-V edition"></a>Computer Organization and Design RISC-V edition</h3><p><a href="http://home.ustc.edu.cn/~louwenqi/reference_books_tools/Computer%20Organization%20and%20Design%20RISC-V%20edition.pdf" target="_blank" rel="noopener">http://home.ustc.edu.cn/~louwenqi/reference_books_tools/Computer%20Organization%20and%20Design%20RISC-V%20edition.pdf</a></p><h3 id="动画图解嵌入式常见的通讯协议：SPI、I²C、UART、红外-……"><a href="#动画图解嵌入式常见的通讯协议：SPI、I²C、UART、红外-……" class="headerlink" title="动画图解嵌入式常见的通讯协议：SPI、I²C、UART、红外 ……"></a>动画图解嵌入式常见的通讯协议：SPI、I²C、UART、红外 ……</h3><p><a href="https://mp.weixin.qq.com/s/XlVMaUaas6SXtURtAGEEng" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/XlVMaUaas6SXtURtAGEEng</a></p><h3 id="HMAT-Heterogeneous-Memory-Attribute-Table"><a href="#HMAT-Heterogeneous-Memory-Attribute-Table" class="headerlink" title="HMAT(Heterogeneous Memory Attribute Table)"></a>HMAT(Heterogeneous Memory Attribute Table)</h3><p><a href="https://lwn.net/Articles/724562/" target="_blank" rel="noopener">https://lwn.net/Articles/724562/</a><br><img src="/images/2022/05/1.jpg" alt></p><h3 id="software-defined-silicon"><a href="#software-defined-silicon" class="headerlink" title="software-defined silicon"></a>software-defined silicon</h3><p><a href="https://lwn.net/Articles/884876/" target="_blank" rel="noopener">https://lwn.net/Articles/884876/</a><br><a href="https://mp.weixin.qq.com/s/LP2BQZbRdYwaoLwNcietxw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LP2BQZbRdYwaoLwNcietxw</a></p><p>人们被自由软件吸引的原因有很多，包括价格、整体质量、社区支持和可用功能。但是，对我们中的许多人来说，自由软件的价值在于它能够让我们实际拥有并保持对我们系统的控制。自由软件中的反特征往往不会持续很久，而自由驱动程序往往可以解锁其供应商可能认为不适合提供的硬件功能。不过，英特尔即将推出的 “软件定义硅”（SDSi）机制可能会减少这种控制，因为它剥夺了任何没有支付必要费用的人对硬件功能的访问。<br>SDSi是一项 “功能”，预计将在即将推出的英特尔处理器中出现。其目的是在没有来自英特尔的证书的情况下，禁止对特定处理器功能的访问。正如David Box的启用补丁集所表明的那样，该机制本身的界面相对简单。它显示为总线上的一个设备，提供了几个操作：安装一个 “认证密钥证书 “或一个 “能力激活有效载荷”。证书用于验证任何启用功能的请求，而有效载荷则包含请求本身。除非这个设备被用来存储一个可接受的证书和有效载荷，否则它所管辖的功能对运行在该CPU上的软件来说是不可用的。</p><p><strong>付费解锁feature</strong>。</p><h3 id="从物理转AI、战数据库，95后程序员的职业选择"><a href="#从物理转AI、战数据库，95后程序员的职业选择" class="headerlink" title="从物理转AI、战数据库，95后程序员的职业选择"></a>从物理转AI、战数据库，95后程序员的职业选择</h3><p><a href="https://mp.weixin.qq.com/s/HrT-5gVLZSjwuM1hGOrt6A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/HrT-5gVLZSjwuM1hGOrt6A</a></p><h3 id="Cambridge-Dictionary"><a href="#Cambridge-Dictionary" class="headerlink" title="Cambridge Dictionary"></a>Cambridge Dictionary</h3><p><a href="https://dictionary.cambridge.org/" target="_blank" rel="noopener">https://dictionary.cambridge.org/</a></p><h3 id="Intel-Hires-Linux-BSD-Performance-Expert-Brendan-Gregg"><a href="#Intel-Hires-Linux-BSD-Performance-Expert-Brendan-Gregg" class="headerlink" title="Intel Hires Linux/BSD Performance Expert Brendan Gregg"></a>Intel Hires Linux/BSD Performance Expert Brendan Gregg</h3><p><a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Brendan-Gregg-Intel" target="_blank" rel="noopener">https://www.phoronix.com/scan.php?page=news_item&amp;px=Brendan-Gregg-Intel</a><br><img src="/images/2022/05/2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;热插拔、热迁移和热升级&quot;&gt;&lt;a href=&quot;#热插拔、热迁移和热升级&quot; class=&quot;headerlink&quot; title=&quot;热插拔、热迁移和热升级&quot;&gt;&lt;/a&gt;热插拔、热迁移和热升级&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.jaguarmicro.com/n4.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jaguarmicro.com/n4.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>ARM VMID vs VT-x VPID</title>
    <link href="http://liujunming.github.io/2022/05/02/ARM-VMID-vs-VT-x-VPID/"/>
    <id>http://liujunming.github.io/2022/05/02/ARM-VMID-vs-VT-x-VPID/</id>
    <published>2022-05-02T15:57:44.000Z</published>
    <updated>2022-07-24T08:22:39.582Z</updated>
    
    <content type="html"><![CDATA[<p>VT-x中VPID vs ARM虚拟化中的VMID(Virtual Machine Identifier)。<a id="more"></a></p><p><a href="/2022/04/12/浅谈TLB-in-Intel-CPU/">该文</a>介绍过PCID与VPID相关知识点。VMID的概念：8-bit value stored in VTTBR_EL2，标识某个VM，可以用于区分不同VM的TLB表项。</p><p>Intel中的PCID类似于ARM中的ASID(Address Space Identifier)，Intel中的VPID类似于ARM中的VMID。这些都很容易理解，但是，在 具体实现中，却有着一个显著的差异：VMID标识的是VM，而VPID标识的却是vCPU。</p><p>以KVM的实现作为佐证，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.17/source/arch/x86/kvm/vmx/vmx.c#L7002</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vmx_create_vcpu</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">vmx-&gt;vpid = allocate_vpid();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>问题1</strong>：<br>为什么VT-x中，VPID标识的是vCPU，而非VM呢？</p><p>首先考虑如下case：<br>在同一个物理CPU上，首先运行的是VM A的vCPU1，接着运行的是VM A的vCPU2，同时，vCPU1与vCPU2上运行的是虚拟机的不同进程。</p><p>如果VPID标识的是vCPU，那么，在由vCPU1切换到vCPU2时，vCPU2并不能使用vCPU1之前缓存的TLB entry。但是，如果VPID标识的是VM，那么，在由vCPU1切换到vCPU2时，vCPU2可以直接使用vCPU1之前缓存的TLB entry。</p><p>从直觉上来说，用VPID标识VM的话，效率是不是更高呢？</p><p>但在VT-x中，如果使用VPID标识VM的话，却存在着问题：</p><ul><li>当guest使用PCID的话，使用VPID标识VM没有任何问题，(VM的id，PCID，virtual address)这个三元组是唯一的</li><li>但是，当guest不使用PCID的话，上述case中，当由vCPU1切换到vCPU2时，(VM的id，virtual address)这个二元组并不唯一，就会产生错误(虚拟机上的进程a用了进程b的TLB entry了，当然会出错！)</li></ul><p><strong>问题2</strong>：<br>经过以上的分析可知：VPID标识VM会存在问题，因此需要使用VPID来标识vCPU。那么ARM下，为什么可以使用VMID来标识VM，而非vCPU呢？</p><p>答案：ARM中，无法disable ASID，ASID是必须要enabled的一个feature。而在Intel的CPU上，是可以disable PCID的。所以，在ARM中，虚拟机必须enable ASID，否则就是guest OS的bug了。因此，使用VMID标识VM没有任何问题，因为(VMID，ASID，virtual address)这个三元组是唯一的！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VT-x中VPID vs ARM虚拟化中的VMID(Virtual Machine Identifier)。
    
    </summary>
    
      <category term="体系结构" scheme="http://liujunming.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
      <category term="ARM" scheme="http://liujunming.github.io/tags/ARM/"/>
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Data Integrity Field(DIF) and Data Integrity Extension (DIX)</title>
    <link href="http://liujunming.github.io/2022/04/14/Notes-about-Data-Integrity-Field-DIF-and-Data-Integrity-Extension-DIX/"/>
    <id>http://liujunming.github.io/2022/04/14/Notes-about-Data-Integrity-Field-DIF-and-Data-Integrity-Extension-DIX/</id>
    <published>2022-04-14T00:24:55.000Z</published>
    <updated>2022-04-14T06:00:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about Data Integrity Field(DIF) and Data Integrity Extension (DIX).<a id="more"></a></p><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><p>Some vendors have adopted the name Protection Information (PI) to refer to the DIF/DIX functionality. </p><p><img src="/images/2022/04/84.PNG" alt></p><h3 id="1-1-Normal-I-O"><a href="#1-1-Normal-I-O" class="headerlink" title="1.1 Normal I/O"></a>1.1 Normal I/O</h3><p><img src="/images/2022/04/86.PNG" alt></p><p>从图中可以知道，对于Normal I/O，从Application-&gt;OS-&gt;I/O Controller-&gt;SAN-&gt;Disk Array-&gt;Disk Driver之间，各层都有自己的integrity measures。这些integrity measures需要存储error checking information。比如硬盘的sector大小为512个字节，因为需要额外的空间存储error checking information，所以，实际能存储的有效数据是低于512字节的。</p><h2 id="2-Data-Integrity-Field-DIF"><a href="#2-Data-Integrity-Field-DIF" class="headerlink" title="2. Data Integrity Field(DIF)"></a>2. Data Integrity Field(DIF)</h2><p>Terms: <a href="https://en.wikipedia.org/wiki/Host_adapter" target="_blank" rel="noopener">HBA</a> </p><p>In computer hardware, a host controller, host adapter, or host bus adapter (HBA), connects a computer, which acts as the host system, to other network and storage devices. The terms are primarily used to refer to devices for connecting SCSI, Fibre Channel and SATA devices.</p><p>DIF is a feature added to the SCSI Standard. It adds 8 bytes to the end of each sector on disk.</p><p><img src="/images/2022/04/85.PNG" alt></p><p>It increases the size of the commonly-used 512-byte disk block from 512 to 520 bytes. The extra bytes comprise the Data Integrity Field (DIF). The basic idea is that the HBA will calculate a checksum value for the data block on writes, and store it in the DIF. The storage device will confirm the checksum on receive, and store the data plus checksum. On a read, the checksum will be checked by the storage device and by the receiving HBA.</p><p><img src="/images/2022/04/87.PNG" alt></p><h2 id="3-Data-Integrity-Extension-DIX"><a href="#3-Data-Integrity-Extension-DIX" class="headerlink" title="3. Data Integrity Extension (DIX)"></a>3. Data Integrity Extension (DIX)</h2><p><img src="/images/2022/04/89.PNG" alt></p><p>SCSI controllers就是HBA。</p><p><img src="/images/2022/04/83.PNG" alt></p><p><img src="/images/2022/04/84.PNG" alt></p><p>个人对end-to-end data integrity的理解：Application-&gt;OS-&gt;I/O Controller-&gt;SAN-&gt;Disk Array-&gt;Disk Driver之间，共用error checking information，而非各层用自己的error checking information。</p><p><img src="/images/2022/04/88.PNG" alt></p><hr><p>参考资料:</p><ol><li><a href="https://access.redhat.com/solutions/41548" target="_blank" rel="noopener">What is DIF/DIX</a></li><li><a href="https://www.landley.net/kdocs/ols/2008/ols2008v2-pages-151-156.pdf" target="_blank" rel="noopener">Linux Data Integrity Extensions paper</a></li><li><a href="http://mkp.net/pubs/ols2008-slides.pdf" target="_blank" rel="noopener">DIF, DIX and Linux Data Integrity slides</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about Data Integrity Field(DIF) and Data Integrity Extension (DIX).
    
    </summary>
    
      <category term="存储" scheme="http://liujunming.github.io/categories/%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="存储" scheme="http://liujunming.github.io/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Notes about EPT Sub-Page Write Permissions</title>
    <link href="http://liujunming.github.io/2022/04/13/Notes-about-EPT-Sub-Page-Write-Permissions/"/>
    <id>http://liujunming.github.io/2022/04/13/Notes-about-EPT-Sub-Page-Write-Permissions/</id>
    <published>2022-04-12T16:28:54.000Z</published>
    <updated>2022-04-13T01:58:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直都听说过SPP(Sub-Page Protection)这个技术，但是一直没有深入研究过，本文将mark下EPT Sub-Page Write Permissions(也就是SPP)相关笔记。<a id="more"></a></p><p>个人觉得最好的材料应该是<a href="/pdf/spp_xen_summit2018_V2.PPTX">Spp Xen Summit2018 V2 </a>了，<a href="https://xensummit18.sched.com/event/EeHb/ept-based-sub-page-write-protection-on-xenc-yi-zhang-intel" target="_blank" rel="noopener">slides</a>源于xensummit18，感兴趣的读者也可以观看<a href="https://www.youtube.com/watch?v=TVrrN3ol6hY" target="_blank" rel="noopener">视频</a>。</p><p><img src="/images/2022/04/72.PNG" alt></p><p><img src="/images/2022/04/73.PNG" alt></p><p><img src="/images/2022/04/74.PNG" alt></p><p><img src="/images/2022/04/75.PNG" alt></p><p>For each guest-physical address eligible for sub-page write permissions, there is a 64-bit <strong>sub-page permission vector</strong> (<strong>SPP vector</strong>). All addresses on a 4-KByte page use the same SPP vector.<br>SPPT以GPA为key，以SPP vector为value。</p><p><img src="/images/2022/04/76.PNG" alt></p><p><img src="/images/2022/04/77.PNG" alt></p><p><img src="/images/2022/04/78.PNG" alt></p><p><img src="/images/2022/04/79.PNG" alt></p><p><img src="/images/2022/04/80.PNG" alt></p><p><img src="/images/2022/04/81.PNG" alt></p><p><img src="/images/2022/04/82.PNG" alt></p><p>Spec在SDM中Sub-Page Write Permissions一节。<br><img src="/images/2022/04/71.PNG" alt></p><p>如果还想研究代码的话，不妨看下<a href="https://lore.kernel.org/kvm/20200119040507.23113-1-weijiang.yang@intel.com/" target="_blank" rel="noopener">Enable Sub-Page Write Protection Support</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直都听说过SPP(Sub-Page Protection)这个技术，但是一直没有深入研究过，本文将mark下EPT Sub-Page Write Permissions(也就是SPP)相关笔记。
    
    </summary>
    
      <category term="VT-x" scheme="http://liujunming.github.io/categories/VT-x/"/>
    
    
      <category term="VT-x" scheme="http://liujunming.github.io/tags/VT-x/"/>
    
  </entry>
  
  <entry>
    <title>浅谈TLB in Intel CPU</title>
    <link href="http://liujunming.github.io/2022/04/12/%E6%B5%85%E8%B0%88TLB-in-Intel-CPU/"/>
    <id>http://liujunming.github.io/2022/04/12/浅谈TLB-in-Intel-CPU/</id>
    <published>2022-04-12T14:46:51.000Z</published>
    <updated>2022-04-12T08:02:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将结合SDM，浅谈下TLB。<a id="more"></a></p><h2 id="1-TLB"><a href="#1-TLB" class="headerlink" title="1. TLB"></a>1. TLB</h2><h3 id="1-1-Why"><a href="#1-1-Why" class="headerlink" title="1.1 Why"></a>1.1 Why</h3><p>没有TLB的话，每次内存寻址时，都需要访问页表（页表位于内存中），开销较大。TLB缓存了VA(Virtual Address)到PA(Physical Address)的映射，当TLB hit时，就无需从内存中访问页表了。</p><h3 id="1-2-What"><a href="#1-2-What" class="headerlink" title="1.2 What"></a>1.2 What</h3><p>The upper bits of a linear address (called the <strong>page number</strong>) determine the upper bits of the physical address (called the <strong>page frame</strong>); the lower bits of the linear address (called the page offset) determine the lower bits of the physical address. The boundary between the page number and the page offset is determined by the <strong>page size</strong>. </p><p><img src="/images/2022/04/67.PNG" alt></p><h2 id="2-全局TLB-flush"><a href="#2-全局TLB-flush" class="headerlink" title="2. 全局TLB flush"></a>2. 全局TLB flush</h2><p>每次进程切换时，需要更换CR3寄存器，flush掉全部的TLB Entries，开销较大。为此，硬件上引入了<a href="/2022/04/12/浅谈TLB-in-Intel-CPU/#3-Global-page">Global page</a>与<a href="/2022/04/12/浅谈TLB-in-Intel-CPU/#4-PCID">PCID</a>机制，避免进程切换时flush掉所有的TLB Entries。</p><h2 id="3-Global-page"><a href="#3-Global-page" class="headerlink" title="3. Global page"></a>3. Global page</h2><p>Linux内存管理中，内核空间是所有进程共享的，每个进程有自己独立的用户空间。进程切换时，是否可以不flush掉内核空间的TLB Entries呢？当然可以，Global page正是为此而生。</p><p>The Intel-64 and IA-32 architectures also allow for global pages when the PGE flag (bit 7) is 1 in CR4. If the G flag(bit 8) is 1 in a paging-structure entry that maps a page (either a PTE or a paging-structure entry in which the PS flag is 1), any TLB entry cached for a linear address using that paging-structure entry is considered to be global.</p><h2 id="4-PCID"><a href="#4-PCID" class="headerlink" title="4. PCID"></a>4. PCID</h2><p>以前，是以(VA)这个一元组为key来唯一索引TLB Entry。PCID(Process-Context Identifier)的引入，硬件以(VA,进程信息)来唯一索引TLB Entry。这样，进程切换时，无需刷掉TLB Entries了，因为不同进程的(VA,进程信息)二元组是不同的。</p><p><img src="/images/2022/04/68.PNG" alt></p><h3 id="4-1-Overlap-between-PCID-and-Global-page"><a href="#4-1-Overlap-between-PCID-and-Global-page" class="headerlink" title="4.1 Overlap between PCID and Global page"></a>4.1 Overlap between PCID and Global page</h3><p>A logical processor may use a global TLB entry to translate a linear address, even if the TLB entry is associated with a PCID different from the current PCID.</p><h2 id="5-TLB-shootdown"><a href="#5-TLB-shootdown" class="headerlink" title="5. TLB shootdown"></a>5. TLB shootdown</h2><p><img src="/images/2022/04/69.PNG" alt></p><h2 id="6-VPID"><a href="#6-VPID" class="headerlink" title="6. VPID"></a>6. VPID</h2><p>虚拟化下，以(VA,进程信息)已经不能唯一索引TLB Entry了，因为不同virtual processors间，可能产生相同的(VA,进程信息)二元组，为此，在同一个物理CPU上，不同vCPU调度时，Hypervisor需要flush掉所有的TLB Entries。为此，VPID(Virtual-Processor IDentifier)应运而生。以(VA,进程信息，virtual processor信息)这个三元组来唯一索引TLB Entry。这样，在同一个物理CPU上，不同vCPU调度时，Hypervisor无需flush掉TLB Entries。</p><p>当然，VPID与PCID的使用不是绑定的，要看具体(Hypervisor和Guest OS)的实现了。例如，Hypervisor可以使用VPID，Guest OS不使用PCID，那么，此刻硬件是以(VA,virtual processor信息)来索引TLB Entry了。在同一个物理CPU上，不同vCPU调度时，Hypervisor无需flush掉TLB Entries，但是，在Guest OS中，每次进程切换时，Guest OS需要Flush掉TLB Entries来保证正确性。</p><p><img src="/images/2022/04/70.PNG" alt></p><h2 id="7-Rethinking-Protection-Keys"><a href="#7-Rethinking-Protection-Keys" class="headerlink" title="7. Rethinking Protection Keys"></a>7. Rethinking Protection Keys</h2><p>之前已经介绍过了<a href="/2020/03/07/Introduction-to-pkeys/">PKU</a>与<a href="/2022/02/27/Introduction-to-PKS/">PKS</a>，这里，从TLB的视角，重新看下Protection Keys。</p><p>Memory Protection Keys (pkeys) are an extension to existing page-based memory permissions. Normal page permissions using page tables require expensive system calls and TLB invalidations when changing permissions. Memory Protection Keys provide a mechanism for changing protections without requiring modification of the page tables on every permission change.</p><p>Protection Keys是无需flush TLB的。留下的open是：</p><ol><li>通过Protection Keys更改permissions，最终硬件是否会更改物理TLB Entry中的access rights位呢?</li><li>如果1成立的话，对于Multiple Processors，是否需要类似于propagating这个过程呢？这个过程是由软件or硬件来完成呢？</li></ol><p>这些问题我当前并不知道答案，等待后续的更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将结合SDM，浅谈下TLB。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
