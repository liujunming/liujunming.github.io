<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2021-12-24T13:08:07.571Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Intel CPU operating modes</title>
    <link href="http://liujunming.github.io/2021/12/24/Intel-CPU-operating-modes/"/>
    <id>http://liujunming.github.io/2021/12/24/Intel-CPU-operating-modes/</id>
    <published>2021-12-24T11:24:52.000Z</published>
    <updated>2021-12-24T13:08:07.571Z</updated>
    
    <content type="html"><![CDATA[<p>本文以Intel SDM为主，以<a href="https://github.com/projectacrn/acrn-hypervisor/tree/release_2.7" target="_blank" rel="noopener">ACRN</a>源码为辅来介绍Intel CPU operating modes。<a id="more"></a></p><h2 id="1-IA-32-architecture"><a href="#1-IA-32-architecture" class="headerlink" title="1. IA-32 architecture"></a>1. IA-32 architecture</h2><h3 id="1-1-Protected-mode"><a href="#1-1-Protected-mode" class="headerlink" title="1.1 Protected mode"></a>1.1 Protected mode</h3><p>This mode is the native state of the processor. Among the capabilities of protected mode is the ability to directly execute “real-address mode” 8086 software in a protected, multi-tasking environment. This feature is called <strong>virtual-8086 mode</strong>, although it is not actually a processor mode. Virtual-8086 mode is actually a protected mode attribute that can be enabled for any task.</p><h3 id="1-2-Real-address-mode"><a href="#1-2-Real-address-mode" class="headerlink" title="1.2 Real-address mode"></a>1.2 Real-address mode</h3><p>This mode implements the programming environment of the Intel 8086 processor with extensions (such as the ability to switch to protected or system management mode). The processor is placed in real-address mode following power-up or a reset.</p><h3 id="1-3-System-management-mode-SMM"><a href="#1-3-System-management-mode-SMM" class="headerlink" title="1.3 System management mode (SMM)"></a>1.3 System management mode (SMM)</h3><p> This mode provides an operating system or executive with a transparent mechanism for implementing platform-specific functions such as power management and system security. The processor enters SMM when the external SMM interrupt pin (SMI#) is activated or an SMI is received from the advanced programmable interrupt controller (APIC).</p><p>In SMM, the processor switches to a separate address space while saving the basic context of the currently running program or task. SMM-specific code may then be executed transparently. Upon returning from SMM, the processor is placed back into its state prior to the system management interrupt. </p><h2 id="2-Intel®-64-Architecture"><a href="#2-Intel®-64-Architecture" class="headerlink" title="2. Intel® 64 Architecture"></a>2. Intel® 64 Architecture</h2><p>Intel 64 architecture adds IA-32e mode. IA-32e mode has two sub-modes.</p><h3 id="2-1-Compatibility-mode-sub-mode-of-IA-32e-mode"><a href="#2-1-Compatibility-mode-sub-mode-of-IA-32e-mode" class="headerlink" title="2.1 Compatibility mode(sub-mode of IA-32e mode)"></a>2.1 Compatibility mode(sub-mode of IA-32e mode)</h3><p>Compatibility mode permits most legacy 16-bit and 32-bit applications to run without re-compilation under a 64-bit operating system. </p><h3 id="2-2-64-bit-mode-sub-mode-of-IA-32e-mode"><a href="#2-2-64-bit-mode-sub-mode-of-IA-32e-mode" class="headerlink" title="2.2 64-bit mode(sub-mode of IA-32e mode)"></a>2.2 64-bit mode(sub-mode of IA-32e mode)</h3><p>This mode enables a 64-bit operating system to run applications written to access 64-bit linear address space.</p><h2 id="3-状态机"><a href="#3-状态机" class="headerlink" title="3. 状态机"></a>3. 状态机</h2><p><img src="/images/2021/12/23.png" alt><br><img src="/images/2021/12/24.png" alt></p><h2 id="4-Code"><a href="#4-Code" class="headerlink" title="4. Code"></a>4. Code</h2><p><a href="https://github.com/projectacrn/acrn-hypervisor/blob/release_2.7/hypervisor/arch/x86/guest/vcpu.c#L301-#L317" target="_blank" rel="noopener">set_vcpu_mode</a></p><h3 id="4-1-How-to-determine-if-protect-mode"><a href="#4-1-How-to-determine-if-protect-mode" class="headerlink" title="4.1 How to determine if protect mode?"></a>4.1 How to determine if protect mode?</h3><p><img src="/images/2021/12/25.png" alt></p><h3 id="4-2-How-to-determine-if-IA-32e-mode"><a href="#4-2-How-to-determine-if-IA-32e-mode" class="headerlink" title="4.2 How to determine if IA-32e mode?"></a>4.2 How to determine if IA-32e mode?</h3><p>注意：IA-32e mode还有一个叫法:long mode。</p><p><img src="/images/2021/12/21.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_IA32_EFER_LME_BIT(1UL &lt;&lt; 8U)<span class="comment">/* IA32e mode enable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_IA32_EFER_LMA_BIT(1UL &lt;&lt; 10U)<span class="comment">/* IA32e mode active */</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> ((ia32_efer &amp; MSR_IA32_EFER_LMA_BIT) != <span class="number">0U</span>L)</span><br></pre></td></tr></table></figure><h3 id="4-3-How-to-determine-if-64-bit-mode"><a href="#4-3-How-to-determine-if-64-bit-mode" class="headerlink" title="4.3 How to determine if 64-bit mode?"></a>4.3 How to determine if 64-bit mode?</h3><p><img src="/images/2021/12/22.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ia32_efer &amp; MSR_IA32_EFER_LMA_BIT) != <span class="number">0U</span>L) &#123;</span><br><span class="line"><span class="keyword">if</span> ((cs_attr &amp; <span class="number">0x2000</span>U) != <span class="number">0U</span>) &#123;</span><br><span class="line"><span class="comment">/* CS.L = 1 */</span></span><br><span class="line">vcpu-&gt;arch.cpu_mode = CPU_MODE_64BIT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-How-to-determine-if-compatibility-mode"><a href="#4-4-How-to-determine-if-compatibility-mode" class="headerlink" title="4.4 How to determine if compatibility mode?"></a>4.4 How to determine if compatibility mode?</h3><p>IA32e mode active and CS.L = 0</p><hr><p>参考资料:</p><ol><li><a href="https://zhuanlan.zhihu.com/p/69334474" target="_blank" rel="noopener">x86-64处理器的几种运行模式</a></li><li><a href="https://zhuanlan.zhihu.com/p/298033676" target="_blank" rel="noopener">X86 CPU的工作模式</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文以Intel SDM为主，以&lt;a href=&quot;https://github.com/projectacrn/acrn-hypervisor/tree/release_2.7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ACRN&lt;/a&gt;源码为辅来介绍Intel CPU operating modes。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>The usage of kdump</title>
    <link href="http://liujunming.github.io/2021/12/23/The-usage-of-kdump/"/>
    <id>http://liujunming.github.io/2021/12/23/The-usage-of-kdump/</id>
    <published>2021-12-22T16:09:36.000Z</published>
    <updated>2021-12-24T05:15:14.135Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about Linux kernel kdump.<a id="more"></a></p><h3 id="1-motivation"><a href="#1-motivation" class="headerlink" title="1. motivation"></a>1. motivation</h3><p>有时候<a href="/2021/12/11/Notes-about-Linux-kernel-Oops/">Oops</a>发生的同时系统也会宕机，此时这些出错信息是来不及存入文件中的，关掉电源后就无法再看到了。我们只能通过其他的方式来记录：手抄或者拍照。</p><p>还有更坏的情况，如果Oops信息过多的话，一页屏幕显示不全，我们怎么来查看完整的内容呢？第一种方法，在grub里用vga参数指定更高的分辨率以使屏幕可以显示更多的内容。很明显，这个方法其实解决不了太多的问题；第二种方法，使用两台机器，把调试机的Oops信息通过串口打印到宿主机的屏幕上。但现在大部分的笔记本电脑是没有串口的，这个解决方法也有很大的局限性；第三种方法，使用内核转储工具kdump把发生Oops时的内存和CPU寄存器的内容dump到一个文件里，之后我们再用工具来分析问题。</p><h3 id="2-Overview"><a href="#2-Overview" class="headerlink" title="2. Overview"></a>2. Overview</h3><p>Kdump uses kexec to quickly boot to a dump-capture kernel whenever a dump of the system kernel’s memory needs to be taken (for example, when the system panics). The system kernel’s memory image is preserved across the reboot and is accessible to the dump-capture kernel.</p><p>You can use common commands, such as cp, scp or makedumpfile to copy the memory image to a dump file on the local disk, or across the network to a remote system.</p><p>When the system kernel boots, it reserves a small section of memory for the dump-capture kernel. This ensures that ongoing Direct Memory Access (DMA) from the system kernel does not corrupt the dump-capture kernel. The kexec -p command loads the dump-capture kernel into this reserved memory.</p><p>With the dump-capture kernel, you can access the memory image through /proc/vmcore. This exports the dump as an ELF-format file that you can write out using file copy commands such as cp or scp. You can also use makedumpfile utility to analyze and write out filtered contents with options, e.g with ‘-d 31’ it will only write out kernel data. Further, you can use analysis tools such as the GDB and the Crash tool to debug the dump file. </p><p><img src="/images/2021/12/20.png" alt></p><h3 id="3-System-kernel-config-options"><a href="#3-System-kernel-config-options" class="headerlink" title="3. System kernel config options"></a>3. System kernel config options</h3><p>There are two possible methods of using Kdump.</p><ol><li>Build a separate custom dump-capture kernel for capturing the kernel core dump.</li><li>Or use the system kernel binary itself as dump-capture kernel and there is no need to build a separate dump-capture kernel. This is possible only with the architectures which support a relocatable kernel. As of today, i386, x86_64, ppc64, ia64, arm and arm64 architectures support relocatable kernel.</li></ol><p>本文选择的是第二种方法。</p><p>system kernel config options配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KEXEC=y</span><br><span class="line">CONFIG_KEXEC_FILE=y</span><br><span class="line">CONFIG_KEXEC_CORE=y</span><br><span class="line">CONFIG_CRASH_CORE=y</span><br><span class="line">CONFIG_SYSFS=y</span><br><span class="line">CONFIG_DEBUG_INFO=y</span><br></pre></td></tr></table></figure><h3 id="4-Setup-and-Installation"><a href="#4-Setup-and-Installation" class="headerlink" title="4. Setup and Installation"></a>4. Setup and Installation</h3><h4 id="4-1-Ubuntu"><a href="#4-1-Ubuntu" class="headerlink" title="4.1 Ubuntu"></a>4.1 Ubuntu</h4><p>参考: <a href="https://ubuntu.com/server/docs/kernel-crash-dump" target="_blank" rel="noopener">ubuntu Kernel Crash Dump</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install linux-crashdump -y</span><br></pre></td></tr></table></figure><p><img src="/images/2021/12/19.png" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/crash-utility/crash/archive/refs/tags/7.3.1.tar.gz</span><br><span class="line">tar xzvf 7.3.1.tar.gz</span><br><span class="line">cd crash-7.3.1</span><br><span class="line"></span><br><span class="line">sudo apt install bison libz-dev libncurses5-dev libncursesw5-dev texinfo -y</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h3 id="5-强制内核崩溃"><a href="#5-强制内核崩溃" class="headerlink" title="5. 强制内核崩溃"></a>5. 强制内核崩溃</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/kernel/sysrq</span><br><span class="line">echo c &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure><p>重启后可以在/var/crash/目录下看到vmcore日志文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /var/crash/</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">202112241159  kdump_lock  kexec_cmd</span><br><span class="line"><span class="meta">$</span> cd 202112241159</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">vmcore.202112241159</span><br><span class="line"><span class="meta">$</span> file vmcore.202112241159</span><br><span class="line">vmcore.202112241159: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style</span><br></pre></td></tr></table></figure><h3 id="6-Kdump-analysis-using-crash"><a href="#6-Kdump-analysis-using-crash" class="headerlink" title="6. Kdump analysis using crash"></a>6. Kdump analysis using crash</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crash vmcore.202112241159 /usr/lib/debug/lib/modules/5.15.0-rc6-virt-ui+/vmlinux</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; bt</span><br><span class="line">PID: 1579   TASK: ffff8d6087084f80  CPU: 0   COMMAND: &quot;bash&quot;</span><br><span class="line"> #0 [ffffae2c80fc7cc0] machine_kexec at ffffffffa9061348</span><br><span class="line"> #1 [ffffae2c80fc7d20] __crash_kexec at ffffffffa91bc670</span><br><span class="line"> #2 [ffffae2c80fc7de8] panic at ffffffffa9f301f0</span><br><span class="line"> #3 [ffffae2c80fc7e68] sysrq_handle_crash at ffffffffa98327a6</span><br><span class="line"> #4 [ffffae2c80fc7e70] __handle_sysrq.cold at ffffffffa9f62e96</span><br><span class="line"> #5 [ffffae2c80fc7ea0] write_sysrq_trigger at ffffffffa98331d4</span><br><span class="line"> #6 [ffffae2c80fc7eb0] proc_reg_write at ffffffffa93e83c3</span><br><span class="line"> #7 [ffffae2c80fc7ec8] vfs_write at ffffffffa934dc2d</span><br><span class="line"> #8 [ffffae2c80fc7f00] ksys_write at ffffffffa934df45</span><br><span class="line"> #9 [ffffae2c80fc7f38] do_syscall_64 at ffffffffa9fa9553</span><br><span class="line">#10 [ffffae2c80fc7f50] entry_SYSCALL_64_after_hwframe at ffffffffaa00007c</span><br><span class="line">    RIP: 00007f5ab67f5224  RSP: 00007ffe5b9e7038  RFLAGS: 00000246</span><br><span class="line">    RAX: ffffffffffffffda  RBX: 0000000000000002  RCX: 00007f5ab67f5224</span><br><span class="line">    RDX: 0000000000000002  RSI: 0000561b7a365e00  RDI: 0000000000000001</span><br><span class="line">    RBP: 0000561b7a365e00   R8: 000000000000000a   R9: 0000000000000001</span><br><span class="line">    R10: 000000000000000a  R11: 0000000000000246  R12: 00007f5ab6ad1760</span><br><span class="line">    R13: 0000000000000002  R14: 00007f5ab6acd2a0  R15: 00007f5ab6acc760</span><br><span class="line">    ORIG_RAX: 0000000000000001  CS: 0033  SS: 002b</span><br></pre></td></tr></table></figure><h3 id="7-MISC"><a href="#7-MISC" class="headerlink" title="7. MISC"></a>7. MISC</h3><ul><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/kdump/kdump.html#crashkernel-syntax" target="_blank" rel="noopener">crashkernel syntax</a></li><li>Configure Dump Location</li><li>Configure Core Collector</li></ul><p>Configure Dump Location和Configure Core Collector可以参考<a href="https://www.thegeekstuff.com/2014/05/kdump/" target="_blank" rel="noopener">How to use kdump for Linux Kernel Crash Analysis</a>。</p><hr><p>参考资料:</p><ol><li><a href="https://events.static.linuxfound.org/sites/events/files/slides/kdump_usage_and_internals.pdf" target="_blank" rel="noopener">kdump: usage and internals</a></li><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/kdump/kdump.html" target="_blank" rel="noopener"> The kexec-based Crash Dumping Solution</a></li><li><a href="https://programming.vip/docs/example-using-crash-to-analyze-kdump-dump-kernel-crash-kernel.html" target="_blank" rel="noopener">Example using crash to analyze Kdump dump kernel crash kernel</a></li><li><a href="https://www.thegeekstuff.com/2014/05/kdump/" target="_blank" rel="noopener">How to use kdump for Linux Kernel Crash Analysis</a></li><li><a href="https://www.jianshu.com/p/3c92647140f7" target="_blank" rel="noopener">如何在Ubuntu18.04下安装和配置kdump</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about Linux kernel kdump.
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Notes about the usage of git log</title>
    <link href="http://liujunming.github.io/2021/12/18/Notes-about-the-usage-of-git-log/"/>
    <id>http://liujunming.github.io/2021/12/18/Notes-about-the-usage-of-git-log/</id>
    <published>2021-12-17T16:04:12.000Z</published>
    <updated>2021-12-18T03:52:22.392Z</updated>
    
    <content type="html"><![CDATA[<p>在看源码过程中，发现可以好好利用git log来查看和搜索提交历史，本文特此mark下notes。<a id="more"></a>大部分内容转载自<a href="https://blog.csdn.net/daguanjia11/article/details/73823617" target="_blank" rel="noopener">git log的常见用法</a>。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://git-scm.com/docs/git-log" target="_blank" rel="noopener">https://git-scm.com/docs/git-log</a></p><p><code>man git-log</code></p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a><code>git log</code></h3><p>使用git log命令，什么参数都没有的话，会以下面的格式输出所有的日志。如果日志特别多的话，在git bash中，按向下键来查看更多，按q键退出查看日志。<br><img src="/images/2021/12/7.png" alt></p><h3 id="git-log-oneline"><a href="#git-log-oneline" class="headerlink" title="git log --oneline"></a><code>git log --oneline</code></h3><p><code>--oneline</code>参数可以将每条日志的输出为一行，如果日志比较多的话，用这个参数能够使结果看起来比较醒目。<br><img src="/images/2021/12/8.png" alt></p><h3 id="git-log-length"><a href="#git-log-length" class="headerlink" title="git log -[length]"></a><code>git log -[length]</code></h3><p><code>-[length]</code>参数用于指定显示多少条日志</p><p><img src="/images/2021/12/9.png" alt><br>这里面使用<code>-2</code>来指定显示前两条日志</p><h3 id="git-log-skip-skip"><a href="#git-log-skip-skip" class="headerlink" title="git log --skip=[skip]"></a><code>git log --skip=[skip]</code></h3><p><code>--skip=[skip]</code>参数用来指定跳过前几条日志。下面的命令用来查看第二和第三条日志<br><img src="/images/2021/12/10.png" alt></p><h3 id="git-log-pretty-raw"><a href="#git-log-pretty-raw" class="headerlink" title="git log --pretty=raw"></a><code>git log --pretty=raw</code></h3><p><code>--pretty=raw</code>会显示出关于每次提交的更多信息。</p><p><img src="/images/2021/12/11.png" alt><br>输出的信息中包括提交ID，文件树ID，父提交ID，作者和提交者，这些信息都非常有用。</p><h3 id="git-log-p"><a href="#git-log-p" class="headerlink" title="git log -p"></a><code>git log -p</code></h3><p><code>-p</code>参数输出的信息会更多，用来显示提交的改动记录，相当于多次使用<code>git show [commit_id]</code>的结果。<br><img src="/images/2021/12/12.png" alt></p><h3 id="git-log-graph"><a href="#git-log-graph" class="headerlink" title="git log --graph"></a><code>git log --graph</code></h3><p><code>--graph</code>参数会绘制提交的线索，如果有合并的话，也会更清晰地显示出来<br><img src="/images/2021/12/14.png" alt></p><p>这样可以查看哪几个commit是一块提交的。</p><h3 id="git-log-decorate"><a href="#git-log-decorate" class="headerlink" title="git log --decorate"></a><code>git log --decorate</code></h3><p><code>--decorate</code>参数用来显示一些相关的信息，如HEAD、分支名、tag名等。<br><img src="/images/2021/12/15.png" alt></p><h3 id="git-log-name-status"><a href="#git-log-name-status" class="headerlink" title="git log --name-status"></a><code>git log --name-status</code></h3><p><code>--name-status</code>参数会带出每次提交对应的文件改动。<br><img src="/images/2021/12/16.png" alt></p><h2 id="搜索git日志"><a href="#搜索git日志" class="headerlink" title="搜索git日志"></a>搜索git日志</h2><h3 id="通过作者搜索"><a href="#通过作者搜索" class="headerlink" title="通过作者搜索"></a>通过作者搜索</h3><p>有时候会从提交记录中查看一下自己（或某个人）的某次提交，git log命令可以很快地检索出这些信息</p><p><code>git log --author yourname</code></p><p>可以筛选出<code>yourname</code>用户提交的所有日志。这里的<code>yourname</code>可以包含通配符，从<code>Author: zdk &lt;zdk@menhoo.com&gt;</code>的信息中匹配信息。</p><p> <img src="/images/2021/12/17.png" alt></p><h3 id="通过关键字搜索"><a href="#通过关键字搜索" class="headerlink" title="通过关键字搜索"></a>通过关键字搜索</h3><p><code>git log --grep keywords</code><br>可以从提交的关键字中抓取匹配的commit项。</p><h3 id="通过文件名搜索"><a href="#通过文件名搜索" class="headerlink" title="通过文件名搜索"></a>通过文件名搜索</h3><p>有时候，我们想查某个文件(file or folder)的所有修改记录，可以根据文件名来过滤一下只跟这个文件有关的提交。<br><code>git log -- A</code></p><h3 id="查看两个tag之间的commit"><a href="#查看两个tag之间的commit" class="headerlink" title="查看两个tag之间的commit"></a>查看两个tag之间的commit</h3><p><code>git log --oneline v3.11..v3.12</code><br> <img src="/images/2021/12/18.png" alt></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="查看KVM目录下的commit"><a href="#查看KVM目录下的commit" class="headerlink" title="查看KVM目录下的commit"></a>查看KVM目录下的commit</h3><p><code>git log --oneline -- arch/x86/kvm/</code></p><h3 id="查看vmx-c的commit"><a href="#查看vmx-c的commit" class="headerlink" title="查看vmx.c的commit"></a>查看vmx.c的commit</h3><p><code>git log --oneline -- arch/x86/kvm/vmx/vmx.c</code><br>或者<br><code>git log -p -- arch/x86/kvm/vmx/vmx.c</code><br>然后关键字搜索，找到你想要的commit。</p><hr><p>参考资料：</p><ol><li><a href="https://stackoverflow.com/questions/16343659/how-to-show-git-log-history-i-e-all-the-related-commits-for-a-sub-directory" target="_blank" rel="noopener">How to show Git log history (i.e., all the related commits) for a sub directory of a Git repository</a></li><li><a href="https://blog.csdn.net/daguanjia11/article/details/73823617" target="_blank" rel="noopener">git log的常见用法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看源码过程中，发现可以好好利用git log来查看和搜索提交历史，本文特此mark下notes。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>The usage of OVMF in QEMU</title>
    <link href="http://liujunming.github.io/2021/12/17/The-usage-of-OVMF/"/>
    <id>http://liujunming.github.io/2021/12/17/The-usage-of-OVMF/</id>
    <published>2021-12-17T14:49:38.000Z</published>
    <updated>2021-12-18T03:52:22.392Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about the usage of OVMF in QEMU.<a id="more"></a></p><h3 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bios /path/to/OVMF.fd \</span><br></pre></td></tr></table></figure><h3 id="Case2-split-firmware"><a href="#Case2-split-firmware" class="headerlink" title="Case2: split firmware"></a>Case2: split firmware</h3><blockquote><p>The variable store and the firmware executable are also available in the build output as separate files: “OVMF_VARS.fd” and “OVMF_CODE.fd”. This enables central management and updates of the firmware executable, while each virtual machine can retain its own variable store.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-drive if=pflash,format=raw,unit=0,readonly=on,file=/path/to/OVMF_CODE.fd \</span><br><span class="line">-drive if=pflash,format=raw,unit=1,file=/path/to/OVMF_VARS.fd \</span><br></pre></td></tr></table></figure><h3 id="Case3-secure-boot"><a href="#Case3-secure-boot" class="headerlink" title="Case3: secure boot"></a>Case3: secure boot</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-drive if=pflash,format=raw,unit=0,readonly=on,file=/path/to/OVMF_SECURE_CODE.fd \</span><br><span class="line">-drive if=pflash,format=raw,unit=1,file=/path/to/OVMF_VARS.fd \</span><br><span class="line">-global driver=cfi.pflash01,property=secure,value=on \</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.linux-kvm.org/downloads/lersek/ovmf-whitepaper-c770f8c.txt" target="_blank" rel="noopener">Open Virtual Machine Firmware (OVMF) Status Report</a></li><li><a href="https://lore.kernel.org/qemu-devel/87y378n5iy.fsf@dusky.pond.sub.org/" target="_blank" rel="noopener">Configuring pflash devices for OVMF firmware</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about the usage of OVMF in QEMU.
    
    </summary>
    
      <category term="Firmware" scheme="http://liujunming.github.io/categories/Firmware/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Firmware" scheme="http://liujunming.github.io/tags/Firmware/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Linux kernel Oops</title>
    <link href="http://liujunming.github.io/2021/12/11/Notes-about-Linux-kernel-Oops/"/>
    <id>http://liujunming.github.io/2021/12/11/Notes-about-Linux-kernel-Oops/</id>
    <published>2021-12-11T14:23:17.000Z</published>
    <updated>2021-12-11T15:19:31.714Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about Linux kernel Oops.<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>什么是Oops？从语言学的角度说，Oops应该是一个拟声词。当出了点小事故，或者做了比较尴尬的事之后，你可以说”Oops”，翻译成中国话就叫做“哎呦”。“哎呦，对不起，对不起，我真不是故意打碎您的杯子的”。看，Oops就是这个意思。</p><p>在Linux内核开发中的Oops是什么呢？其实，它和上面的解释也没什么本质的差别，只不过说话的主角变成了Linux。当某些比较致命的问题出现时，我们的Linux内核也会抱歉的对我们说：“哎呦（Oops），对不起，我把事情搞砸了”。Linux内核在发生kernel panic时会打印出Oops信息，把目前的寄存器状态、堆栈内容、以及完整的Call trace都show给我们看，这样就可以帮助我们定位错误。</p><p>Kernel bug reports often come with a stack dump like the one below:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">------------[ cut here ]------------</span><br><span class="line">WARNING: CPU: 1 PID: 28102 at kernel/module.c:1108 module_put+0x57/0x70</span><br><span class="line">Modules linked in: dvb_usb_gp8psk(-) dvb_usb dvb_core nvidia_drm(PO) nvidia_modeset(PO) snd_hda_codec_hdmi snd_hda_intel snd_hda_codec snd_hwdep snd_hda_core snd_pcm snd_timer snd soundcore nvidia(PO) [last unloaded: rc_core]</span><br><span class="line">CPU: 1 PID: 28102 Comm: rmmod Tainted: P        WC O 4.8.4-build.1 #1</span><br><span class="line">Hardware name: MSI MS-7309/MS-7309, BIOS V1.12 02/23/2009</span><br><span class="line"> 00000000 c12ba080 00000000 00000000 c103ed6a c1616014 00000001 00006dc6</span><br><span class="line"> c1615862 00000454 c109e8a7 c109e8a7 00000009 ffffffff 00000000 f13f6a10</span><br><span class="line"> f5f5a600 c103ee33 00000009 00000000 00000000 c109e8a7 f80ca4d0 c109f617</span><br><span class="line">Call Trace:</span><br><span class="line"> [&lt;c12ba080&gt;] ? dump_stack+0x44/0x64</span><br><span class="line"> [&lt;c103ed6a&gt;] ? __warn+0xfa/0x120</span><br><span class="line"> [&lt;c109e8a7&gt;] ? module_put+0x57/0x70</span><br><span class="line"> [&lt;c109e8a7&gt;] ? module_put+0x57/0x70</span><br><span class="line"> [&lt;c103ee33&gt;] ? warn_slowpath_null+0x23/0x30</span><br><span class="line"> [&lt;c109e8a7&gt;] ? module_put+0x57/0x70</span><br><span class="line"> [&lt;f80ca4d0&gt;] ? gp8psk_fe_set_frontend+0x460/0x460 [dvb_usb_gp8psk]</span><br><span class="line"> [&lt;c109f617&gt;] ? symbol_put_addr+0x27/0x50</span><br><span class="line"> [&lt;f80bc9ca&gt;] ? dvb_usb_adapter_frontend_exit+0x3a/0x70 [dvb_usb]</span><br><span class="line"> [&lt;f80bb3bf&gt;] ? dvb_usb_exit+0x2f/0xd0 [dvb_usb]</span><br><span class="line"> [&lt;c13d03bc&gt;] ? usb_disable_endpoint+0x7c/0xb0</span><br><span class="line"> [&lt;f80bb48a&gt;] ? dvb_usb_device_exit+0x2a/0x50 [dvb_usb]</span><br><span class="line"> [&lt;c13d2882&gt;] ? usb_unbind_interface+0x62/0x250</span><br><span class="line"> [&lt;c136b514&gt;] ? __pm_runtime_idle+0x44/0x70</span><br><span class="line"> [&lt;c13620d8&gt;] ? __device_release_driver+0x78/0x120</span><br><span class="line"> [&lt;c1362907&gt;] ? driver_detach+0x87/0x90</span><br><span class="line"> [&lt;c1361c48&gt;] ? bus_remove_driver+0x38/0x90</span><br><span class="line"> [&lt;c13d1c18&gt;] ? usb_deregister+0x58/0xb0</span><br><span class="line"> [&lt;c109fbb0&gt;] ? SyS_delete_module+0x130/0x1f0</span><br><span class="line"> [&lt;c1055654&gt;] ? task_work_run+0x64/0x80</span><br><span class="line"> [&lt;c1000fa5&gt;] ? exit_to_usermode_loop+0x85/0x90</span><br><span class="line"> [&lt;c10013f0&gt;] ? do_fast_syscall_32+0x80/0x130</span><br><span class="line"> [&lt;c1549f43&gt;] ? sysenter_past_esp+0x40/0x6a</span><br><span class="line">---[ end trace 6ebc60ef3981792f ]---</span><br></pre></td></tr></table></figure></p><p>Such stack traces provide enough information to identify the line inside the Kernel’s source code where the bug happened. Depending on the severity of the issue, it may also contain the word <strong>Oops</strong>, as on this one:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BUG: unable to handle kernel NULL pointer dereference at   (null)</span><br><span class="line">IP: [&lt;c06969d4&gt;] iret_exc+0x7d0/0xa59</span><br><span class="line">*pdpt = 000000002258a001 *pde = 0000000000000000</span><br><span class="line">Oops: 0002 [#1] PREEMPT SMP</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Despite being an <strong>Oops</strong> or some other sort of stack trace, the offended line is usually required to identify and handle the bug. Along this chapter, we’ll refer to “Oops” for all kinds of stack traces that need to be analyzed.</p><h3 id="2-decode-stacktrace"><a href="#2-decode-stacktrace" class="headerlink" title="2. decode_stacktrace"></a>2. decode_stacktrace</h3><p>If the kernel is compiled with <code>CONFIG_DEBUG_INFO</code>, you can enhance the quality of the stack trace by using file:<a href="https://lwn.net/Articles/592724/" target="_blank" rel="noopener">scripts/decode_stacktrace.sh</a>.</p><h4 id="2-1-Input"><a href="#2-1-Input" class="headerlink" title="2.1 Input"></a>2.1 Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[    6.906437]  [&lt;ffffffff811f0e90&gt;] ? backtrace_test_irq_callback+0x20/0x20</span><br><span class="line">[    6.907121]  [&lt;ffffffff84388ce8&gt;] dump_stack+0x52/0x7f</span><br><span class="line">[    6.907640]  [&lt;ffffffff811f0ec8&gt;] backtrace_regression_test+0x38/0x110</span><br><span class="line">[    6.908281]  [&lt;ffffffff813596a0&gt;] ? proc_create_data+0xa0/0xd0</span><br><span class="line">[    6.908870]  [&lt;ffffffff870a8040&gt;] ? proc_modules_init+0x22/0x22</span><br><span class="line">[    6.909480]  [&lt;ffffffff810020c2&gt;] do_one_initcall+0xc2/0x1e0</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h4 id="2-2-Output"><a href="#2-2-Output" class="headerlink" title="2.2 Output"></a>2.2 Output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[  635.148361]  dump_stack (lib/dump_stack.c:52)</span><br><span class="line">[  635.149127]  warn_slowpath_common (kernel/panic.c:418)</span><br><span class="line">[  635.150214]  warn_slowpath_null (kernel/panic.c:453)</span><br><span class="line">[  635.151031]  _oalloc_pages_slowpath+0x6a/0x7d0</span><br><span class="line">[  635.152171]  ? zone_watermark_ok (mm/page_alloc.c:1728)</span><br><span class="line">[  635.152988]  ? get_page_from_freelist (mm/page_alloc.c:1939)</span><br><span class="line">[  635.154766]  __alloc_pages_nodemask (mm/page_alloc.c:2766)</span><br></pre></td></tr></table></figure><h4 id="2-3-Usage"><a href="#2-3-Usage" class="headerlink" title="2.3 Usage"></a>2.3 Usage</h4><p><code>./decode_stacktrace.sh [vmlinux] [base path]</code></p><p>Where vmlinux is the vmlinux to extract line numbers from and base path is the path that points to the root of the build tree, for example:</p><p><code>./decode_stacktrace.sh vmlinux /home/sasha/linux/ &lt; input.log &gt; output.log</code></p><h3 id="3-Finding-the-bug-location-by-gdb"><a href="#3-Finding-the-bug-location-by-gdb" class="headerlink" title="3. Finding the bug location by gdb"></a>3. Finding the bug location by gdb</h3><p>Reporting a bug works best if you point the location of the bug at the Kernel source file. Usually, using gdb is easier, but the Kernel should be pre-compiled with debug info.</p><p>The gdb is the best way to figure out the exact file and line number of the OOPS from the <code>vmlinux</code> file.</p><p>The usage of gdb works best on a kernel compiled with <code>CONFIG_DEBUG_INFO</code>. This can be set by running:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./scripts/config -d COMPILE_TEST -e DEBUG_KERNEL -e DEBUG_INFO</span><br></pre></td></tr></table></figure><p>On a kernel compiled with <code>CONFIG_DEBUG_INFO</code>, you can simply copy the EIP value from the OOPS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EIP:    0060:[&lt;c021e50e&gt;]    Not tainted VLI</span><br></pre></td></tr></table></figure><p>And use GDB to translate that to human-readable form:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gdb vmlinux</span><br><span class="line">(gdb) l *0xc021e50e</span><br></pre></td></tr></table></figure><h3 id="4-More-info"><a href="#4-More-info" class="headerlink" title="4. More info"></a>4. More info</h3><h4 id="4-1-Oops-0002-1"><a href="#4-1-Oops-0002-1" class="headerlink" title="4.1 Oops: 0002 [#1]"></a>4.1 Oops: 0002 [#1]</h4><p>0002表示Oops的error code, #1表示这个错误发生一次。</p><h4 id="4-2-Tainted信息"><a href="#4-2-Tainted信息" class="headerlink" title="4.2 Tainted信息"></a>4.2 Tainted信息</h4><ul><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/bug-hunting.html#modules-linked-in" target="_blank" rel="noopener">Modules linked in</a></li><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/tainted-kernels.html" target="_blank" rel="noopener">Tainted kernels</a></li></ul><hr><p>参考资料:</p><ol><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/bug-hunting.html" target="_blank" rel="noopener">Bug hunting</a></li><li><a href="https://www.cnblogs.com/wwang/archive/2010/11/14/1876735.html" target="_blank" rel="noopener">Linux内核的Oops</a></li><li><a href="https://lwn.net/Articles/592724/" target="_blank" rel="noopener">decode_stacktrace: make stack dump output useful again</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about Linux kernel Oops.
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to cpu affinity</title>
    <link href="http://liujunming.github.io/2021/12/05/Introduction-to-cpu-affinity/"/>
    <id>http://liujunming.github.io/2021/12/05/Introduction-to-cpu-affinity/</id>
    <published>2021-12-05T13:27:43.000Z</published>
    <updated>2021-12-05T15:31:19.010Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about cpu affinity.<a id="more"></a></p><h3 id="1-Motivation"><a href="#1-Motivation" class="headerlink" title="1. Motivation"></a>1. Motivation</h3><p>CPU的亲和性， 就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器，即绑定CPU or 绑核。</p><p>在多核运行的机器上，每个CPU本身自己会有缓存，缓存着进程使用的信息，而进程可能会被OS调度到其他CPU上，如此，CPU cache命中率就低了。当绑定CPU后，程序就会一直在指定的cpu跑，不会由操作系统调度到其他CPU上，性能有一定的提高。</p><p>另外一种使用绑核考虑就是将重要的业务进程隔离开，对于部分实时进程调度优先级高，可以将其绑定到一个指定核上，既可以保证实时进程的调度，也可以避免其他CPU上进程对该实时进程的干扰。</p><p><a href="https://en.wikipedia.org/wiki/Processor_affinity" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Processor_affinity</a></p><h3 id="2-Material"><a href="#2-Material" class="headerlink" title="2. Material"></a>2. Material</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man taskset</span><br></pre></td></tr></table></figure><p>C language: <code>sched_setaffinity</code> and <code>sched_getaffinity</code> function.</p><h3 id="3-Example"><a href="#3-Example" class="headerlink" title="3. Example"></a>3. Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        prctl(PR_SET_NAME,<span class="string">"myProcess\0"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc a.c</span><br><span class="line">$ taskset 0x10 ./a.out</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pgrep myProcess</span><br><span class="line">8402</span><br><span class="line">$ sudo trace-cmd record -e sched:sched_switch -P 8402</span><br><span class="line">$ sudo trace-cmd report</span><br></pre></td></tr></table></figure><p><img src="/images/2021/12/5.png" alt></p><p>From the result, we can see: process 8402 is running on processor #4, it’s corresponding to mask <code>0x10</code>.</p><hr><p>参考资料:</p><ol><li><a href="https://oenhan.com/cpu-affinity" target="_blank" rel="noopener">CPU亲和性的使用与机制</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about cpu affinity.
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>The usage of QEMU&amp;&amp;KVM live migration</title>
    <link href="http://liujunming.github.io/2021/12/04/The-usage-of-QEMU-KVM-live-migration/"/>
    <id>http://liujunming.github.io/2021/12/04/The-usage-of-QEMU-KVM-live-migration/</id>
    <published>2021-12-04T07:45:45.000Z</published>
    <updated>2021-12-05T11:12:42.291Z</updated>
    
    <content type="html"><![CDATA[<p>Steps of live migration under QEMU&amp;&amp;KVM.<a id="more"></a></p><p>A is the source host, B is the destination host.</p><h3 id="1-launch-source-VM-on-A"><a href="#1-launch-source-VM-on-A" class="headerlink" title="1. launch source VM on A"></a>1. launch source VM on A</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;qemu-command-line&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash -x</span><br><span class="line">    qemu-system-x86_64 \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -m 4096 \</span><br><span class="line">    -smp 2 \</span><br><span class="line">    -cpu host \</span><br><span class="line">    -drive format=raw,file=laag.img \</span><br><span class="line">    -serial mon:stdio \</span><br><span class="line">    -vnc :3</span><br></pre></td></tr></table></figure><h3 id="2-launch-destination-VM-on-B"><a href="#2-launch-destination-VM-on-B" class="headerlink" title="2. launch destination VM on B"></a>2. launch destination VM on B</h3><p>Start the VM on B with the exact same parameters as the VM on A, in migration-listen mode:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;qemu-command-line&gt; -incoming tcp:0:4444</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash -x</span><br><span class="line">    qemu-system-x86_64 \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -m 4096 \</span><br><span class="line">    -smp 2 \</span><br><span class="line">    -cpu host \</span><br><span class="line">    -drive format=raw,file=laag.img \</span><br><span class="line">    -serial mon:stdio \</span><br><span class="line">    -vnc :4 \</span><br><span class="line">    -incoming tcp:0:4444</span><br></pre></td></tr></table></figure><h3 id="3-start-the-migration-on-A-only"><a href="#3-start-the-migration-on-A-only" class="headerlink" title="3. start the migration (on A only)"></a>3. start the migration (on A only)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(qemu)migrate -d tcp:&lt;host B IP&gt;:4444</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(qemu)migrate -d tcp:localhost:4444</span><br></pre></td></tr></table></figure><h3 id="4-check-the-status-on-A-only"><a href="#4-check-the-status-on-A-only" class="headerlink" title="4.  check the status (on A only)"></a>4.  check the status (on A only)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(qemu) info migrate</span><br></pre></td></tr></table></figure><p>When completed, get can the info: <code>Migration status: completed</code>.  The source VM will stop at the end.</p><h3 id="5-misc"><a href="#5-misc" class="headerlink" title="5. misc"></a>5. misc</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(qemu) help migrate</span><br><span class="line">migrate [-d] [-b] [-i] [-r] uri -- migrate to URI (using -d to not wait for completion)</span><br><span class="line">                         -b for migration without shared storage with full copy of disk</span><br><span class="line">                         -i for migration without shared storage with incremental copy of disk (base image shared between src and destination)</span><br><span class="line">                         -r to resume a paused migration</span><br></pre></td></tr></table></figure><p>The ‘-d’ will let you query the status of the migration. With no ‘-d’ the monitor prompt returns when the migration completes.</p><hr><p>参考资料:</p><ol><li><a href="https://www.linux-kvm.org/page/Migration" target="_blank" rel="noopener">page/Migration</a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/03/01/qemu-live-migration" target="_blank" rel="noopener">qemu热迁移简介</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Steps of live migration under QEMU&amp;amp;&amp;amp;KVM.
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="live migration" scheme="http://liujunming.github.io/tags/live-migration/"/>
    
  </entry>
  
  <entry>
    <title>How to verify the virtio kick behavior</title>
    <link href="http://liujunming.github.io/2021/12/03/How-to-verify-the-virtio-kick-behavior/"/>
    <id>http://liujunming.github.io/2021/12/03/How-to-verify-the-virtio-kick-behavior/</id>
    <published>2021-12-03T05:27:34.000Z</published>
    <updated>2021-12-05T11:12:42.288Z</updated>
    
    <content type="html"><![CDATA[<p>How to use QEMU monitor and trace-cmd to verify the virtio kick behavior?<a id="more"></a></p><h3 id="1-definition-of-virtio-kick"><a href="#1-definition-of-virtio-kick" class="headerlink" title="1. definition of virtio kick"></a>1. definition of virtio kick</h3><p>kick: used by the guest to notify the host that SGs have been added.</p><p><a href="http://retis.sssup.it/luca/KernelProgramming/Slides/kp_virtio.pdf" target="_blank" rel="noopener">http://retis.sssup.it/luca/KernelProgramming/Slides/kp_virtio.pdf</a></p><h3 id="2-create-a-virtio-device"><a href="#2-create-a-virtio-device" class="headerlink" title="2. create a virtio device"></a>2. create a virtio device</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-drive format=raw,file=laag.img,if=virtio</span><br></pre></td></tr></table></figure><h3 id="3-get-the-notify-mmio-addr-in-guest"><a href="#3-get-the-notify-mmio-addr-in-guest" class="headerlink" title="3. get the notify mmio addr in guest"></a>3. get the notify mmio addr in guest</h3><p>In QEMU monitor, type <code>info mtree</code></p><p><img src="/images/2021/12/2.png" alt></p><p>type <code>info pci</code></p><p><img src="/images/2021/12/3.png" alt></p><h3 id="4-track-the-kvm-mmio-event"><a href="#4-track-the-kvm-mmio-event" class="headerlink" title="4. track the kvm_mmio event"></a>4. track the kvm_mmio event</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e kvm_mmio</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><p><img src="/images/2021/12/4.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;How to use QEMU monitor and trace-cmd to verify the virtio kick behavior?
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
      <category term="virtio" scheme="http://liujunming.github.io/tags/virtio/"/>
    
  </entry>
  
  <entry>
    <title>Notes about QEMU monitor</title>
    <link href="http://liujunming.github.io/2021/12/03/Notes-about-QEMU-monitor/"/>
    <id>http://liujunming.github.io/2021/12/03/Notes-about-QEMU-monitor/</id>
    <published>2021-12-03T00:10:12.000Z</published>
    <updated>2021-12-05T11:12:42.290Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about QEMU monitor.<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>The QEMU monitor is used to give complex commands to the QEMU emulator. You can use it to:</p><ul><li>Remove or insert removable media images (such as CD-ROM or floppies).</li><li>Freeze/unfreeze the Virtual Machine (VM) and save or restore its state from a disk file.</li><li>Inspect the VM state without an external debugger</li><li>…</li></ul><h4 id="1-1-commands"><a href="#1-1-commands" class="headerlink" title="1.1 commands"></a>1.1 commands</h4><p><a href="https://qemu.readthedocs.io/en/latest/system/monitor.html#commands" target="_blank" rel="noopener">QEMU Monitor Commands</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(qemu) help</span><br></pre></td></tr></table></figure><h3 id="2-Usage"><a href="#2-Usage" class="headerlink" title="2. Usage"></a>2. Usage</h3><p>QEMU启动时，需要使用<code>-monitor</code>选项指定做为<code>console</code>设备，<a href="https://gitlab.com/qemu-project/qemu/-/blob/master/qemu-options.hx" target="_blank" rel="noopener">官方文档</a>说明如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-monitor dev</span><br><span class="line">    Redirect the monitor to host device dev (same devices as the serialport).</span><br><span class="line">    The default device is vc in graphical mode and stdio in non graphical mode.</span><br><span class="line">    Use -monitor none to disable the default monitor.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-serial mon:stdio</span><br><span class="line">    creates a multiplexed stdio backend connected to the serial port and the QEMU monitor</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(qemu) info kvm</span><br><span class="line">kvm support: enabled</span><br></pre></td></tr></table></figure><p>上述这种方式更偏向用户直接输入命令进行交互，称为HMP(Human Machine Protocol)，程序使用这种方式不是太方便。QEMU还提供了另外一种基于JSON的QMP(QEMU Machine Protocol)来满足自动化处理的需求。Libvirt就是使用QMP来控制QEMU实例。</p><h3 id="3-QMP"><a href="#3-QMP" class="headerlink" title="3. QMP"></a>3. QMP</h3><p>QMP规范可以参考:</p><ul><li><a href="https://github.com/qemu/qemu/blob/master/docs/interop/qmp-intro.txt" target="_blank" rel="noopener">qmp-intro.txt</a></li><li><a href="https://github.com/qemu/qemu/blob/master/docs/interop/qmp-spec.txt" target="_blank" rel="noopener">qmp-spec.txt</a></li><li><a href="https://qemu.readthedocs.io/en/latest/interop/qemu-qmp-ref.html" target="_blank" rel="noopener">QEMU QMP Reference Manual</a></li></ul><p>QMP协议的工作流程如下:</p><ul><li>连接建立后服务器发送欢迎信息，进入能力协商(<code>capabilities negotiation</code>)模式</li><li>客户端发送<code>{“execute”:”qmp_capablities”}</code></li><li>成功则服务器返回<code>{“return”:{}}</code>，否则<code>return</code>中会含有<code>error</code>。</li><li>客户端发送命令</li><li>服务器以异步消息返回结果</li></ul><hr><p>参考资料:</p><ol><li><a href="https://qemu.readthedocs.io/en/latest/system/monitor.html" target="_blank" rel="noopener">QEMU Monitor</a></li><li><a href="http://just4coding.com/2017/11/19/qemu-monitor/" target="_blank" rel="noopener">QEMU monitor机制实例分析</a></li><li><a href="https://wiki.qemu.org/Documentation/QMP" target="_blank" rel="noopener">Documentation/QMP</a></li><li><a href="https://github.com/qemu/qemu/blob/master/docs/interop/qmp-intro.txt" target="_blank" rel="noopener">qmp-intro.txt</a></li><li><a href="https://github.com/qemu/qemu/blob/master/docs/interop/qmp-spec.txt" target="_blank" rel="noopener">qmp-spec.txt</a></li><li><a href="https://qemu.readthedocs.io/en/latest/interop/qemu-qmp-ref.html" target="_blank" rel="noopener">QEMU QMP Reference Manual</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about QEMU monitor.
    
    </summary>
    
      <category term="QEMU" scheme="http://liujunming.github.io/categories/QEMU/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Notes about KVM trace</title>
    <link href="http://liujunming.github.io/2021/12/02/Notes-about-KVM-trace/"/>
    <id>http://liujunming.github.io/2021/12/02/Notes-about-KVM-trace/</id>
    <published>2021-12-02T10:37:46.000Z</published>
    <updated>2021-12-11T15:19:31.714Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about KVM trace.<a id="more"></a></p><h3 id="kvm-trace-point"><a href="#kvm-trace-point" class="headerlink" title="kvm trace point"></a>kvm trace point</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /sys/kernel/debug/tracing/available_events | grep kvm:</span><br><span class="line">sudo cat /sys/kernel/debug/tracing/available_filter_functions | grep -i kvm</span><br></pre></td></tr></table></figure><p>了解kvm 的trace event也是了解kvm的一个渠道。</p><h3 id="Track-kvm-event"><a href="#Track-kvm-event" class="headerlink" title="Track kvm event"></a>Track kvm event</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e kvm</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="Track-kvm-cpuid"><a href="#Track-kvm-cpuid" class="headerlink" title="Track kvm_cpuid"></a>Track kvm_cpuid</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e kvm_cpuid</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="Track-kvm-inj-virq"><a href="#Track-kvm-inj-virq" class="headerlink" title="Track kvm_inj_virq"></a>Track kvm_inj_virq</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e kvm_inj_virq</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="Track-kvm-inj-exception"><a href="#Track-kvm-inj-exception" class="headerlink" title="Track kvm_inj_exception"></a>Track kvm_inj_exception</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e kvm_inj_exception</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="Track-kvm-exit"><a href="#Track-kvm-exit" class="headerlink" title="Track kvm_exit"></a>Track kvm_exit</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e kvm_exit</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.linux-kvm.org/page/Tracing" target="_blank" rel="noopener">linux-kvm.org Tracing</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about KVM trace.
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Notes about trace-cmd</title>
    <link href="http://liujunming.github.io/2021/12/02/Notes-about-trace-cmd/"/>
    <id>http://liujunming.github.io/2021/12/02/Notes-about-trace-cmd/</id>
    <published>2021-12-02T07:19:02.000Z</published>
    <updated>2021-12-05T11:12:42.291Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about trace-cmd.<a id="more"></a></p><h3 id="1-Motivation"><a href="#1-Motivation" class="headerlink" title="1. Motivation"></a>1. Motivation</h3><p>ftrace isn’t a <strong>program</strong> exactly – you don’t just run <code>ftrace my_cool_function</code>. </p><p>If you read <a href="https://lwn.net/Articles/365835/" target="_blank" rel="noopener">Debugging the kernel using Ftrace</a> it starts out by telling you to <code>cd /sys/kernel/debug/tracing</code> and then do various filesystem manipulations.</p><p>For me this is way too annoying – a simple example of using ftrace this way is something like <a href="/2021/12/01/Notes-about-ftrace/#2-1-function">this</a></p><p>This filesystem interface to the tracing system (“put values in these magic files and things will happen”) seems theoretically possible to use but really not my preference.</p><p>Luckily, team ftrace also thought this interface wasn’t that user friendly and so there is an easier-to-use interface called <strong>trace-cmd</strong>!!! trace-cmd is a normal program with command line arguments. We’ll use that! I found an intro to trace-cmd on LWN at <a href="https://lwn.net/Articles/410200/" target="_blank" rel="noopener">trace-cmd: A front-end for Ftrace</a>.</p><h3 id="2-Installation-and-manual"><a href="#2-Installation-and-manual" class="headerlink" title="2. Installation and manual"></a>2. Installation and manual</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install trace-cmd -y</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trace-cmd record --help</span><br><span class="line">man trace-cmd-record</span><br><span class="line">man trace-cmd-report</span><br></pre></td></tr></table></figure><p><img src="/images/2021/12/1.png" alt></p><h3 id="3-Trace-functions"><a href="#3-Trace-functions" class="headerlink" title="3. Trace functions"></a>3. Trace functions</h3><p>How to know what functions you can trace?</p><p>If you run <code>sudo trace-cmd list -f</code> you’ll get a list of all the functions you can trace. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -p function -l __do_fault</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="4-Trace-a-process"><a href="#4-Trace-a-process" class="headerlink" title="4. Trace a process"></a>4. Trace a process</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -p function -P 25314 # record for PID 25314</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="5-Trace-function-graph"><a href="#5-Trace-function-graph" class="headerlink" title="5. Trace function graph"></a>5. Trace function graph</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -p function_graph -P 25314</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="6-Trace-events"><a href="#6-Trace-events" class="headerlink" title="6. Trace events"></a>6. Trace events</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e sched:sched_switch</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="7-MISC"><a href="#7-MISC" class="headerlink" title="7. MISC"></a>7. MISC</h3><ul><li><code>trace-cmd report -F filter</code> </li></ul><hr><p>参考资料:</p><ol><li><a href="https://jvns.ca/blog/2017/03/19/getting-started-with-ftrace/" target="_blank" rel="noopener">ftrace: trace your kernel functions!</a></li><li><a href="https://lwn.net/Articles/410200/" target="_blank" rel="noopener">trace-cmd: A front-end for Ftrace</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about trace-cmd.
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Notes about ftrace</title>
    <link href="http://liujunming.github.io/2021/12/01/Notes-about-ftrace/"/>
    <id>http://liujunming.github.io/2021/12/01/Notes-about-ftrace/</id>
    <published>2021-12-01T06:37:29.000Z</published>
    <updated>2021-12-05T11:12:42.291Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about ftrace.<a id="more"></a></p><p>建议先阅读下<a href="https://www.jianshu.com/p/99e127973abe" target="_blank" rel="noopener">使用 ftrace 来跟踪系统问题 - ftrace 介绍</a>.</p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>ftrace is an internal tracer designed to help out developers and designers of systems to find what is going on inside the kernel. It can be used for debugging or analyzing latencies and performance issues that take place outside of user-space.</p><p>Although ftrace is typically considered the function tracer, it is really a frame work of several assorted tracing utilities. There’s latency tracing to examine what occurs between interrupts disabled and enabled, as well as for preemption and from a time a task is woken to the task is actually scheduled in.</p><p>One of the most common uses of ftrace is the event tracing. Through out the kernel is hundreds of static event points that can be enabled via the tracefs file system to see what is going on in certain parts of the kernel.</p><h3 id="2-Tracers"><a href="#2-Tracers" class="headerlink" title="2. Tracers"></a>2. Tracers</h3><h4 id="2-1-function"><a href="#2-1-function" class="headerlink" title="2.1 function"></a>2.1 function</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/kernel/debug/tracing</span><br><span class="line">echo 0 &gt; tracing_on</span><br><span class="line">echo __do_fault &gt; set_ftrace_filter</span><br><span class="line">echo function &gt; current_tracer</span><br><span class="line">echo 1 &gt; tracing_on</span><br><span class="line">cat trace</span><br></pre></td></tr></table></figure><h4 id="2-2-function-graph"><a href="#2-2-function-graph" class="headerlink" title="2.2 function_graph"></a>2.2 function_graph</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/kernel/debug/tracing</span><br><span class="line">echo 0 &gt; tracing_on</span><br><span class="line">echo __do_fault &gt; set_graph_function</span><br><span class="line">echo function_graph &gt; current_tracer</span><br><span class="line">echo 1 &gt; tracing_on</span><br><span class="line">cat trace</span><br></pre></td></tr></table></figure><h4 id="2-3-blk"><a href="#2-3-blk" class="headerlink" title="2.3 blk"></a>2.3 blk</h4><h4 id="2-4-hwlat"><a href="#2-4-hwlat" class="headerlink" title="2.4 hwlat"></a>2.4 hwlat</h4><h4 id="2-5-irqsoff"><a href="#2-5-irqsoff" class="headerlink" title="2.5 irqsoff"></a>2.5 irqsoff</h4><h4 id="2-6-preemptoff"><a href="#2-6-preemptoff" class="headerlink" title="2.6 preemptoff"></a>2.6 preemptoff</h4><h4 id="2-7-preemptirqsoff"><a href="#2-7-preemptirqsoff" class="headerlink" title="2.7 preemptirqsoff"></a>2.7 preemptirqsoff</h4><h4 id="2-8-wakeup"><a href="#2-8-wakeup" class="headerlink" title="2.8 wakeup"></a>2.8 wakeup</h4><h4 id="2-9-wakeup-rt"><a href="#2-9-wakeup-rt" class="headerlink" title="2.9 wakeup_rt"></a>2.9 wakeup_rt</h4><h4 id="2-10-wakeup-dl"><a href="#2-10-wakeup-dl" class="headerlink" title="2.10 wakeup_dl"></a>2.10 wakeup_dl</h4><h4 id="2-11-mmiotrace"><a href="#2-11-mmiotrace" class="headerlink" title="2.11 mmiotrace"></a>2.11 mmiotrace</h4><h4 id="2-12-branch"><a href="#2-12-branch" class="headerlink" title="2.12 branch"></a>2.12 branch</h4><h4 id="2-13-nop"><a href="#2-13-nop" class="headerlink" title="2.13 nop"></a>2.13 nop</h4><h3 id="3-Examples-of-using-the-tracer"><a href="#3-Examples-of-using-the-tracer" class="headerlink" title="3. Examples of using the tracer"></a>3. Examples of using the tracer</h3><p><a href="https://www.kernel.org/doc/html/latest/trace/ftrace.html#examples-of-using-the-tracer" target="_blank" rel="noopener">Examples of using the tracer</a></p><h3 id="4-How-userspace-can-interact-with-ftrace"><a href="#4-How-userspace-can-interact-with-ftrace" class="headerlink" title="4. How userspace can interact with ftrace"></a>4. How userspace can interact with ftrace</h3><p><a href="https://lwn.net/Articles/366796/" target="_blank" rel="noopener">Debugging the kernel using Ftrace - part 2</a><br><a href="https://www.kernel.org/doc/html/latest/trace/ftrace.html#single-thread-tracing" target="_blank" rel="noopener">Single thread tracing</a></p><h3 id="5-Useful-commands-and-links"><a href="#5-Useful-commands-and-links" class="headerlink" title="5. Useful commands and links"></a>5. Useful commands and links</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /sys/kernel/debug/tracing/available_events</span><br><span class="line">sudo cat /sys/kernel/debug/tracing/available_filter_functions</span><br><span class="line">sudo cat /sys/kernel/debug/tracing/available_tracers</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.kernel.org/doc/html/latest/trace/ftrace.html" target="_blank" rel="noopener">ftrace - Function Tracer</a></li><li><a href="https://jvns.ca/blog/2017/03/19/getting-started-with-ftrace/" target="_blank" rel="noopener">ftrace: trace your kernel functions!</a></li><li><a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt" target="_blank" rel="noopener">trace/ftrace.txt</a></li><li><a href="https://lwn.net/Articles/365835/" target="_blank" rel="noopener">Debugging the kernel using Ftrace - part 1</a></li><li><a href="https://lwn.net/Articles/366796/" target="_blank" rel="noopener">Debugging the kernel using Ftrace - part 2</a></li><li><a href="https://lwn.net/Articles/370423/" target="_blank" rel="noopener">Secrets of the Ftrace function tracer</a></li><li><a href="https://lwn.net/Articles/608497/" target="_blank" rel="noopener">Ftrace: The hidden light switch</a></li><li><a href="https://www.kernel.org/doc/Documentation/trace/events.txt" target="_blank" rel="noopener">trace/events.txt</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about ftrace.
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>QEMU tutorial:How to use ivshmem-plain</title>
    <link href="http://liujunming.github.io/2021/11/30/QEMU-tutorial-Inter-VM-Shared-Memory-device/"/>
    <id>http://liujunming.github.io/2021/11/30/QEMU-tutorial-Inter-VM-Shared-Memory-device/</id>
    <published>2021-11-30T14:15:12.000Z</published>
    <updated>2021-11-30T16:07:47.394Z</updated>
    
    <content type="html"><![CDATA[<p>QEMU tutorial: How to use ivshmem-plain。<a id="more"></a><br><a href="/2021/11/11/Notes-about-ivshmem/">Notes about ivshmem</a></p><h3 id="1-hotplug-ivshmem-in-QEMU-monitor"><a href="#1-hotplug-ivshmem-in-QEMU-monitor" class="headerlink" title="1. hotplug ivshmem in QEMU monitor"></a>1. hotplug ivshmem in QEMU monitor</h3><p>Use QEMU to launch a VM, enter the <a href="/2020/05/06/QEMU-usage-notes/#built-in-monitor-mode">monitor mode</a>.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(qemu) object_add  memory-backend-file,size=16M,share,mem-path=/dev/shm/shm1,id=shm1</span><br><span class="line">(qemu) device_add  ivshmem-plain,memdev=shm1,bus=pci.0,addr=0x10,master=on</span><br><span class="line">(qemu) object_add  memory-backend-file,size=8M,share,mem-path=/dev/shm/shm2,id=shm2</span><br><span class="line">(qemu) device_add  ivshmem-plain,memdev=shm2,bus=pci.0,addr=0x11,master=on</span><br></pre></td></tr></table></figure></p><h3 id="2-write-the-signature-into-shared-memory-in-host"><a href="#2-write-the-signature-into-shared-memory-in-host" class="headerlink" title="2. write the signature into shared memory in host"></a>2. write the signature into shared memory in host</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo "SIGN_01" &gt; /dev/shm/shm1</span><br><span class="line">echo "SIGN_02" &gt; /dev/shm/shm2</span><br></pre></td></tr></table></figure><h3 id="3-read-the-signature-from-shared-memory-in-guest"><a href="#3-read-the-signature-from-shared-memory-in-guest" class="headerlink" title="3. read the signature from shared memory in guest"></a>3. read the signature from shared memory in guest</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE (16 * 1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">"/sys/bus/pci/devices/0000:00:10.0/resource2"</span>, O_RDWR);</span><br><span class="line">    assert(fd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    p = mmap(<span class="number">0</span>, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    assert(p != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(p, SHM_SIZE);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gcc t.c</span><br><span class="line"><span class="meta">$</span> ./a.out</span><br><span class="line">SIGN_01</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.qemu.org/docs/master/system/devices/ivshmem.html" target="_blank" rel="noopener">qemu doc: Inter-VM Shared Memory device</a></li><li><a href="http://just4coding.com/2021/09/12/qemu-ivshmem/" target="_blank" rel="noopener">QEMU虚拟机内识别ivshmem设备</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QEMU tutorial: How to use ivshmem-plain。
    
    </summary>
    
      <category term="QEMU" scheme="http://liujunming.github.io/categories/QEMU/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>How to use GDB to debug QEMU process</title>
    <link href="http://liujunming.github.io/2021/11/30/How-to-use-GDB-to-debug-QEMU/"/>
    <id>http://liujunming.github.io/2021/11/30/How-to-use-GDB-to-debug-QEMU/</id>
    <published>2021-11-30T07:37:29.000Z</published>
    <updated>2021-11-30T12:45:49.054Z</updated>
    
    <content type="html"><![CDATA[<p>How to use GDB to debug QEMU process?<a id="more"></a></p><h3 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-debug</span><br></pre></td></tr></table></figure><h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> which qemu-system-x86_64</span><br><span class="line">/usr/local/bin/qemu-system-x86_64</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb --args /usr/local/bin/qemu-system-x86_64\</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -m 2048 \</span><br><span class="line">    -smp 2 \</span><br><span class="line">    -cpu host \</span><br><span class="line">    -drive format=raw,file=laag.img \</span><br><span class="line">    -serial mon:stdio \</span><br><span class="line">    -net nic,macaddr=00:16:3e:60:0a:50 \</span><br><span class="line">    -net tap \</span><br><span class="line">    -vnc :3</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b x86_cpu_get_supported_feature_word</span><br><span class="line">Breakpoint 1 at 0x44f372: file /home/kvm/qemu/target/i386/cpu.c, line 5050.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /usr/local/bin/qemu-system-x86_64 -enable-kvm -m 2048 -smp 2 -cpu host -drive format=raw,file=laag.img -serial mon:stdio -net nic,macaddr=00:16:3e:60:0a:50 -net tap -vnc :3</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".</span><br><span class="line">[New Thread 0x7fffe8d59700 (LWP 15519)]</span><br><span class="line">++ brctl show</span><br><span class="line">++ sed -n 2p</span><br><span class="line">++ awk '&#123;print $1&#125;'</span><br><span class="line">+ switch=br0</span><br><span class="line">+ '[' -n br0 ']'</span><br><span class="line">++ whoami</span><br><span class="line">+ tunctl -u root -t tap0</span><br><span class="line">TUNSETIFF: Device or resource busy</span><br><span class="line">+ ip link set tap0 up</span><br><span class="line">+ brctl addif br0 tap0</span><br><span class="line">+ exit 0</span><br><span class="line"></span><br><span class="line">Thread 1 "qemu-system-x86" hit Breakpoint 1, x86_cpu_get_supported_feature_word (w=FEAT_1_EDX, migratable_only=true) at /home/kvm/qemu/target/i386/cpu.c:5050</span><br><span class="line">5050        FeatureWordInfo *wi = &amp;feature_word_info[w];</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta">#</span>0  0x00005555559a3372 in x86_cpu_get_supported_feature_word (w=FEAT_1_EDX, migratable_only=true) at /home/kvm/qemu/target/i386/cpu.c:5050</span><br><span class="line"><span class="meta">#</span>1  0x00005555559a67bf in x86_cpu_expand_features (cpu=0x555556acef90, errp=0x7fffffffda60) at /home/kvm/qemu/target/i386/cpu.c:6386</span><br><span class="line"><span class="meta">#</span>2  0x00005555559a70a3 in x86_cpu_realizefn (dev=0x555556acef90, errp=0x7fffffffdae0) at /home/kvm/qemu/target/i386/cpu.c:6574</span><br><span class="line"><span class="meta">#</span>3  0x0000555555aa54cf in device_set_realized (obj=0x555556acef90, value=true, errp=0x7fffffffdbe8) at /home/kvm/qemu/hw/core/qdev.c:864</span><br><span class="line"><span class="meta">#</span>4  0x0000555555cf4adf in property_set_bool (obj=0x555556acef90, v=0x555556aecae0, name=0x555555fb5771 "realized", opaque=0x5555568916e0, errp=0x7fffffffdbe8) at /home/kvm/qemu/qom/object.c:2202</span><br><span class="line"><span class="meta">#</span>5  0x0000555555cf2c00 in object_property_set (obj=0x555556acef90, name=0x555555fb5771 "realized", v=0x555556aecae0, errp=0x55555681c0a0 &lt;error_fatal&gt;) at /home/kvm/qemu/qom/object.c:1349</span><br><span class="line"><span class="meta">#</span>6  0x0000555555cf5f45 in object_property_set_qobject (obj=0x555556acef90, name=0x555555fb5771 "realized", value=0x555556aea3a0, errp=0x55555681c0a0 &lt;error_fatal&gt;) at /home/kvm/qemu/qom/qom-qobject.c:28</span><br><span class="line"><span class="meta">#</span>7  0x0000555555cf2f47 in object_property_set_bool (obj=0x555556acef90, name=0x555555fb5771 "realized", value=true, errp=0x55555681c0a0 &lt;error_fatal&gt;) at /home/kvm/qemu/qom/object.c:1416</span><br><span class="line"><span class="meta">#</span>8  0x0000555555aa4083 in qdev_realize (dev=0x555556acef90, bus=0x0, errp=0x55555681c0a0 &lt;error_fatal&gt;) at /home/kvm/qemu/hw/core/qdev.c:379</span><br><span class="line"><span class="meta">#</span>9  0x000055555594235d in x86_cpu_new (x86ms=0x555556a43800, apic_id=0, errp=0x55555681c0a0 &lt;error_fatal&gt;) at /home/kvm/qemu/hw/i386/x86.c:126</span><br><span class="line"><span class="meta">#</span>10 0x00005555559424e8 in x86_cpus_init (x86ms=0x555556a43800, default_cpu_version=1) at /home/kvm/qemu/hw/i386/x86.c:164</span><br><span class="line"><span class="meta">#</span>11 0x000055555594ac74 in pc_init1 (machine=0x555556a43800, host_type=0x555555f73516 "i440FX-pcihost", pci_type=0x555555f7350f "i440FX") at /home/kvm/qemu/hw/i386/pc_piix.c:159</span><br><span class="line"><span class="meta">#</span>12 0x000055555594b791 in pc_init_v5_1 (machine=0x555556a43800) at /home/kvm/qemu/hw/i386/pc_piix.c:438</span><br><span class="line"><span class="meta">#</span>13 0x0000555555ab385c in machine_run_board_init (machine=0x555556a43800) at /home/kvm/qemu/hw/core/machine.c:1135</span><br><span class="line"><span class="meta">#</span>14 0x000055555599b752 in qemu_init (argc=18, argv=0x7fffffffe238, envp=0x7fffffffe2d0) at /home/kvm/qemu/softmmu/vl.c:4355</span><br><span class="line"><span class="meta">#</span>15 0x0000555555ddeb86 in main (argc=18, argv=0x7fffffffe238, envp=0x7fffffffe2d0) at /home/kvm/qemu/softmmu/main.c:48</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://kernelgo.org/linux-tips.html" target="_blank" rel="noopener"> Debug Qemu代码</a></li><li><a href="https://ctf-wiki.github.io/ctf-tools/binary-core-tools/virtualization/qemu/qemu-install-and-debug/" target="_blank" rel="noopener">qemu 安装与调试</a></li><li><a href="https://www.cnblogs.com/ck1020/p/7795242.html" target="_blank" rel="noopener">GDB调试qemu源码纪录</a></li><li><a href="https://blog.csdn.net/wujianyongw4/article/details/85701740" target="_blank" rel="noopener">gdb 调试qemu</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;How to use GDB to debug QEMU process?
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>How to enable QEMU  to use public bridge</title>
    <link href="http://liujunming.github.io/2021/11/29/How-to-enable-QEMU-guests-to-use-public-bridge/"/>
    <id>http://liujunming.github.io/2021/11/29/How-to-enable-QEMU-guests-to-use-public-bridge/</id>
    <published>2021-11-29T06:32:27.000Z</published>
    <updated>2021-11-30T12:45:49.054Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍enable QEMU  to use public bridge。<a id="more"></a></p><h3 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h3><p><strong>Bridge</strong>类似于一个网络交换机，用于交换数据包，连接不同的VMs, containers以及Host.<br><img src="/images/2021/11/13.png" alt></p><h3 id="2-Tun-Tap网卡"><a href="#2-Tun-Tap网卡" class="headerlink" title="2. Tun/Tap网卡"></a>2. Tun/Tap网卡</h3><p>在我们创建完虚拟机后，一般在host里会多了张tap网卡，那这个网卡有什么作用呢？</p><h4 id="2-1-普通网卡工作模式"><a href="#2-1-普通网卡工作模式" class="headerlink" title="2.1 普通网卡工作模式"></a>2.1 普通网卡工作模式</h4><p><img src="/images/2021/11/14.png" alt><br>普通的网卡一端连接物理链路，一端连接内核协议栈。</p><h4 id="2-2-tun-tap网卡工作模式"><a href="#2-2-tun-tap网卡工作模式" class="headerlink" title="2.2 tun/tap网卡工作模式"></a>2.2 tun/tap网卡工作模式</h4><p>普通的物理网卡是通过物理链路来收发数据，而tun/tap 是通过/dev/net/tun来收发数据。tun/tap网卡一端连着/dev/net/tun，一端连着协议栈。</p><h4 id="2-3-虚拟化场景下的tap网卡"><a href="#2-3-虚拟化场景下的tap网卡" class="headerlink" title="2.3 虚拟化场景下的tap网卡"></a>2.3 虚拟化场景下的tap网卡</h4><p>虚拟机主要用的是tap类型网卡，下面是tap网卡工作模式：<br><img src="/images/2021/11/15.png" alt></p><p>tap网卡主要是两部分组成，字符设备驱动和虚拟网卡驱动。</p><ul><li>字符设备驱动：负责和用户进程打交道，把数据写入/dev/net/tun，然后通知用户进程从/dev/net/tun里面拿数据实现数据交互</li><li>虚拟网卡驱动：负责和网络协议栈的数据打交道</li></ul><p>qemu-kvm中 vm与host之间的通讯过程:</p><ol><li>在创建一个vm并启动时，在host中创建一个tap类型的网卡，例如tap0，同时vm作为一个qemu进程，内核为其提供了一个/dev/net/tun设备的文件描述符(fd),供其读写</li><li>vm用户进程产生数据，发到vm的虚拟网卡上，实质上vm作为host的一个qemu进程，其产生的数据写入到/dev/net/tun里</li><li>tap0网卡通过字符设备驱动从/dev/net/tun 里收到数据后，会转发给网桥，网桥再判断是否丢弃，转发或者交给上层的API来处理</li></ol><h3 id="3-Solutions"><a href="#3-Solutions" class="headerlink" title="3. Solutions"></a>3. Solutions</h3><h4 id="3-1-Create-bridge"><a href="#3-1-Create-bridge" class="headerlink" title="3.1 Create bridge"></a>3.1 Create bridge</h4><h5 id="3-1-1-Using-Distribution-Specific-Scripts"><a href="#3-1-1-Using-Distribution-Specific-Scripts" class="headerlink" title="3.1.1 Using Distribution-Specific Scripts"></a>3.1.1 Using Distribution-Specific Scripts</h5><p><a href="https://www.linux-kvm.org/page/Networking#Public_Bridge" target="_blank" rel="noopener">Networking#Public_Bridge</a>中列举了RedHat，Debian和SuSE上的配置。<br>还有一个重要的tool是<a href="/2021/06/01/Introduction-to-netplan/">netplan</a>。</p><p>主机重启后，无需重新配置，重点推荐😊。</p><h5 id="3-1-2-Manual-Configuration"><a href="#3-1-2-Manual-Configuration" class="headerlink" title="3.1.2 Manual Configuration"></a>3.1.2 Manual Configuration</h5><p>参见<a href="https://www.cnblogs.com/haiyonghao/p/14440163.html" target="_blank" rel="noopener">QEMU使用网桥模式</a>和<a href="https://blog.stefan-koch.name/2020/10/25/qemu-public-ip-vm-with-tap" target="_blank" rel="noopener">Hosting QEMU VMs with Public IP Addresses using TAP Interfaces</a>中的步骤。</p><p>此方法的弊端在于:每次主机重启都需要重新配置，所以不推荐😢。</p><h4 id="3-2-Create-tap"><a href="#3-2-Create-tap" class="headerlink" title="3.2 Create tap"></a>3.2 Create tap</h4><p>The default network configure script is <code>/etc/qemu-ifup</code> and the default network deconfigure script is <code>/etc/qemu-ifdown</code>.</p><p>将创建tap的脚本放入到<code>/etc/qemu-ifup</code>中即可。</p><h3 id="4-Experience"><a href="#4-Experience" class="headerlink" title="4. Experience"></a>4. Experience</h3><h4 id="4-1-netplan-and-qemu-ifup"><a href="#4-1-netplan-and-qemu-ifup" class="headerlink" title="4.1 netplan and qemu-ifup"></a>4.1 netplan and qemu-ifup</h4><p><a href="https://github.com/liujunming/qemu_usage/tree/master/0002-set-net-on-kvm" target="_blank" rel="noopener">https://github.com/liujunming/qemu_usage/tree/master/0002-set-net-on-kvm</a></p><h4 id="4-2-virtio-net-pci"><a href="#4-2-virtio-net-pci" class="headerlink" title="4.2 virtio-net-pci"></a>4.2 virtio-net-pci</h4><p><a href="https://github.com/liujunming/qemu_usage/tree/master/0007-use-virtio-net-pci-dev" target="_blank" rel="noopener">https://github.com/liujunming/qemu_usage/tree/master/0007-use-virtio-net-pci-dev</a></p><h4 id="4-3-e1000-device"><a href="#4-3-e1000-device" class="headerlink" title="4.3 e1000 device"></a>4.3 e1000 device</h4><p><a href="https://github.com/liujunming/qemu_usage/tree/master/0009-e1000-device" target="_blank" rel="noopener">https://github.com/liujunming/qemu_usage/tree/master/0009-e1000-device</a></p><h4 id="4-4-net-nic"><a href="#4-4-net-nic" class="headerlink" title="4.4 net nic"></a>4.4 net nic</h4><p><a href="https://github.com/liujunming/qemu_usage/tree/master/0010-net-nic" target="_blank" rel="noopener">https://github.com/liujunming/qemu_usage/tree/master/0010-net-nic</a></p><h3 id="5-Troubleshooting"><a href="#5-Troubleshooting" class="headerlink" title="5. Troubleshooting"></a>5. Troubleshooting</h3><p><strong>docker makes existing KVM VMs have suddenly no connection</strong></p><p>Potential solutions:</p><ul><li><p><a href="https://github.com/docker/for-linux/issues/949#issuecomment-594528885" target="_blank" rel="noopener">docker-ce package makes existing KVM guests unusable</a></p></li><li><p><a href="https://anteru.net/blog/2017/docker-kvm-iptables/" target="_blank" rel="noopener">Docker, KVM and iptables</a></p></li></ul><hr><p>参考资料:</p><ol><li><a href="https://www.linux-kvm.org/page/Networking#Public_Bridge" target="_blank" rel="noopener">Networking#Public_Bridge</a></li><li><a href="https://www.cnblogs.com/xia-dong/p/11555625.html" target="_blank" rel="noopener">qemu虚拟机网桥通讯过程</a></li><li><a href="https://calinyara.github.io/technology/2019/08/22/vnet_interface.html" target="_blank" rel="noopener">虚拟网络设备简介</a></li><li><a href="https://www.cnblogs.com/haiyonghao/p/14440163.html" target="_blank" rel="noopener">QEMU使用网桥模式</a></li><li><a href="https://blog.stefan-koch.name/2020/10/25/qemu-public-ip-vm-with-tap" target="_blank" rel="noopener">Hosting QEMU VMs with Public IP Addresses using TAP Interfaces</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍enable QEMU  to use public bridge。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>CPUID management in QEMU/KVM</title>
    <link href="http://liujunming.github.io/2021/11/28/CPUID-management-in-QEMU-KVM/"/>
    <id>http://liujunming.github.io/2021/11/28/CPUID-management-in-QEMU-KVM/</id>
    <published>2021-11-28T05:23:15.000Z</published>
    <updated>2021-11-28T10:49:16.773Z</updated>
    
    <content type="html"><![CDATA[<p>本文以<a href="https://gitlab.com/qemu-project/qemu/-/tree/v5.2.0" target="_blank" rel="noopener">QEMU V5.2.0</a>,<a href="https://elixir.bootlin.com/linux/v5.14/source" target="_blank" rel="noopener">kernel  v5.14</a>的源码，介绍CPUID management，具体细节不会一一介绍，但是会给出函数调用链，读者可以以此为线索，深挖细节。<a id="more"></a></p><h3 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h3><p>guest执行cpuid指令肯定会导致VM Exit，然后由KVM处理cpuid指令的模拟。</p><p>KVM会执行<a href="https://elixir.bootlin.com/linux/v5.14/source/arch/x86/kvm/cpuid.c#L1225" target="_blank" rel="noopener">kvm_emulate_cpuid</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_emulate_cpuid</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u32 eax, ebx, ecx, edx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpuid_fault_enabled(vcpu) &amp;&amp; !kvm_require_cpl(vcpu, <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">eax = kvm_rax_read(vcpu); <span class="comment">// 读取vcpu的rax内容</span></span><br><span class="line">ecx = kvm_rcx_read(vcpu); <span class="comment">// 读取vcpu的rcx内容</span></span><br><span class="line">kvm_cpuid(vcpu, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx, <span class="literal">true</span>);</span><br><span class="line">kvm_rax_write(vcpu, eax);</span><br><span class="line">kvm_rbx_write(vcpu, ebx);</span><br><span class="line">kvm_rcx_write(vcpu, ecx);</span><br><span class="line">kvm_rdx_write(vcpu, edx);</span><br><span class="line"><span class="keyword">return</span> kvm_skip_emulated_instruction(vcpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kvm_cpuid</span><span class="params">(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx,</span></span></span><br><span class="line"><span class="function"><span class="params">       u32 *ecx, u32 *edx, <span class="keyword">bool</span> check_limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u32 function = *eax, index = *ecx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_cpuid_entry2</span> *<span class="title">best</span>;</span></span><br><span class="line"><span class="keyword">bool</span> entry_found = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">best = kvm_find_cpuid_entry(vcpu, function, index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!best) &#123;</span><br><span class="line">entry_found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!check_limit)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">best = check_cpuid_limit(vcpu, function, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (best) &#123;</span><br><span class="line">*eax = best-&gt;eax;</span><br><span class="line">*ebx = best-&gt;ebx;</span><br><span class="line">*ecx = best-&gt;ecx;</span><br><span class="line">*edx = best-&gt;edx;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">*eax = *ebx = *ecx = *edx = <span class="number">0</span>;</span><br><span class="line">trace_kvm_cpuid(function, *eax, *ebx, *ecx, *edx, entry_found);</span><br><span class="line"><span class="keyword">return</span> entry_found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较重要的函数为<a href="https://elixir.bootlin.com/linux/v5.14/source/arch/x86/kvm/cpuid.c#L1100" target="_blank" rel="noopener">kvm_find_cpuid_entry</a>,该函数寻找qemu写入到KVM中的CPUID entry(具体细节请参考源码)。</p><p>所以比较重要的是这个”entry”,该entry由qemu写入。</p><p>大致过程为:</p><ol><li>qemu通过ioctl(KVM_GET_SUPPORTED_CPUID)读取到host支持的CPUID列表</li><li>qemu通过与运算剔除掉qemu(用户通过 -cpu option来指定)不支持的CPUID</li><li>qemu通过ioctl(KVM_SET_CPUID2)将CPUID数据写入到KVM中供guest使用</li></ol><p>说白了，就是qemu与KVM协调创建cpuid “entry”，最终，qemu将该“entry”的值写入KVM。接下来，guest执行cpuid指令而发生VM Exit时，KVM就可以cover住，无需qemu的参与。</p><h3 id="2-Call-chains-in-QEMU"><a href="#2-Call-chains-in-QEMU" class="headerlink" title="2. Call chains in QEMU"></a>2. Call chains in QEMU</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x86_cpu_realizefn</span><br><span class="line">x86_cpu_expand_features</span><br><span class="line">x86_cpu_get_supported_feature_word</span><br><span class="line">kvm_arch_get_supported_cpuid</span><br><span class="line">get_supported_cpuid</span><br><span class="line">try_get_cpuid</span><br><span class="line">KVM_GET_SUPPORTED_CPUID</span><br><span class="line">x86_cpu_filter_features</span><br><span class="line">x86_cpu_get_supported_feature_word</span><br><span class="line">kvm_arch_get_supported_cpuid</span><br><span class="line">get_supported_cpuid</span><br><span class="line">try_get_cpuid</span><br><span class="line">KVM_GET_SUPPORTED_CPUID</span><br><span class="line">qemu_init_vcpu</span><br><span class="line">cpus_accel-&gt;create_vcpu_thread[kvm_start_vcpu_thread]</span><br><span class="line">kvm_vcpu_thread_fn</span><br><span class="line">kvm_init_vcpu</span><br><span class="line">kvm_arch_init_vcpu</span><br><span class="line">cpu_x86_cpuid</span><br><span class="line">KVM_SET_CPUID2</span><br></pre></td></tr></table></figure><p><code>KVM_GET_SUPPORTED_CPUID</code>和<code>KVM_SET_CPUID2</code>的更多描述，可以参考<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt" target="_blank" rel="noopener">kvm/api.txt</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***** Steps involved on loading and filtering CPUID data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When initializing and realizing a CPU object, the steps</span></span><br><span class="line"><span class="comment"> * involved in setting up CPUID data are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) Loading CPU model definition (X86CPUDefinition). This is</span></span><br><span class="line"><span class="comment"> *    implemented by x86_cpu_load_model() and should be completely</span></span><br><span class="line"><span class="comment"> *    transparent, as it is done automatically by instance_init.</span></span><br><span class="line"><span class="comment"> *    No code should need to look at X86CPUDefinition structs</span></span><br><span class="line"><span class="comment"> *    outside instance_init.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2) CPU expansion. This is done by realize before CPUID</span></span><br><span class="line"><span class="comment"> *    filtering, and will make sure host/accelerator data is</span></span><br><span class="line"><span class="comment"> *    loaded for CPU models that depend on host capabilities</span></span><br><span class="line"><span class="comment"> *    (e.g. "host"). Done by x86_cpu_expand_features().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3) CPUID filtering. This initializes extra data related to</span></span><br><span class="line"><span class="comment"> *    CPUID, and checks if the host supports all capabilities</span></span><br><span class="line"><span class="comment"> *    required by the CPU. Runnability of a CPU model is</span></span><br><span class="line"><span class="comment"> *    determined at this step. Done by x86_cpu_filter_features().</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="3-How-to-use"><a href="#3-How-to-use" class="headerlink" title="3.How to use"></a>3.How to use</h3><p><code>qemu-system-x86_64 -cpu help</code></p><ul><li><p>增加 pdpe1gb feature (其中Nehalem是我选定的CPU型号, 也可以是别的型号)</p><p>  <code>qemu-system-x86_64 -cpu Nehalem,+pdpe1gb</code></p></li><li><p>增加 pdpe1gb feature, 减去sse feature</p><p><code>qemu-system-x86_64 -cpu Nehalem,+pdpe1gb,-sse</code></p></li><li><p>增加x2apic feature</p><p> <code>qemu-system-x86_64 -cpu host,x2apic=on</code></p></li></ul><p>qemu解析cpu feature选项的函数为<a href="https://gitlab.com/qemu-project/qemu/-/blob/v5.2.0/target/i386/cpu.c#L4697" target="_blank" rel="noopener">x86_cpu_parse_featurestr</a>。</p><h3 id="4-MISC"><a href="#4-MISC" class="headerlink" title="4. MISC"></a>4. MISC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compatibily hack to maintain legacy +-feat semantic,</span></span><br><span class="line"><span class="comment"> * where +-feat overwrites any feature set by</span></span><br><span class="line"><span class="comment"> * feat=on|feat even if the later is parsed after +-feat</span></span><br><span class="line"><span class="comment"> * (i.e. "-x2apic,x2apic=on" will result in x2apic disabled)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> GList *plus_features, *minus_features;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CPUID usage for interaction between Hypervisors and Linux</span></span><br><span class="line"><span class="comment">//https://lore.kernel.org/kvm/1222881242.9381.17.camel@alok-dev1/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPUID_EXT_HYPERVISOR  (1U &lt;&lt; 31)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This CPUID returns the signature 'KVMKVMKVM' in ebx, ecx, and edx.  It</span></span><br><span class="line"><span class="comment"> * should be used to determine that a VM is running under KVM.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_CPUID_SIGNATURE0x40000000</span></span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.cnblogs.com/haiyonghao/p/14440954.html" target="_blank" rel="noopener">READMSR和CPUID指令在Guest中的代码执行路径学习</a></li><li><a href="https://www.cnblogs.com/hugetong/p/7773526.html" target="_blank" rel="noopener">qemu增加减少CPUID</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文以&lt;a href=&quot;https://gitlab.com/qemu-project/qemu/-/tree/v5.2.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QEMU V5.2.0&lt;/a&gt;,&lt;a href=&quot;https://elixir.bootlin.com/linux/v5.14/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kernel  v5.14&lt;/a&gt;的源码，介绍CPUID management，具体细节不会一一介绍，但是会给出函数调用链，读者可以以此为线索，深挖细节。
    
    </summary>
    
      <category term="QEMU" scheme="http://liujunming.github.io/categories/QEMU/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>Notes about the usage of Linux kernel modules</title>
    <link href="http://liujunming.github.io/2021/11/26/commands-on-Linux-kernel-modules/"/>
    <id>http://liujunming.github.io/2021/11/26/commands-on-Linux-kernel-modules/</id>
    <published>2021-11-26T02:27:40.000Z</published>
    <updated>2021-11-26T12:03:30.909Z</updated>
    
    <content type="html"><![CDATA[<p>总结下Linux modules的使用笔记。<a id="more"></a></p><h3 id="1-指令"><a href="#1-指令" class="headerlink" title="1.  指令"></a>1.  指令</h3><ul><li><code>modinfo</code></li><li><code>modprobe</code></li><li><code>insmod</code></li><li><code>rmmod</code></li><li><code>lsmod</code></li><li><code>depmod</code></li></ul><h3 id="2-文件"><a href="#2-文件" class="headerlink" title="2. 文件"></a>2. 文件</h3><ul><li><code>modprobe.d</code></li><li><code>modules.dep</code></li><li><code>modules-load.d</code></li></ul><h3 id="3-功能"><a href="#3-功能" class="headerlink" title="3. 功能"></a>3. 功能</h3><p>详情请参考<a href="https://wiki.archlinux.org/title/Kernel_module" target="_blank" rel="noopener">archlinux Kernel module</a>。</p><ul><li>Obtaining information</li><li>Automatic module loading with systemd</li><li>Manual module handling</li><li>Setting module options(pass a parameter to a kernel module)<ul><li>Manually at load time using modprobe</li><li>Using files in /etc/modprobe.d/</li><li>Using kernel command line</li></ul></li><li>Blacklisting<ul><li>Using files in /etc/modprobe.d/</li><li>Using kernel command line</li><li><a href="https://documentation.suse.com/sles/12-SP4/html/SLES-all/cha-mod.html" target="_blank" rel="noopener">modprobe.blacklist=<em>MODULE_NAME</em></a></li></ul></li></ul><h3 id="4-tips"><a href="#4-tips" class="headerlink" title="4. tips"></a>4. tips</h3><ul><li><p><code>modprobe</code> uses modules.dep to translate module names into module locations and get dependency relationship.</p></li><li><p><code>depmod</code>generates modules.dep and map files.</p></li><li><code>insmod</code> your module by providing a fully qualified path to the .ko file. <code>insmod</code> doesn’t do any dependency checking.</li></ul><hr><p>参考资料:</p><ol><li><a href="https://wiki.archlinux.org/title/Kernel_module" target="_blank" rel="noopener">archlinux Kernel module</a></li><li><a href="https://lists.kernelnewbies.org/pipermail/kernelnewbies/2011-September/003152.html" target="_blank" rel="noopener">How make modprobe find my kernel module?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结下Linux modules的使用笔记。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Compiling kernel module only w/o whole kernel compilation</title>
    <link href="http://liujunming.github.io/2021/11/26/Compiling-kernel-module-only-w-o-whole-kernel-compilation/"/>
    <id>http://liujunming.github.io/2021/11/26/Compiling-kernel-module-only-w-o-whole-kernel-compilation/</id>
    <published>2021-11-26T02:07:04.000Z</published>
    <updated>2021-11-26T12:03:30.908Z</updated>
    
    <content type="html"><![CDATA[<p>如何只编译内核的单个模块，然后reload新的模块呢？本文以kvm kernel module为例，阐述下具体的过程。本文转载自: <a href="https://yulistic.gitlab.io/2017/10/compiling-kernel-module-only-w/o-whole-kernel-compilation/" target="_blank" rel="noopener">Compiling kernel module only w/o whole kernel compilation</a><a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>I was tried to modify a <code>kvm</code> kernel module for my research. Because it was a built-in kernel module, I needed to build all the kernel source code after modifying <code>kvm</code> module which is located in path <code>arch/x86/kvm/</code> from the linux kernel source root.</p><p>The whole kernel compilation was a time consuming job, usually taking over 10 minutes even on my i7 desktop machine. I tried to find a way to compile modules only without the whole kernel compilation. The solution and some troublesomes are described below.</p><h3 id="2-Assumption"><a href="#2-Assumption" class="headerlink" title="2. Assumption"></a>2. Assumption</h3><p>It is assumed that you have a kernel source code and configured it properly according to your taste. Also, assumed that you had installed the kernel and rebooted with it.</p><h3 id="3-Solution"><a href="#3-Solution" class="headerlink" title="3. Solution"></a>3. Solution</h3><p>Building only one module is easy. After configuring, build the source as following.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make M=path/to/module/directory</span><br><span class="line">make M=path/to/module/directory modules_install</span><br></pre></td></tr></table></figure><p>You can find the path of modules with <code>modinfo</code> command.<br>In my case, the required module was <code>kvm.ko</code>, and <code>kvm-intel.ko</code>. They were located in <code>arch/x86/kvm</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make M=arch/x86/kvm</span><br><span class="line">make M=arch/x86/kvm modules_install</span><br></pre></td></tr></table></figure><p>You can reload the new modules. I removed the <code>kvm-intel</code> module first because it depends on the <code>kvm</code> module.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rmmod kvm-intel kvm</span><br></pre></td></tr></table></figure><p>And, load the new modules.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe kvm-intel</span><br></pre></td></tr></table></figure><p>Loading <code>kvm-intel</code> will load <code>kvm</code> automatically.</p><p>FYI: the new modules are installed in <strong>/lib/modules/`uname -r`/extra</strong> directory.</p><h3 id="4-Troublesomes"><a href="#4-Troublesomes" class="headerlink" title="4. Troublesomes"></a>4. Troublesomes</h3><h4 id="4-1-modprobe-failure"><a href="#4-1-modprobe-failure" class="headerlink" title="4.1 modprobe failure."></a>4.1 <code>modprobe</code> failure.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe: error: could not insert &apos;kvm&apos;: exec format error</span><br></pre></td></tr></table></figure><p>The <code>modprobe</code> might fail if the version of a kernel module and that of a kernel are different. You can check the error with <code>dmesg</code> after the <code>modprobe</code> failure.</p><p>In my case, I built the kernel without any modification which resulted in the version number of <code>4.13.0-rc6</code>. When I modified the <code>kvm</code> module and compiled it, the version number was changed to <code>4.13.0-rc6+</code>.</p><p>My solution was building the kernel with some small modifications generating the version number as <code>4.13.0-rc6+</code> as a baseline.<br>The problem solved because the kvm module was also built with the same version number, <code>4.13.0-rc6+</code>, which did not produce any <code>modprobe</code> error.</p><h4 id="4-2-Location-of-generated-modules"><a href="#4-2-Location-of-generated-modules" class="headerlink" title="4. 2 Location of generated modules"></a>4. 2 Location of generated modules</h4><p>The modules generated with <code>M=path</code> options are installed into <strong>/lib/modules/`uname -r`/extra</strong> path. The path is different from the originally built one (when compiling the whole kernel) which is <strong>/lib/modules/`uname -r`/kernel/arch/x86/kvm</strong> in the case of <code>kvm</code>.</p><p>If you want to install a new module into the same location of original one, use <code>INSTALL_MOD_DIR</code> option. Example follows.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make INSTALL_MOD_DIR=kernel/arch/x86/kvm M=arch/x86/kvm modules_install</span><br></pre></td></tr></table></figure><p>如果<code>modprobe</code>中遇到其他问题，请参考<a href="/2021/11/26/commands-on-Linux-kernel-modules/">commands on Linux kernel modules</a>。</p><h3 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5. Conclusion"></a>5. Conclusion</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make M=arch/x86/kvm</span><br><span class="line">make INSTALL_MOD_DIR=kernel/arch/x86/kvm M=arch/x86/kvm modules_install</span><br><span class="line"></span><br><span class="line">rmmod kvm-intel kvm</span><br><span class="line">modprobe kvm-intel</span><br></pre></td></tr></table></figure><p>Create a simple shell file under your Linux source code root.</p><hr><p>参考资料:</p><ol><li><a href="https://yulistic.gitlab.io/2017/10/compiling-kernel-module-only-w/o-whole-kernel-compilation/" target="_blank" rel="noopener">Compiling kernel module only w/o whole kernel compilation</a></li><li><a href="https://www.cnblogs.com/haiyonghao/p/14440240.html" target="_blank" rel="noopener">linux内核中单独module的编译和使用</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何只编译内核的单个模块，然后reload新的模块呢？本文以kvm kernel module为例，阐述下具体的过程。本文转载自: &lt;a href=&quot;https://yulistic.gitlab.io/2017/10/compiling-kernel-module-only-w/o-whole-kernel-compilation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Compiling kernel module only w/o whole kernel compilation&lt;/a&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第25期</title>
    <link href="http://liujunming.github.io/2021/11/25/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC25%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/11/25/每周分享第25期/</id>
    <published>2021-11-25T02:27:36.000Z</published>
    <updated>2021-11-26T12:03:30.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="I-hear-and-I-forget-I-see-and-I-remember-I-do-and-I-understand"><a href="#I-hear-and-I-forget-I-see-and-I-remember-I-do-and-I-understand" class="headerlink" title="I hear and I forget, I see and I remember, I do and I understand."></a>I hear and I forget, I see and I remember, I do and I understand.</h3><p>不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。<br><a id="more"></a></p><h3 id="hololens"><a href="#hololens" class="headerlink" title="hololens"></a>hololens</h3><p>HoloLens是一个Windows 10的智能眼镜产品。</p><h3 id="破壁机"><a href="#破壁机" class="headerlink" title="破壁机"></a>破壁机</h3><p>破壁料理机集合了榨汁机、豆浆机、冰激凌机、料理机、研磨机等产品功能，完全达到一机多用功能，可以瞬间击破食物细胞壁，释放植物生化素的机器。</p><h3 id="我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前"><a href="#我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前" class="headerlink" title="我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前"></a>我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前</h3><p><a href="https://www.sohu.com/a/462173590_99992021" target="_blank" rel="noopener">https://www.sohu.com/a/462173590_99992021</a></p><h3 id="藏书羊肉"><a href="#藏书羊肉" class="headerlink" title="藏书羊肉"></a>藏书羊肉</h3><p><a href="https://new.qq.com/omn/20191103/20191103A0FTE000.html" target="_blank" rel="noopener">https://new.qq.com/omn/20191103/20191103A0FTE000.html</a></p><h3 id="高盛"><a href="#高盛" class="headerlink" title="高盛"></a>高盛</h3><p><a href="https://www.bilibili.com/video/BV1hy4y1h7Cu" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1hy4y1h7Cu</a></p><h3 id="PDU"><a href="#PDU" class="headerlink" title="PDU"></a>PDU</h3><p>Power distribution unit</p><p><a href="https://en.wikipedia.org/wiki/Power_distribution_unit" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Power_distribution_unit</a></p><h3 id="KVM-switch"><a href="#KVM-switch" class="headerlink" title="KVM switch"></a>KVM switch</h3><p>A KVM switch (with KVM being an abbreviation for “keyboard, video and mouse”) is a hardware device that allows a user to control multiple computers from one or more sets of keyboards, video monitors, and mice.</p><p><a href="https://en.wikipedia.org/wiki/KVM_switch" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/KVM_switch</a></p><h3 id="BMC"><a href="#BMC" class="headerlink" title="BMC"></a>BMC</h3><p>baseboard management controller (<em>BMC</em>) 底板管理控制器</p><p>A baseboard management controller (BMC) is a specialized service processor that monitors the physical state of a computer, network server or other hardware device using sensors and communicating with the system administrator through an independent connection. The BMC is part of the Intelligent Platform Management Interface (IPMI) and is usually contained in the motherboard or main circuit board of the device to be monitored.</p><p><a href="https://www.techtarget.com/searchnetworking/definition/baseboard-management-controller" target="_blank" rel="noopener">https://www.techtarget.com/searchnetworking/definition/baseboard-management-controller</a></p><p><a href="https://www.intel.cn/content/www/cn/zh/support/articles/000007913/server-products.html" target="_blank" rel="noopener">https://www.intel.cn/content/www/cn/zh/support/articles/000007913/server-products.html</a></p><h3 id="强者与弱者的零界点"><a href="#强者与弱者的零界点" class="headerlink" title="强者与弱者的零界点"></a>强者与弱者的零界点</h3><p>强者和弱者区别在于是否热爱解决问题。</p><p>善于总结、反思、分析、实践。</p><p>解决问题之前，最先需要培养的是观察和反思的能力，如果没有观察，就不会发现问题，如果不会观察就不会发现自己的心理变化，从而找到可以解决问题的办法，而反思是帮助我们基于观察后进行修正的修正值。</p><p><a href="https://www.zhihu.com/question/47410550/answer/148990988" target="_blank" rel="noopener">https://www.zhihu.com/question/47410550/answer/148990988</a></p><p>大部分人先解决身体健康问题，然后情绪心理问题，因为这关乎生命力，欲望，执行力，勇气，信心等等，其实心理问题和身体问题解决好了，生存发展和人际关系问题基本就迎刃而解了。</p><h3 id="第二届中国云计算基础架构开发者大会"><a href="#第二届中国云计算基础架构开发者大会" class="headerlink" title="第二届中国云计算基础架构开发者大会"></a>第二届中国云计算基础架构开发者大会</h3><p><a href="https://github.com/chinacid/cid_slides" target="_blank" rel="noopener">https://github.com/chinacid/cid_slides</a></p><p><a href="https://www.youku.com/profile/index/?spm=a2hbt.13141534.1_1.1&amp;uid=UMzc1NzQ2NDg0" target="_blank" rel="noopener">https://www.youku.com/profile/index/?spm=a2hbt.13141534.1_1.1&amp;uid=UMzc1NzQ2NDg0</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;I-hear-and-I-forget-I-see-and-I-remember-I-do-and-I-understand&quot;&gt;&lt;a href=&quot;#I-hear-and-I-forget-I-see-and-I-remember-I-do-and-I-understand&quot; class=&quot;headerlink&quot; title=&quot;I hear and I forget, I see and I remember, I do and I understand.&quot;&gt;&lt;/a&gt;I hear and I forget, I see and I remember, I do and I understand.&lt;/h3&gt;&lt;p&gt;不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Linux MSR tools</title>
    <link href="http://liujunming.github.io/2021/11/21/Linux-MSR-tools/"/>
    <id>http://liujunming.github.io/2021/11/21/Linux-MSR-tools/</id>
    <published>2021-11-21T08:17:28.000Z</published>
    <updated>2021-11-21T10:16:17.903Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about MSR tools in Linux，并结合一个具体的例子，展示其用法。<a id="more"></a>本文大部分内容源于<a href="https://ilinuxkernel.com/?p=255" target="_blank" rel="noopener">Linux读写CPU MSR寄存器命令rdmsr/wrmsr</a>。</p><p>Linux内核源码提供了读写CPU MSR寄存器模块，使得用户空间可以直接读写MSR寄存器。</p><p>开源社区提供msr寄存器读写工具:msr-tools，其中有两个命令，<code>rdmsr</code>/<code>wrmsr</code>。</p><h3 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h3><p>要使<code>rdmsr</code>/<code>wrmsr</code>命令可以读写msr寄存器，系统中必须有msr模块，或将msr模块编译进内核。下面是从内核配置选项中选取的内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Processor type and features  —&gt;</span><br><span class="line">&lt;M&gt; /dev/cpu/*/msr – Model-specific register support</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modprobe msr</span><br><span class="line"></span><br><span class="line">apt-get install -y msr-tools</span><br></pre></td></tr></table></figure><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@kvm:~# rdmsr -h</span><br><span class="line">Usage: rdmsr [options] regno</span><br><span class="line">  --help         -h  Print this help</span><br><span class="line">  --version      -V  Print current version</span><br><span class="line">  --hexadecimal  -x  Hexadecimal output (lower case)</span><br><span class="line">  --capital-hex  -X  Hexadecimal output (upper case)</span><br><span class="line">  --decimal      -d  Signed decimal output</span><br><span class="line">  --unsigned     -u  Unsigned decimal output</span><br><span class="line">  --octal        -o  Octal output</span><br><span class="line">  --c-language   -c  Format output as a C language constant</span><br><span class="line">  --zero-pad     -0  Output leading zeroes</span><br><span class="line">  --raw          -r  Raw binary output</span><br><span class="line">  --all          -a  all processors</span><br><span class="line">  --processor #  -p  Select processor number (default 0)</span><br><span class="line">  --bitfield h:l -f  Output bits [h:l] only</span><br><span class="line">root@kvm:~# wrmsr -h</span><br><span class="line">Usage: wrmsr [options] regno value...</span><br><span class="line">  --help         -h  Print this help</span><br><span class="line">  --version      -V  Print current version</span><br><span class="line">  --all          -a  all processors</span><br><span class="line">  --processor #  -p  Select processor number (default 0)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@kvm:~# rdmsr -p 0 0x1b</span><br><span class="line">fee00d00</span><br><span class="line">root@kvm:~# rdmsr -p 1 0x1b</span><br><span class="line">fee00c00</span><br></pre></td></tr></table></figure><p><img src="/images/2021/11/12.png" alt></p><p>由此可加:</p><ul><li>CPU 0 has set BSP flag, while CPU 1 has cleared BSP flag</li><li>x2APIC mode is enabled</li><li>APIC Global enabled</li><li>…</li></ul><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p><code>/dev/cpu/CPUNUM/msr</code> provides  an interface to read and write the model-specific registers (MSRs) of an x86 CPU. CPUNUM is the number of the CPU to access as listed in /proc/cpuinfo.</p><p>The register access is done by opening the file and seeking to the MSR number as offset in the file, and then reading or writing in chunks  of  8 bytes. </p><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><ul><li><code>man msr</code></li><li><a href="https://github.com/intel/msr-tools" target="_blank" rel="noopener">intel/msr-tools</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about MSR tools in Linux，并结合一个具体的例子，展示其用法。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
