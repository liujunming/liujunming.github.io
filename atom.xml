<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2023-07-30T14:25:38.620Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux kernel RCU usage</title>
    <link href="http://liujunming.github.io/2023/07/30/Linux-kernel-RCU-usage/"/>
    <id>http://liujunming.github.io/2023/07/30/Linux-kernel-RCU-usage/</id>
    <published>2023-07-30T14:08:27.000Z</published>
    <updated>2023-07-30T14:25:38.620Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍Linux kernel中RCU的使用。<a id="more"></a></p><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>需要仔细阅读<a href="/2018/12/13/深入理解-Linux-的-RCU-机制/">深入理解 Linux 的 RCU 机制</a>。</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://lwn.net/Articles/609973/" target="_blank" rel="noopener">The RCU API tables</a><br><a href="https://lwn.net/Articles/263130/" target="_blank" rel="noopener">What is RCU? Part 2: Usage</a></p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p><a href="https://github.com/jinb-park/rcu_example/blob/master/list_rcu_example.c" target="_blank" rel="noopener">list_rcu_example</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * list_rcu_example.c - list rcu sample module</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016 Jinbum Park &lt;jinb.park7@gmail.com&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is free software; you can redistribute it and/or</span></span><br><span class="line"><span class="comment"> * modify it under the terms of the GNU General Public License</span></span><br><span class="line"><span class="comment"> * as published by the Free Software Foundation; either version 2</span></span><br><span class="line"><span class="comment"> * of the License, or (at your option) any later version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment"> * GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment"> * along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rculist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/preempt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct book - a book</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @borrow: If it is 0, book is not borrowed. it is 1, book is borrowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> borrow;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(books)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">spinlock_t</span> books_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * callback function for async-reclaim</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * call_rcu()       :  callback function is called when finish to wait every grace periods (async)</span></span><br><span class="line"><span class="comment"> * synchronize_rcu() :  wait to finish every grace periods (sync)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">book_reclaim_callback</span><span class="params">(struct rcu_head *rcu)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span> = <span class="title">container_of</span>(<span class="title">rcu</span>, <span class="title">struct</span> <span class="title">book</span>, <span class="title">rcu</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Why print preemt_count??</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * To check whether this callback is atomic context or not.</span></span><br><span class="line"><span class="comment">     * preempt_count here is more than 0. Because it is irq context.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pr_info(<span class="string">"callback free : %lx, preempt_count : %d\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)b, preempt_count());</span><br><span class="line">    kfree(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_book</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *author)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    b = kzalloc(<span class="keyword">sizeof</span>(struct book), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    b-&gt;id = id;</span><br><span class="line">    <span class="built_in">strncpy</span>(b-&gt;name, name, <span class="keyword">sizeof</span>(b-&gt;name));</span><br><span class="line">    <span class="built_in">strncpy</span>(b-&gt;author, author, <span class="keyword">sizeof</span>(b-&gt;author));</span><br><span class="line">    b-&gt;borrow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * list_add_rcu</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * add_node(writer - add) use spin_lock()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    spin_lock(&amp;books_lock);</span><br><span class="line">    list_add_rcu(&amp;b-&gt;node, &amp;books);</span><br><span class="line">    spin_unlock(&amp;books_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">borrow_book</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">new_b</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">old_b</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * updater</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * (updater) require that alloc new node &amp; copy, update new node &amp; reclaim old node</span></span><br><span class="line"><span class="comment">     * list_replace_rcu() is used to do that.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(b, &amp;books, node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;id == id) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b-&gt;borrow) &#123;</span><br><span class="line">                rcu_read_unlock();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            old_b = b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!old_b) &#123;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    new_b = kzalloc(<span class="keyword">sizeof</span>(struct book), GFP_ATOMIC);</span><br><span class="line">    <span class="keyword">if</span>(!new_b) &#123;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_b, old_b, <span class="keyword">sizeof</span>(struct book));</span><br><span class="line">    new_b-&gt;borrow = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    spin_lock(&amp;books_lock);</span><br><span class="line">    list_replace_rcu(&amp;old_b-&gt;node, &amp;new_b-&gt;node);</span><br><span class="line">    spin_unlock(&amp;books_lock);</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(async) &#123;</span><br><span class="line">        call_rcu(&amp;old_b-&gt;rcu, book_reclaim_callback);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        synchronize_rcu();</span><br><span class="line">        kfree(old_b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"borrow success %d, preempt_count : %d\n"</span>, id, preempt_count());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">is_borrowed_book</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reader</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * iteration(read) require rcu_read_lock(), rcu_read_unlock()</span></span><br><span class="line"><span class="comment">     * and use list_for_each_entry_rcu()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    list_for_each_entry_rcu(b, &amp;books, node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;id == id) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">return</span> b-&gt;borrow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    pr_err(<span class="string">"not exist book\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">return_book</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">new_b</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">old_b</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * updater</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * (updater) require that alloc new node &amp; copy, update new node &amp; reclaim old node</span></span><br><span class="line"><span class="comment">     * list_replace_rcu() is used to do that.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(b, &amp;books, node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;id == id) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!b-&gt;borrow) &#123;</span><br><span class="line">                rcu_read_unlock();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            old_b = b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!old_b) &#123;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    new_b = kzalloc(<span class="keyword">sizeof</span>(struct book), GFP_ATOMIC);</span><br><span class="line">    <span class="keyword">if</span>(!new_b) &#123;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_b, old_b, <span class="keyword">sizeof</span>(struct book));</span><br><span class="line">    new_b-&gt;borrow = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    spin_lock(&amp;books_lock);</span><br><span class="line">    list_replace_rcu(&amp;old_b-&gt;node, &amp;new_b-&gt;node);</span><br><span class="line">    spin_unlock(&amp;books_lock);</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(async) &#123;</span><br><span class="line">        call_rcu(&amp;old_b-&gt;rcu, book_reclaim_callback);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        synchronize_rcu();</span><br><span class="line">        kfree(old_b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"return success %d, preempt_count : %d\n"</span>, id, preempt_count());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_book</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;books_lock);</span><br><span class="line">    list_for_each_entry(b, &amp;books, node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;id == id) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * list_del</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * del_node(writer - delete) require locking mechanism.</span></span><br><span class="line"><span class="comment">             * we can choose 3 ways to lock. Use 'a' here.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  a.  locking,</span></span><br><span class="line"><span class="comment">             *  b.  atomic operations, or</span></span><br><span class="line"><span class="comment">             *  c.  restricting updates to a single task.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            list_del_rcu(&amp;b-&gt;node);</span><br><span class="line">            spin_unlock(&amp;books_lock);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(async) &#123;</span><br><span class="line">                call_rcu(&amp;b-&gt;rcu, book_reclaim_callback);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                synchronize_rcu();</span><br><span class="line">                kfree(b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;books_lock);</span><br><span class="line"></span><br><span class="line">    pr_err(<span class="string">"not exist book\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_book</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    list_for_each_entry_rcu(b, &amp;books, node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;id == id) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Why print address of "struct book *b"??</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * If b was updated, address of b must be different.</span></span><br><span class="line"><span class="comment">             * We can know whether b is updated or not by address.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            pr_info(<span class="string">"id : %d, name : %s, author : %s, borrow : %d, addr : %lx\n"</span>, \</span><br><span class="line">                        b-&gt;id, b-&gt;name, b-&gt;author, b-&gt;borrow, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)b);</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    pr_err(<span class="string">"not exist book\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_example</span><span class="params">(<span class="keyword">int</span> async)</span> </span>&#123;</span><br><span class="line">    add_book(<span class="number">0</span>, <span class="string">"book1"</span>, <span class="string">"jb"</span>);</span><br><span class="line">    add_book(<span class="number">1</span>, <span class="string">"book2"</span>, <span class="string">"jb"</span>);</span><br><span class="line"></span><br><span class="line">    print_book(<span class="number">0</span>);</span><br><span class="line">    print_book(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"book1 borrow : %d\n"</span>, is_borrowed_book(<span class="number">0</span>));</span><br><span class="line">    pr_info(<span class="string">"book2 borrow : %d\n"</span>, is_borrowed_book(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    borrow_book(<span class="number">0</span>, async);</span><br><span class="line">    borrow_book(<span class="number">1</span>, async);</span><br><span class="line"></span><br><span class="line">    print_book(<span class="number">0</span>);</span><br><span class="line">    print_book(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    return_book(<span class="number">0</span>, async);</span><br><span class="line">    return_book(<span class="number">1</span>, async);</span><br><span class="line"></span><br><span class="line">    print_book(<span class="number">0</span>);</span><br><span class="line">    print_book(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    delete_book(<span class="number">0</span>, async);</span><br><span class="line">    delete_book(<span class="number">1</span>, async);</span><br><span class="line"></span><br><span class="line">    print_book(<span class="number">0</span>);</span><br><span class="line">    print_book(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">list_rcu_example_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    spin_lock_init(&amp;books_lock);</span><br><span class="line"></span><br><span class="line">    test_example(<span class="number">0</span>);</span><br><span class="line">    test_example(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_rcu_example_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(list_rcu_example_init);</span><br><span class="line">module_exit(list_rcu_example_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><h3 id="struct-rcu-head"><a href="#struct-rcu-head" class="headerlink" title="struct rcu_head"></a>struct rcu_head</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct callback_head - callback structure for use with RCU and task_work</span></span><br><span class="line"><span class="comment"> * @next: next update requests in a list</span></span><br><span class="line"><span class="comment"> * @func: actual update function to call after the grace period.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The struct is aligned to size of pointer. On most architectures it happens</span></span><br><span class="line"><span class="comment"> * naturally due ABI requirements, but some architectures (like CRIS) have</span></span><br><span class="line"><span class="comment"> * weird ABI and we need to ask it explicitly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The alignment is required to guarantee that bit 0 of @next will be</span></span><br><span class="line"><span class="comment"> * clear under normal conditions -- as long as we use call_rcu() or</span></span><br><span class="line"><span class="comment"> * call_srcu() to queue the callback.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This guarantee is important for few reasons:</span></span><br><span class="line"><span class="comment"> *  - future call_rcu_lazy() will make use of lower bits in the pointer;</span></span><br><span class="line"><span class="comment"> *  - the structure shares storage space in struct page with @compound_head,</span></span><br><span class="line"><span class="comment"> *    which encode PageTail() in bit 0. The guarantee is needed to avoid</span></span><br><span class="line"><span class="comment"> *    false-positive PageTail().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(struct callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>回调的时候使用，可以结合call_rcu(Queue an RCU callback for invocation after a grace period)使用。</p><h3 id="rcu-dereference-protected"><a href="#rcu-dereference-protected" class="headerlink" title="rcu_dereference_protected"></a>rcu_dereference_protected</h3><p><code>rcu_dereference_protected()</code> primitive is used to access RCU-protected pointers from update-side code. Because the update-side code is using some other synchronization mechanism (locks, atomic operations, single updater thread, etc.), it does not need to put RCU read-side protections in place. This primitive also takes a lockdep expression, which can be used to assert that the right locks are held and that any other necessary conditions hold.</p><p><img src="/images/2023/07/001.jpg" alt></p><hr><p>参考资料:</p><ol><li><a href="https://lwn.net/Articles/777036/" target="_blank" rel="noopener">The RCU API, 2019 edition</a></li><li><a href="https://stackoverflow.com/questions/39251287/rcu-dereference-vs-rcu-dereference-protected" target="_blank" rel="noopener">rcu_dereference() vs rcu_dereference_protected()?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍Linux kernel中RCU的使用。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>kprobe/kretprobe使用方法</title>
    <link href="http://liujunming.github.io/2023/07/22/%E8%BD%AC-kprobe-kretprobe%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://liujunming.github.io/2023/07/22/转-kprobe-kretprobe使用方法/</id>
    <published>2023-07-22T07:54:06.000Z</published>
    <updated>2023-07-22T08:37:45.001Z</updated>
    
    <content type="html"><![CDATA[<p>转载自:<a href="https://kernel.love/kprobe.html" target="_blank" rel="noopener">https://kernel.love/kprobe.html</a> <a id="more"></a> </p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>有时候想知道下发某个操作后内核在做些什么，这个时候就要对内核进行调试， 然而KGDB这种方法操作起来相对麻烦，这个时候我们就可以使用kprobe来探测内核的行为。</p><p>介绍kprobe和kretprobe的文档为:<a href="https://www.kernel.org/doc/Documentation/kprobes.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/kprobes.txt</a></p><p>划重点，这里是文档和很多博客没有解释清楚的地方：</p><ol><li>对于kprobe而言，理论上它可以probe任何一个地方（只需要指定某个代码段地址就行了，例如函数的地址）；</li><li>对于kprobe而言，pre_handler回调函数执行是发生在probe断点执行之前，post_handler回调执行是发生在probe断点<em>单步执行</em>之后，而不是函数返回之前；</li><li>对于kretprobe而言，一般只用来探测函数，entry_handler回调执行是在函数入口的地方（这时候我们可以探测函数的入参），handler回调函数执行是发生在函数准备返回的时候，注意这个时候参数都已经弹栈，我们只能探测函数的返回值。</li></ol><h2 id="kprobe"><a href="#kprobe" class="headerlink" title="kprobe"></a>kprobe</h2><p>下面举一个最简单的例子，介绍如何使用kprobe来查看<code>inet_bind</code>这个函数的调用情况。 <code>inet_bind</code>函数是在发生ipv4 socket bind阶段调用的一个内核函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched/clock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kprobes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ptrace.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sockios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/net.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/inet_common.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* For each probe you need to allocate a kprobe structure */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kprobe</span> <span class="title">kp</span> = &#123;</span></span><br><span class="line">    .symbol_name    = <span class="string">"inet_bind"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kprobe pre_handler: called just before the probed instruction is executed */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handler_pre</span><span class="params">(struct kprobe *p, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARM64</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span> = <span class="title">regs</span>-&gt;<span class="title">regs</span>[0];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">uaddr</span> = <span class="title">regs</span>-&gt;<span class="title">regs</span>[1];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span> = <span class="title">regs</span>-&gt;<span class="title">di</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">uaddr</span> = <span class="title">regs</span>-&gt;<span class="title">si</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> =  (<span class="title">struct</span> <span class="title">sockaddr_in</span> *)<span class="title">uaddr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> snum = ntohs(addr-&gt;sin_port);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"%s name:%s pid:%d socket bind port=%d\n"</span>,</span><br><span class="line">            p-&gt;symbol_name, current-&gt;comm, task_pid_nr(current), snum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* kprobe post_handler: called after the probed instruction is executed */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler_post</span><span class="params">(struct kprobe *p, struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">"%s called\n"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fault_handler: this is called if an exception is generated for any</span></span><br><span class="line"><span class="comment"> * instruction within the pre- or post-handler, or when Kprobes</span></span><br><span class="line"><span class="comment"> * single-steps the probed instruction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handler_fault</span><span class="params">(struct kprobe *p, struct pt_regs *regs, <span class="keyword">int</span> trapnr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"fault_handler: p-&gt;addr = 0x%p, trap #%dn"</span>,</span><br><span class="line">            p-&gt;addr, trapnr);</span><br><span class="line">    <span class="comment">/* Return 0 because we don't handle the fault. */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">kprobe_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    kp.pre_handler = handler_pre;</span><br><span class="line">    kp.post_handler = handler_post;</span><br><span class="line">    kp.fault_handler = handler_fault;</span><br><span class="line"></span><br><span class="line">    ret = register_kprobe(&amp;kp);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">"register_kprobe failed, returned %d\n"</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Planted kprobe at %p\n"</span>, kp.addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">kprobe_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unregister_kprobe(&amp;kp);</span><br><span class="line">    printk(KERN_INFO <span class="string">"kprobe at %p unregistered\n"</span>, kp.addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kprobe_init)</span><br><span class="line">module_exit(kprobe_exit)</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><p>使用下面的Makefile文件，对其进行编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m := kprobe_example.o</span><br><span class="line">CROSS_COMPILE=&apos;&apos;</span><br><span class="line">KDIR := /lib/modules/$(shell uname -r)/build</span><br><span class="line">all:  </span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules   </span><br><span class="line">clean:  </span><br><span class="line">    rm -f *.ko *.o *.mod.o *.mod.c .*.cmd *.symvers  modul*</span><br></pre></td></tr></table></figure></p><p>编译完成后会生产一个名为<em>kprobe_example.ko</em>的内核模块文件，执行<code>insmod kprobe_example.ko</code>后内核模块立即生效，通过<code>dmesg</code>命令可以查看到<code>inet_bind</code>这个函数的调用情况。从dmesg日志可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[46071.632951] inet_bind name:test pid:68248 socdmket bind port=49152</span><br><span class="line">[46071.632984] inet_bind name:test pid:68248 socket bind port=49152</span><br><span class="line">[46071.632995] inet_bind name:test pid:68248 socket bind port=49152</span><br></pre></td></tr></table></figure></p><h3 id="函数参数获取"><a href="#函数参数获取" class="headerlink" title="函数参数获取"></a>函数参数获取</h3><p>值得一提的是，kprobe里面我们在probe某个函数的时候，获取函数参数的时候是和体系结构相关的。</p><p>例如：在x86平台上，根据C ABI <a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/ptrace.h" target="_blank" rel="noopener">ptrace</a>接口规范，函数的参数和pt_regs的对应关系是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren't saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled "struct pt_regs".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r15;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r14;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r13;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r12;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> bp;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> bx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r11;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r10;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r9;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> r8;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> ax;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> cx;   <span class="comment">// mapped to arg[3]</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> dx;   <span class="comment">// mapped to arg[2]</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> si;   <span class="comment">// mapped to arg[1]</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> di;   <span class="comment">// mapped to arg[0]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it's IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> orig_ax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> ip;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> sp;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在ARM64平台上，根据C ABI <a href="https://elixir.bootlin.com/linux/v4.19.69/source/arch/arm64/include/asm/ptrace.h" target="_blank" rel="noopener">ptrace</a>规范， 函数的参数和pt_regs的对应关系是：入参args[0]对应了regs[0]，入参args[1]对应regs[1]依此类推。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct defines the way the registers are stored on the stack during an</span></span><br><span class="line"><span class="comment"> * exception. Note that sizeof(struct pt_regs) has to be a multiple of 16 (for</span></span><br><span class="line"><span class="comment"> * stack alignment). struct user_pt_regs must form a prefix of struct pt_regs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">user_pt_regs</span> <span class="title">user_regs</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                        u64 regs[<span class="number">31</span>];</span><br><span class="line">                        u64 sp;</span><br><span class="line">                        u64 pc;</span><br><span class="line">                        u64 pstate;</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        u64 orig_x0;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __AARCH64EB__</span></span><br><span class="line">        u32 unused2;</span><br><span class="line">        s32 syscallno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        s32 syscallno;</span><br><span class="line">        u32 unused2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        u64 orig_addr_limit;</span><br><span class="line">        <span class="comment">/* Only valid when ARM64_HAS_IRQ_PRIO_MASKING is enabled. */</span></span><br><span class="line">        u64 pmr_save;</span><br><span class="line">        u64 stackframe[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="kretprobe"><a href="#kretprobe" class="headerlink" title="kretprobe"></a>kretprobe</h2><p>kretprobe可以用来探测函数的返回值，示例中我们用它来探测<code>inet_release</code>函数的返回值和执行时间：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kretprobe_example.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Here's a sample kernel module showing the use of return probes to</span></span><br><span class="line"><span class="comment"> * report the return value and total time taken for probed function</span></span><br><span class="line"><span class="comment"> * to run.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * usage: insmod kretprobe_example.ko func=&lt;func_name&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If no func_name is specified, inet_release is instrumented</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For more information on theory of operation of kretprobes, see</span></span><br><span class="line"><span class="comment"> * Documentation/kprobes.txt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Build and insert the kernel module as done in the kprobe example.</span></span><br><span class="line"><span class="comment"> * You will see the trace data in /var/log/messages and on the console</span></span><br><span class="line"><span class="comment"> * whenever the probed function returns. (Some messages may be suppressed</span></span><br><span class="line"><span class="comment"> * if syslogd is configured to eliminate duplicate messages.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kprobes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ktime.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> func_name[NAME_MAX] = <span class="string">"inet_release"</span>;</span><br><span class="line">module_param_string(func, func_name, NAME_MAX, S_IRUGO);</span><br><span class="line">MODULE_PARM_DESC(func, <span class="string">"Function to kretprobe; this module will report the"</span></span><br><span class="line">                        <span class="string">" function's execution time"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* per-instance private data */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_data</span> &#123;</span></span><br><span class="line">        <span class="keyword">ktime_t</span> entry_stamp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here we use the entry_hanlder to timestamp function entry */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">entry_handler</span><span class="params">(struct kretprobe_instance *ri, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">my_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!current-&gt;mm)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">/* Skip kernel threads */</span></span><br><span class="line"></span><br><span class="line">        data = (struct my_data *)ri-&gt;data;</span><br><span class="line">        data-&gt;entry_stamp = ktime_get();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return-probe handler: Log the return value and duration. Duration may turn</span></span><br><span class="line"><span class="comment"> * out to be zero consistently, depending upon the granularity of time</span></span><br><span class="line"><span class="comment"> * accounting on the platform.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ret_handler</span><span class="params">(struct kretprobe_instance *ri, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> retval = regs_return_value(regs);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">my_data</span> *<span class="title">data</span> = (<span class="title">struct</span> <span class="title">my_data</span> *)<span class="title">ri</span>-&gt;<span class="title">data</span>;</span></span><br><span class="line">        s64 delta;</span><br><span class="line">        <span class="keyword">ktime_t</span> now;</span><br><span class="line"></span><br><span class="line">        now = ktime_get();</span><br><span class="line">        delta = ktime_to_ns(ktime_sub(now, data-&gt;entry_stamp));</span><br><span class="line"></span><br><span class="line">        printk(KERN_INFO <span class="string">"%s returned %d and took %lld ns to execute\n"</span>,</span><br><span class="line">                        func_name, retval, (<span class="keyword">long</span> <span class="keyword">long</span>)delta);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kretprobe</span> <span class="title">my_kretprobe</span> = &#123;</span></span><br><span class="line">        .handler                = ret_handler,</span><br><span class="line">        .entry_handler          = entry_handler,</span><br><span class="line">        .data_size              = <span class="keyword">sizeof</span>(struct my_data),</span><br><span class="line">        <span class="comment">/* Probe up to 20 instances concurrently. */</span></span><br><span class="line">        .maxactive              = <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">kretprobe_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        my_kretprobe.kp.symbol_name = func_name;</span><br><span class="line">        ret = register_kretprobe(&amp;my_kretprobe);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                printk(KERN_INFO <span class="string">"register_kretprobe failed, returned %d\n"</span>,</span><br><span class="line">                                ret);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(KERN_INFO <span class="string">"Planted return probe at %s: %p\n"</span>,</span><br><span class="line">                        my_kretprobe.kp.symbol_name, my_kretprobe.kp.addr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">kretprobe_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        unregister_kretprobe(&amp;my_kretprobe);</span><br><span class="line">        printk(KERN_INFO <span class="string">"kretprobe at %p unregistered\n"</span>,</span><br><span class="line">                        my_kretprobe.kp.addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* nmissed &gt; 0 suggests that maxactive was set too low. */</span></span><br><span class="line">        printk(KERN_INFO <span class="string">"Missed probing %d instances of %s\n"</span>,</span><br><span class="line">                my_kretprobe.nmissed, my_kretprobe.kp.symbol_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kretprobe_init)</span><br><span class="line">module_exit(kretprobe_exit)</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure></p><p>探测的结果输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[60362.085372] inet_release returned 0 and took 16360 ns to execute</span><br><span class="line">[60362.091124] inet_release returned 0 and took 8880 ns to execute</span><br><span class="line">[60362.091147] inet_release returned 0 and took 7640 ns to execute</span><br><span class="line">[60362.091173] inet_release returned 0 and took 7900 ns to execute</span><br><span class="line">[60362.941665] inet_release returned 0 and took 9100 ns to execute</span><br><span class="line">[60363.099577] inet_release returned 0 and took 9240 ns to execute</span><br><span class="line">[60363.126682] inet_release returned 0 and took 6000 ns to execute</span><br><span class="line">[60363.153610] inet_release returned 0 and took 9060 ns to execute</span><br><span class="line">[60363.153820] inet_release returned 0 and took 3220 ns to execute</span><br><span class="line">[60363.154699] inet_release returned 0 and took 3260 ns to execute</span><br><span class="line">[60363.159178] inet_release returned 0 and took 3200 ns to execute</span><br><span class="line">[60363.180098] inet_release returned 0 and took 3080 ns to execute</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自:&lt;a href=&quot;https://kernel.love/kprobe.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://kernel.love/kprobe.html&lt;/a&gt;
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第34期</title>
    <link href="http://liujunming.github.io/2023/06/10/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC34%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2023/06/10/每周分享第34期/</id>
    <published>2023-06-10T08:34:02.000Z</published>
    <updated>2023-06-25T11:58:28.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="X86-S"><a href="#X86-S" class="headerlink" title="X86-S"></a>X86-S</h3><p>A 64-bit mode-only architecture removes some older appendages of the architecture, reducing the overall complexity of the software and hardware architecture. </p><p><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/envisioning-future-simplified-architecture.html" target="_blank" rel="noopener">Envisioning a Simplified Intel Architecture</a><a id="more"></a> </p><p><a href="https://mp.weixin.qq.com/s/iZDb1l5I3OMFsMpmEvLjrw" target="_blank" rel="noopener">英特尔颠覆性的纯64位CPU架构x86s是什么？会有哪些影响？</a></p><p><a href="https://mp.weixin.qq.com/s/O0_nc55vqSZ510YTd-JvUw" target="_blank" rel="noopener">X86指令集的未来</a></p><h3 id="从网络到-AI：我的一点思考"><a href="#从网络到-AI：我的一点思考" class="headerlink" title="从网络到 AI：我的一点思考"></a>从网络到 AI：我的一点思考</h3><p><a href="https://bojieli.com/2023/04/from-networking-to-ai/" target="_blank" rel="noopener">https://bojieli.com/2023/04/from-networking-to-ai/</a></p><h3 id="Mac操作系统进化史"><a href="#Mac操作系统进化史" class="headerlink" title="Mac操作系统进化史"></a>Mac操作系统进化史</h3><p><a href="https://mp.weixin.qq.com/s/PFsR13qDZM3cw3lFpGKFhg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PFsR13qDZM3cw3lFpGKFhg</a></p><h3 id="Linux-Perf-底层数据收集机制概述"><a href="#Linux-Perf-底层数据收集机制概述" class="headerlink" title="Linux  Perf 底层数据收集机制概述"></a>Linux  Perf 底层数据收集机制概述</h3><p><a href="https://www.bilibili.com/video/BV1sW4y1X7QE/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1sW4y1X7QE/</a></p><h3 id="MMU-notifier"><a href="#MMU-notifier" class="headerlink" title="MMU notifier"></a>MMU notifier</h3><p><a href="http://www.biscuitos.cn/blog/Human-Knowledge-Common/#H000012" target="_blank" rel="noopener">http://www.biscuitos.cn/blog/Human-Knowledge-Common/#H000012</a></p><h3 id="Systems-Architecture-Video"><a href="#Systems-Architecture-Video" class="headerlink" title="Systems Architecture Video"></a>Systems Architecture Video</h3><p><a href="https://www.youtube.com/channel/UCPSsA8oxlSBjidJsSPdpjsQ/playlists" target="_blank" rel="noopener">https://www.youtube.com/channel/UCPSsA8oxlSBjidJsSPdpjsQ/playlists</a></p><h3 id="Posted-write"><a href="#Posted-write" class="headerlink" title="Posted write"></a>Posted write</h3><p>A posted write is a computer bus write transaction that does not wait for a write completion response to indicate success or failure of the write transaction.</p><h3 id="如何选择开源许可证"><a href="#如何选择开源许可证" class="headerlink" title="如何选择开源许可证"></a>如何选择开源许可证</h3><p><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</a></p><h3 id="Linux-LFS"><a href="#Linux-LFS" class="headerlink" title="Linux LFS"></a>Linux LFS</h3><p>Linux From Scratch (LFS) is a project that provides you with step-by-step instructions for building your own custom Linux system, entirely from source code.<br><a href="https://www.linuxfromscratch.org/" target="_blank" rel="noopener">https://www.linuxfromscratch.org/</a></p><h3 id="NVMe-VFIO-Live-Migration-for-IPU-DPU-Devices"><a href="#NVMe-VFIO-Live-Migration-for-IPU-DPU-Devices" class="headerlink" title="NVMe VFIO Live Migration for IPU/DPU Devices"></a>NVMe VFIO Live Migration for IPU/DPU Devices</h3><p><a href="https://mp.weixin.qq.com/s/GnN06H864XuXU41-jFH4jA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GnN06H864XuXU41-jFH4jA</a></p><h3 id="OOB"><a href="#OOB" class="headerlink" title="OOB"></a>OOB</h3><p>所谓“带外”，指的区别于数据传输通道的另外一条传输通道。</p><p><a href="https://en.wiktionary.org/wiki/out-of-band" target="_blank" rel="noopener">https://en.wiktionary.org/wiki/out-of-band</a><br>Relating to communication on a different channel, or by a different method, from that of the primary communication channel.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;X86-S&quot;&gt;&lt;a href=&quot;#X86-S&quot; class=&quot;headerlink&quot; title=&quot;X86-S&quot;&gt;&lt;/a&gt;X86-S&lt;/h3&gt;&lt;p&gt;A 64-bit mode-only architecture removes some older appendages of the architecture, reducing the overall complexity of the software and hardware architecture. &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.intel.com/content/www/us/en/developer/articles/technical/envisioning-future-simplified-architecture.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Envisioning a Simplified Intel Architecture&lt;/a&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解virtio-balloon</title>
    <link href="http://liujunming.github.io/2023/06/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3virtio-balloon/"/>
    <id>http://liujunming.github.io/2023/06/03/深入理解virtio-balloon/</id>
    <published>2023-06-03T11:46:04.000Z</published>
    <updated>2023-06-03T14:42:07.433Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2023/06/02.jpg" alt><br>本文将结合virtio spec、qemu与Linux kernel源码深入解析virtio-balloon的原理与实现。<a id="more"></a> </p><p>本文参考的virtio spec是<a href="https://ozlabs.org/~rusty/virtio-spec/virtio-0.9.5.pdf" target="_blank" rel="noopener">0.9.5</a>，qemu版本为<a href="https://gitlab.com/qemu-project/qemu/-/tree/v2.6.0" target="_blank" rel="noopener">v2.6.0</a>，Linux kernel版本为<a href="https://elixir.bootlin.com/linux/v4.19/source" target="_blank" rel="noopener">v4.19</a>。</p><p>为了简单起见，本文只介绍virtio-balloon的inflate操作，deflate、Memory Statistics就不赘述了。</p><p>本文考虑的场景:guest原先的内存为4096M，现在希望利用virtio-balloon，从guest内回收20M内存。</p><h3 id="在hmp中设置内存"><a href="#在hmp中设置内存" class="headerlink" title="在hmp中设置内存"></a>在hmp中设置内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ETEXI</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        .name       = <span class="string">"balloon"</span>,</span><br><span class="line">        .args_type  = <span class="string">"value:M"</span>,</span><br><span class="line">        .params     = <span class="string">"target"</span>,</span><br><span class="line">        .help       = <span class="string">"request VM to change its memory allocation (in MB)"</span>,</span><br><span class="line">        .mhandler.cmd = hmp_balloon,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">STEXI</span><br><span class="line">@item balloon @var&#123;value&#125;</span><br><span class="line">@findex balloon</span><br><span class="line">Request VM to change its memory allocation to @var&#123;value&#125; (in MB).</span><br></pre></td></tr></table></figure><p>在QEMU的hmp中执行<code>balloon 4076</code>，将guest的内存设置为4076M(4096-20)。此时会触发virtio-balloon设备的cofiguration change interrupt。</p><h3 id="cofiguration-change-interrupt"><a href="#cofiguration-change-interrupt" class="headerlink" title="cofiguration change interrupt"></a>cofiguration change interrupt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QEMU</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtio_balloon_to_target</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">ram_addr_t</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VirtIOBalloon *dev = VIRTIO_BALLOON(opaque);</span><br><span class="line">    VirtIODevice *vdev = VIRTIO_DEVICE(dev);</span><br><span class="line">    <span class="keyword">ram_addr_t</span> vm_ram_size = get_current_ram_size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target &gt; vm_ram_size) &#123;</span><br><span class="line">        target = vm_ram_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        dev-&gt;num_pages = (vm_ram_size - target) &gt;&gt; VIRTIO_BALLOON_PFN_SHIFT;</span><br><span class="line">        virtio_notify_config(vdev);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dev-&gt;num_pages</code>记录了Number of pages host wants Guest to give up。<code>virtio_notify_config</code>会给guest发送cofiguration change interrupt。<br>guest cofiguration change interrupt的handler是<code>virtballoon_changed</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// guest driver</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtballoon_changed</span><span class="params">(struct virtio_device *vdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_balloon</span> *<span class="title">vb</span> = <span class="title">vdev</span>-&gt;<span class="title">priv</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;vb-&gt;stop_update_lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (!vb-&gt;stop_update)</span><br><span class="line">        queue_work(system_freezable_wq, &amp;vb-&gt;update_balloon_size_work);</span><br><span class="line">    spin_unlock_irqrestore(&amp;vb-&gt;stop_update_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>vb-&gt;update_balloon_size_work</code>就是<code>update_balloon_size_func</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// guest driver</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_balloon_size_func</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_balloon</span> *<span class="title">vb</span>;</span></span><br><span class="line">    s64 diff;</span><br><span class="line"></span><br><span class="line">    vb = container_of(work, struct virtio_balloon,</span><br><span class="line">              update_balloon_size_work);</span><br><span class="line">    diff = towards_target(vb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">        diff -= fill_balloon(vb, diff);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">        diff += leak_balloon(vb, -diff);</span><br><span class="line">    update_balloon_size(vb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff)</span><br><span class="line">        queue_work(system_freezable_wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="guest-inflate"><a href="#guest-inflate" class="headerlink" title="guest inflate"></a>guest inflate</h3><p>首先思考下这个问题，guest怎么知道要inflate的呢？<br><code>update_balloon_size_func</code>会调用<code>towards_target</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// guest driver</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> s64 <span class="title">towards_target</span><span class="params">(struct virtio_balloon *vb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s64 target;</span><br><span class="line">    u32 num_pages;</span><br><span class="line"></span><br><span class="line">    virtio_cread(vb-&gt;vdev, struct virtio_balloon_config, num_pages,</span><br><span class="line">             &amp;num_pages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Legacy balloon config space is LE, unlike all other devices. */</span></span><br><span class="line">    <span class="keyword">if</span> (!virtio_has_feature(vb-&gt;vdev, VIRTIO_F_VERSION_1))</span><br><span class="line">        num_pages = le32_to_cpu((__force __le32)num_pages);</span><br><span class="line"></span><br><span class="line">    target = num_pages;</span><br><span class="line">    <span class="keyword">return</span> target - vb-&gt;num_pages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>towards_target</code>会读取<code>virtio_balloon_config</code>中的<code>num_pages</code>寄存器。<br><img src="/images/2023/06/04.jpg" alt><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_balloon_config</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Number of pages host wants Guest to give up. */</span></span><br><span class="line">    __u32 num_pages;</span><br><span class="line">    <span class="comment">/* Number of pages we've actually got in balloon. */</span></span><br><span class="line">    __u32 actual;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>因为<code>num_pages</code>位于PIO BAR0中，因此会发生VM Exit，QEMU的<code>virtio_balloon_get_config</code>最终会模拟<code>num_pages</code>寄存器的读。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QEMU</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtio_balloon_get_config</span><span class="params">(VirtIODevice *vdev, <span class="keyword">uint8_t</span> *config_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VirtIOBalloon *dev = VIRTIO_BALLOON(vdev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_balloon_config</span> <span class="title">config</span>;</span></span><br><span class="line"></span><br><span class="line">    config.num_pages = cpu_to_le32(dev-&gt;num_pages);</span><br><span class="line">    config.actual = cpu_to_le32(dev-&gt;actual);</span><br><span class="line"></span><br><span class="line">    trace_virtio_balloon_get_config(config.num_pages, config.actual);</span><br><span class="line">    <span class="built_in">memcpy</span>(config_data, &amp;config, <span class="keyword">sizeof</span>(struct virtio_balloon_config));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终guest看到的<code>num_pages</code>寄存器的值就是<code>dev-&gt;num_pages</code>，即为Number of pages host wants Guest to give up。</p><p><code>towards_target</code>中<code>vb-&gt;num_pages</code>的含义为Number of balloon pages guest has told the Host it’s not using. 在我们考虑的场景中，<code>vb-&gt;num_pages</code>为0(初始值)，此时<code>towards_target</code>返回的值为20 * （2MB/4KB）= 10K。因此<code>update_balloon_size_func</code>中的<code>diff</code>变量大于0，此时会调用<code>fill_balloon</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fill_balloon</span><br><span class="line">├── balloon_page_enqueue</span><br><span class="line">└── tell_host</span><br><span class="line">    ├── virtqueue_add_outbuf</span><br><span class="line">    └── virtqueue_kick</span><br></pre></td></tr></table></figure><p><code>balloon_page_enqueue</code>函数是guest os实现的回收unused pages的功能,与本文关系不大，这里就不继续往下追了。<code>virtqueue_add_outbuf</code>会往descs中填充pages的GFN(Guest Frame Number)，并更新avail ring，最后<code>virtqueue_kick</code>会写kick寄存器来通知QEMU回收内存。</p><h3 id="QEMU回收内存"><a href="#QEMU回收内存" class="headerlink" title="QEMU回收内存"></a>QEMU回收内存</h3><p><img src="/images/2023/06/01.jpg" alt></p><p>guest driver调用<code>virtqueue_kick</code>后，QEMU最终会调用<code>virtio_balloon_handle_output</code>来回收内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtio_balloon_handle_output</span><span class="params">(VirtIODevice *vdev, VirtQueue *vq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);</span><br><span class="line">    VirtQueueElement *elem;</span><br><span class="line">    MemoryRegionSection section;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> pfn;</span><br><span class="line">        elem = virtqueue_pop(vq, <span class="keyword">sizeof</span>(VirtQueueElement));</span><br><span class="line">        <span class="keyword">if</span> (!elem) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iov_to_buf(elem-&gt;out_sg, elem-&gt;out_num, offset, &amp;pfn, <span class="number">4</span>) == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">ram_addr_t</span> pa;</span><br><span class="line">            <span class="keyword">ram_addr_t</span> addr;</span><br><span class="line">            <span class="keyword">int</span> p = virtio_ldl_p(vdev, &amp;pfn);</span><br><span class="line"></span><br><span class="line">            pa = (<span class="keyword">ram_addr_t</span>) p &lt;&lt; VIRTIO_BALLOON_PFN_SHIFT;</span><br><span class="line">            offset += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            section = memory_region_find(get_system_memory(), pa, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!int128_nz(section.size) || !memory_region_is_ram(section.mr))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            trace_virtio_balloon_handle_output(memory_region_name(section.mr),</span><br><span class="line">                                               pa);</span><br><span class="line">            <span class="comment">/* Using memory_region_get_ram_ptr is bending the rules a bit, but</span></span><br><span class="line"><span class="comment">               should be OK because we only want a single page.  */</span></span><br><span class="line">            addr = section.offset_within_region;</span><br><span class="line">            balloon_page(memory_region_get_ram_ptr(section.mr) + addr,</span><br><span class="line">                         !!(vq == s-&gt;dvq));</span><br><span class="line">            memory_region_unref(section.mr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        virtqueue_push(vq, elem, offset);</span><br><span class="line">        virtio_notify(vdev, vq);</span><br><span class="line">        g_free(elem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>virtqueue_pop</code>会读取avail ring，从descs中获取要回收pages的GFN，然后进行内存的回收，回收完毕后，<code>virtqueue_push</code>会更新used ring，最后<code>virtio_notify</code>会发送inflateq的中断。</p><h3 id="guest-inflateq-handler"><a href="#guest-inflateq-handler" class="headerlink" title="guest inflateq handler"></a>guest inflateq handler</h3><p>guest inflateq handler是<code>balloon_ack</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">balloon_ack</span><span class="params">(struct virtqueue *vq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_balloon</span> *<span class="title">vb</span> = <span class="title">vq</span>-&gt;<span class="title">vdev</span>-&gt;<span class="title">priv</span>;</span></span><br><span class="line"></span><br><span class="line">    wake_up(&amp;vb-&gt;acked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>guest在<code>tell_host</code>中注册了<code>virtqueue_get_buf</code> callback，最终<code>balloon_ack</code>的结果就是读取inflateq的used ring，回收descs。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell_host</span><span class="params">(struct virtio_balloon *vb, struct virtqueue *vq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* When host has read buffer, this completes via balloon_ack */</span></span><br><span class="line">    wait_event(vb-&gt;acked, virtqueue_get_buf(vq, &amp;len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="guest-updates-balloon-size"><a href="#guest-updates-balloon-size" class="headerlink" title="guest updates balloon size"></a>guest updates balloon size</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update_balloon_size_func</span><br><span class="line">├── fill_balloon</span><br><span class="line">└── update_balloon_size</span><br></pre></td></tr></table></figure><p><code>update_balloon_size_func</code>在调用完<code>fill_balloon</code>来回收内存后，guest driver会调用<code>update_balloon_size</code>来通知QEMU Number of pages it’s actually got in balloon。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_balloon_size</span><span class="params">(struct virtio_balloon *vb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u32 actual = vb-&gt;num_pages;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Legacy balloon config space is LE, unlike all other devices. */</span></span><br><span class="line">    <span class="keyword">if</span> (!virtio_has_feature(vb-&gt;vdev, VIRTIO_F_VERSION_1))</span><br><span class="line">        actual = (__force u32)cpu_to_le32(actual);</span><br><span class="line"></span><br><span class="line">    virtio_cwrite(vb-&gt;vdev, struct virtio_balloon_config, actual,</span><br><span class="line">              &amp;actual);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>guest最终会将<code>vb-&gt;num_pages</code>(在<code>fill_balloon</code>中会确定<code>vb-&gt;num_pages</code>的值)写到<code>virtio_balloon_config</code>中的<code>actual</code>寄存器来通知QEMU。<br><img src="/images/2023/06/06.jpg" alt><br>QEMU最终会调用<code>virtio_balloon_set_config</code>，将guest写入的<code>vb-&gt;num_pages</code>值记录到<code>dev-&gt;actual</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtio_balloon_set_config</span><span class="params">(VirtIODevice *vdev,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="keyword">uint8_t</span> *config_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VirtIOBalloon *dev = VIRTIO_BALLOON(vdev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_balloon_config</span> <span class="title">config</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> oldactual = dev-&gt;actual;</span><br><span class="line">    <span class="keyword">ram_addr_t</span> vm_ram_size = get_current_ram_size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;config, config_data, <span class="keyword">sizeof</span>(struct virtio_balloon_config));</span><br><span class="line">    dev-&gt;actual = le32_to_cpu(config.actual);</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;actual != oldactual) &#123;</span><br><span class="line">        qapi_event_send_balloon_change(vm_ram_size -</span><br><span class="line">                        ((<span class="keyword">ram_addr_t</span>) dev-&gt;actual &lt;&lt; VIRTIO_BALLOON_PFN_SHIFT),</span><br><span class="line">                        &amp;error_abort);</span><br><span class="line">    &#125;</span><br><span class="line">    trace_virtio_balloon_set_config(dev-&gt;actual, oldactual);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/2023/06/03.jpg" alt><br>the descriptor describing the resulting 32-bit array is added to the inflateq中<strong>32-bit array</strong>的含义如下所示:<br><img src="/images/2023/06/05.jpg" alt></p><hr><p>参考资料:</p><ol><li><a href="http://ssdxiao.github.io/linux/2017/03/20/Virtio-Balloon.html" target="_blank" rel="noopener">Virtio-Balloon超详细分析</a></li><li><a href="https://static.sched.com/hosted_files/kvmforum2020/51/The%20Practice%20Method%20to%20Speed%20Up%2010x%20Boot-up%20Time%20for%20Guest%20in%20Alibaba%20Cloud.pdf" target="_blank" rel="noopener">Speed Up Boot-up Time for Guest in Alibaba Cloud</a></li><li><a href="https://hhb584520.github.io/kvm_blog/2017/04/14/kvm-overcommit.html" target="_blank" rel="noopener">内存过载使用</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2023/06/02.jpg&quot; alt&gt;&lt;br&gt;本文将结合virtio spec、qemu与Linux kernel源码深入解析virtio-balloon的原理与实现。
    
    </summary>
    
      <category term="virtio" scheme="http://liujunming.github.io/categories/virtio/"/>
    
    
      <category term="virtio" scheme="http://liujunming.github.io/tags/virtio/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Linux swiotlb技术</title>
    <link href="http://liujunming.github.io/2023/05/28/Notes-about-Linux-swiotlb%E6%8A%80%E6%9C%AF/"/>
    <id>http://liujunming.github.io/2023/05/28/Notes-about-Linux-swiotlb技术/</id>
    <published>2023-05-28T06:18:14.000Z</published>
    <updated>2023-05-28T07:47:44.247Z</updated>
    
    <content type="html"><![CDATA[<p>本文将总结下Linux swiotlb技术。<a id="more"></a></p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><img src="/images/2023/05/52.jpg" alt></p><h3 id="2-bounce-buffer"><a href="#2-bounce-buffer" class="headerlink" title="2. bounce buffer"></a>2. bounce buffer</h3><p><img src="/images/2023/05/53.jpg" alt><br>If the requested DMA operation is a DMA read (the device reads from memory DMA_TO_DEVICE), the data is copied from the original buffer to the bounce buffer, and the adapter reads it from the bounce buffer’s memory location. If the requested DMA operation is a write, the data is written(the device writes to memory DMA_FROM_DEVICE) by the adapter to the bounce buffer, and then copied to the original buffer.</p><p><img src="/images/2023/05/54.jpg" alt><br><img src="/images/2023/05/55.jpg" alt></p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>理解mmap时、同步时、unmap时的内存copy即可。<br>为了简单起见，只讨论DMA_FROM_DEVICE与DMA_TO_DEVICE这两个case。</p><ol><li>mmap时，建立原始物理地址与swiotlb buffer的映射，对于DMA_TO_DEVICE，需要将数据从原始物理地址处拷贝到swiotlb buffer</li><li>当设备往swiotlb buffer写入后，driver CPU需要读DMA内存时，需要sync下，将数据从swiotlb buffer拷贝到原始物理地址处</li><li>driver CPU更改原始物理地址内存，当需要DMA_TO_DEVICE时，需要sync下，将数据从原始物理地址处拷贝到swiotlb buffer</li><li>unmap时，解除原始物理地址与swiotlb buffer的映射，对于DMA_FROM_DEVICE，需要将数据从swiotlb buffer拷贝到原始物理地址处</li></ol><hr><p>参考资料:</p><ol><li><a href="https://research.ibm.com/haifa/dept/stt/pubs/utilizing-iommus-ols06.pdf" target="_blank" rel="noopener">Utilizing IOMMUs for Virtualization in Linux and Xen</a></li><li><a href="https://blog.csdn.net/liuhangtiant/article/details/87825466" target="_blank" rel="noopener">Linux swiotlb技术解析</a></li><li><a href="https://blog.csdn.net/qq_34719392/article/details/114873284" target="_blank" rel="noopener">Linux x86-64 IOMMU详解（二）——SWIOTLB（软件IOMMU）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将总结下Linux swiotlb技术。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Linux NAPI</title>
    <link href="http://liujunming.github.io/2023/05/28/Notes-about-Linux-NAPI/"/>
    <id>http://liujunming.github.io/2023/05/28/Notes-about-Linux-NAPI/</id>
    <published>2023-05-28T03:48:45.000Z</published>
    <updated>2023-05-28T04:55:05.588Z</updated>
    
    <content type="html"><![CDATA[<p>本文将学习下Linux网络收包的NAPI机制。<a id="more"></a></p><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>NAPI (“new API,” though it is not so new anymore) is an interrupt mitigation mechanism used with network devices. </p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><blockquote><p>随着网络带宽的发展，网速越来越快，之前的中断收包模式已经无法适应目前千兆，万兆的带宽了。如果每个数据包大小等于MTU大小(1460字节)。当驱动以千兆网速收包时，CPU将每秒被中断91829次。过多的中断会引起一个问题，CPU一直陷入硬中断而没有时间来处理别的事情了。为了解决这个问题，内核引入了NAPI机制。</p></blockquote><blockquote><p>NAPI就是混合中断和轮询的方式来收包，当有中断来了，驱动关闭中断，通知内核收包，内核软中断轮询当前网卡，在规定时间尽可能多的收包。时间用尽或者没有数据可收，内核再次开启中断，准备下一次收包。</p></blockquote><p>When network traffic is heavy, the kernel can safely predict that incoming packets will be available anytime it gets around to looking, so there is no need to have the adapter interrupting it (possibly thousands of times per second) to tell it about those packets. So a NAPI-compliant driver will turn off the packet receive interrupt and provide a <code>poll()</code> method to the kernel. When the kernel is ready to deal with more packets, <code>poll()</code> will be called with a maximum number of packets it is allowed to feed into the kernel; it should process up to that many packets and quit.</p><h3 id="Full-Picture"><a href="#Full-Picture" class="headerlink" title="Full Picture"></a>Full Picture</h3><p><img src="/images/2023/05/51.png" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/2023/05/50.jpg" alt></p><hr><p>参考资料:</p><ol><li><a href="https://lwn.net/Articles/214457/" target="_blank" rel="noopener">Reworking NAPI</a></li><li><a href="https://lwn.net/Articles/244640/" target="_blank" rel="noopener">Newer, newer NAPI</a></li><li><a href="https://docs.kernel.org/networking/napi.html" target="_blank" rel="noopener">NAPI</a></li><li><a href="https://blog.csdn.net/Rong_Toa/article/details/109401935" target="_blank" rel="noopener">Linux网络协议栈：NAPI机制与处理流程分析（图解）</a></li><li><a href="https://zhuanlan.zhihu.com/p/610334133" target="_blank" rel="noopener">NAPI 内核机制与驱动实现</a></li><li><a href="https://wenfh2020.com/2021/12/29/kernel-tcp-receive/" target="_blank" rel="noopener">Linux 网络数据接收流程（TCP）- NAPI</a></li><li><a href="https://access.redhat.com/sites/default/files/attachments/20150325_network_performance_tuning.pdf" target="_blank" rel="noopener">Red Hat Enterprise Linux Network Performance Tuning Guide</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将学习下Linux网络收包的NAPI机制。
    
    </summary>
    
      <category term="计算机网络" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="计算机网络" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Notes about SMAP and SMEP</title>
    <link href="http://liujunming.github.io/2023/05/27/Notes-about-SMAP-and-SMEP/"/>
    <id>http://liujunming.github.io/2023/05/27/Notes-about-SMAP-and-SMEP/</id>
    <published>2023-05-27T07:54:33.000Z</published>
    <updated>2023-05-27T10:16:36.435Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark下SMAP(Supervisor Memory Access Protection) and SMEP(Supervisor Memory Execute Protection)相关notes，参考kernel版本为<a href="https://elixir.bootlin.com/linux/v6.3/source" target="_blank" rel="noopener">v6.3</a>。<a id="more"></a></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>SMEP prevents the kernel running in ring 0 from executing code which is user accessible. SMAP prevents the kernel from accessing userspace memory while the AC flag in the RFLAGS register is clear. These features can help harden the kernel against exploitation and prevent certain kinds of memory corruption.</p><h3 id="Description-from-SDM"><a href="#Description-from-SDM" class="headerlink" title="Description from SDM"></a>Description from SDM</h3><p><img src="/images/2023/05/45.jpg" alt><br><img src="/images/2023/05/46.jpg" alt><br><img src="/images/2023/05/47.jpg" alt></p><p><img src="/images/2023/05/48.jpg" alt><br><img src="/images/2023/05/49.jpg" alt></p><h3 id="copy-to-user"><a href="#copy-to-user" class="headerlink" title="copy_to_user"></a>copy_to_user</h3><p>由于内核空间与用户空间的内存不能直接互访，因此需要借助内核函数<code>copy_to_user</code>完成内核空间到用户空间的复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * igb_ptp_get_ts_config - get hardware time stamping config</span></span><br><span class="line"><span class="comment"> * @netdev: netdev struct</span></span><br><span class="line"><span class="comment"> * @ifr: interface struct</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Get the hwtstamp_config settings to return to the user. Rather than attempt</span></span><br><span class="line"><span class="comment"> * to deconstruct the settings from the registers, just return a shadow copy</span></span><br><span class="line"><span class="comment"> * of the last known settings.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">igb_ptp_get_ts_config</span><span class="params">(struct net_device *netdev, struct ifreq *ifr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">igb_adapter</span> *<span class="title">adapter</span> = <span class="title">netdev_priv</span>(<span class="title">netdev</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hwtstamp_config</span> *<span class="title">config</span> = &amp;<span class="title">adapter</span>-&gt;<span class="title">tstamp_config</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copy_to_user(ifr-&gt;ifr_data, config, <span class="keyword">sizeof</span>(*config)) ?</span><br><span class="line">        -EFAULT : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">copy_to_user</span><br><span class="line">└── _copy_to_user</span><br><span class="line">    └── raw_copy_to_user</span><br><span class="line">        └── copy_user_generic</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline __must_check <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">copy_user_generic(<span class="keyword">void</span> *to, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">unsigned</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If CPU has ERMS feature, use copy_user_enhanced_fast_string.</span></span><br><span class="line"><span class="comment">     * Otherwise, if CPU has rep_good feature, use copy_user_generic_string.</span></span><br><span class="line"><span class="comment">     * Otherwise, use copy_user_generic_unrolled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    alternative_call_2(copy_user_generic_unrolled,</span><br><span class="line">             copy_user_generic_string,</span><br><span class="line">             X86_FEATURE_REP_GOOD,</span><br><span class="line">             copy_user_enhanced_fast_string,</span><br><span class="line">             X86_FEATURE_ERMS,</span><br><span class="line">             ASM_OUTPUT2(<span class="string">"=a"</span> (ret), <span class="string">"=D"</span> (to), <span class="string">"=S"</span> (from),</span><br><span class="line">                     <span class="string">"=d"</span> (len)),</span><br><span class="line">             <span class="string">"1"</span> (to), <span class="string">"2"</span> (from), <span class="string">"3"</span> (len)</span><br><span class="line">             : <span class="string">"memory"</span>, <span class="string">"rcx"</span>, <span class="string">"r8"</span>, <span class="string">"r9"</span>, <span class="string">"r10"</span>, <span class="string">"r11"</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SYM_FUNC_START(copy_user_generic_string)</span><br><span class="line">    ASM_STAC</span><br><span class="line">    cmpl $<span class="number">8</span>,%edx</span><br><span class="line">    jb <span class="number">2f</span>       <span class="comment">/* less than 8 bytes, go to byte copy loop */</span></span><br><span class="line">    ALIGN_DESTINATION</span><br><span class="line">    movl %edx,%ecx</span><br><span class="line">    shrl $<span class="number">3</span>,%ecx</span><br><span class="line">    andl $<span class="number">7</span>,%edx</span><br><span class="line"><span class="number">1</span>:  rep movsq</span><br><span class="line"><span class="number">2</span>:  movl %edx,%ecx</span><br><span class="line"><span class="number">3</span>:  rep movsb</span><br><span class="line">    xorl %eax,%eax</span><br><span class="line">    ASM_CLAC</span><br><span class="line">    RET</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>: leal (%rdx,%rcx,<span class="number">8</span>),%ecx</span><br><span class="line"><span class="number">12</span>: movl %ecx,%edx      <span class="comment">/* ecx is zerorest also */</span></span><br><span class="line">    jmp .Lcopy_user_handle_tail</span><br><span class="line"></span><br><span class="line">    _ASM_EXTABLE_CPY(<span class="number">1b</span>, <span class="number">11b</span>)</span><br><span class="line">    _ASM_EXTABLE_CPY(<span class="number">3b</span>, <span class="number">12b</span>)</span><br><span class="line">SYM_FUNC_END(copy_user_generic_string)</span><br><span class="line">EXPORT_SYMBOL(copy_user_generic_string)</span><br></pre></td></tr></table></figure><p>从copy_user_generic_string的第2行可知，在内核态往用户态复制内存前，需要运行<code>STAC</code>指令；从第13行可知，在内核态往用户态复制内存后，需要运行<code>CLAC</code>指令。</p><hr><p>参考资料:</p><ol><li><a href="https://wiki.osdev.org/Supervisor_Memory_Protection" target="_blank" rel="noopener">Supervisor Memory Protection</a></li><li><a href="https://lore.kernel.org/all/1348256595-29119-9-git-send-email-hpa@linux.intel.com/" target="_blank" rel="noopener">x86, smap: Add STAC and CLAC instructions to control user space access</a></li><li><a href="https://blog.csdn.net/Haomione/article/details/122217131" target="_blank" rel="noopener">copy_to_user/copy_from_user参数解析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark下SMAP(Supervisor Memory Access Protection) and SMEP(Supervisor Memory Execute Protection)相关notes，参考kernel版本为&lt;a href=&quot;https://elixir.bootlin.com/linux/v6.3/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v6.3&lt;/a&gt;。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Notes about iommu=pt kernel parameter</title>
    <link href="http://liujunming.github.io/2023/05/21/Notes-about-iommu-pt-kernel-parameter/"/>
    <id>http://liujunming.github.io/2023/05/21/Notes-about-iommu-pt-kernel-parameter/</id>
    <published>2023-05-21T07:22:58.000Z</published>
    <updated>2023-05-21T13:02:58.896Z</updated>
    
    <content type="html"><![CDATA[<p>当使用KVM pass-thru设备时，通常会设置<code>intel_iommu=on iommu=pt</code>内核参数，其中<code>intel_iommu=on</code>就是使能intel iommu，本文将介绍<code>iommu=pt</code>。<a id="more"></a></p><p>本文参考的内核版本是<a href="https://elixir.bootlin.com/linux/v5.0/source" target="_blank" rel="noopener">v5.0</a>。</p><p>identity mapping指的是iova与hpa 1:1映射。</p><h2 id="1-Motivation"><a href="#1-Motivation" class="headerlink" title="1. Motivation"></a>1. Motivation</h2><p>The <code>pt</code> option only enables IOMMU translation for devices used in pass-thru ,doesn’t enable IOMMU translation for host used devices ,and this will improve performance for host PCIe devices (which are not pass-thru to a VM).</p><p>内核的注释：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This variable becomes 1 if iommu=pt is passed on the kernel command line.</span></span><br><span class="line"><span class="comment"> * If this variable is 1, IOMMU implementations do no DMA translation for</span></span><br><span class="line"><span class="comment"> * devices and allow every device to access to whole physical memory. This is</span></span><br><span class="line"><span class="comment"> * useful if a user wants to use an IOMMU only for KVM device assignment to</span></span><br><span class="line"><span class="comment"> * guests and not for driver dma translation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> iommu_pass_through __read_mostly = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h2><h3 id="2-1-pt-option解析"><a href="#2-1-pt-option解析" class="headerlink" title="2.1 pt option解析"></a>2.1 <code>pt</code> option解析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __<span class="function">init <span class="keyword">int</span> <span class="title">iommu_setup</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(p, <span class="string">"pt"</span>, <span class="number">2</span>))</span><br><span class="line">        iommu_pass_through = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-init-dmars"><a href="#2-2-init-dmars" class="headerlink" title="2.2 init_dmars"></a>2.2 init_dmars</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDENTMAP_ALL        1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This domain is a statically identity mapping domain.</span></span><br><span class="line"><span class="comment"> *  1. This domain creats a static 1:1 mapping to all usable memory.</span></span><br><span class="line"><span class="comment"> *  2. It maps to each iommu if successful.</span></span><br><span class="line"><span class="comment"> *  3. Each iommu maps to this domain if successful.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dmar_domain</span> *<span class="title">si_domain</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> hw_pass_through = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_dmars</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!ecap_pass_through(iommu-&gt;ecap))</span><br><span class="line">        hw_pass_through = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (iommu_pass_through)</span><br><span class="line">        iommu_identity_mapping |= IDENTMAP_ALL;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (iommu_identity_mapping) &#123;</span><br><span class="line">        ret = si_domain_init(hw_pass_through);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> free_iommu;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (iommu_identity_mapping) &#123;</span><br><span class="line">        ret = iommu_prepare_static_identity_mapping(hw_pass_through);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            pr_crit(<span class="string">"Failed to setup IOMMU pass-through\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> free_iommu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#define ecap_pass_through(e)    ((e &gt;&gt; 6) &amp; 0x1)</code></p><p><code>ecap_pass_through(iommu-&gt;ecap)</code>的含义是检查Extended Capability Register的<code>PT</code> field。<br><img src="/images/2023/05/43.jpg" alt><br>如果Hardware supports pass-through translation type,那么<code>hw_pass_through</code>为1；否则<code>hw_pass_through</code>为0。</p><p>当<code>iommu_pass_through</code>被设置时，<code>iommu_identity_mapping</code>也会被设置。接着会依次调用<code>si_domain_init</code>与<code>iommu_prepare_static_identity_mapping</code>。</p><h3 id="2-3-si-domain-init"><a href="#2-3-si-domain-init" class="headerlink" title="2.3 si_domain_init"></a>2.3 si_domain_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">si_domain_init</span><span class="params">(<span class="keyword">int</span> hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nid, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    si_domain = alloc_domain(DOMAIN_FLAG_STATIC_IDENTITY);</span><br><span class="line">    <span class="keyword">if</span> (!si_domain)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (md_domain_init(si_domain, DEFAULT_DOMAIN_ADDRESS_WIDTH)) &#123;</span><br><span class="line">        domain_exit(si_domain);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">"Identity mapping domain allocated\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hw)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    for_each_online_node(nid) &#123; <span class="comment">//迭代所有的活动结点(针对NUMA)</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> start_pfn, end_pfn;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        for_each_mem_pfn_range(i, nid, &amp;start_pfn, &amp;end_pfn, <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ret = iommu_domain_identity_map(si_domain, <span class="comment">//iova与hpa 1:1映射</span></span><br><span class="line">                    PFN_PHYS(start_pfn), PFN_PHYS(end_pfn));</span><br><span class="line">            <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可知，当<code>hw_pass_through</code>为1时，无需建立iova与hpa 1:1映射的iommu页表；否则需要对all usable memory建立iova与hpa 1:1映射的iommu页表。</p><h3 id="2-4-iommu-prepare-static-identity-mapping"><a href="#2-4-iommu-prepare-static-identity-mapping" class="headerlink" title="2.4 iommu_prepare_static_identity_mapping"></a>2.4 iommu_prepare_static_identity_mapping</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iommu_prepare_static_identity_mapping</span><br><span class="line">└── dev_prepare_static_identity_mapping</span><br><span class="line">    └── domain_add_dev_info</span><br><span class="line">        └── dmar_insert_one_dev_info</span><br><span class="line">            └── domain_context_mapping</span><br><span class="line">                └── domain_context_mapping_one</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">domain_context_mapping_one</span><span class="params">(struct dmar_domain *domain,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      struct intel_iommu *iommu,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      u8 bus, u8 devfn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设置translation type 为 pass through</span></span><br><span class="line">    <span class="keyword">if</span> (hw_pass_through &amp;&amp; domain_type_is_si(domain))</span><br><span class="line">        translation = CONTEXT_TT_PASS_THROUGH;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取这个设备在contex table表里面的地址</span></span><br><span class="line">    context = iommu_context_addr(iommu, bus, devfn, <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dma_pte</span> *<span class="title">pgd</span> = <span class="title">domain</span>-&gt;<span class="title">pgd</span>;</span> <span class="comment">// iova页表基址</span></span><br><span class="line">    <span class="keyword">int</span> agaw;</span><br><span class="line"></span><br><span class="line">    context_set_domain_id(context, did);</span><br><span class="line">    <span class="comment">// 设置转换类型</span></span><br><span class="line">    context_set_translation_type(context, translation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面代码可以看出pass through模式不会设置iova页表地址</span></span><br><span class="line">    <span class="keyword">if</span> (translation != CONTEXT_TT_PASS_THROUGH) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 非pass through模式下需要设置iova页表的基地址</span></span><br><span class="line">        context_set_address_root(context, virt_to_phys(pgd));</span><br><span class="line">        context_set_address_width(context, agaw);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * In pass through mode, AW must be programmed to</span></span><br><span class="line"><span class="comment">         * indicate the largest AGAW value supported by</span></span><br><span class="line"><span class="comment">         * hardware. And ASR is ignored by hardware.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        context_set_address_width(context, iommu-&gt;msagaw);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#define CONTEXT_TT_PASS_THROUGH 2</code><br><img src="/images/2023/05/44.jpg" alt><br>因此<code>CONTEXT_TT_PASS_THROUGH</code>为10b，即是2。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>配置了<code>iommu=pt</code>就会实现identity mapping:</p><ul><li>如果Hardware supports pass-through translation type，则配置pass-through translation type即可实现identity mapping，此时无需配置iommu页表;</li><li>如果Hardware doesn’t support pass-through translation type，则需要配置iommu页表，使得iova与hpa 1:1映射。</li></ul><p>当<code>hw_pass_through</code>=0时，依然要走iommu页表，因此性能是不如<code>hw_pass_through</code>=1的。</p><hr><p>参考资料:</p><ol><li><a href="http://blog.chinaunix.net/uid-28541347-id-5868588.html" target="_blank" rel="noopener">iommu passthrough分析</a></li><li>Intel VT-d spec</li><li><a href="https://zhuanlan.zhihu.com/p/365408539" target="_blank" rel="noopener">IOMMU(二)-从配置说起</a></li><li><a href="https://pve.proxmox.com/wiki/PCI_Passthrough#PT_Mode" target="_blank" rel="noopener">PCI_Passthrough PT Mode</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_virtualization/4.1/html/installation_guide/appe-configuring_a_hypervisor_host_for_pci_passthrough" target="_blank" rel="noopener">Configuring a Host for PCI Passthrough</a></li><li><a href="https://mp.weixin.qq.com/s/6OK4e-m_NRn4vdl3p4sbTw" target="_blank" rel="noopener">深入了解iommu系列一：iommu硬件架构和驱动初始化</a></li><li><a href="https://zhuanlan.zhihu.com/p/479963917" target="_blank" rel="noopener">深入了解iommu系列二:iommu 工作原理解析之dma remapping</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当使用KVM pass-thru设备时，通常会设置&lt;code&gt;intel_iommu=on iommu=pt&lt;/code&gt;内核参数，其中&lt;code&gt;intel_iommu=on&lt;/code&gt;就是使能intel iommu，本文将介绍&lt;code&gt;iommu=pt&lt;/code&gt;。
    
    </summary>
    
      <category term="IOMMU" scheme="http://liujunming.github.io/categories/IOMMU/"/>
    
    
      <category term="IOMMU" scheme="http://liujunming.github.io/tags/IOMMU/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Speed Up Boot-up Time for Guest in Alibaba Cloud</title>
    <link href="http://liujunming.github.io/2023/05/14/Notes-about-Speed-Up-Boot-up-Time-for-Guest-in-Alibaba-Cloud/"/>
    <id>http://liujunming.github.io/2023/05/14/Notes-about-Speed-Up-Boot-up-Time-for-Guest-in-Alibaba-Cloud/</id>
    <published>2023-05-14T04:31:55.000Z</published>
    <updated>2023-05-14T10:01:50.931Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about <a href="https://static.sched.com/hosted_files/kvmforum2020/51/The%20Practice%20Method%20to%20Speed%20Up%2010x%20Boot-up%20Time%20for%20Guest%20in%20Alibaba%20Cloud.pdf" target="_blank" rel="noopener">Speed Up Boot-up Time for Guest in Alibaba Cloud</a>。</p><p>Motivation: 当有<a href="/2021/07/29/Notes-about-guest-memory-pinning-when-direct-assignment-of-I-0-devices/">pass-thru设备</a>，虚拟机启动时，需要分配好全部内存;当虚拟机内存较大时，开机时间较长。<br>Idea: 利用气球驱动，guest刚启动时，气球充气，Only map necessary memory first；guest启动后，气球放气，将内存还给guest。这样在guest启动过程中，只需map必要内存，无需map所有内存，即可达到Speed Up Boot-up Time for Guest的目的。<br><a id="more"></a></p><p><img src="/images/2023/05/39.jpg" alt><br><img src="/images/2023/05/40.jpg" alt><br><img src="/images/2023/05/42.jpg" alt><br><img src="/images/2023/05/41.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about &lt;a href=&quot;https://static.sched.com/hosted_files/kvmforum2020/51/The%20Practice%20Method%20to%20Speed%20Up%2010x%20Boot-up%20Time%20for%20Guest%20in%20Alibaba%20Cloud.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Speed Up Boot-up Time for Guest in Alibaba Cloud&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Motivation: 当有&lt;a href=&quot;/2021/07/29/Notes-about-guest-memory-pinning-when-direct-assignment-of-I-0-devices/&quot;&gt;pass-thru设备&lt;/a&gt;，虚拟机启动时，需要分配好全部内存;当虚拟机内存较大时，开机时间较长。&lt;br&gt;Idea: 利用气球驱动，guest刚启动时，气球充气，Only map necessary memory first；guest启动后，气球放气，将内存还给guest。这样在guest启动过程中，只需map必要内存，无需map所有内存，即可达到Speed Up Boot-up Time for Guest的目的。&lt;br&gt;
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Crystal Beach DMA(CBDMA)</title>
    <link href="http://liujunming.github.io/2023/05/14/Notes-about-Crystal-Beach-DMA-CBDMA/"/>
    <id>http://liujunming.github.io/2023/05/14/Notes-about-Crystal-Beach-DMA-CBDMA/</id>
    <published>2023-05-14T03:23:54.000Z</published>
    <updated>2023-05-14T04:16:06.272Z</updated>
    
    <content type="html"><![CDATA[<p>Crystal Beach DMA(CBDMA)其实就是<a href="/2022/03/29/Introduction-to-Intel-I-OAT/#2-Intel®-QuickData-Technology">Intel® QuickData Technology</a>，说白了就是offload memory copy to DMA engine，<a href="/2022/10/23/Notes-about-Intel-Data-Streaming-Accelerator-DSA/">DSA</a>代替了该技术。<a id="more"></a></p><p><img src="/images/2023/05/37.jpg" alt></p><p><img src="/images/2023/05/38.jpg" alt></p><p>FAST ‘23 paper <a href="https://www.usenix.org/conference/fast23/presentation/su" target="_blank" rel="noopener">Revitalizing the Forgotten On-Chip DMA to Expedite Data Movement in NVM-based Storage Systems</a>也是使用了CBDMA来offload memory copy。</p><hr><p>参考资料:</p><ol><li><a href="https://zhuanlan.zhihu.com/p/133489817" target="_blank" rel="noopener">NFV加速利器，CPU中的CBDMA引擎</a></li><li><a href="https://www.dpdk.org/wp-content/uploads/sites/35/2018/12/JiayuHu_Accelerating_paravirtio_with_CBDMA.pdf" target="_blank" rel="noopener">Accelerating Para-Virtual I/O with CBDMA</a></li><li><a href="https://static.sched.com/hosted_files/dpdkbordeaux2019/09/Asynchronous%20CBDMA%20Enqueue%20Framework%20for%20vHost-User.pdf" target="_blank" rel="noopener">Asynchronous CBDMA Enqueue Framework for vHost-User</a></li><li><a href="https://insujang.github.io/2021-04-26/using-intel-ioat-dma/" target="_blank" rel="noopener">Using Intel IOAT DMA</a></li><li><a href="https://www.intel.com/content/www/us/en/wireless-network/accel-technology.html" target="_blank" rel="noopener">Intel® I/O Acceleration Technology</a></li><li><a href="https://www.usenix.org/conference/fast23/presentation/su" target="_blank" rel="noopener">Revitalizing the Forgotten On-Chip DMA to Expedite Data Movement in NVM-based Storage Systems</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Crystal Beach DMA(CBDMA)其实就是&lt;a href=&quot;/2022/03/29/Introduction-to-Intel-I-OAT/#2-Intel®-QuickData-Technology&quot;&gt;Intel® QuickData Technology&lt;/a&gt;，说白了就是offload memory copy to DMA engine，&lt;a href=&quot;/2022/10/23/Notes-about-Intel-Data-Streaming-Accelerator-DSA/&quot;&gt;DSA&lt;/a&gt;代替了该技术。
    
    </summary>
    
      <category term="Intel" scheme="http://liujunming.github.io/categories/Intel/"/>
    
    
      <category term="Intel" scheme="http://liujunming.github.io/tags/Intel/"/>
    
  </entry>
  
  <entry>
    <title>Notes about VT-d Virtual Command Support</title>
    <link href="http://liujunming.github.io/2023/05/13/Notes-about-VT-d-Virtual-Command-Support/"/>
    <id>http://liujunming.github.io/2023/05/13/Notes-about-VT-d-Virtual-Command-Support/</id>
    <published>2023-05-12T23:41:02.000Z</published>
    <updated>2023-05-13T03:45:24.725Z</updated>
    
    <content type="html"><![CDATA[<p>Virtual Command Support (VCS) - Virtual register intended to help support virtualization of the IOMMU. Unlike an SR-IOV device where an entire device is exposed to a guest, the new model creates device instances using PASID. This requires the PASID to be a flat global space which <strong>requires the guest and host PASIDs to be the same</strong>. Only virtual IOMMUs exposed to a guest would enumerate this capability. <strong>It provides an interface to for the host to control allocation of PASIDs in a guest OS</strong>.<a id="more"></a></p><p><img src="/images/2023/05/36.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Virtual command interface for enlightened pasid management. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_CMD_ALLOC          0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_CMD_FREE           0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_VRSP_IP            0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_VRSP_SC(e)         (((e) &amp; 0xff) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_VRSP_SC_SUCCESS        0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_VRSP_SC_NO_PASID_AVAIL 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_VRSP_SC_INVALID_PASID  16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_VRSP_RESULT_PASID(e)   (((e) &gt;&gt; 16) &amp; 0xfffff)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VCMD_CMD_OPERAND(e)     ((e) &lt;&lt; 16)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vcmd_alloc_pasid</span><span class="params">(struct intel_iommu *iommu, u32 *pasid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    u8 status_code;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    u64 res;</span><br><span class="line"></span><br><span class="line">    raw_spin_lock_irqsave(&amp;iommu-&gt;register_lock, flags);</span><br><span class="line">    dmar_writeq(iommu-&gt;reg + DMAR_VCMD_REG, VCMD_CMD_ALLOC);</span><br><span class="line">    IOMMU_WAIT_OP(iommu, DMAR_VCRSP_REG, dmar_readq,</span><br><span class="line">              !(res &amp; VCMD_VRSP_IP), res);</span><br><span class="line">    raw_spin_unlock_irqrestore(&amp;iommu-&gt;register_lock, flags);</span><br><span class="line"></span><br><span class="line">    status_code = VCMD_VRSP_SC(res);</span><br><span class="line">    <span class="keyword">switch</span> (status_code) &#123;</span><br><span class="line">    <span class="keyword">case</span> VCMD_VRSP_SC_SUCCESS:</span><br><span class="line">        *pasid = VCMD_VRSP_RESULT_PASID(res);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VCMD_VRSP_SC_NO_PASID_AVAIL:</span><br><span class="line">        pr_info(<span class="string">"IOMMU: %s: No PASID available\n"</span>, iommu-&gt;name);</span><br><span class="line">        ret = -ENOSPC;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -ENODEV;</span><br><span class="line">        pr_warn(<span class="string">"IOMMU: %s: Unexpected error code %d\n"</span>,</span><br><span class="line">            iommu-&gt;name, status_code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vcmd_free_pasid</span><span class="params">(struct intel_iommu *iommu, u32 pasid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    u8 status_code;</span><br><span class="line">    u64 res;</span><br><span class="line"></span><br><span class="line">    raw_spin_lock_irqsave(&amp;iommu-&gt;register_lock, flags);</span><br><span class="line">    dmar_writeq(iommu-&gt;reg + DMAR_VCMD_REG,</span><br><span class="line">            VCMD_CMD_OPERAND(pasid) | VCMD_CMD_FREE);</span><br><span class="line">    IOMMU_WAIT_OP(iommu, DMAR_VCRSP_REG, dmar_readq,</span><br><span class="line">              !(res &amp; VCMD_VRSP_IP), res);</span><br><span class="line">    raw_spin_unlock_irqrestore(&amp;iommu-&gt;register_lock, flags);</span><br><span class="line"></span><br><span class="line">    status_code = VCMD_VRSP_SC(res);</span><br><span class="line">    <span class="keyword">switch</span> (status_code) &#123;</span><br><span class="line">    <span class="keyword">case</span> VCMD_VRSP_SC_SUCCESS:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VCMD_VRSP_SC_INVALID_PASID:</span><br><span class="line">        pr_info(<span class="string">"IOMMU: %s: Invalid PASID\n"</span>, iommu-&gt;name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        pr_warn(<span class="string">"IOMMU: %s: Unexpected error code %d\n"</span>,</span><br><span class="line">            iommu-&gt;name, status_code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程主要分为如下两个步骤:</p><ol><li><p>guest分配pasid时，写vIOMMU的vcmd寄存器，此时会trap下来，host会将分配好的host paisd传给guest，这样guest与host的pasid就一样了。</p></li><li><p>当guest配置WQ Configuration register(MMIO寄存器)的PASID field时需要trap下来，hypervisor会检查guest的pasid与host的pasid是否一致，如果一致，那么hypervisor会将这个host PASID写入物理WQ Configuration register的PASID field。</p></li></ol><hr><p>参考资料:</p><ol><li><a href="https://01.org/blogs/ashokraj/2018/recent-enhancements-intel-virtualization-technology-directed-i/o-intel-vt-d" target="_blank" rel="noopener">RECENT ENHANCEMENTS IN INTEL® VIRTUALIZATION TECHNOLOGY FOR DIRECTED I/O (INTEL® VT-D)</a></li><li><a href="https://elixir.bootlin.com/linux/v6.3/source" target="_blank" rel="noopener">Linux kernel v6.3</a></li><li>Intel VT-d spec</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Virtual Command Support (VCS) - Virtual register intended to help support virtualization of the IOMMU. Unlike an SR-IOV device where an entire device is exposed to a guest, the new model creates device instances using PASID. This requires the PASID to be a flat global space which &lt;strong&gt;requires the guest and host PASIDs to be the same&lt;/strong&gt;. Only virtual IOMMUs exposed to a guest would enumerate this capability. &lt;strong&gt;It provides an interface to for the host to control allocation of PASIDs in a guest OS&lt;/strong&gt;.
    
    </summary>
    
      <category term="VT-d" scheme="http://liujunming.github.io/categories/VT-d/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Shared Virtual Memory virtualization</title>
    <link href="http://liujunming.github.io/2023/05/07/Notes-about-Shared-Virtual-Memory-virtualization/"/>
    <id>http://liujunming.github.io/2023/05/07/Notes-about-Shared-Virtual-Memory-virtualization/</id>
    <published>2023-05-07T07:37:36.000Z</published>
    <updated>2023-05-07T11:32:15.311Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍下Shared Virtual Memory virtualization相关内容。<a id="more"></a></p><h2 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h2><ul><li><a href="/2022/03/30/Introduction-to-Shared-Virtual-Memory/">Shared Virtual Memory</a></li><li>VT-d基础知识(需要阅读VT-d spec)<ul><li>Legacy Mode Address Translation</li><li><a href="/2022/05/14/浅谈IOMMU-pageing-structures/">Scalable Mode Address Translation</a><ul><li>First-Stage Translation</li><li>Second-Stage Translation</li><li>Nested Translation</li><li>Pass-through Translation<br><img src="/images/2023/05/24.png" alt><br><img src="/images/2023/05/34.jpg" alt></li></ul></li></ul></li></ul><h2 id="2-Enable-SVM-in-VM"><a href="#2-Enable-SVM-in-VM" class="headerlink" title="2. Enable SVM in VM"></a>2. Enable SVM in VM</h2><p><img src="/images/2023/05/25.jpg" alt></p><p><img src="/images/2023/05/26.jpg" alt></p><p><img src="/images/2023/05/27.jpg" alt></p><p><img src="/images/2023/05/28.jpg" alt></p><p><img src="/images/2023/05/32.jpg" alt></p><p><img src="/images/2023/05/33.jpg" alt></p><p><img src="/images/2023/05/29.jpg" alt></p><p><img src="/images/2023/05/30.jpg" alt></p><p><img src="/images/2023/05/31.jpg" alt></p><p><img src="/images/2023/05/35.jpg" alt></p><hr><p>参考资料:</p><ol><li><a href="https://events19.linuxfoundation.cn/wp-content/uploads/2017/11/Shared-Virtual-Memory-in-KVM_Yi-Liu.pdf" target="_blank" rel="noopener">Shared Virtual Memory in KVM</a></li><li><a href="https://static.sched.com/hosted_files/kvmforum2018/52/kvm-forum-vSVA-yliu-jpan-jean-eric.pdf" target="_blank" rel="noopener">Shared Virtual Addressing in KVM</a></li><li><a href="https://www.youtube.com/watch?v=Kq_nfGK5MwQ" target="_blank" rel="noopener">Video for SVM in KVM forum</a></li><li><a href="http://blog.chinaunix.net/uid-28541347-id-5854016.html" target="_blank" rel="noopener">Shared Virtual Memory（SVM）介绍</a></li><li><a href="https://www.cnblogs.com/shaohef/p/12079657.html" target="_blank" rel="noopener">Shared Virtual Memory (SVM) Functions</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍下Shared Virtual Memory virtualization相关内容。
    
    </summary>
    
      <category term="VT-d" scheme="http://liujunming.github.io/categories/VT-d/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
  <entry>
    <title>DSA dedicated work queue virtualization</title>
    <link href="http://liujunming.github.io/2023/05/07/DSA-dedicated-work-queue-virtualization/"/>
    <id>http://liujunming.github.io/2023/05/07/DSA-dedicated-work-queue-virtualization/</id>
    <published>2023-05-07T00:13:11.000Z</published>
    <updated>2023-05-07T11:24:27.729Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2023/05/04/Scalable-Work-Submission-in-Device-Virtualization/">Scalable Work Submission in Device Virtualization</a>介绍了<a href="/2022/10/23/Notes-about-Intel-Data-Streaming-Accelerator-DSA/">DSA</a> shared work queue的virtualization，本文将介绍DSA dedicated work queue的virtualization。<a id="more"></a></p><p>本文将带着如下两个问题进行讨论：<br>Q1: 虚拟机用dedicated work queue时，要使用pasid吗？<br>Q2: 如果guest使用pasid，那pasid翻译该如何操作?</p><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><p><img src="/images/2023/05/22.png" alt><br>从DSA的spec中可知，当使用dedicated work queue时，pasid是一个可选项。因此，当虚拟机使用dedicated work queue时，可以使用pasid，也可以不使用pasid。</p><h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><p>To submit work to a Dedicated Work Queue, software uses a 64-byte memory write transaction with write atomicity.</p><p>On Intel CPUs, work submission to a DWQ(Dedicated Work Queue) is performed using the MOVDIR64B instruction, which generates a non-torn 64-byte write. </p><p>If the PASID capability is enabled, the WQ(Work Queue) PASID Enable field of the WQ Configuration register controls whether PASID is used for each DWQ. Since the MOVDIR64B instruction does not fill in the PASID as the ENQCMD or ENQCMDS instructions do, the PASID field in the descriptor is ignored. When PASID is enabled for a DWQ, the device uses the WQ PASID field of the WQ Configuration register to do address translation. The WQ PASID field must be set by the driver before enabling a work queue in dedicated mode.</p><p><img src="/images/2023/05/23.png" alt></p><p><strong>dedicated work queue不会共享，所以MOVDIR64B就不用写入pasid了</strong>。</p><p>当guest配置WQ Configuration register(MMIO寄存器)的PASID field时需要trap下来，hypervisor分配一个host的PASID，然后将这个host PASID写入物理WQ Configuration register的PASID field。这样即可完成pasid虚拟化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2023/05/04/Scalable-Work-Submission-in-Device-Virtualization/&quot;&gt;Scalable Work Submission in Device Virtualization&lt;/a&gt;介绍了&lt;a href=&quot;/2022/10/23/Notes-about-Intel-Data-Streaming-Accelerator-DSA/&quot;&gt;DSA&lt;/a&gt; shared work queue的virtualization，本文将介绍DSA dedicated work queue的virtualization。
    
    </summary>
    
      <category term="VT-d" scheme="http://liujunming.github.io/categories/VT-d/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
  <entry>
    <title>Scalable Work Submission in Device Virtualization</title>
    <link href="http://liujunming.github.io/2023/05/04/Scalable-Work-Submission-in-Device-Virtualization/"/>
    <id>http://liujunming.github.io/2023/05/04/Scalable-Work-Submission-in-Device-Virtualization/</id>
    <published>2023-05-04T05:47:12.000Z</published>
    <updated>2023-05-04T11:43:41.306Z</updated>
    
    <content type="html"><![CDATA[<p>本文将以<a href="/2022/10/23/Notes-about-Intel-Data-Streaming-Accelerator-DSA/">Intel Data Streaming Accelerator</a>为例，讲解DMWr (Deferrable Memory Write) TLP、ENQCMD/ENQCMDS指令、ENQCMD Virtualization、<a href="/2022/03/30/Introduction-to-Shared-Virtual-Memory/">SVA</a> Work Submission In Guest相关内容。<a id="more"></a></p><h2 id="1-DMWr-TLP"><a href="#1-DMWr-TLP" class="headerlink" title="1. DMWr TLP"></a>1. DMWr TLP</h2><h3 id="1-1-What"><a href="#1-1-What" class="headerlink" title="1.1 What"></a>1.1 What</h3><p>Deferrable Memory Write (DMWr) transactions are a new type of TLP supported by the PCI Specifications. This new feature allows the completer to return an acknowledgement to the requester of the DMWr transaction and provides the completer a mechanism to temporarily refuse the request.</p><p>The Deferrable Memory Write (DMWr) is an Optional Non-Posted Request that enables a scalable high-performance mechanism to implement shared work queues and similar capabilities. With DMWr, devices can have a single shared work queue and accept work items from multiple non-cooperating software agents in a non-blocking way.</p><p>读完上述定义后，或许对DMWr的理解不够深刻，接下来我们将以DSA的SWQ(Shared Work Queue)为例，阐述下为什么要有DMWr。</p><h3 id="1-2-Why"><a href="#1-2-Why" class="headerlink" title="1.2 Why"></a>1.2 Why</h3><p><img src="/images/2023/05/04.png" alt></p><p><img src="/images/2023/05/05.png" alt></p><p><img src="/images/2023/05/07.png" alt></p><p><img src="/images/2023/05/06.png" alt></p><blockquote><p>DMWr is a 64-byte non-posted write that waits for a response from the device before completing. The device returns Success if the descriptor is accepted into the work queue, or Retry if the descriptor is not accepted due to WQ capacity or QoS. </p></blockquote><p>正常写mmio寄存器是posted tlp，也就是说completer不会给requester返回报文。<br>DMWr是non-posted write tlp，这也为retry带来了可能！</p><h2 id="2-ENQCMD-ENQCMDS指令"><a href="#2-ENQCMD-ENQCMDS指令" class="headerlink" title="2. ENQCMD/ENQCMDS指令"></a>2. ENQCMD/ENQCMDS指令</h2><p>On Intel CPUs, DMWr is generated using the <code>ENQCMD</code> or <code>ENQCMDS</code> instructions. The <code>ENQCMD</code> and <code>ENQCMDS</code> instructions return the status of the command submission in <code>EFLAGS.ZF</code> flag; 0 indicates Success, and 1 indicates Retry.</p><p><img src="/images/2023/05/08.jpg" alt><br>SDM vol2中有这两个指令的详细描述。</p><p><img src="/images/2023/05/12.jpg" alt></p><p><img src="/images/2023/05/09.jpg" alt><br>ENQCMD 中destination offset参数的含义： enqueue registers, which are special device registers accessed using memory-mapped I/O (MMIO). 说白了，offset就是MMIO enqueue registers的location！</p><p><img src="/images/2023/05/13.jpg" alt></p><p><img src="/images/2023/05/14.jpg" alt></p><h3 id="2-1-Example-in-DSA"><a href="#2-1-Example-in-DSA" class="headerlink" title="2.1 Example in DSA"></a>2.1 Example in DSA</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span>  <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">enqcmd(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> retry;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">".byte 0xf2, 0x0f, 0x38, 0xf8, 0x02\t\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="string">"setz %0\t\n"</span></span></span></span><br><span class="line">                 : "=r"(retry) : "a" (dst), "d" (src));</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (enqcmd(wq_portal, &amp;desc) &amp;&amp; enq_retry++ &lt; ENQ_RETRY_MAX) ;</span><br><span class="line"><span class="keyword">if</span> (enq_retry == ENQ_RETRY_MAX) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ENQCMD retry limit exceeded\n"</span>);</span><br><span class="line">    rc = EXIT_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><a href="https://github.com/RaymondHuang210129/Intel-DSA-Experiments/blob/master/intel_dsa_sample.c" target="_blank" rel="noopener">https://github.com/RaymondHuang210129/Intel-DSA-Experiments/blob/master/intel_dsa_sample.c</a></p><h2 id="3-Scalability-In-Device-Virtualization"><a href="#3-Scalability-In-Device-Virtualization" class="headerlink" title="3. Scalability In Device Virtualization"></a>3. Scalability In Device Virtualization</h2><p><img src="/images/2023/05/16.jpg" alt><br><img src="/images/2023/05/17.jpg" alt><br><img src="/images/2023/05/18.jpg" alt><br><img src="/images/2023/05/19.jpg" alt></p><h2 id="4-ENQCMD-Virtualization"><a href="#4-ENQCMD-Virtualization" class="headerlink" title="4. ENQCMD Virtualization"></a>4. ENQCMD Virtualization</h2><p><img src="/images/2023/05/10.png" alt></p><p><img src="/images/2023/05/11.png" alt><br>sdm vol3  搜索ENQCMD即可！</p><p><img src="/images/2023/05/20.jpg" alt><br><img src="/images/2023/05/21.jpg" alt></p><h2 id="5-SVA-Work-Submission-In-Guest"><a href="#5-SVA-Work-Submission-In-Guest" class="headerlink" title="5. SVA Work Submission In Guest"></a>5. SVA Work Submission In Guest</h2><p><img src="/images/2023/05/15.jpg" alt></p><hr><p>参考资料:</p><ol><li><a href="https://static.sched.com/hosted_files/kvmforum2020/22/Scalable_Work_Submission_In_Device_Virtualization.pdf" target="_blank" rel="noopener">Scalable Work Submission in Device Virtualization</a></li><li><a href="https://blog.csdn.net/weixin_40357487/article/details/123339073" target="_blank" rel="noopener">PCIe 6.0 新特性 - DMWr (Deferrable Memory Write) 详解</a></li><li><a href="https://www.intel.com/content/www/us/en/docs/programmable/683501/22-2-6-0-0/deferrable-memory-write-dmwr.html" target="_blank" rel="noopener">Deferrable Memory Write (DMWr)</a></li><li><a href="https://www.freepatentsonline.com/y2020/0004703.html" target="_blank" rel="noopener">NON-POSTED WRITE TRANSACTIONS</a></li><li>Intel SDM</li><li>Intel Data Streaming Accelerator spec</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将以&lt;a href=&quot;/2022/10/23/Notes-about-Intel-Data-Streaming-Accelerator-DSA/&quot;&gt;Intel Data Streaming Accelerator&lt;/a&gt;为例，讲解DMWr (Deferrable Memory Write) TLP、ENQCMD/ENQCMDS指令、ENQCMD Virtualization、&lt;a href=&quot;/2022/03/30/Introduction-to-Shared-Virtual-Memory/&quot;&gt;SVA&lt;/a&gt; Work Submission In Guest相关内容。
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
  </entry>
  
  <entry>
    <title>Notes about NBD（Network Block Device)</title>
    <link href="http://liujunming.github.io/2023/05/04/Notes-about-NBD%EF%BC%88Network-Block-Device/"/>
    <id>http://liujunming.github.io/2023/05/04/Notes-about-NBD（Network-Block-Device/</id>
    <published>2023-05-04T05:29:23.000Z</published>
    <updated>2023-05-04T05:37:17.282Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/50460919" target="_blank" rel="noopener">NBD（Network Block Device）简介及基本使用</a></p><p>NBD指的是Network Block Device，正如其名字的意思，NBD让用户可以通过网络访问到某个块设备，或者镜像文件。<a id="more"></a></p><p><img src="/images/2023/05/03.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50460919&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NBD（Network Block Device）简介及基本使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NBD指的是Network Block Device，正如其名字的意思，NBD让用户可以通过网络访问到某个块设备，或者镜像文件。
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Notes about协程</title>
    <link href="http://liujunming.github.io/2023/05/02/Notes-about%E5%8D%8F%E7%A8%8B/"/>
    <id>http://liujunming.github.io/2023/05/02/Notes-about协程/</id>
    <published>2023-05-02T06:23:49.000Z</published>
    <updated>2023-05-02T12:22:15.347Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark下协程(Coroutines)相关notes。<a id="more"></a></p><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-Why"><a href="#1-1-Why" class="headerlink" title="1.1 Why?"></a>1.1 Why?</h3><p><a href="/pdf/什么是协程.pdf">什么是协程</a></p><p>vs多线程：<br>操作系统在线程等待IO的时候，会阻塞当前线程，切换到其它线程，这样在当前线程等待IO的过程中，其它线程可以继续执行。当系统线程较少的时候没有什么问题，但是当线程数量非常多的时候，却产生了问题。<strong>一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间</strong>。</p><p>协程刚好可以解决上述2个问题。协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</p><h3 id="1-2-What"><a href="#1-2-What" class="headerlink" title="1.2 What"></a>1.2 What</h3><p><img src="/images/2023/05/02.png" alt></p><blockquote><p>协程本质上和单线程+状态机是等价的，只是用协程的话，协程负责来保存状态，开发起来方便些(不用自己写那个状态机)。</p></blockquote><h3 id="1-3-When"><a href="#1-3-When" class="headerlink" title="1.3 When"></a>1.3 When</h3><p>在有大量IO操作业务的情况下，我们采用协程替换线程，可以到达很好的效果，一是降低了系统内存，二是减少了系统切换开销，因此系统的性能也会提升。</p><p>在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用。</p><p><strong>协程只有和异步IO结合起来才能发挥出最大的威力</strong>。</p><h2 id="2-QEMU中的协程"><a href="#2-QEMU中的协程" class="headerlink" title="2. QEMU中的协程"></a>2. QEMU中的协程</h2><h3 id="2-1-为什么qemu要使用协程"><a href="#2-1-为什么qemu要使用协程" class="headerlink" title="2.1 为什么qemu要使用协程"></a>2.1 为什么qemu要使用协程</h3><p><a href="https://lore.kernel.org/qemu-devel/1311672077-4592-1-git-send-email-stefanha@linux.vnet.ibm.com/" target="_blank" rel="noopener">Coroutines for better asynchronous programming</a></p><p>仔细阅读<a href="http://blog.vmsplice.net/2014/01/coroutines-in-qemu-basics.html" target="_blank" rel="noopener">Coroutines in QEMU: The basics</a> <em>Callback hell in event-driven programs</em>即可。The coroutine version is much easier to understand because the code is sequential. Under the hood the coroutine version returns back to the event loop just like the callback version. Therefore the code still uses the event loop but it can be written like a sequential program.</p><blockquote><p>Coroutines make it possible to write sequential code that is actually executed across multiple iterations of the event loop. This is useful for code that needs to perform blocking I/O and would quickly become messy if split into a chain of callback functions. </p></blockquote><h3 id="2-2-The-QEMU-coroutine-API"><a href="#2-2-The-QEMU-coroutine-API" class="headerlink" title="2.2 The QEMU coroutine API"></a>2.2 The QEMU coroutine API</h3><p>The coroutine API is documented in <a href="https://gitlab.com/qemu-project/qemu/-/blob/stable-6.0/include/qemu/coroutine.h" target="_blank" rel="noopener">include/qemu/coroutine.h</a>. The main functions are:</p><h4 id="2-2-1-create-coroutine"><a href="#2-2-1-create-coroutine" class="headerlink" title="2.2.1 create coroutine"></a>2.2.1 create coroutine</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Coroutine entry point</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When the coroutine is entered for the first time, opaque is passed in as an</span></span><br><span class="line"><span class="comment"> * argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When this function returns, the coroutine is destroyed automatically and</span></span><br><span class="line"><span class="comment"> * execution continues in the caller who last entered the coroutine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> coroutine_fn <span class="title">CoroutineEntry</span><span class="params">(<span class="keyword">void</span> *opaque)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new coroutine</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use qemu_coroutine_enter() to actually transfer control to the coroutine.</span></span><br><span class="line"><span class="comment"> * The opaque argument is passed as the argument to the entry point.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Coroutine *<span class="title">qemu_coroutine_create</span><span class="params">(CoroutineEntry *entry, <span class="keyword">void</span> *opaque)</span></span>;</span><br></pre></td></tr></table></figure><p>When a new coroutine is started, it will begin executing the entry function. The caller can pass an opaque pointer to data needed by the coroutine.</p><h4 id="2-2-2-execute-coroutine"><a href="#2-2-2-execute-coroutine" class="headerlink" title="2.2.2 execute coroutine"></a>2.2.2 execute coroutine</h4><p>The new coroutine is executed by calling <code>qemu_coroutine_enter</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfer control to a coroutine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qemu_coroutine_enter</span><span class="params">(Coroutine *coroutine)</span></span>;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-3-yield-coroutine"><a href="#2-2-3-yield-coroutine" class="headerlink" title="2.2.3 yield coroutine"></a>2.2.3 yield coroutine</h4><p>If the coroutine needs to wait for an event such as I/O completion or user input, it calls <code>qemu_coroutine_yield</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfer control back to a coroutine's caller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function does not return until the coroutine is re-entered using</span></span><br><span class="line"><span class="comment"> * qemu_coroutine_enter().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> coroutine_fn <span class="title">qemu_coroutine_yield</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>The yield function transfers control back to the <code>qemu_coroutine_enter</code> caller. The coroutine can be re-entered at a later point in time by calling <code>qemu_coroutine_enter</code>, for example, when an I/O request has completed.</p><hr><p>参考资料:</p><ol><li><a href="http://blog.vmsplice.net/2014/01/coroutines-in-qemu-basics.html" target="_blank" rel="noopener">Coroutines in QEMU: The basics</a></li><li><a href="https://royhunter.github.io/2016/06/24/qemu-coroutine/" target="_blank" rel="noopener">QEMU中的协程—qemu-coroutine</a></li><li><a href="https://zhuanlan.zhihu.com/p/172471249" target="_blank" rel="noopener">什么是协程？</a></li><li><a href="https://mp.weixin.qq.com/s/SyWjLg3lYx3pIJQfEtik8Q" target="_blank" rel="noopener">​浅谈协程</a></li><li><a href="https://mp.weixin.qq.com/s/IO4ynnKEfy2Rt-Me7EIeqg" target="_blank" rel="noopener">当谈论协程时，我们在谈论什么</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark下协程(Coroutines)相关notes。
    
    </summary>
    
      <category term="操作系统" scheme="http://liujunming.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="操作系统" scheme="http://liujunming.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>如何mount虚拟机镜像</title>
    <link href="http://liujunming.github.io/2023/05/01/%E5%A6%82%E4%BD%95mount%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/"/>
    <id>http://liujunming.github.io/2023/05/01/如何mount虚拟机镜像/</id>
    <published>2023-05-01T11:49:38.000Z</published>
    <updated>2023-05-01T12:36:17.731Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍下mount虚拟机镜像的方法。 <a id="more"></a></p><h3 id="losetup"><a href="#losetup" class="headerlink" title="losetup"></a>losetup</h3><p>losetup只能mount raw格式的镜像。</p><p>To check what is the first usable loop device, run<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">losetup -f</span><br></pre></td></tr></table></figure></p><p>After that, use the output of that command to link the disk image to the loop device file (using root privileges):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">losetup -P /dev/loopX example.img</span><br></pre></td></tr></table></figure></p><p>The -P flag searches through the image for partitions, which you need to mount.</p><p>After that, create the folder named example and run the command:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/loopXpY example</span><br></pre></td></tr></table></figure></p><p>The disk image should now be mounted in that directory. Depending on the Y variable, the right partition was mounted.</p><h3 id="qemu-nbd"><a href="#qemu-nbd" class="headerlink" title="qemu-nbd"></a>qemu-nbd</h3><p>Export a QEMU disk image using the NBD protocol.</p><p>qemu-nbd可以mount多种格式的虚拟机镜像，因此适用范围比losetup要广！</p><ul><li><p>Enable NBD on the host</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe nbd max_part=8</span><br></pre></td></tr></table></figure></li><li><p>Connect the QCOW2 as a network block device</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-nbd -c /dev/nbd0 /var/lib/vz/images/100/vm-100-disk-1.qcow2</span><br></pre></td></tr></table></figure></li><li><p>List partitions inside the QCOW2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/nbd0 -l</span><br></pre></td></tr></table></figure></li><li><p>Mount the partition from the VM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/nbd0p1 /mnt/somepoint/</span><br></pre></td></tr></table></figure></li><li><p>After you’re done, unmount and disconnect</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">umount /mnt/somepoint/</span><br><span class="line">qemu-nbd -d /dev/nbd0</span><br><span class="line">rmmod nbd</span><br></pre></td></tr></table></figure></li></ul><hr><p>参考资料:</p><ol><li><a href="https://iaguozhi.github.io/blogs/Change-vm-kernel-by-qemu-nbd.html" target="_blank" rel="noopener">记录一次将虚拟机kernel写坏之后的修复过程</a></li><li><a href="https://www.qemu.org/docs/master/tools/qemu-nbd.html" target="_blank" rel="noopener">QEMU Disk Network Block Device Server</a></li><li><a href="https://eloydegen.com/blog/posts/losetup/" target="_blank" rel="noopener">Mount disk images using losetup</a></li><li><a href="https://www.man7.org/linux/man-pages/man8/losetup.8.html" target="_blank" rel="noopener">man losetup</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍下mount虚拟机镜像的方法。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Notes about GPU Direct Storage</title>
    <link href="http://liujunming.github.io/2023/05/01/Notes-about-GPU-Direct-Storage/"/>
    <id>http://liujunming.github.io/2023/05/01/Notes-about-GPU-Direct-Storage/</id>
    <published>2023-05-01T07:32:26.000Z</published>
    <updated>2023-05-01T11:29:26.325Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark下GPU Direct Storage相关notes。<a id="more"></a></p><blockquote><p>从IO读取链路来看，NVMe控制器通过DMA引擎将硬盘数据直接写入GPU显存，避免了主机内存和CPU的参与，从而实现CPU和主存的IO旁路，使IO吞吐能力不在受限于系统总线的带宽压力。</p></blockquote><p>说白了，就是支持NVMe与GPU的PCIe p2p，不过只支持NVMe到GPU的方向。</p><p><img src="/images/2023/05/01.png" alt></p><p><strong>GPUDirect Storage</strong> enables a direct data path between local or remote storage, such as NVMe or NVMe over Fabric (NVMe-oF), and GPU memory. It avoids extra copies through a bounce buffer in the CPU’s memory, enabling a direct memory access (DMA) engine near the NIC or storage to move data on a direct path into or out of GPU memory — all without burdening the CPU.</p><hr><p>参考资料:</p><ol><li><a href="https://zhuanlan.zhihu.com/p/509396439" target="_blank" rel="noopener">GPU Direct Storage</a></li><li><a href="https://developer.nvidia.com/gpudirect" target="_blank" rel="noopener">NVIDIA GPUDirect</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark下GPU Direct Storage相关notes。
    
    </summary>
    
      <category term="体系结构" scheme="http://liujunming.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
      <category term="GPU" scheme="http://liujunming.github.io/tags/GPU/"/>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
  </entry>
  
  <entry>
    <title>Notes about hyper_dmabuf</title>
    <link href="http://liujunming.github.io/2023/04/30/Notes-about-hyper-dmabuf/"/>
    <id>http://liujunming.github.io/2023/04/30/Notes-about-hyper-dmabuf/</id>
    <published>2023-04-30T12:26:38.000Z</published>
    <updated>2023-04-30T13:22:49.838Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark下hyper_dmabuf相关notes。<a id="more"></a><br><img src="/images/2023/04/20.png" alt></p><p>Hyper_DMABUF driver is a Linux device driver running on multiple Virtual achines (VMs), which expands DMA-BUF sharing capability to the VM environment where multiple different OS instances need to share same physical data without data-copy across VMs.</p><p>To share a DMA_BUF across VMs, an instance of the Hyper_DMABUF drv on the exporting VM (so called, “exporter”) imports a local DMA_BUF from the original producer of the buffer, then re-exports it with an unique ID, hyper_dmabuf_id for the buffer to the importing VM (so called, “importer”).</p><p>Another instance of the Hyper_DMABUF driver on importer registers a hyper_dmabuf_id together with reference information for the shared physical pages associated with the DMA_BUF to its database when the export happens.</p><p>The actual mapping of the DMA_BUF on the importer’s side is done by the Hyper_DMABUF driver when user space issues the IOCTL command to access the shared DMA_BUF. The Hyper_DMABUF driver works as both an importing and exporting driver as is, that is, no special configuration is required. Consequently, only a single module per VM is needed to enable cross-VM DMA_BUF exchange.</p><hr><p>参考资料:</p><ol><li><a href="https://projectacrn.github.io/1.6.1/developer-guides/hld/hld-APL_GVT-g.html#hyper-dma-buffer-sharing" target="_blank" rel="noopener">Hyper DMA Buffer Sharing</a></li><li><a href="https://github.com/downor/linux_hyper_dmabuf/blob/hyper_dmabuf_integration_v4/Documentation/hyper-dmabuf-sharing.txt" target="_blank" rel="noopener">Linux Hyper DMABUF Driver</a></li><li><a href="https://lists.freedesktop.org/archives/dri-devel/2017-December/160709.html" target="_blank" rel="noopener">hyper_dmabuf: initial working version of hyper_dmabuf drv</a></li><li><a href="https://www.phoronix.com/news/Intel-Hyper-DMA-BUF" target="_blank" rel="noopener">Intel Introduces “Hyper DMA-BUF” To Exchange Buffers Between VMs</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark下hyper_dmabuf相关notes。
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Notes about dma_buf</title>
    <link href="http://liujunming.github.io/2023/04/30/Notes-about-dma-buf/"/>
    <id>http://liujunming.github.io/2023/04/30/Notes-about-dma-buf/</id>
    <published>2023-04-30T06:25:25.000Z</published>
    <updated>2023-04-30T08:16:16.512Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark下dma_buf相关notes。<a id="more"></a></p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p><img src="/images/2023/04/17.jpg" alt><br>以摄像头采集数据，GPU显示数据为例。摄像头设备将数据DMA到内存中后，GPU需要将这些DMA内存进行显示，也就是说摄像头DMA的输出数据是GPU的DMA输入数据。如果没有DMA buffer sharing机制，则需要将摄像头的DMA数据拷贝一份以搬到GPU的DMA数据中，因此存在内存copy的开销！<br>dma_buf则提供了一套统一框架，可以实现不同device的驱动之间DMA buffer的sharing，同时还允许userspace mmap共享的DMA buffer！</p><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p><img src="/images/2023/04/19.jpg" alt></p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="/images/2023/04/18.jpg" alt></p><p><img src="/images/2023/04/14.png" alt></p><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p><img src="/images/2023/04/13.png" alt></p><p><img src="/images/2023/04/15.png" alt><br><img src="/images/2023/04/16.png" alt></p><hr><p>参考资料:</p><ol><li><a href="https://blog.csdn.net/hexiaolong2009/article/details/102596744" target="_blank" rel="noopener">dma-buf 由浅入深（一） —— 最简单的 dma-buf 驱动程序</a></li><li><a href="https://github.com/hexiaolong2008/sample-code/tree/master/dma-buf/08" target="_blank" rel="noopener">dma-buf</a></li><li><a href="https://saiyn.github.io/homepage/2018/04/18/linux-kernel-dmabuf/" target="_blank" rel="noopener">Linux内核笔记之DMA_BUF</a></li><li><a href="https://elinux.org/images/a/a8/DMA_Buffer_Sharing-_An_Introduction.pdf" target="_blank" rel="noopener">DMA Buffer Sharing Framework:An Introduction</a></li><li><a href="https://www.openfabrics.org/wp-content/uploads/2020-workshop-presentations/303.-OFI-GPU-DMA-BUF-OFA2020v2.pdf" target="_blank" rel="noopener">RDMA WITH GPU MEMORY VIA DMA-BUF</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTc0ODAzMw==&amp;mid=2247502900&amp;idx=1&amp;sn=dd73aae7e7b296317fbff613d475888e&amp;chksm=ce9ad01af9ed590c71f309a8b4ba4bad72dda1d75f9af5d153caf5dd11e229aa75c8507685c7&amp;mpshare=1&amp;scene=1&amp;srcid=0403TMj3qA6LY1DDtxctawJO&amp;sharer_sharetime=1648995232072&amp;sharer_shareid=fcd8378fa2afcbc997c8bd7f888f36e6&amp;exportkey=AZdgR1ASyNPvcNHeaNH3PpE%3D&amp;acctmode=0&amp;pass_ticket=bxkMR5mJMnjqkgrSRKMG4Na40WpTHdV%2FfvZCJEtYhn3FUItw%2FA0ZMr0FE2oTAbbL&amp;wx_header=0#rd" target="_blank" rel="noopener">dma-buf学习分享</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark下dma_buf相关notes。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
</feed>
