<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2021-03-30T10:51:17.709Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每周分享第21期</title>
    <link href="http://liujunming.github.io/2021/03/30/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC21%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/03/30/每周分享第21期/</id>
    <published>2021-03-30T11:09:58.000Z</published>
    <updated>2021-03-30T10:51:17.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="紧急复位孔"><a href="#紧急复位孔" class="headerlink" title="紧急复位孔"></a>紧急复位孔</h3><p><a href="https://zhuanlan.zhihu.com/p/35785409" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35785409</a></p><p><a href="https://download.lenovo.com/pccbbs/mobiles_pdf/x1_carbon_ug_zh-cn.pdf" target="_blank" rel="noopener">https://download.lenovo.com/pccbbs/mobiles_pdf/x1_carbon_ug_zh-cn.pdf</a></p><p>如果计算机停止响应，并且无法通过按电源按键关闭计算机，请卸下交流电源适配器，然后向紧急复位孔插入拉直的曲别针以使计算机复位。</p><a id="more"></a><h3 id="如何设置Outlook按照开源社区的方式进行回复"><a href="#如何设置Outlook按照开源社区的方式进行回复" class="headerlink" title="如何设置Outlook按照开源社区的方式进行回复"></a>如何设置Outlook按照开源社区的方式进行回复</h3><p><a href="https://blog.csdn.net/leoufung/article/details/49175751" target="_blank" rel="noopener">https://blog.csdn.net/leoufung/article/details/49175751</a></p><h3 id="中国专利查询"><a href="#中国专利查询" class="headerlink" title="中国专利查询"></a>中国专利查询</h3><p><a href="http://epub.sipo.gov.cn/gjcx.jsp" target="_blank" rel="noopener">http://epub.sipo.gov.cn/gjcx.jsp</a></p><h3 id="Keem-Bay"><a href="#Keem-Bay" class="headerlink" title="Keem Bay"></a>Keem Bay</h3><p>Intel has now detailed what it calls the Gen 3 Intel Movidius VPU codenamed Keem Bay. </p><p><a href="https://www.tomshardware.com/news/intel-announces-movidius-keem-bay-vpu" target="_blank" rel="noopener">https://www.tomshardware.com/news/intel-announces-movidius-keem-bay-vpu</a></p><h3 id="Movidius"><a href="#Movidius" class="headerlink" title="Movidius"></a>Movidius</h3><p>Movidius is a company based in San Mateo, California that designs specialised low-power processor chips for computer vision. The company was acquired by Intel in September 2016.</p><h3 id="chromebook"><a href="#chromebook" class="headerlink" title="chromebook"></a>chromebook</h3><p><a href="https://www.google.com/chromebook/" target="_blank" rel="noopener">https://www.google.com/chromebook/</a></p><h3 id="brpc"><a href="#brpc" class="headerlink" title="brpc"></a>brpc</h3><p><a href="https://github.com/apache/incubator-brpc" target="_blank" rel="noopener">https://github.com/apache/incubator-brpc</a></p><p>An industrial-grade RPC framework used throughout Baidu, with 1,000,000+ instances(not counting clients) and thousands kinds of services. “brpc” means “better RPC”.</p><h3 id="https-salaryfly-com"><a href="#https-salaryfly-com" class="headerlink" title="https://salaryfly.com/"></a><a href="https://salaryfly.com/" target="_blank" rel="noopener">https://salaryfly.com/</a></h3><h3 id="KVM-switch"><a href="#KVM-switch" class="headerlink" title="KVM switch"></a>KVM switch</h3><p><a href="https://en.wikipedia.org/wiki/KVM_switch" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/KVM_switch</a></p><p>A KVM switch (with KVM being an abbreviation for “keyboard, video and mouse”) is a hardware device that allows a user to control multiple computers from one or more sets of keyboards, video monitors, and mice.</p><p><a href="https://www.youtube.com/watch?v=CYq9aeDNAFA" target="_blank" rel="noopener">KVM Switch Setup – 2 Laptops to 1 Monitor – Mac &amp; PC + Zoom – Easy Setup!</a></p><h3 id="Create-a-bootable-USB-drive-using-Etcher"><a href="#Create-a-bootable-USB-drive-using-Etcher" class="headerlink" title="Create a bootable USB drive using Etcher*"></a>Create a bootable USB drive using Etcher*</h3><p><a href="https://docs.01.org/clearlinux/latest/get-started/bootable-usb.html#bootable-usb" target="_blank" rel="noopener">https://docs.01.org/clearlinux/latest/get-started/bootable-usb.html#bootable-usb</a></p><p><a href="/pdf/Create a bootable USB drive using Etcher.pdf">Create a bootable USB drive using Etcher*</a></p><h3 id="atlassian"><a href="#atlassian" class="headerlink" title="atlassian"></a>atlassian</h3><p><a href="https://www.atlassian.com/software/confluence" target="_blank" rel="noopener">https://www.atlassian.com/software/confluence</a></p><p>Confluence is your remote-friendly team workspace where knowledge and collaboration meet.</p><h3 id="学计算机治好了我的完美主义"><a href="#学计算机治好了我的完美主义" class="headerlink" title="学计算机治好了我的完美主义"></a><a href="https://zhuanlan.zhihu.com/p/355089813" target="_blank" rel="noopener">学计算机治好了我的完美主义</a></h3><p><a href="/pdf/学计算机治好了我的完美主义.pdf">学计算机治好了我的完美主义</a></p><blockquote><p>有三种美，结构的美（代表为设计模式）;解构的美（代表为软件开发中的刀砍火烧，虽然程序一团迷惑，但却能正确运行）;重构的美（代表为在开发过程中整理代码，对目标的理解逐渐清晰，逐渐形成团队的共识）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;紧急复位孔&quot;&gt;&lt;a href=&quot;#紧急复位孔&quot; class=&quot;headerlink&quot; title=&quot;紧急复位孔&quot;&gt;&lt;/a&gt;紧急复位孔&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35785409&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/35785409&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://download.lenovo.com/pccbbs/mobiles_pdf/x1_carbon_ug_zh-cn.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://download.lenovo.com/pccbbs/mobiles_pdf/x1_carbon_ug_zh-cn.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果计算机停止响应，并且无法通过按电源按键关闭计算机，请卸下交流电源适配器，然后向紧急复位孔插入拉直的曲别针以使计算机复位。&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>A Simple LD_PRELOAD Tutorial, Part Two</title>
    <link href="http://liujunming.github.io/2021/03/30/A-Simple-LD-PRELOAD-Tutorial-Part-Two/"/>
    <id>http://liujunming.github.io/2021/03/30/A-Simple-LD-PRELOAD-Tutorial-Part-Two/</id>
    <published>2021-03-30T07:10:02.000Z</published>
    <updated>2021-03-30T10:51:17.707Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自:</p><ul><li><a href="https://catonmat.net/simple-ld-preload-tutorial-part-two" target="_blank" rel="noopener">A Simple LD_PRELOAD Tutorial, Part Two</a></li></ul><a id="more"></a><p><a href="https://catonmat.net/simple-ld-preload-tutorial" target="_blank" rel="noopener">Last time</a> I showed you how to override functions in shared libraries by creating your own shared library and preloading it via the <code>LD_PRELOAD</code> environment variable. Today I’ll show you how to call the original function from the overridden function.</p><p>First, let’s review the code example that we used in the previous article. We had a program called <code>prog.c</code> that used <code>fopen</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Calling the fopen() function...\n"</span>);</span><br><span class="line"></span><br><span class="line">    FILE *fd = fopen(<span class="string">"test.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fopen() returned NULL\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fopen() succeeded\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Today let’s write a shared library called <code>myfopen.c</code> that overrides <code>fopen</code> in <code>prog.c</code> and calls the original <code>fopen</code> from the C standard library:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In our own fopen, opening %s\n"</span>, path);</span><br><span class="line"></span><br><span class="line">    FILE *(*original_fopen)(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line">    original_fopen = dlsym(RTLD_NEXT, <span class="string">"fopen"</span>);</span><br><span class="line">    <span class="keyword">return</span> (*original_fopen)(path, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This shared library exports the <code>fopen</code> function that prints the path and then uses <code>dlsym</code> with the <code>RTLD_NEXT</code> pseudohandle to find the original <code>fopen</code> function.</p><p>We must define the _GNU_SOURCE feature macro in order to get the <code>RTLD_NEXT</code> definition from <code>&lt;dlfcn.h&gt;</code>. What <code>RTLD_NEXT</code> does is finds the next occurrence of a function in the search order after the current library.</p><p>We can compile this shared library this way:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -fPIC -shared -o myfopen.so myfopen.c -ldl</span><br></pre></td></tr></table></figure><p>When we preload it and run <code>prog</code> we get the following output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> LD_PRELOAD=./myfopen.so ./prog</span><br><span class="line">Calling the fopen() function...</span><br><span class="line">In our own fopen, opening test.txt</span><br><span class="line">fopen() succeeded</span><br></pre></td></tr></table></figure><p>It prints the filename of the file we’re opening and successfully opens it.</p><p>This is really useful if you need to change how a part of a program works or do some advanced debugging.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://catonmat.net/simple-ld-preload-tutorial-part-two&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A Simple LD_PRELOAD Tutorial, Part Two&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机系统" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机系统" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>A Simple LD_PRELOAD Tutorial</title>
    <link href="http://liujunming.github.io/2021/03/30/A-Simple-LD-PRELOAD-Tutorial/"/>
    <id>http://liujunming.github.io/2021/03/30/A-Simple-LD-PRELOAD-Tutorial/</id>
    <published>2021-03-30T06:21:08.000Z</published>
    <updated>2021-03-30T10:51:17.707Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自:</p><ul><li><a href="https://catonmat.net/simple-ld-preload-tutorial" target="_blank" rel="noopener">A Simple LD_PRELOAD Tutorial</a></li></ul><a id="more"></a><p><code>LD_PRELOAD</code> 的详细描述可以从<code>man ld.so</code>中查询。</p><p>Did you know you could override the C standard library functions, such as <code>printf</code> and <code>fopen</code> with your own functions in any program? In this short article I’ll teach you how to do it via the <code>LD_PRELOAD</code> environment variable.</p><p>Let’s start with a simple C program (prog.c):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Calling the fopen() function...\n"</span>);</span><br><span class="line"></span><br><span class="line">    FILE *fd = fopen(<span class="string">"test.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fopen() returned NULL\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fopen() succeeded\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The code above simply makes a call to the standard <code>fopen</code> function and then checks its return value. Now, let’s compile and execute it:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ls</span><br><span class="line">prog.c  test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> gcc prog.c -o prog</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">prog  prog.c  test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ./prog</span><br><span class="line">Calling the fopen() function...</span><br><span class="line">fopen() succeeded</span><br></pre></td></tr></table></figure></p><p>As you can see, the call to <code>fopen</code> was successful.</p><p>Now, let’s write our own version of <code>fopen</code> that always fails and call this file <code>myfopen.c</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Always failing fopen\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Let’s compile it as a shared library called <code>myfopen.so</code>:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -fPIC -shared -o myfopen.so myfopen.c</span><br></pre></td></tr></table></figure></p><p>Now, if we set the <code>LD_PRELOAD</code> environment variable to <code>myfopen.so</code> shared library before running the program that we created earlier, we get this output:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> LD_PRELOAD=./myfopen.so ./prog</span><br><span class="line">Calling the fopen() function...</span><br><span class="line">Always failing fopen</span><br><span class="line">fopen() returned NULL</span><br></pre></td></tr></table></figure></p><p>As you can see, <code>fopen</code> got replaced with our own version that is always failing.</p><p>This is really handy if you need to debug or replace certain parts of programs or libraries that you didn’t write.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://catonmat.net/simple-ld-preload-tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A Simple LD_PRELOAD Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机系统" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机系统" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Notes for GNU related knowledge</title>
    <link href="http://liujunming.github.io/2021/03/29/Notes-for-GNU-related-knowledge/"/>
    <id>http://liujunming.github.io/2021/03/29/Notes-for-GNU-related-knowledge/</id>
    <published>2021-03-29T08:05:17.000Z</published>
    <updated>2021-03-30T10:51:17.708Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h3><p><a href="https://www.gnu.org/" target="_blank" rel="noopener">https://www.gnu.org/</a></p><p>GNU is an operating system that is <a href="https://www.gnu.org/philosophy/free-sw.html" target="_blank" rel="noopener">free software</a>—that is, it respects users’ freedom. The GNU operating system consists of GNU packages (programs specifically released by the GNU Project) as well as free software released by third parties. The development of GNU made it possible to use a computer without software that would trample your freedom.</p><a id="more"></a><h3 id="GNU-Software"><a href="#GNU-Software" class="headerlink" title="GNU Software"></a>GNU Software</h3><p><a href="https://www.gnu.org/software/" target="_blank" rel="noopener">https://www.gnu.org/software/</a></p><h3 id="groff"><a href="#groff" class="headerlink" title="groff"></a>groff</h3><p><a href="https://www.gnu.org/software/groff/" target="_blank" rel="noopener">https://www.gnu.org/software/groff/</a></p><p>Groff (GNU troff) is a typesetting system that reads plain text mixed with formatting commands and produces formatted output. </p><h3 id="texinfo"><a href="#texinfo" class="headerlink" title="texinfo"></a>texinfo</h3><p><a href="https://www.gnu.org/software/texinfo/" target="_blank" rel="noopener">https://www.gnu.org/software/texinfo/</a></p><p>Texinfo is the official documentation format of the GNU project. It is used by many non-GNU projects as well.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;GNU&quot;&gt;&lt;a href=&quot;#GNU&quot; class=&quot;headerlink&quot; title=&quot;GNU&quot;&gt;&lt;/a&gt;GNU&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.gnu.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GNU is an operating system that is &lt;a href=&quot;https://www.gnu.org/philosophy/free-sw.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;free software&lt;/a&gt;—that is, it respects users’ freedom. The GNU operating system consists of GNU packages (programs specifically released by the GNU Project) as well as free software released by third parties. The development of GNU made it possible to use a computer without software that would trample your freedom.&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Linux下如何有效使用帮助命令</title>
    <link href="http://liujunming.github.io/2021/03/29/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/"/>
    <id>http://liujunming.github.io/2021/03/29/Linux下如何有效使用帮助命令/</id>
    <published>2021-03-29T07:45:07.000Z</published>
    <updated>2021-03-30T10:51:17.708Z</updated>
    
    <content type="html"><![CDATA[<p>建议阅读如下参考资料:</p><ol><li><a href="https://www.jianshu.com/p/1ab03290f8bc" target="_blank" rel="noopener">linux：帮助命令help、man、info</a></li><li><a href="https://unix.stackexchange.com/questions/19451/difference-between-help-info-and-man-command/159817" target="_blank" rel="noopener">Difference between help, info and man command</a></li></ol><ul><li><p>For help page of  <code>tig</code>, type <code>tig --help</code></p></li><li><p>When you enter <code>tig</code>, type <code>h</code> key for more detailed info.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;建议阅读如下参考资料:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/1ab03290f8bc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;linux：帮助命令help、man、info&lt;/a&gt;&lt;/li&gt;
      
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第20期</title>
    <link href="http://liujunming.github.io/2021/03/27/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC20%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/03/27/每周分享第20期/</id>
    <published>2021-03-27T10:42:41.000Z</published>
    <updated>2021-03-27T14:07:57.655Z</updated>
    
    <content type="html"><![CDATA[<h3 id="101"><a href="#101" class="headerlink" title="101"></a>101</h3><p><a href="https://en.wikipedia.org/wiki/101_(topic)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/101_(topic)</a><br>101 (pronounced “one-oh-one”) is a topic for beginners in any area. It has all the basic principles and concepts that are expected in a particular field.</p><a id="more"></a><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p><a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Universally_unique_identifier</a><br>A universally unique identifier (UUID) is a 128-bit number used to identify information in computer systems. The term globally unique identifier (GUID) is also used, typically in software created by Microsoft.</p><p><strong>UUIDs</strong> are generally <strong>used for</strong> identifying information that needs to be unique within a system or network thereof. Their uniqueness and low probability in being repeated makes them useful for being associative keys in databases and identifiers for physical hardware within an organization.</p><h3 id="SpanDB"><a href="#SpanDB" class="headerlink" title="SpanDB"></a>SpanDB</h3><p><a href="https://github.com/SpanDB/SpanDB" target="_blank" rel="noopener">https://github.com/SpanDB/SpanDB</a></p><p>SpanDB: A Fast, Cost-Effective LSM-tree Based KV Store on Hybrid Storage</p><h3 id="posix-error-code"><a href="#posix-error-code" class="headerlink" title="posix error code"></a>posix error code</h3><p><a href="https://man7.org/linux/man-pages/man3/errno.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/errno.3.html</a><br><a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html" target="_blank" rel="noopener">https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html</a></p><h3 id="usbserial-pl2303"><a href="#usbserial-pl2303" class="headerlink" title="usbserial/pl2303"></a>usbserial/pl2303</h3><p><a href="https://os.mbed.com/handbook/USBSerial" target="_blank" rel="noopener">USBSerial</a> interface is used to emulate a serial port over USB. </p><p>Prolific (PL2303) adapter is an common solution about USB to Serial port adapters.</p><h3 id="Intel-VTune"><a href="#Intel-VTune" class="headerlink" title="Intel VTune"></a>Intel VTune</h3><p><a href="https://software.intel.com/content/www/us/en/develop/tools/oneapi/components/vtune-profiler.html" target="_blank" rel="noopener">https://software.intel.com/content/www/us/en/develop/tools/oneapi/components/vtune-profiler.html</a><br>Intel® VTune™ Profiler optimizes application performance, system performance, and system configuration for HPC, cloud, IoT, media, storage, and more.</p><h3 id="Kata-Container-介绍"><a href="#Kata-Container-介绍" class="headerlink" title="Kata Container 介绍"></a>Kata Container 介绍</h3><p><a href="https://www.cnblogs.com/qccz123456/p/10978505.html" target="_blank" rel="noopener">https://www.cnblogs.com/qccz123456/p/10978505.html</a></p><h3 id="Github-项目与-Travis-CI-集成"><a href="#Github-项目与-Travis-CI-集成" class="headerlink" title="Github 项目与 Travis CI 集成"></a>Github 项目与 Travis CI 集成</h3><p><a href="https://lingxiankong.github.io/2018-06-28-travis-ci-integration.html" target="_blank" rel="noopener">https://lingxiankong.github.io/2018-06-28-travis-ci-integration.html</a><br>要知道什么是 Travis CI，首先要知道什么是持续集成。持续集成，Continuous Integration，简称CI，意思是，在一个项目中，任何人对代码库的任何改动，都会触发CI服务器自动对项目进行构建，自动运行测试，自动编译，甚至自动部署到测试环境。这样做的好处就是，随时发现问题，随时修复。因为修复问题的成本随着时间的推移而增长，越早发现，修复成本越低。</p><p>Travis CI 是在线托管的CI服务，用Travis来进行持续集成，不需要自己搭服务器，在网页上点几下就好，用起来更方便。最重要的是，Travis CI 对 Github 友好，这也是很多程序员喜欢 Travis CI 的理由。写完代码，提交，让 Traivs CI 跑自动化测试，或者 repo 收到 PR 时也会自动跑测试，repo owner 自然就根据测试结果决定是否 review，提高效率。</p><h3 id="Question-on-MMIO-for-a-PCI-device"><a href="#Question-on-MMIO-for-a-PCI-device" class="headerlink" title="Question on MMIO for a PCI device"></a>Question on MMIO for a PCI device</h3><p><a href="https://community.osr.com/discussion/143641/question-on-mmio-for-a-pci-device" target="_blank" rel="noopener">https://community.osr.com/discussion/143641/question-on-mmio-for-a-pci-device</a><br><a href="/pdf/Question on MMIO for a PCI device — OSR.pdf">Question on MMIO for a PCI device</a></p><h3 id="Junfeng-Yang"><a href="#Junfeng-Yang" class="headerlink" title="Junfeng Yang"></a>Junfeng Yang</h3><p><a href="http://www.cs.columbia.edu/~junfeng/" target="_blank" rel="noopener">http://www.cs.columbia.edu/~junfeng/</a></p><h3 id="十年，阿里云重构“计算”"><a href="#十年，阿里云重构“计算”" class="headerlink" title="十年，阿里云重构“计算”"></a>十年，阿里云重构“计算”</h3><p><a href="https://mp.weixin.qq.com/s/RECOMlm46-yaFbEgwlH6iA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/RECOMlm46-yaFbEgwlH6iA</a></p><h3 id="ghproxy-com"><a href="#ghproxy-com" class="headerlink" title="ghproxy.com"></a><a href="http://ghproxy.com" target="_blank" rel="noopener">ghproxy.com</a></h3><p>GitHub 文件 , Releases , archive 以及 raw.githubusercontent.com 文件加速下载服务</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;101&quot;&gt;&lt;a href=&quot;#101&quot; class=&quot;headerlink&quot; title=&quot;101&quot;&gt;&lt;/a&gt;101&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/101_(topic)&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://en.wikipedia.org/wiki/101_(topic)&lt;/a&gt;&lt;br&gt;101 (pronounced “one-oh-one”) is a topic for beginners in any area. It has all the basic principles and concepts that are expected in a particular field.&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化学习心得:three context</title>
    <link href="http://liujunming.github.io/2021/03/20/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97-three-context/"/>
    <id>http://liujunming.github.io/2021/03/20/虚拟化学习心得-three-context/</id>
    <published>2021-03-20T11:40:49.000Z</published>
    <updated>2021-03-20T12:19:16.876Z</updated>
    
    <content type="html"><![CDATA[<p>在虚拟化的学习过程中，对于特权资源，必须知道三个 context: virtual context, shadow context and physical context。同时需要具有如下两个mindsets:</p><ol><li>Know what is done by hardware, what is done by software</li><li>Know what is done in root mode, what is done in non-root mode<a id="more"></a></li></ol><p>详细的讲解可以参考<a href="/pdf/virtualization_basic_concept_discussion.pdf">Basic Concepts of Virtualization</a>。若有疑问，可邮箱联系作者：<a href="mailto:ljm0910@mail.ustc.edu.cn" target="_blank" rel="noopener">ljm0910@mail.ustc.edu.cn</a>。</p><p>看完slides后，读者可以尝试回答:The motivation of MSR area mechanism?</p><p>Answer:<br>Let’s take MSR_IA32_TSC_AUX as an example. We need its virtual context is different from physical context. If shadow context equals physical context, Each time guest wants to read this MSR, VM Exit needs to happen(read MSR maybe a frequent operation). This method may impact system performance.</p><p>So it is better to use guest/host field in the MSR area for performance. BTW, use guest/host field in the MSR area, the shadow context can be different from the physical context. So we don’t need to trap MSR_IA32_TSC_AUX.  So, MSR area mechanism is to provide host/guest field to the MSR, the hypervisor can use this host/guest field to separate shadow context from physical context.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在虚拟化的学习过程中，对于特权资源，必须知道三个 context: virtual context, shadow context and physical context。同时需要具有如下两个mindsets:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Know what is done by hardware, what is done by software&lt;/li&gt;
&lt;li&gt;Know what is done in root mode, what is done in non-root mode
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>高级操作系统-清华大学-陈渝</title>
    <link href="http://liujunming.github.io/2021/02/09/%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-%E9%99%88%E6%B8%9D/"/>
    <id>http://liujunming.github.io/2021/02/09/高级操作系统-清华大学-陈渝/</id>
    <published>2021-02-09T14:24:39.000Z</published>
    <updated>2021-02-18T13:44:19.018Z</updated>
    
    <content type="html"><![CDATA[<h3 id="课程主页"><a href="#课程主页" class="headerlink" title="课程主页"></a>课程主页</h3><p><a href="http://os.cs.tsinghua.edu.cn/oscourse/AOS2020" target="_blank" rel="noopener">http://os.cs.tsinghua.edu.cn/oscourse/AOS2020</a><br><a id="more"></a></p><h3 id="b站资源"><a href="#b站资源" class="headerlink" title="b站资源"></a>b站资源</h3><p><a href="https://www.bilibili.com/video/BV1pC4y1x7iw" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1pC4y1x7iw</a></p><h3 id="OS2020-video"><a href="#OS2020-video" class="headerlink" title="OS2020-video"></a>OS2020-video</h3><p><a href="https://cloud.tsinghua.edu.cn/d/339de5f93d8c420ebbb7/?p=%2F&amp;mode=list" target="_blank" rel="noopener">https://cloud.tsinghua.edu.cn/d/339de5f93d8c420ebbb7/?p=%2F&amp;mode=list</a></p><h3 id="云学堂"><a href="#云学堂" class="headerlink" title="云学堂"></a>云学堂</h3><p><a href="https://www.xuetangx.com/course/thu080917777/3234209" target="_blank" rel="noopener">https://www.xuetangx.com/course/thu080917777/3234209</a><br>本课程主要围绕操作系统相关研究领域的经典和前沿论文和研究成果进行讲解。大致课程内容如下：</p><p>Lec 1 Advanced OS Overview:</p><ol><li>Course Overview</li><li>Course Scheduling</li><li>Rethink OS Components</li><li>Tendency of OS – Performance</li><li>Tendency of OS – Reliability</li><li>Tendency of OS – Correctness</li><li>Summary</li></ol><p>Lec 2 OS Architecture</p><ol><li>History of OS Architecture – THE</li><li>Monolithic Kernel – UNIX</li><li>Micro Kernel – L4</li><li>ExoKernel</li><li>Extensible Kernel</li><li>Summary</li></ol><p>Lec 3+4 System Virtualization Overview</p><ol><li>Introduction</li><li>Traditional Virtualization Challenges</li><li>Virtualization Technologies -CPU</li><li>Virtualization Technologies -Mmeory</li><li>Virtualization Technologies -I/O</li><li>Some VMMs</li><li>Summary</li></ol><p>Lec 5+6 OS/System API/Interface</p><ol><li>Introduction</li><li>Rethinking the Library OS from the Top Down</li><li>DPDK: Accelerating the I/O Path</li><li>Dune: Safe User-level Access to Privileged CPU Features</li><li>Safe and Secure Drivers in High-Level Languages</li><li>Summary</li></ol><p>Lec 7+8 OS for MultiCore Architecture</p><ol><li>Introduction</li><li>How to analyze the OS bottleneck for multicore arch</li><li>How to optimize the OS for multicore arch</li><li>Optimizing the OS performance from MIT’s research</li><li>Scalable Kernel TCP Design and Implementation for Short-Lived Connections</li><li>Summary</li></ol><p>Lec 9+10 OS/System Security</p><ol><li>Introduction</li><li>Improving Integer Security for Systems with KINT</li><li>PF-Miner: A new paired functions mining method for Android kernel in error paths</li><li>RID: Finding Reference Count Bugs with Inconsistent Path Pair Checking</li><li>Summary</li></ol><p>Lec 11+12 Correctness: OS/System Verification</p><ol><li>Introduction</li><li>seL4: Formal Verification of an OS Kernel</li><li>Jitk: A trustworthy in-kernel interpreter infrastructure</li><li>Hyperkernel: Push-Button Verification of an OS Kernel</li><li>Summary</li></ol><p>Lec 13+14 OS Kernel and HLL</p><ol><li>Introduction</li><li>Multiprogramming a 64 kB Computer Safely and Efficiently</li><li>The benefits and costs of writing a POSIX kernel in a high-level language</li><li>Summary</li></ol><p>Lec 15+16 Invited Talks From Visitors &amp; Students</p><ol><li>High-Performance Network Optimization on Data Center</li><li>Security OS Design for  Multi-tenancy</li><li>OS Performance Optimization for Serverless Service</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;课程主页&quot;&gt;&lt;a href=&quot;#课程主页&quot; class=&quot;headerlink&quot; title=&quot;课程主页&quot;&gt;&lt;/a&gt;课程主页&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://os.cs.tsinghua.edu.cn/oscourse/AOS2020&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://os.cs.tsinghua.edu.cn/oscourse/AOS2020&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://liujunming.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://liujunming.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>软技巧合集</title>
    <link href="http://liujunming.github.io/2021/02/09/%E8%BD%AF%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/"/>
    <id>http://liujunming.github.io/2021/02/09/软技巧合集/</id>
    <published>2021-02-09T06:21:29.000Z</published>
    <updated>2021-03-30T10:51:17.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="The-Essence-of-Programming"><a href="#The-Essence-of-Programming" class="headerlink" title="The Essence of Programming"></a>The Essence of Programming</h3><p><a href="https://www.gingerbill.org/article/2021/02/01/the-essence-of-programming/" target="_blank" rel="noopener">https://www.gingerbill.org/article/2021/02/01/the-essence-of-programming/</a><br><a id="more"></a></p><h3 id="5W1H"><a href="#5W1H" class="headerlink" title="5W1H"></a>5W1H</h3><p><a href="https://zhuanlan.zhihu.com/p/53393292" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53393292</a></p><p><a href="https://www.humanperf.com/en/blog/nowiunderstand-glossary/articles/5W1H-method" target="_blank" rel="noopener">https://www.humanperf.com/en/blog/nowiunderstand-glossary/articles/5W1H-method</a></p><h3 id="系统设计黄金法则：简单之美"><a href="#系统设计黄金法则：简单之美" class="headerlink" title="系统设计黄金法则：简单之美"></a>系统设计黄金法则：简单之美</h3><p><a href="http://blog.sciencenet.cn/blog-414166-562616.html" target="_blank" rel="noopener">http://blog.sciencenet.cn/blog-414166-562616.html</a></p><h3 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h3><p><a href="https://zhuanlan.zhihu.com/p/118183282" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/118183282</a></p><p><a href="https://www.youtube.com/watch?v=hh9kFKVKpSM" target="_blank" rel="noopener">从学渣到博士：一个学习方法改变我的命运，自创2.0版费曼学习法</a></p><h3 id="What-is-Applied-Category-Theory"><a href="#What-is-Applied-Category-Theory" class="headerlink" title="What is Applied Category Theory?"></a>What is Applied Category Theory?</h3><p><a href="https://arxiv.org/pdf/1809.05923.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1809.05923.pdf</a></p><p> 什么是应用范畴论？</p><p>这是一本关于应用范畴理论的介绍性、解释性笔记集，灵感来自2018年应用范畴理论研讨会，在这些笔记中，我们悠闲地漫步于两个主题（功能语义和组合性），领域内的两个构造（单倍体范畴和修饰cospans）和两个例子（化学反应网络和自然语言处理）  </p><h3 id="如何高效地使用搜索引擎？"><a href="#如何高效地使用搜索引擎？" class="headerlink" title="如何高效地使用搜索引擎？"></a>如何高效地使用搜索引擎？</h3><p><a href="https://www.zhihu.com/question/28013848/answer/62475371" target="_blank" rel="noopener">https://www.zhihu.com/question/28013848/answer/62475371</a></p><h3 id="发现bug的心得"><a href="#发现bug的心得" class="headerlink" title="发现bug的心得"></a>发现bug的心得</h3><p>排列组合所有情况，同时注意corner case，比如边界值。然后给定输入，看看实际的输出与期待的输出是否有差距。写dmar command register就是一个教训，没有考虑初始值，需要将那四位清零之后，再保存到软件的缓存值，否则可能会违背vt-d的spec。<br>分析出各种状态以及状态之间的转换情况，逐个去分析。比如disable physical msi的位置，要考虑到之前的physical msi是enable的，如果放发错位置，那么，当guest disable MSI时，物理的MSI可能并不会disable掉，这就引入了新的bug。<a href="https://lists.projectacrn.org/g/acrn-dev/topic/patch_v3_hv_vpci_fix_msi/81519474?p=,,,20,0,0,0::recentpostdate%2Fsticky,,,20,2,0,81519474" target="_blank" rel="noopener">hv: vpci: fix msi enable issue under some cases</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;The-Essence-of-Programming&quot;&gt;&lt;a href=&quot;#The-Essence-of-Programming&quot; class=&quot;headerlink&quot; title=&quot;The Essence of Programming&quot;&gt;&lt;/a&gt;The Essence of Programming&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.gingerbill.org/article/2021/02/01/the-essence-of-programming/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.gingerbill.org/article/2021/02/01/the-essence-of-programming/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化学习心得:learn from native</title>
    <link href="http://liujunming.github.io/2021/02/04/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97-learn-from-native/"/>
    <id>http://liujunming.github.io/2021/02/04/虚拟化学习心得-learn-from-native/</id>
    <published>2021-02-04T15:35:28.000Z</published>
    <updated>2021-02-06T14:30:50.061Z</updated>
    
    <content type="html"><![CDATA[<p>在虚拟化场景下，遇到复杂的case，可能不知道如何处理。learn from native可能是一个突破口。何为native呢？本文指的是非虚拟化场景下，该case的行为（读者需要清楚：什么operation由硬件完成，什么operation由软件完成）。<a id="more"></a></p><p>读者可能会觉得上面的话很抽象，本文将以一个例子阐述该思想。</p><h3 id="1-Background-behavior-in-native"><a href="#1-Background-behavior-in-native" class="headerlink" title="1. Background(behavior in native)"></a>1. Background(behavior in native)</h3><p>读者需要阅读<a href="/2021/02/03/Notes-about-instruction-boundaries/">Notes about instruction boundaries</a>。</p><blockquote><p>If more than one exception or interrupt is pending at an instruction boundary, the processor services them in a predictable order. Table 6-2 shows the priority among classes of exception and interrupt sources. </p></blockquote><p><img src="/images/2021/01/2.PNG" alt></p><p><img src="/images/2021/01/3.PNG" alt></p><blockquote><p>The processor first services a pending exception or interrupt from the class which has the highest priority, transferring execution to the first instruction of the handler. Lower priority exceptions are discarded; lower priority interrupts are held pending. Discarded exceptions are re-generated when the interrupt handler returns execution to the point in the program or task where the exceptions and/or interrupts occurred. </p></blockquote><p>SDM对于Simultaneous Exceptions and Interrupts 给出了描述。接下来将以一个具体的例子阐述相关知识点。</p><p>在native环境下，假设当前CPU会执行<code>rdmsr</code>指令，<code>rdmsr</code>指令的执行时间为5个cycle，并且<code>rdsmr</code>指令会产生#GP。当CPU执行<code>rdmsr</code>到第3个cycle时，外部设备向该CPU发送了一个Maskable Hardware Interrupt。那么，接下来的硬件行为是什么呢？</p><p>当CPU执行完<code>rdmsr</code>指令后，由于Maskable Hardware Interrupt的优先级高于#GP，因此CPU会丢弃#GP,优先处理Maskable Hardware Interrupt。当Maskable Hardware Interrupt处理完之后，硬件会re-generate  #GP。</p><h3 id="2-Is-Simultaneous-Exceptions-and-Interrupts-behavior-in-virtualization"><a href="#2-Is-Simultaneous-Exceptions-and-Interrupts-behavior-in-virtualization" class="headerlink" title="2. Is Simultaneous Exceptions and Interrupts?(behavior  in virtualization)"></a>2. Is Simultaneous Exceptions and Interrupts?(behavior  in virtualization)</h3><p>假设在虚拟化场景下：</p><ol><li>当前CPU只运行一个vCPU thread</li><li>当前CPU的LAPIC pass-thru给vCPU</li><li>在root mode下，hv会关中断</li><li>在non-root mode下，当vCPU执行<code>rdmsr</code>时，会发生VM Exit，hv将为vCPU注入#GP</li><li>在root下，当hv为vCPU注入#GP时，外部设备向该CPU发送了一个Maskable Hardware Interrupt</li></ol><p>那么，读者可以尝试回答如下问题：</p><p>在guest看来，Maskable Hardware Interrupt和#GP是Simultaneous Exceptions and Interrupts吗？</p><p>实验结果如下：当进入non-root mode后，vCPU会先处理#GP，然后处理Maskable Hardware Interrupt。由此可见，在guest看来，Maskable Hardware Interrupt和#GP<strong>不是</strong>Simultaneous Exceptions and Interrupts。</p><p>为什么？此时，learn from native的方案就派上用场了。在native环境下，Maskable Hardware Interrupt和#GP pending at an instruction boundary时，硬件才会将Maskable Hardware Interrupt和#GP当作Simultaneous Exceptions and Interrupts。在我们的这个例子中，当guest执行完<code>rdmsr</code>指令后，根据instruction boundary，以guest的视角来看，硬件会立刻为其注入#GP，而Maskable Hardware Interrupt是在guest执行完<code>rdmsr</code>指令后产生的，因此，在guest看来，Maskable Hardware Interrupt和#GP<strong>不是</strong>Simultaneous Exceptions and Interrupts。</p><h3 id="3-Rethinking"><a href="#3-Rethinking" class="headerlink" title="3. Rethinking"></a>3. Rethinking</h3><p>假设在虚拟化场景下：</p><ol><li>当前CPU只运行一个vCPU thread</li><li>当前CPU的LAPIC pass-thru给vCPU</li><li>在non-root mode下，当vCPU执行<code>rdmsr</code>时（执行时间为5个cycle），会发生VM Exit，hv将为vCPU注入#GP</li><li>在non-root mode下，当vCPU执行<code>rdmsr</code>到第3个cycle时时，外部设备向该CPU发送了一个Maskable Hardware Interrupt</li></ol><p>那么，读者可以尝试回答如下问题：</p><p>在guest看来，Maskable Hardware Interrupt和#GP是Simultaneous Exceptions and Interrupts吗？</p><p>利用learn from native的方案可知，在guest看来，Maskable Hardware Interrupt和#GP是Simultaneous Exceptions and Interrupts。</p><p>问题又来了，在虚拟化环境下，是如何保证Discarded exceptions are re-generated when the interrupt handler returns execution to the point in the program or task where the exceptions and/or interrupts occurred？</p><p>在non-root mode下，当vCPU处理完Maskable Hardware Interrupt后，RIP寄存器会保证vCPU再执行一次<code>rdmsr</code>指令，那么，就会发生VM Exit，hv会给vCPU 注入#GP。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在虚拟化场景下，遇到复杂的case，可能不知道如何处理。learn from native可能是一个突破口。何为native呢？本文指的是非虚拟化场景下，该case的行为（读者需要清楚：什么operation由硬件完成，什么operation由软件完成）。
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Notes about instruction boundaries</title>
    <link href="http://liujunming.github.io/2021/02/03/Notes-about-instruction-boundaries/"/>
    <id>http://liujunming.github.io/2021/02/03/Notes-about-instruction-boundaries/</id>
    <published>2021-02-03T06:47:53.000Z</published>
    <updated>2021-02-06T14:30:50.060Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/leoufung/article/details/48828197" target="_blank" rel="noopener">Intel的instruction boundaries是什么</a><br><a id="more"></a></p><p>SDM中<code>instruction boundaries</code>一词经常出现。如<code>All interrupts are guaranteed to be taken on an instruction boundary</code>。 那么什么是指令的边界呢?一个指令会有边界吗? </p><p>在X86中, 使用的是非精简指令,会占用很多的cycle才可以完成一条指令,而且不同的指令占用的cycle数是不同的,复杂的指令会占用很多的cycle才可以完成; 而ARM指令的执行占用固定的cycle。</p><p>这里说的是中断会发生在指令的边界上。也就是说, 假如一个复杂的指令需要100个cycle才可以完成逻辑, 但是在第50个cycle发生了中断, 那么中断也会在执行完整个逻辑, 在第100cycle的地方才发生, 而不会在第50cycle的地方立即发生。</p><p>OK,理解了之后,看下面这句话, <code>Interrupts are taken at instruction boundaries located during the retirement phase of instruction execution;</code>  这下就好理解了, 中断发生在指令边界上, 也就是发生在指令的”完成阶段”, 完成阶段就是上面指的第100个cycle处。</p><h3 id="VM-Exit发生在指令边界上吗？"><a href="#VM-Exit发生在指令边界上吗？" class="headerlink" title="VM Exit发生在指令边界上吗？"></a>VM Exit发生在指令边界上吗？</h3><p>个人认为VM Exit发生在指令边界上。<br><a href="https://revers.engineering/day-5-vmexits-interrupts-cpuid-emulation/" target="_blank" rel="noopener">https://revers.engineering/day-5-vmexits-interrupts-cpuid-emulation/</a></p><p><img src="/images/2021/01/4.PNG" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/leoufung/article/details/48828197&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Intel的instruction boundaries是什么&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="体系结构" scheme="http://liujunming.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第19期</title>
    <link href="http://liujunming.github.io/2021/01/28/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC19%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/01/28/每周分享第19期/</id>
    <published>2021-01-28T01:33:39.000Z</published>
    <updated>2021-02-03T14:12:58.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Intel-Appoints-Sunil-Shenoy-as-Senior-Vice-President-of-Design-Engineering-Group"><a href="#Intel-Appoints-Sunil-Shenoy-as-Senior-Vice-President-of-Design-Engineering-Group" class="headerlink" title="Intel Appoints Sunil Shenoy as Senior Vice President of Design Engineering Group"></a>Intel Appoints Sunil Shenoy as Senior Vice President of Design Engineering Group</h3><p><a href="https://newsroom.intel.com/news-releases/intel-appoints-sunil-shenoy-senior-vice-president-design-engineering-group/" target="_blank" rel="noopener">https://newsroom.intel.com/news-releases/intel-appoints-sunil-shenoy-senior-vice-president-design-engineering-group/</a><br><a id="more"></a></p><h3 id="ACRN-TCM"><a href="#ACRN-TCM" class="headerlink" title="ACRN TCM"></a>ACRN TCM</h3><p><a href="https://drive.google.com/drive/folders/1_XTGu6re3BOQAjtPx636Mz1T5lOy2UWC" target="_blank" rel="noopener">https://drive.google.com/drive/folders/1_XTGu6re3BOQAjtPx636Mz1T5lOy2UWC</a></p><h3 id="Zhenyuan-Ruan"><a href="#Zhenyuan-Ruan" class="headerlink" title="Zhenyuan Ruan"></a>Zhenyuan Ruan</h3><p><a href="https://zainryan.github.io/" target="_blank" rel="noopener">https://zainryan.github.io/</a></p><h3 id="Accessing-PCI-Express-Configuration-Registers-Using-Intel®-Chipsets"><a href="#Accessing-PCI-Express-Configuration-Registers-Using-Intel®-Chipsets" class="headerlink" title="Accessing PCI Express Configuration Registers Using Intel® Chipsets"></a>Accessing PCI Express Configuration Registers Using Intel® Chipsets</h3><p><a href="http://www.csit-sun.pub.ro/~cpop/Documentatie_SMP/Intel_Microprocessor_Systems/Intel_ProcessorNew/Intel%20White%20Paper/Accessing%20PCI%20Express%20Configuration%20Registers%20Using%20Intel%20Chipsets.pdf" target="_blank" rel="noopener">http://www.csit-sun.pub.ro/~cpop/Documentatie_SMP/Intel_Microprocessor_Systems/Intel_ProcessorNew/Intel%20White%20Paper/Accessing%20PCI%20Express%20Configuration%20Registers%20Using%20Intel%20Chipsets.pdf</a></p><h3 id="Intel®-5100-Memory-Controller-Hub-Chipset-Datasheet"><a href="#Intel®-5100-Memory-Controller-Hub-Chipset-Datasheet" class="headerlink" title="Intel® 5100 Memory Controller Hub Chipset Datasheet"></a>Intel® 5100 Memory Controller Hub Chipset Datasheet</h3><p><a href="https://www.intel.com/content/dam/doc/datasheet/5100-memory-controller-hub-chipset-datasheet.pdf" target="_blank" rel="noopener">https://www.intel.com/content/dam/doc/datasheet/5100-memory-controller-hub-chipset-datasheet.pdf</a><br>Includes details for I/O Address: CF8h &amp; CFCh</p><h3 id="Windows-10-X"><a href="#Windows-10-X" class="headerlink" title="Windows 10 X"></a>Windows 10 X</h3><p>Windows 10 X （微软全新操作系统）安装教程与体验！<br><a href="https://www.youtube.com/watch?v=N9aRsV_2uRE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=N9aRsV_2uRE</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Intel-Appoints-Sunil-Shenoy-as-Senior-Vice-President-of-Design-Engineering-Group&quot;&gt;&lt;a href=&quot;#Intel-Appoints-Sunil-Shenoy-as-Senior-Vice-President-of-Design-Engineering-Group&quot; class=&quot;headerlink&quot; title=&quot;Intel Appoints Sunil Shenoy as Senior Vice President of Design Engineering Group&quot;&gt;&lt;/a&gt;Intel Appoints Sunil Shenoy as Senior Vice President of Design Engineering Group&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://newsroom.intel.com/news-releases/intel-appoints-sunil-shenoy-senior-vice-president-design-engineering-group/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://newsroom.intel.com/news-releases/intel-appoints-sunil-shenoy-senior-vice-president-design-engineering-group/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第18期</title>
    <link href="http://liujunming.github.io/2021/01/21/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC18%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/01/21/每周分享第18期/</id>
    <published>2021-01-21T08:02:20.000Z</published>
    <updated>2021-01-24T07:38:51.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nvidia为什么收购Mellanox？"><a href="#Nvidia为什么收购Mellanox？" class="headerlink" title="Nvidia为什么收购Mellanox？"></a>Nvidia为什么收购Mellanox？</h3><p><a href="https://www.jiqizhixin.com/articles/2019-03-15-13" target="_blank" rel="noopener">https://www.jiqizhixin.com/articles/2019-03-15-13</a></p><a id="more"></a><h3 id="AMD收购赛灵思（Xilinx）"><a href="#AMD收购赛灵思（Xilinx）" class="headerlink" title="AMD收购赛灵思（Xilinx）"></a>AMD收购赛灵思（Xilinx）</h3><p><a href="https://www.sdnlab.com/24506.html" target="_blank" rel="noopener">https://www.sdnlab.com/24506.html</a></p><h3 id="xilinx-和-altera-两家公司的主要区别和各自优势分别是什么？"><a href="#xilinx-和-altera-两家公司的主要区别和各自优势分别是什么？" class="headerlink" title="xilinx 和 altera 两家公司的主要区别和各自优势分别是什么？"></a>xilinx 和 altera 两家公司的主要区别和各自优势分别是什么？</h3><p><a href="https://www.zhihu.com/question/31440109" target="_blank" rel="noopener">https://www.zhihu.com/question/31440109</a></p><h3 id="HW-hardware-accelerator"><a href="#HW-hardware-accelerator" class="headerlink" title="HW(hardware) accelerator"></a>HW(hardware) accelerator</h3><p><a href="https://blog.mellanox.com/2018/08/defining-smartnic/" target="_blank" rel="noopener">https://blog.mellanox.com/2018/08/defining-smartnic/</a></p><p>Mellanox,Huawei,Xilinx,Intel</p><h3 id="Chrome-tracing"><a href="#Chrome-tracing" class="headerlink" title="Chrome tracing"></a>Chrome tracing</h3><p><a href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool" target="_blank" rel="noopener">https://www.chromium.org/developers/how-tos/trace-event-profiling-tool</a></p><h3 id="specVirt"><a href="#specVirt" class="headerlink" title="specVirt"></a>specVirt</h3><p><a href="https://www.spec.org/virt_sc2013/" target="_blank" rel="noopener">https://www.spec.org/virt_sc2013/</a><br>The SPEC virt_sc ® 2013 benchmark suites are used to measure performance of virtualized platforms. </p><h3 id="self-contained-meaning"><a href="#self-contained-meaning" class="headerlink" title="self-contained meaning"></a>self-contained meaning</h3><p><a href="https://www.yourdictionary.com/self-contained" target="_blank" rel="noopener">https://www.yourdictionary.com/self-contained</a><br>The definition of self contained refers to something or someone that is complete on its own and that doesn’t need anything else.</p><h3 id="Zhaorong-Hou-Intel公司资深工程经理"><a href="#Zhaorong-Hou-Intel公司资深工程经理" class="headerlink" title="Zhaorong Hou, Intel公司资深工程经理"></a>Zhaorong Hou, Intel公司资深工程经理</h3><p><a href="https://www.youtube.com/watch?v=yKVG9jYOwz8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=yKVG9jYOwz8</a></p><h3 id="经济机器是怎样运行的"><a href="#经济机器是怎样运行的" class="headerlink" title="经济机器是怎样运行的"></a>经济机器是怎样运行的</h3><p><a href="https://www.youtube.com/watch?v=rFV7wdEX-Mo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=rFV7wdEX-Mo</a></p><h3 id="x2APIC-Virtualization-and-Posted-Interrupt-Processing"><a href="#x2APIC-Virtualization-and-Posted-Interrupt-Processing" class="headerlink" title="x2APIC Virtualization and Posted Interrupt Processing"></a>x2APIC Virtualization and Posted Interrupt Processing</h3><p><a href="https://cs.stanford.edu/~jhumphri/documents/x2apic-posted-ipi.pdf" target="_blank" rel="noopener">https://cs.stanford.edu/~jhumphri/documents/x2apic-posted-ipi.pdf</a></p><p><a href="/pdf/x2apic-posted-ipi.pdf">x2APIC Virtualization and Posted Interrupt Processing</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Nvidia为什么收购Mellanox？&quot;&gt;&lt;a href=&quot;#Nvidia为什么收购Mellanox？&quot; class=&quot;headerlink&quot; title=&quot;Nvidia为什么收购Mellanox？&quot;&gt;&lt;/a&gt;Nvidia为什么收购Mellanox？&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.jiqizhixin.com/articles/2019-03-15-13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jiqizhixin.com/articles/2019-03-15-13&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Deep into CR0/CR4 in VMX operation</title>
    <link href="http://liujunming.github.io/2020/12/26/Deep-into-CR0-CR4-in-VMX-operation/"/>
    <id>http://liujunming.github.io/2020/12/26/Deep-into-CR0-CR4-in-VMX-operation/</id>
    <published>2020-12-26T05:12:10.000Z</published>
    <updated>2021-01-24T07:38:51.961Z</updated>
    
    <content type="html"><![CDATA[<p>In VMX operation, the value of guest CR0/CR4 need to consider the following cases:</p><ol><li>processors may fix certain bits in CR0 and CR4 to specific values and not support other values. </li><li>Guest/Host Masks and Read Shadows for CR0 and CR4</li></ol><a id="more"></a><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><p>For the first case, you can refer to intel SDM Vol. 3D A.7(<strong>VMX-FIXED BITS IN CR0</strong>) and A.8(<strong>VMX-FIXED BITS IN CR4</strong>).</p><p>We’ll deep into the second case.</p><p><img src="/images/2020/12/3.PNG" alt></p><p>From the description, please try to answer this question: Why needs the <strong>guest/host masks</strong>  and <strong>read shadow</strong>?</p><p>Let’s consider this example:</p><p><img src="/images/2020/12/4.PNG" alt></p><p>From SDM description, CR4.VMXE must be 1 in VMX operation. Without <strong>guest/host masks</strong> and <strong>read shadow</strong>, if guest is a normal operating system, not a VMM, when guest want to get CR4.VMXE, it would be 1. That’s the wrong value for guest. But we still need to ensure physical CR4.VMXE is1 in non-root mode!</p><p>How can we satisfy all the above requirements?</p><p><strong>guest/host masks</strong> and <strong>read shadow</strong> help us solve the issue.</p><ol><li><p>set VMCS Guest CR4(00006804H ) field VMXE bit to be 1, to ensure physical CR4.VMXE  is 1 in non-root mode;</p></li><li><p>set CR4 guest/host masks(00006002H ) field VMXE bit to be 1, means VMXE bit is owned by host;</p></li><li>set CR4 read shadow(00006006H ) field VMXE bit to be 0.</li></ol><p>When guest reads CR4.VMXE, hardware will return value for this bit from the corresponding read shadow(the value is 0 here). While physical CR4.VMXE  still is 1 in non-root mode.</p><h3 id="2-Example"><a href="#2-Example" class="headerlink" title="2. Example"></a>2. Example</h3><p>Let’s take <a href="https://github.com/projectacrn/acrn-hypervisor/blob/acrn-2020w51.5-180000p/hypervisor/arch/x86/guest/virtual_cr.c" target="_blank" rel="noopener">ACRN virtual_cr.c</a> as an example.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Physical CR4 bits in VMX operation may be either flexible or fixed.</span></span><br><span class="line"><span class="comment"> * Guest CR4 bits may be operatable or reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All the guest reserved bits should be TRAPed and EMULATed by HV</span></span><br><span class="line"><span class="comment"> * (inject #GP).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For guest operatable bits, it may be:</span></span><br><span class="line"><span class="comment"> * CR4_PASSTHRU_BITS:</span></span><br><span class="line"><span class="comment"> *Bits that may be passed through to guest. The actual passthru bits</span></span><br><span class="line"><span class="comment"> *should be masked by flexible bits.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CR4_TRAP_AND_PASSTHRU_BITS:</span></span><br><span class="line"><span class="comment"> *The bits are trapped by HV and HV emulation will eventually write</span></span><br><span class="line"><span class="comment"> *the guest value to physical CR4 (GUEST_CR4) too. The actual bits</span></span><br><span class="line"><span class="comment"> *should be masked by flexible bits.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CR4_TRAP_AND_EMULATE_BITS:</span></span><br><span class="line"><span class="comment"> *The bits are trapped by HV and emulated, but HV updates vCR4 only</span></span><br><span class="line"><span class="comment"> *(no update to physical CR4), i.e. pure software emulation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CR4_EMULATED_RESERVE_BITS:</span></span><br><span class="line"><span class="comment"> *The bits are trapped, but are emulated by injecting a #GP.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> Above bits should not overlap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_TRAP_AND_PASSTHRU_BITS(CR0_PE | CR0_PG | CR0_WP)</span></span><br></pre></td></tr></table></figure><p>CR0_PG is trapped by HV and HV emulation will eventually write the guest value to physical CR0 (GUEST_CR0) too. Can we pass through CR0_PG to guest? The answer is no!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((cr0_changed_bits &amp; CR0_PG) != <span class="number">0U</span>L) &#123;</span><br><span class="line"><span class="comment">/* PG bit changes */</span></span><br><span class="line"><span class="keyword">if</span> ((effective_cr0 &amp; CR0_PG) != <span class="number">0U</span>L) &#123;</span><br><span class="line"><span class="comment">/* Enable paging */</span></span><br><span class="line"><span class="keyword">if</span> ((vcpu_get_efer(vcpu) &amp; MSR_IA32_EFER_LME_BIT) != <span class="number">0U</span>L) &#123;</span><br><span class="line"><span class="comment">/* Enable long mode */</span></span><br><span class="line">pr_dbg(<span class="string">"VMM: Enable long mode"</span>);</span><br><span class="line">entry_ctrls = exec_vmread32(VMX_ENTRY_CONTROLS);</span><br><span class="line">entry_ctrls |= VMX_ENTRY_CTLS_IA32E_MODE;</span><br><span class="line">exec_vmwrite32(VMX_ENTRY_CONTROLS, entry_ctrls);</span><br><span class="line"></span><br><span class="line">vcpu_set_efer(vcpu, vcpu_get_efer(vcpu) | MSR_IA32_EFER_LMA_BIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here’s the reason why we set the<code>VMX_ENTRY_CTLS_IA32E_MODE</code> and <code>MSR_IA32_EFER_LMA_BIT</code>.</p><p><img src="/images/2020/12/5.PNG" alt></p><p>If pass through CR0_PG to guest, while guest runs in non-root mode, hardware couldn’t update<code>VMX_ENTRY_CONTROLS</code> field. So we should trap CR0_PG, and HV will  update<code>VMX_ENTRY_CONTROLS</code> field in root mode.</p><h3 id="3-Conclusion"><a href="#3-Conclusion" class="headerlink" title="3. Conclusion"></a>3. Conclusion</h3><p>If one bit has restriction in VMX operation or needs to do some operations in root mode, It’s better to trap(owned by host) this bit. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;In VMX operation, the value of guest CR0/CR4 need to consider the following cases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;processors may fix certain bits in CR0 and CR4 to specific values and not support other values. &lt;/li&gt;
&lt;li&gt;Guest/Host Masks and Read Shadows for CR0 and CR4&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="VT-x" scheme="http://liujunming.github.io/categories/VT-x/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-x" scheme="http://liujunming.github.io/tags/VT-x/"/>
    
  </entry>
  
  <entry>
    <title>VT-x:Relative Priority of Faults and VM Exits</title>
    <link href="http://liujunming.github.io/2020/12/01/VT-x-Relative-Priority-of-Faults-and-VM-Exits/"/>
    <id>http://liujunming.github.io/2020/12/01/VT-x-Relative-Priority-of-Faults-and-VM-Exits/</id>
    <published>2020-12-01T08:55:04.000Z</published>
    <updated>2020-12-01T14:36:04.198Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录SDM中<code>Relative Priority of Faults and VM Exits</code>一节的相关笔记。<a id="more"></a><br>The following principles describe the ordering between existing faults and VM exits:</p><ul><li>Certain exceptions have priority over VM exits. These include <strong>invalid-opcode exceptions (#UD)</strong>, <strong>faults based on privilege level</strong>, and general-protection exceptions that are based on checking I/O permission bits in the taskstate segment (TSS). For example, execution of RDMSR with CPL = 3 generates a general-protection exception and not a VM exit.</li></ul><p>以<code>XSETBV</code>instruction为例：<br><img src="/images/2020/12/2.PNG" alt></p><p>In non-root mode，if the current privileage level is not 0, VM exit won’t happen. Because <strong>faults based on privilege level</strong> has priority over VM exits.</p><p>In non-root mode，if CR4.OSXSAVE[bit 18] = 0, VM exit won’t happen. Because <strong>invalid-opcode exceptions(#UD)</strong> has priority over VM exits.</p><p>详细内容可参考patch：<a href="https://github.com/projectacrn/acrn-hypervisor/commit/56eb859ea4e3af1edbd15b80276e9f2404a43e2b" target="_blank" rel="noopener">hv: vmexit: refine xsetbv_vmexit_handler API</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录SDM中&lt;code&gt;Relative Priority of Faults and VM Exits&lt;/code&gt;一节的相关笔记。
    
    </summary>
    
      <category term="VT-x" scheme="http://liujunming.github.io/categories/VT-x/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-x" scheme="http://liujunming.github.io/tags/VT-x/"/>
    
  </entry>
  
  <entry>
    <title>VT-x:Information for VM Exits During Event Delivery</title>
    <link href="http://liujunming.github.io/2020/12/01/VT-x-Information-for-VM-Exits-During-Event-Delivery/"/>
    <id>http://liujunming.github.io/2020/12/01/VT-x-Information-for-VM-Exits-During-Event-Delivery/</id>
    <published>2020-12-01T05:11:55.000Z</published>
    <updated>2020-12-01T14:37:10.379Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录SDM中<code>Information for VM Exits During Event Delivery</code>一节的相关笔记。<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p><code>Information for VM Exits That Occur During Event Delivery</code> defined fields containing information for VM exits that occur while delivering an event through the IDT and as a result of any of the following cases:</p><ul><li>A fault occurs during event delivery and causes a VM exit (because the bit associated with the fault is set to 1 in the exception bitmap).</li><li>A task switch is invoked through a task gate in the IDT. The VM exit occurs due to the task switch only after the initial checks of the task switch pass.</li><li>Event delivery causes an APIC-access VM exit.</li><li>An EPT violation, EPT misconfiguration, page-modification log-full event, or SPP-related event that occurs during event delivery.</li></ul><p>ACRN中的<a href="https://github.com/projectacrn/acrn-hypervisor/blob/v2.2/hypervisor/arch/x86/guest/vmexit.c#L183" target="_blank" rel="noopener">实现</a>如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vcpu-&gt;arch.idt_vectoring_info = exec_vmread32(VMX_IDT_VEC_INFO_FIELD);</span><br><span class="line"><span class="keyword">if</span> ((vcpu-&gt;arch.idt_vectoring_info &amp; VMX_INT_INFO_VALID) != <span class="number">0U</span>) &#123;</span><br><span class="line"><span class="keyword">uint32_t</span> vector_info = vcpu-&gt;arch.idt_vectoring_info;</span><br><span class="line"><span class="keyword">uint32_t</span> <span class="built_in">vector</span> = vector_info &amp; <span class="number">0xff</span>U;</span><br><span class="line"><span class="keyword">uint32_t</span> type = (vector_info &amp; VMX_INT_TYPE_MASK) &gt;&gt; <span class="number">8U</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> err_code = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == VMX_INT_TYPE_HW_EXP) &#123;</span><br><span class="line"><span class="keyword">if</span> ((vector_info &amp; VMX_INT_INFO_ERR_CODE_VALID) != <span class="number">0U</span>) &#123;</span><br><span class="line">err_code = exec_vmread32(VMX_IDT_VEC_ERROR_CODE);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">void</span>)vcpu_queue_exception(vcpu, <span class="built_in">vector</span>, err_code);</span><br><span class="line">vcpu-&gt;arch.idt_vectoring_info = <span class="number">0U</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == VMX_INT_TYPE_NMI) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_notification_nmi(vcpu-&gt;vm)) &#123;</span><br><span class="line">pr_dbg(<span class="string">"This NMI is used as notification signal. So ignore it."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">vcpu_make_request(vcpu, ACRN_REQUEST_NMI);</span><br><span class="line">vcpu-&gt;arch.idt_vectoring_info = <span class="number">0U</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* No action on EXT_INT or SW exception. */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>hardware exception的定义:<br><img src="/images/2020/12/1.PNG" alt></p><h3 id="2-测试用例"><a href="#2-测试用例" class="headerlink" title="2. 测试用例"></a>2. 测试用例</h3><p>对于<code>A fault occurs during event delivery and causes a VM exit</code> case，可以利用如下测试用例复现：</p><ol><li>设置guest IDT中Divide Error vector项的present位为0(to trigger NP fault)；</li><li>设置VMCS  exception bitmap field中的NP fault位为1(to trigger VM exit)；</li><li>guest执行divide 0指令。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录SDM中&lt;code&gt;Information for VM Exits During Event Delivery&lt;/code&gt;一节的相关笔记。
    
    </summary>
    
      <category term="VT-x" scheme="http://liujunming.github.io/categories/VT-x/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-x" scheme="http://liujunming.github.io/tags/VT-x/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to SR-IOV</title>
    <link href="http://liujunming.github.io/2020/10/24/Introduction-to-SR-IOV/"/>
    <id>http://liujunming.github.io/2020/10/24/Introduction-to-SR-IOV/</id>
    <published>2020-10-24T01:37:02.000Z</published>
    <updated>2020-10-25T08:45:21.038Z</updated>
    
    <content type="html"><![CDATA[<p>本文只介绍SR-IOV的基本内容，并不能cover SR-IOV的全部知识点。<a id="more"></a></p><h3 id="1-prerequisites"><a href="#1-prerequisites" class="headerlink" title="1. prerequisites"></a>1. prerequisites</h3><ol><li>需要理解VT-d的DMA remapping,interrupt remapping ,posted interrupt<ul><li><a href="/2020/10/10/VT-d-Interrupt-Remapping/">VT-d Interrupt Remapping</a></li><li><a href="/2020/10/11/VT-d-Posted-Interrupt/">VT-d Posted Interrupt</a></li></ul></li><li>需要理解PCI&amp;PCIe的config space，MSI与MSI-X.<ul><li><a href="https://tcbbd.moe/ref-and-spec/pci/" target="_blank" rel="noopener">PCI Local Bus (i.e. Conventional PCI)</a></li></ul></li><li>需要理解ATS,ACS,ARI<ul><li><a href="/2019/11/24/Introduction-to-PCIe-Address-Translation-Services/">Introduction to PCIe Address Translation Services</a></li><li><a href="/2019/11/24/Introduction-to-PCIe-Access-Control-Services/">Introduction to PCIe Access Control Services</a></li><li>PCIe Alternative Routing-ID Interpretation (ARI)<ul><li>Enable up-to 256 functions for single PCI Express component</li></ul></li></ul></li><li>PCIe config space位于MMIO空间内</li></ol><h3 id="2-motivation"><a href="#2-motivation" class="headerlink" title="2. motivation"></a>2. motivation</h3><p>推荐论文：High Performance Network Virtualization with SRIOV</p><p>可阅读<a href="https://github.com/liujunming/paper_reading_notes/issues/1" target="_blank" rel="noopener">Junming’s notes</a>。</p><p><img src="https://user-images.githubusercontent.com/11829057/97032861-0ac62400-1595-11eb-8a98-412ffb6a57b4.png" alt></p><p><img src="https://user-images.githubusercontent.com/11829057/97033169-81fbb800-1595-11eb-8db4-94d969346946.png" alt></p><p><img src="https://user-images.githubusercontent.com/11829057/97033444-f33b6b00-1595-11eb-940d-2d687db55fc7.png" alt></p><p><img src="https://user-images.githubusercontent.com/11829057/97034420-7dd09a00-1597-11eb-9027-03c31b5234ff.png" alt></p><p><img src="https://user-images.githubusercontent.com/11829057/97034474-904ad380-1597-11eb-9e00-e52f8fa7d5d1.png" alt></p><h3 id="3-details"><a href="#3-details" class="headerlink" title="3. details"></a>3. details</h3><p><strong>BIOS should be able to enumerate SR-IOV capable device and allocate MMIO (Memory mapped IO) resource for VFs.</strong></p><p><a href="https://projectacrn.github.io/latest/tutorials/sriov_virtualization.html#sr-iov-extended-capability" target="_blank" rel="noopener">SR-IOV Extended Capability</a> The SR-IOV Extended Capability defined here is a PCIe extended capability that must be implemented in each PF device that supports the SR-IOV feature. This capability is used to describe and control a PF’s SR-IOV capabilities.</p><h4 id="3-1-the-differences-between-a-normal-passthrough-device-and-SR-IOV-VF-device"><a href="#3-1-the-differences-between-a-normal-passthrough-device-and-SR-IOV-VF-device" class="headerlink" title="3.1 the differences between a normal passthrough device and SR-IOV VF device"></a>3.1 the differences between a normal passthrough device and SR-IOV VF device</h4><ol><li>physical device detection</li></ol><p>The hypervisor uses <code>Subsystem Vendor ID</code> to detect the SR-IOV VF physical device instead of <code>Vendor ID</code> since no valid <code>Vendor ID</code> exists for the SR-IOV VF physical device. </p><ol start="2"><li>BARs initialization</li></ol><p>The VF BARs are initialized by its associated PF’s SR-IOV capabilities, not PCI standard BAR registers. </p><ol start="3"><li>MSI-X initialization</li></ol><p>The MSI-X mapping base address is also from the PF’s SR-IOV capabilities, not PCI standard BAR registers.</p><h4 id="3-2-VF的bdf-number如何分配"><a href="#3-2-VF的bdf-number如何分配" class="headerlink" title="3.2 VF的bdf number如何分配"></a>3.2 VF的bdf number如何分配</h4><p>Routing ID就是BDF number,<strong>即采用Bus Number、Device Number和Function Number来确定目标设备的位置的id。</strong></p><p>SR-IOV Extended Capability中用FirstVF Offset和VF Stride来标记VF的Routing ID。VF的Routing ID是以PF的Routing ID值为参考来计算的。</p><p><strong>FirstVF Offset</strong>：第一个VF相对PF的Routing ID的偏移量</p><p><strong>VF Stride</strong>： 相邻VF之间的Routing ID的偏移量</p><p>PF的Routing ID在PF枚举之后就已经分配好了。PF的驱动程序通过配置SR-IOV Extended Capability，打开这个PF关联的VF之后，通过<strong>FirstVF Offset和VF Stride</strong>就能计算出VF们的Routing ID。</p><h4 id="3-3-VF的BAR空间如何分配"><a href="#3-3-VF的BAR空间如何分配" class="headerlink" title="3.3 VF的BAR空间如何分配"></a>3.3 VF的BAR空间如何分配</h4><p>VF的BAR[n]空间是通过PF的SR-IOV Capability中每个VF_BAR[n]来分配的，和VF Configuration Space的BAR无关。</p><p><img src="/images/2020/10/25.PNG" alt></p><h4 id="3-4-ACRN-Enable-SR-IOV-Virtualization"><a href="#3-4-ACRN-Enable-SR-IOV-Virtualization" class="headerlink" title="3.4 ACRN Enable SR-IOV Virtualization"></a>3.4 ACRN Enable SR-IOV Virtualization</h4><p>建议阅读<a href="https://projectacrn.github.io/latest/tutorials/sriov_virtualization.html" target="_blank" rel="noopener">ACRN Enable SR-IOV Virtualization</a>。😊</p><hr><p>参考资料：</p><ol><li>Chapter 9 of PCI-SIG’s <a href="https://pcisig.com/pci-express-architecture-configuration-space-test-specification-revision-40-version-10" target="_blank" rel="noopener">PCI Express Base Specification Revision 4.0, Version 1.0</a></li><li><a href="https://www.snia.org/sites/default/orig/sdc_archives/2010_presentations/thursday/RichardSolomon_PCI_Express.pdf" target="_blank" rel="noopener">RichardSolomon_PCI_Express.pdf</a></li><li><a href="https://projectacrn.github.io/latest/tutorials/sriov_virtualization.html" target="_blank" rel="noopener">ACRN Enable SR-IOV Virtualization</a></li><li><a href="https://blog.csdn.net/u010443710/article/details/104756445" target="_blank" rel="noopener">SR-IOV及linux驱动浅析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文只介绍SR-IOV的基本内容，并不能cover SR-IOV的全部知识点。
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about pause loop exiting</title>
    <link href="http://liujunming.github.io/2020/10/23/Some-notes-about-pause-loop-exiting/"/>
    <id>http://liujunming.github.io/2020/10/23/Some-notes-about-pause-loop-exiting/</id>
    <published>2020-10-23T00:59:55.000Z</published>
    <updated>2020-12-01T11:31:02.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-background"><a href="#1-background" class="headerlink" title="1. background"></a>1. background</h3><p>Spin-locking code typically uses <code>PAUSE</code> instructions in a loop.<a id="more"></a></p><p>For more details, please refer to <a href="/2020/05/01/Introduction-to-halt-pause-monitor-mwait-instruction/#pause">pause</a>.</p><h3 id="2-motivation"><a href="#2-motivation" class="headerlink" title="2. motivation"></a>2. motivation</h3><p>为什么需要pause loop exiting(ple)这一feature呢?<br><img src="/images/2020/10/21.PNG" alt></p><p><img src="/images/2020/10/22.PNG" alt></p><p><img src="/images/2020/10/23.PNG" alt></p><p><img src="/images/2020/10/24.PNG" alt></p><h3 id="3-details"><a href="#3-details" class="headerlink" title="3. details"></a>3. details</h3><p>Basic Exit Reason 40<br><img src="/images/2020/10/18.PNG" alt></p><p>PLE_Gap - upper bound on the amount of time between two successive executions of PAUSE in a loop.<br>PLE_Window - upper bound on the amount of time a guest is allowed to execute in a PAUSE loop</p><p>If the time, between this execution of PAUSE and previous one, exceeds the PLE_Gap, processor consider this PAUSE belongs to a new loop. Otherwise, processor determins the the total execution time of this loop(since 1st PAUSE in this loop), and triggers a VM exit if total time exceeds the PLE_Window.</p><p>Pause-Loop Exiting can be used to detect Lock-Holder Preemption, where one VCPU is sched-out after hold a spinlock, then other VCPUs for same lock are sched-in to waste the CPU time.</p><p>个人感觉PLE_Gap与PLE_Window的设置，就是调参吧。</p><hr><p>参考资料：</p><ol><li><a href="https://surriel.com/system/files/riel_t_1620_kvm_performance.pdf" target="_blank" rel="noopener">riel_t_1620_kvm_performance.pdf</a></li><li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/linux-containers-hypervisor-based-vms-paper.pdf" target="_blank" rel="noopener">linux-containers-hypervisor-based-vms-paper.pdf</a></li><li><a href="https://kernel-team.narkive.com/x1rgNbzk/patch-0-2-kvm-add-support-for-pause-loop-exit" target="_blank" rel="noopener">KVM: add support for Pause-Loop exit</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-background&quot;&gt;&lt;a href=&quot;#1-background&quot; class=&quot;headerlink&quot; title=&quot;1. background&quot;&gt;&lt;/a&gt;1. background&lt;/h3&gt;&lt;p&gt;Spin-locking code typically uses &lt;code&gt;PAUSE&lt;/code&gt; instructions in a loop.
    
    </summary>
    
      <category term="VT-x" scheme="http://liujunming.github.io/categories/VT-x/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
      <category term="VT-x" scheme="http://liujunming.github.io/tags/VT-x/"/>
    
  </entry>
  
  <entry>
    <title>VT-d Posted Interrupt</title>
    <link href="http://liujunming.github.io/2020/10/11/VT-d-Posted-Interrupt/"/>
    <id>http://liujunming.github.io/2020/10/11/VT-d-Posted-Interrupt/</id>
    <published>2020-10-11T11:23:20.000Z</published>
    <updated>2020-10-23T15:18:20.489Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍VT-d Posted Interrupt的相关内容。首先会以一个例子介绍Posted interrupt的motivation；然后详细阐述涉及到的硬件和软件细节；接下来会介绍不同vCPU状态下的差异化处理；最后总结下本文。<a id="more"></a></p><p>阅读本文前，需先阅读以下文章：</p><ol><li><a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/" target="_blank" rel="noopener">Intel SDM Chapter 29: APIC Virtualizaton &amp; Virtual Interrupts</a></li><li><a href="/2020/10/07/Introduction-to-Posted-interrupt/">Introduction to CPU-based Posted-interrupt</a></li><li><a href="/2020/10/10/VT-d-Interrupt-Remapping/">VT-d Interrupt Remapping</a></li></ol><h3 id="1-terms"><a href="#1-terms" class="headerlink" title="1. terms"></a>1. terms</h3><ul><li>PI(Posted Interrupt)</li><li>hv(hypervisor)</li><li>VM(Virtual Machine)</li><li>IRTE(Interrupt Remapping Table Entry)</li><li>PID(Posted Interrupt Descriptor)</li><li>PIR( Posted Interrupt Requests)</li><li>ON(Outstanding Notification)</li><li>NV(Notification Vector)</li><li>ANV(Active Notification Vector)</li><li>WNV(Wake-up Notification Vector)</li><li>ple(pause loop exiting)</li></ul><h3 id="2-motivation"><a href="#2-motivation" class="headerlink" title="2.  motivation"></a>2.  motivation</h3><p>在<a href="/2020/10/10/VT-d-Interrupt-Remapping/#demo-usage">VT-d Interrupt Remapping demo usage</a>中，如果目标vCPU正在运行，但是，当物理CPU接受到physical interrupt时，需发生VM-Exit，由hv为guest注入vector为30的virtual中断。</p><p>思考下：是否可以省去如下步骤：<em>当物理CPU接受到physical interrupt时，需发生VM-Exit，由hv为guest注入vector为30的virtual中断</em>。由硬件为正在运行的vCPU直接注入vector为30的virtual 中断(这样避免了一次VM-Exit)，而这正是VT-d PI所能完成的功能。</p><h3 id="3-details"><a href="#3-details" class="headerlink" title="3. details"></a>3. details</h3><h4 id="3-1-CAP-REG的PI位"><a href="#3-1-CAP-REG的PI位" class="headerlink" title="3.1 CAP_REG的PI位"></a>3.1 CAP_REG的PI位</h4><p>IOMMU通过Capability Register(CAP_REG)的PI位来报告interrupt posting capability。<br><img src="/images/2020/10/7.PNG" alt></p><h4 id="3-2-IRTE"><a href="#3-2-IRTE" class="headerlink" title="3.2 IRTE"></a>3.2 IRTE</h4><p>VT-d PI是VT-d Interrupt Remapping的一个扩展功能。根据<a href="/2020/10/10/VT-d-Interrupt-Remapping/">Interrupt Remapping</a>可知， 所有的Remapping格式中断请求都需要通过中断重映射表来投递， IRTE中的Mode域(IM)用来指定这个remappable中断请求是interrupt-remapping方式还是interrupt-posting方式。</p><p>如果IRTE的IM位为1，则VT-d硬件将会以PI的形式来解析该IRTE，如下图所示：<br><img src="/images/2020/10/9.PNG" alt></p><p>需要关注PI格式的IRTE的以下几个field：</p><ol><li>Posted Descriptor Address Low/High，该区域保存一个指向内存的指针，该指针指向的位置就是PID。</li><li>Urgent位，该位用于表示该中断是否是紧急的，即是否需要目标CPU立即响应。</li><li>Vector用于指定PID.PIR中哪个bit要置位。</li></ol><h4 id="3-3-PID"><a href="#3-3-PID" class="headerlink" title="3.3 PID"></a>3.3 PID</h4><p>每个PID的大小为64 Byte，直接被硬件用来记录将要post的中断请求。其格式如下所示：<br><img src="/images/2020/10/8.PNG" alt></p><ol><li>Posted Interrupt Request (PIR)域，一共256 bit，每个bit对应一个中断向量，当VT-d硬件将中断请求post过来的时候，IRTE.Vector对应的bit将会被置起。</li><li><p>Outstanding Notification (ON)域，表示该PID当前是否已经发出了一个Notification Event等待CPU的处理。</p><ul><li><p>当VT-d硬件将中断请求记录到PIR的时候，如果ON为0，并且允许立即发出一个Notification Event时，则将会将ON置起来，并且产生一个Notification Event；如果ON已经被置起来，则不会产生一个Notification Event。</p></li><li><p>ON的清零。</p><p><img src="/images/2020/10/16.PNG" alt></p></li></ul></li><li>Suppress Notification (SN)域，表示当PIR寄存器记录到non-urgent的中断时，是否不发出Notification Event，如果该位为1，则当PIR记录到non-urgent中断的时候，不发出Notification Event，并且不更改Outstanding Notification位的值。</li><li>Notification Vector (NV)域，表示如果发出Notification Event时，具体的Vector值。</li><li>Notification Destination (NDST)域，表示如果发出Notification Event时，要传递的物理CPU的LAPIC ID。</li></ol><h4 id="3-4-硬件上Posted-Interrupt的处理过程"><a href="#3-4-硬件上Posted-Interrupt的处理过程" class="headerlink" title="3.4 硬件上Posted Interrupt的处理过程"></a>3.4 硬件上Posted Interrupt的处理过程</h4><p><img src="/images/2020/10/15.PNG" alt></p><p>PST即IRTE中的Interrupt Mode位。</p><p><img src="/images/2020/10/10.jpg" alt></p><p>当VT-d硬件接收到其旗下I/O设备传递过来的中断请求时，会先查看自己的中断重定向功能是否打开，如果没有打开则，直接上传给LAPIC。如果中断重定向功能打开，则会查看中断请求的格式，如果是不可重定向格式，则直接将中断请求提交给LAPIC。如果是可重定向的格式，则会根据算法计算Interrupt_Index值，对中断重定向表进行索引找到相应的IRTE。然后，查看IRTE中的Interrupt Mode，如果为0，则该IRTE的格式为Remapped Format，即立即根据IRTE的信息产生一个新的中断请求，提交到LAPIC。如果Interrupt Mode为1，则表示该IRTE的格式为Posted Format，根据IRTE中提供的PID的地址，在内存中找到相应PID，并根据其ON、URG和SN的设置判断是否需要立即产生一个Notification Event，如果不需要，则只是将该中断信息记录到PID.PIR中，等待hv的后续处理(会在<a href="/2020/10/11/VT-d-Posted-Interrupt/#4-5-vCPU-is-ready-to-run-or-halted-when-Notification-Event-happen">vCPU is ready-to-run or halted when Notification Event happen</a>中介绍)。如果需要立即产生一个Notification Event，则根据PID（会提供目标APIC ID、vector、传输模式和触发模式等信息）产生一个Notification Event，同时将ON置位。</p><p>硬件在对PID进行修改的时候，要保证该修改是原子操作，即对PID的读取、修改和写入必须是原子操作，并且在写入之后，要保证相应内存在各个cache agent之间的一致性，即所有的CPU应该立马能够看到该内存修改。</p><h4 id="3-5-the-relationship-with-CPU-based-Posted-interrupt"><a href="#3-5-the-relationship-with-CPU-based-Posted-interrupt" class="headerlink" title="3.5 the relationship with CPU-based Posted-interrupt"></a>3.5 the relationship with CPU-based Posted-interrupt</h4><p>CPU-based Posted-interrupt需要与IOMMU协同工作才能实现VT-d Posted Interrupt feature。</p><p>有三点需要注意：</p><ol><li>enable APICv</li><li>设置VMCS的posted-interrupt descriptor，这正是IRTE中Posted Descriptor Address Low/High所设置的值。</li><li>设置VMCS的posted-interrupt notification vector为ANV(下节会详细介绍)。</li></ol><p><img src="/images/2020/10/13.PNG" alt><br><img src="/images/2020/10/14.PNG" alt></p><h3 id="4-不同vCPU状态下的差异化处理"><a href="#4-不同vCPU状态下的差异化处理" class="headerlink" title="4. 不同vCPU状态下的差异化处理"></a>4. 不同vCPU状态下的差异化处理</h3><h4 id="4-1-Background"><a href="#4-1-Background" class="headerlink" title="4.1 Background"></a>4.1 Background</h4><p>在vCPU调度的过程中，vCPU会有如下三种状态:</p><ol><li>当vCPU被scheduler选中来运行的时候，此时vCPU的状态为’active’。</li><li>当vCPU被抢占（Preempted），例如时间片到期了，此时vCPU的状态为’ready-to-run’。</li><li>当vCPU执行了<code>hlt</code>指令或者触发了<a href="/2020/10/23/Some-notes-about-pause-loop-exiting/">ple</a>，hv也会干预进来将vCPU给block出来，此时vCPU状态为’halted ‘。</li></ol><h4 id="4-2-ANV-and-WNV"><a href="#4-2-ANV-and-WNV" class="headerlink" title="4.2 ANV and WNV"></a>4.2 ANV and WNV</h4><p>hv需要为每个vCPU分配物理中断vector:<br>第一个称作Active Notification Vector（ANV），该Vector对应到vCPU的状态为active时，Notification Event所使用的中断vector(需要设置VMCS的posted-interrupt notification vector为ANV)。</p><p>第二个称作Wake-up Notification Vector（WNV），该Vector对应到目标vCPU不在当前物理CPU上执行时，由于Urgent被置起来产生的Notification Event所使用的中断Vector。</p><blockquote><p>在active状态下，PID.NV的值就是ANV。在ready-to-run或者halted状态下，PID.NV的值就是WNV。这里的ANV和WNV可以是同一个值。</p></blockquote><p>hv需要保证的是：运行在同一个pCPU上的所有vCPU的PID.NV值不同。</p><p>详情可参考:<a href="https://projectacrn.github.io/latest/developer-guides/hld/hv-dev-passthrough.html#vt-d-interrupt-remapping" target="_blank" rel="noopener">ACRN posted interrupt</a></p><h4 id="4-3-vCPU-Scheduling"><a href="#4-3-vCPU-Scheduling" class="headerlink" title="4.3 vCPU Scheduling"></a>4.3 vCPU Scheduling</h4><p><img src="/images/2020/10/12.PNG" alt></p><p>只需理解状态转换，对于‘NV’的设置是hv specific的，无需深究。</p><h4 id="4-4-vCPU-is-active-when-Notification-Event-happen"><a href="#4-4-vCPU-is-active-when-Notification-Event-happen" class="headerlink" title="4.4 vCPU is active when Notification Event happen"></a>4.4 vCPU is active when Notification Event happen</h4><p>guest在Non-Root下就能直接处理此中断，而不需要hv的参与。</p><p>详细步骤请参考：<a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/#posted-interrupt" target="_blank" rel="noopener">Posted Interrupt</a></p><h4 id="4-5-vCPU-is-ready-to-run-or-halted-when-Notification-Event-happen"><a href="#4-5-vCPU-is-ready-to-run-or-halted-when-Notification-Event-happen" class="headerlink" title="4.5 vCPU is ready-to-run or halted when Notification Event happen"></a>4.5 vCPU is ready-to-run or halted when Notification Event happen</h4><p>WNV的handler:</p><p>如果vCPU的state为halted，则需要先将vCPU的状态设置为ready-to-run。</p><p>handler会调度vCPU。</p><p>扫描PID.PIR,检测是否有处于pending状态的posted interrupt请求；如果有处于pending状态的posted interrupt请求，hv会在LAPIC上生成一个vector号为ANV的self-IPI(注意：在还未真正enter guest之前,当前物理CPU处于关中断状态)。 当进入Non-Root模式时，物理IRR寄存器中的ANV位会被置上，硬件(CPU)会处理posted interrupt。该中断的处理类似于vCPU处于active状态时，接收到了ANV的中断请求，vCPU可以直接对其进行处理，不需要hv的参与。</p><h3 id="5-summary"><a href="#5-summary" class="headerlink" title="5. summary"></a>5. summary</h3><p>VT-d PI advantages</p><ul><li>External interrupts from direct-assigned devices are delivered to guest running in non-root mode directly</li><li>Improve Interrupt virtualization efficiency, e.g. Less VM-Exits.</li><li>Simplify interrupt migration<ul><li>更新PID.NDST</li><li>如果per-PCPU的IDT向量管理不一样，还需要更新PCPU IDT的vector<br><img src="/images/2020/10/17.PNG" alt></li></ul></li><li>Consume less physical interrupts</li></ul><hr><p>参考资料：</p><ol><li><a href="https://kernelgo.org/posted-interrupt.html" target="_blank" rel="noopener">fangying:VT-d Posted Interrupt</a></li><li><a href="https://zhuanlan.zhihu.com/p/51018597" target="_blank" rel="noopener">河马 Intel VT-d（4）- Interrupt Posting</a></li><li><a href="https://events.static.linuxfound.org/sites/events/files/slides/VT-d%20Posted%20Interrupts-final%20.pdf" target="_blank" rel="noopener">Feng Wu:VT-d Posted Interrupts </a></li><li><a href="https://lettieri.iet.unipi.it/virtualization/2018/passthrough.pdf" target="_blank" rel="noopener">Hardware passthrough</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍VT-d Posted Interrupt的相关内容。首先会以一个例子介绍Posted interrupt的motivation；然后详细阐述涉及到的硬件和软件细节；接下来会介绍不同vCPU状态下的差异化处理；最后总结下本文。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
  <entry>
    <title>VT-d Interrupt Remapping</title>
    <link href="http://liujunming.github.io/2020/10/10/VT-d-Interrupt-Remapping/"/>
    <id>http://liujunming.github.io/2020/10/10/VT-d-Interrupt-Remapping/</id>
    <published>2020-10-10T11:20:19.000Z</published>
    <updated>2020-10-13T22:52:43.868Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍VT-d Interrupt Remapping的motivation，然后推荐一篇介绍Interrupt Remapping细节的文章，最后以一个具体的例子来展示VT-d Interrupt Remapping的用法。<a id="more"></a></p><h3 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h3><ol><li>Supporting isolation and routing of interrupts from devices and external interrupt controllers to appropriate VMs.</li><li>Supporting x2APIC</li></ol><h3 id="details"><a href="#details" class="headerlink" title="details"></a>details</h3><p>可以详细阅读此文。<br><a href="https://kernelgo.org/interrupt-remapping.html" target="_blank" rel="noopener">https://kernelgo.org/interrupt-remapping.html</a></p><h3 id="demo-usage"><a href="#demo-usage" class="headerlink" title="demo usage"></a>demo usage</h3><p><img src="/images/2020/10/6.PNG" alt></p><p>以上图为例，将展示VT-d Interrupt Remapping的具体过程。</p><ol><li>当guest配置MSI address和MSI data时，hypervisor(hv)会trap，解析相关field，得到virtual interrupt的vector为30，而对应的physical interrupt的vector为60。这样hv会记录physical interrupt到virtual interrupt的映射(vector 60 -&gt; vector 30)。</li><li>分配一个IRTE并且按照IRTE的格式要求填好IRTE的每个属性。如：B:D.F, Vector(60), 运行目标vCPU的物理CPU的LAPIC ID。</li><li>按照Remapping format的格式对MSI进行编程。如：将Interrupt Format置1，设置中断的interrupt_index。</li><li>设置VMCS(configured to cause vmexit on external interrupt)。当物理CPU收到vector为60的中断时，会发生VM-Exit。</li><li>hv处理VM-Exit，根据physical interrupt到virtual interrupt的映射(vector 60 -&gt; vector 30)关系，为guest注入vector为30的interrupt。</li><li>VM-Entry到guest VM，process vector为30的interrupt。</li></ol><h3 id="rethinking-the-motivation"><a href="#rethinking-the-motivation" class="headerlink" title="rethinking the motivation"></a>rethinking the motivation</h3><p><img src="/images/2020/10/19.PNG" alt></p><p><img src="/images/2020/10/20.PNG" alt></p><p>两者可以完成相同的功能。那么为什么还要有VT-d Interrupt Remapping呢？</p><p>在<a href="https://invisiblethingslab.com/resources/2011/Software%20Attacks%20on%20Intel%20VT-d.pdf" target="_blank" rel="noopener">Following the White Rabbit:Software attacks against Intel(R) VT-d technology</a>一文中找到了答案：vulnerable to the BDF spoofing attack。</p><blockquote><p>Even though the interrupt remapping seems vulnerable to the BDF spoofing attack (just like DMA<br>remapping is), still we believe it has a potential to prevent all the above-mentioned MSI attacks, because we anticipate that none of the interrupt vector used in our attacks should be allowed to any devices in the system. In that case, BDF spoofing would not bring any advantage to the attacker, as there should be no device at all that the attacker might want to impersonate, which could deliver those dangerous interrupts, such as SIPI, syscall interrupts, or the #AC exception.</p></blockquote><blockquote><p>BDF spoofing is a type of a hardware attack against VT-d, where a malicious device generates PCIe packets with spoofed BDF address. </p></blockquote><p>说白了，VT-d Interrupt Remapping可以解决security问题。</p><hr><p>参考资料：</p><ol><li><a href="https://compas.cs.stonybrook.edu/~nhonarmand/courses/sp17/cse506/slides/hw_io_virtualization.pdf" target="_blank" rel="noopener">I/O Virtualization with Hardware Support</a></li><li><a href="https://invisiblethingslab.com/resources/2011/Software%20Attacks%20on%20Intel%20VT-d.pdf" target="_blank" rel="noopener">Following the White Rabbit:Software attacks against Intel(R) VT-d technology</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍VT-d Interrupt Remapping的motivation，然后推荐一篇介绍Interrupt Remapping细节的文章，最后以一个具体的例子来展示VT-d Interrupt Remapping的用法。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
</feed>
