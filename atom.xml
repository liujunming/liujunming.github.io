<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2019-08-30T15:25:47.939Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux kernel ioremap_nocache and ioremap function</title>
    <link href="http://liujunming.github.io/2019/08/30/Linux-kernel-ioremap-nocache-and-ioremap-function/"/>
    <id>http://liujunming.github.io/2019/08/30/Linux-kernel-ioremap-nocache-and-ioremap-function/</id>
    <published>2019-08-30T14:17:35.000Z</published>
    <updated>2019-08-30T15:25:47.939Z</updated>
    
    <content type="html"><![CDATA[<p>这两天都源码时，总是看到<code>ioremap_nocache</code>和<code>ioremap</code>这两个函数，本文就介绍总结一下吧。<br><a id="more"></a></p><h2 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1. 背景知识"></a>1. 背景知识</h2><h3 id="1-1-物理地址空间"><a href="#1-1-物理地址空间" class="headerlink" title="1.1 物理地址空间"></a>1.1 物理地址空间</h3><p>内容源于《系统虚拟化：原理与实现》2.2.1章节。<br><img src="/images/2019/8/26.png" alt><br><img src="/images/2019/8/27.png" alt><br><img src="/images/2019/8/28.png" alt></p><h3 id="1-2-CPU-cache"><a href="#1-2-CPU-cache" class="headerlink" title="1.2 CPU cache"></a>1.2 CPU cache</h3><p>如果对<a href="/2019/04/20/CPU-cache/">CPU Cache</a>概念有遗忘，可以参考此文。<br>本文中，读者只需明白一点：内核可以让部分物理地址空间的内存不使用cpu cache。<br>ps:读者若想了解细节，可以参考<a href="https://software.intel.com/sites/default/files/managed/7c/f1/253668-sdm-vol-3a.pdf" target="_blank" rel="noopener">SDM</a>11.3METHODS OF CACHING AVAILABLE章节。</p><h2 id="2-函数说明"><a href="#2-函数说明" class="headerlink" title="2. 函数说明"></a>2. 函数说明</h2><p>有了背景知识后，理解这些函数就变得简单了。<br>首先看下内核中<code>ioremap_nocache</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ioremap_nocache     -   map bus memory into CPU space</span></span><br><span class="line"><span class="comment"> * @phys_addr:    bus address of the memory</span></span><br><span class="line"><span class="comment"> * @size:      size of the resource to map</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ioremap_nocache performs a platform specific sequence of operations to</span></span><br><span class="line"><span class="comment"> * make bus memory CPU accessible via the readb/readw/readl/writeb/</span></span><br><span class="line"><span class="comment"> * writew/writel functions and the other mmio helpers. The returned</span></span><br><span class="line"><span class="comment"> * address is not guaranteed to be usable directly as a virtual</span></span><br><span class="line"><span class="comment"> * address.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This version of ioremap ensures that the memory is marked uncachable</span></span><br><span class="line"><span class="comment"> * on the CPU. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Must be freed with iounmap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __<span class="function">iomem *<span class="title">ioremap_nocache</span><span class="params">(<span class="keyword">resource_size_t</span> phys_addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br></pre></td></tr></table></figure></p><p>就比如图2-1，当我们需要映射512MB的I/O地址时，调用<code>ioremap_nocache(3GB, 512MB)</code>即可。</p><p><code>ioremap</code>和<code>ioremap_nocache</code>的区别从名称中就可以看出区别：<code>ioremap</code>映射的物理地址空间使用CPU cache，而<code>ioremap_nocache</code>映射的物理地址空间不使用CPU cache。</p><p>知道函数的作用后，就可以去慢慢啃内核了。</p><hr><p>参考资料：</p><ol><li>《系统虚拟化：原理与实现》</li><li><a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/mm/ioremap.c#L262" target="_blank" rel="noopener">LINUX kernel</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天都源码时，总是看到&lt;code&gt;ioremap_nocache&lt;/code&gt;和&lt;code&gt;ioremap&lt;/code&gt;这两个函数，本文就介绍总结一下吧。&lt;br&gt;
    
    </summary>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/categories/I-O%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Some details about select implementation</title>
    <link href="http://liujunming.github.io/2019/08/26/Some-details-about-select-implementation/"/>
    <id>http://liujunming.github.io/2019/08/26/Some-details-about-select-implementation/</id>
    <published>2019-08-26T08:37:03.000Z</published>
    <updated>2019-08-30T14:29:00.164Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2019/08/26/select-usage-and-implementation-in-kernel/">select usage and implementation in kernel</a>简单介绍了select的内核实现，<a href="/2019/08/26/file-operations-poll-function/">file_operations poll function</a>介绍了file_operations中的 poll函数。在看完 <a href="https://blog.csdn.net/lizhiguo0532/article/details/6568964" target="_blank" rel="noopener">select(poll)系统调用实现解析(一)</a>文章后，发现还是需要介绍下detail。本文内容源于该系列文章。</p><a id="more"></a><p>PS:本文不适合阅读，但是当结合代码看时效果明显。</p><h2 id="1-为什么要实现-file-operation结构体的poll函数？"><a href="#1-为什么要实现-file-operation结构体的poll函数？" class="headerlink" title="1. 为什么要实现 file_operation结构体的poll函数？"></a>1. 为什么要实现 file_operation结构体的poll函数？</h2><p>上层要能使用select()和poll()系统调用来监测某个设备文件描述符，那么就必须实现这个设备驱动程序中struct file_operation结构体的poll函数，为什么？</p><p>因为这两个系统调用最终都会调用驱动程序中的poll函数来初始化一个等待队列项, 然后将其加入到驱动程序中的等待队列头，这样就可以在硬件可读写的时候wake up这个等待队列头，然后等待硬件设备可读写事件的进程都将被唤醒。(这个等待队列头可以包含多个等待队列项，这些不同的等待队列项是由不同的应用程序调用select或者poll来监测同一个硬件设备的时候调用file_operation的poll函数初始化填充的)。</p><h2 id="2-select系统调用"><a href="#2-select系统调用" class="headerlink" title="2. select系统调用"></a>2. select系统调用</h2><p><strong>select()系统调用代码</strong><br>调用顺序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sys_select()</span><br><span class="line">core_sys_select()</span><br><span class="line">do_select()</span><br><span class="line">fop-&gt;poll()</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(select, <span class="keyword">int</span>, n, fd_set __user *, inp, fd_set __user *, outp, </span><br><span class="line">fd_set __user *, <span class="built_in">exp</span>, struct timeval __user *, tvp)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">       <span class="keyword">int</span> ret; </span><br><span class="line">       <span class="keyword">if</span> (tvp) &#123;<span class="comment">// 如果超时值非NULL</span></span><br><span class="line">              <span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv)))   <span class="comment">// 从用户空间取数据到内核空间</span></span><br><span class="line">                     <span class="keyword">return</span> -EFAULT;</span><br><span class="line">              to = &amp;end_time;</span><br><span class="line">              <span class="comment">// 得到timespec格式的未来超时时间</span></span><br><span class="line">              <span class="keyword">if</span> (poll_select_set_timeout(to,</span><br><span class="line">                            tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),</span><br><span class="line">                            (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))</span><br><span class="line">                     <span class="keyword">return</span> -EINVAL;</span><br><span class="line">       &#125;</span><br><span class="line">       ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, to);             <span class="comment">// 关键函数</span></span><br><span class="line">       ret = poll_select_copy_remaining(&amp;end_time, tvp, <span class="number">1</span>, ret);</span><br><span class="line">       <span class="comment">/*如果有超时值, 并拷贝离超时时刻还剩的时间到用户空间的timeval中*/</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> ret;             <span class="comment">// 返回就绪的文件描述符的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp, </span></span></span><br><span class="line"><span class="function"><span class="params">fd_set __user *<span class="built_in">exp</span>, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       fd_set_bits fds;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">       typedef struct &#123;</span></span><br><span class="line"><span class="comment">              unsigned long *in, *out, *ex;</span></span><br><span class="line"><span class="comment">              unsigned long *res_in, *res_out, *res_ex;</span></span><br><span class="line"><span class="comment">&#125; fd_set_bits;</span></span><br><span class="line"><span class="comment">这个结构体中定义的全是指针，这些指针都是用来指向描述符集合的。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">void</span> *bits;</span><br><span class="line">       <span class="keyword">int</span> ret, max_fds;</span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">       <span class="comment">/* Allocate small arguments on the stack to save memory and be faster */</span></span><br><span class="line">       <span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">       ret = -EINVAL;</span><br><span class="line">       <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">goto</span> out_nofds;</span><br><span class="line">       <span class="comment">/* max_fds can increase, so grab it once to avoid race */</span></span><br><span class="line">       rcu_read_lock();</span><br><span class="line">       fdt = files_fdtable(current-&gt;files); <span class="comment">// RCU ref, 获取当前进程的文件描述符表</span></span><br><span class="line">       max_fds = fdt-&gt;max_fds;</span><br><span class="line">       rcu_read_unlock();</span><br><span class="line">       <span class="keyword">if</span> (n &gt; max_fds)<span class="comment">// 如果传入的n大于当前进程最大的文件描述符，给予修正</span></span><br><span class="line">              n = max_fds;</span><br><span class="line">              </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * We need 6 bitmaps (in/out/ex for both incoming and outgoing),</span></span><br><span class="line"><span class="comment">        * since we used fdset we need to allocate memory in units of</span></span><br><span class="line"><span class="comment">        * long-words.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       size = FDS_BYTES(n);</span><br><span class="line">       <span class="comment">// 以一个文件描述符占一bit来计算，传递进来的这些fd_set需要用掉多少个字</span></span><br><span class="line">       bits = stack_fds;</span><br><span class="line">       <span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;</span><br><span class="line">              <span class="comment">// 除6，为什么?因为每个文件描述符需要6个bitmaps</span></span><br><span class="line">              <span class="comment">/* Not enough space in on-stack array; must use kmalloc */</span></span><br><span class="line">              ret = -ENOMEM;</span><br><span class="line">              bits = kmalloc(<span class="number">6</span> * size, GFP_KERNEL); <span class="comment">// stack中分配的太小，直接kmalloc</span></span><br><span class="line">              <span class="keyword">if</span> (!bits)</span><br><span class="line">                     <span class="keyword">goto</span> out_nofds;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 这里就可以明显看出struct fd_set_bits结构体的用处了。</span></span><br><span class="line">       fds.in      = bits;</span><br><span class="line">       fds.out     = bits +   size;</span><br><span class="line">       fds.ex      = bits + <span class="number">2</span>*size;</span><br><span class="line">       fds.res_in  = bits + <span class="number">3</span>*size;</span><br><span class="line">       fds.res_out = bits + <span class="number">4</span>*size;</span><br><span class="line">       fds.res_ex  = bits + <span class="number">5</span>*size;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// get_fd_set仅仅调用copy_from_user从用户空间拷贝了fd_set</span></span><br><span class="line">       <span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">           (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">           (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line">              <span class="keyword">goto</span> out;</span><br><span class="line">       zero_fd_set(n, fds.res_in);  <span class="comment">// 对这些存放返回状态的字段清0</span></span><br><span class="line">       zero_fd_set(n, fds.res_out);</span><br><span class="line">       zero_fd_set(n, fds.res_ex);</span><br><span class="line"></span><br><span class="line">       ret = do_select(n, &amp;fds, end_time);    <span class="comment">// 关键函数，完成主要的工作</span></span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)             <span class="comment">// 有错误</span></span><br><span class="line">              <span class="keyword">goto</span> out;</span><br><span class="line">       <span class="keyword">if</span> (!ret) &#123;              <span class="comment">// 超时返回，无设备就绪</span></span><br><span class="line">              ret = -ERESTARTNOHAND;</span><br><span class="line">              <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">                     <span class="keyword">goto</span> out;</span><br><span class="line">              ret = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 把结果集,拷贝回用户空间</span></span><br><span class="line">       <span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">           set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">           set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">              ret = -EFAULT;</span><br><span class="line">             </span><br><span class="line">out:</span><br><span class="line">       <span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">              kfree(bits);     <span class="comment">// 如果有申请空间，那么释放fds对应的空间</span></span><br><span class="line">out_nofds:</span><br><span class="line">       <span class="keyword">return</span> ret;                    <span class="comment">// 返回就绪的文件描述符的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">       poll_table *wait;</span><br><span class="line">       <span class="keyword">int</span> retval, i, timed_out = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">long</span> slack = <span class="number">0</span>;</span><br><span class="line">       rcu_read_lock();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 根据已经设置好的fd位图检查用户打开的fd, 要求对应fd必须打开, 并且返回最大的fd。</span></span><br><span class="line">       retval = max_select_fd(n, fds);</span><br><span class="line">       rcu_read_unlock();</span><br><span class="line">       <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> retval;</span><br><span class="line">       n = retval;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 一些重要的初始化:</span></span><br><span class="line">       <span class="comment">// poll_wqueues.poll_table.qproc函数指针初始化，该函数是驱动程序中poll函数实</span></span><br><span class="line">       <span class="comment">// 现中必须要调用的poll_wait()中使用的函数。</span></span><br><span class="line">       poll_initwait(&amp;table);</span><br><span class="line">       wait = &amp;table.pt;</span><br><span class="line">       <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">              wait = <span class="literal">NULL</span>;</span><br><span class="line">              timed_out = <span class="number">1</span>;     <span class="comment">// 如果系统调用带进来的超时时间为0，那么设置</span></span><br><span class="line">                                          <span class="comment">// timed_out = 1，表示不阻塞，直接返回。</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">              slack = estimate_accuracy(end_time); <span class="comment">// 超时时间转换</span></span><br><span class="line">              </span><br><span class="line">       retval = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line">              inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">              rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// 所有n个fd的循环</span></span><br><span class="line">              <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">                     <span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;</span><br><span class="line">                     <span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line">                     <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span> = <span class="title">NULL</span>;</span></span><br><span class="line">                     <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 先取出当前循环周期中的32个文件描述符对应的bitmaps</span></span><br><span class="line">                     in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">                     all_bits = in | out | ex;  <span class="comment">// 组合一下，有的fd可能只监测读，或者写，</span></span><br><span class="line">                     <span class="comment">//或者e rr，或者同时都监测</span></span><br><span class="line">                     <span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;  <span class="comment">// 这32个描述符没有任何状态被监测，就跳入</span></span><br><span class="line"><span class="comment">// 下一个32个fd的循环中</span></span><br><span class="line">                            i += __NFDBITS; <span class="comment">//每32个文件描述符一个循环，正好一个long型数</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 本次32个fd的循环中有需要监测的状态存在</span></span><br><span class="line">                     <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;<span class="comment">// 初始bit = 1</span></span><br><span class="line">                            <span class="keyword">int</span> fput_needed;</span><br><span class="line">                            <span class="keyword">if</span> (i &gt;= n)      <span class="comment">// i用来检测是否超出了最大待监测的fd</span></span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">if</span> (!(bit &amp; all_bits))</span><br><span class="line">                                   <span class="keyword">continue</span>; <span class="comment">// bit每次循环后左移一位的作用在这</span></span><br><span class="line">                                                        <span class="comment">// 跳过没有状态监测的fd</span></span><br><span class="line">                            file = fget_light(i, &amp;fput_needed); <span class="comment">// 得到file结构指针，并增加</span></span><br><span class="line">                                               <span class="comment">// 引用计数字段f_count</span></span><br><span class="line">                            <span class="keyword">if</span> (file) &#123;        <span class="comment">// 如果file存在</span></span><br><span class="line">                                   f_op = file-&gt;f_op;</span><br><span class="line">                                   mask = DEFAULT_POLLMASK;</span><br><span class="line">                                   <span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll) &#123;</span><br><span class="line">                                          wait_key_set(wait, in, out, bit);</span><br><span class="line">                                          <span class="comment">// 设置当前fd待监测的事件掩码</span></span><br><span class="line">                                          mask = (*f_op-&gt;poll)(file, wait);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用驱动程序中的poll函数，</span></span><br><span class="line"><span class="comment">以evdev驱动中的evdev_poll()为例该函数会调用函数poll_wait(file, &amp;evdev-&gt;wait, wait)，</span></span><br><span class="line"><span class="comment">继续调用__pollwait()回调来分配一个poll_table_entry结构体，</span></span><br><span class="line"><span class="comment">该结构体有一个内嵌的等待队列项，</span></span><br><span class="line"><span class="comment">设置好wake时调用的回调函数后将其添加到驱动程序中的等待队列头中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                                   &#125;</span><br><span class="line">                                   fput_light(file, fput_needed);</span><br><span class="line">                                   <span class="comment">// 释放file结构指针，实际就是减小他的一个引用计数字段f_count。</span></span><br><span class="line"></span><br><span class="line">                                   <span class="comment">// mask是每一个fop-&gt;poll()程序返回的设备状态掩码。</span></span><br><span class="line">                                   <span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">                                          res_in |= bit;         <span class="comment">// fd对应的设备可读</span></span><br><span class="line">                                          retval++;</span><br><span class="line">                                          wait = <span class="literal">NULL</span>;       <span class="comment">// 后续有用，避免重复执行__pollwait()</span></span><br><span class="line">                                   &#125;</span><br><span class="line">                                   <span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">                                          res_out |= bit;              <span class="comment">// fd对应的设备可写</span></span><br><span class="line">                                          retval++;</span><br><span class="line">                                          wait = <span class="literal">NULL</span>;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   <span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">                                          res_ex |= bit;</span><br><span class="line">                                          retval++;</span><br><span class="line">                                          wait = <span class="literal">NULL</span>;</span><br><span class="line">                                   &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 根据poll的结果写回到输出位图里,返回给上级函数</span></span><br><span class="line">                     <span class="keyword">if</span> (res_in)</span><br><span class="line">                            *rinp = res_in;</span><br><span class="line">                     <span class="keyword">if</span> (res_out)</span><br><span class="line">                            *routp = res_out;</span><br><span class="line">                     <span class="keyword">if</span> (res_ex)</span><br><span class="line">                            *rexp = res_ex;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            这里的目的纯粹是为了增加一个抢占点。</span></span><br><span class="line"><span class="comment">                            在支持抢占式调度的内核中（定义了CONFIG_PREEMPT），</span></span><br><span class="line"><span class="comment">cond_resched是空操作。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                     cond_resched();</span><br><span class="line">              &#125;</span><br><span class="line">              wait = <span class="literal">NULL</span>;  <span class="comment">// 后续有用，避免重复执行__pollwait()</span></span><br><span class="line">              <span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">if</span> (table.error) &#123;</span><br><span class="line">                     retval = table.error;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">/*跳出这个大循环的条件有: 有设备就绪或有异常(retval!=0), 超时(timed_out</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              = 1), 或者有中止信号出现*/</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">               * If this is the first loop and we have a timeout</span></span><br><span class="line"><span class="comment">               * given, then we convert to ktime_t and set the to</span></span><br><span class="line"><span class="comment">               * pointer to the expiry value.</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">                     expire = timespec_to_ktime(*end_time);</span><br><span class="line">                     to = &amp;expire;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 第一次循环中，当前用户进程从这里进入休眠，</span></span><br><span class="line">              <span class="comment">//上面传下来的超时时间只是为了用在睡眠超时这里而已</span></span><br><span class="line">              <span class="comment">// 超时，poll_schedule_timeout()返回0；被唤醒时返回-EINTR</span></span><br><span class="line">              <span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">                                      to, slack))</span><br><span class="line">                     timed_out = <span class="number">1</span>; <span class="comment">/* 超时后，将其设置成1，方便后面退出循环返回到上层 */</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 清理各个驱动程序的等待队列头，同时释放掉所有空出来的page页(poll_table_entry)</span></span><br><span class="line"></span><br><span class="line">       poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> retval; <span class="comment">// 返回就绪的文件描述符的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-重要结构体之间关系"><a href="#3-重要结构体之间关系" class="headerlink" title="3. 重要结构体之间关系"></a>3. 重要结构体之间关系</h2><p>比较重要的结构体由四个：struct poll_wqueues、struct poll_table_page、struct poll_table_entry、struct poll_table_struct。</p><h3 id="3-1-结构体关系"><a href="#3-1-结构体关系" class="headerlink" title="3.1 结构体关系"></a>3.1 结构体关系</h3><p>每一个调用select()系统调用的应用进程都会存在一个struct poll_weueues结构体，用来统一辅佐实现这个进程中所有待监测的fd的轮询工作，后面所有的工作和都这个结构体有关，所以它非常重要。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> &#123;</span></span><br><span class="line">       poll_table pt;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> *<span class="title">table</span>;</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">polling_task</span>;</span> <span class="comment">//保存当前调用select的用户进程struct task_struct结构体</span></span><br><span class="line">       <span class="keyword">int</span> triggered;         <span class="comment">// 当前用户进程被唤醒后置成1，以免该进程接着睡眠</span></span><br><span class="line">       <span class="keyword">int</span> error;               <span class="comment">// 错误码</span></span><br><span class="line">       <span class="keyword">int</span> inline_index;   <span class="comment">// 数组inline_entries的引用下标</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">inline_entries</span>[<span class="title">N_INLINE_POLL_ENTRIES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>实际上结构体poll_wqueues内嵌的poll_table_entry数组inline_entries[] 的大小是有限：如果空间不够用，后续会动态申请物理内存页以链表的形式挂载poll_wqueues.table上统一管理。接下来的两个结构体就和这项内容密切相关：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> &#123;</span> <span class="comment">// 申请的物理页都会将起始地址强制转换成该结构体指针</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> * <span class="title">next</span>;</span>     <span class="comment">// 指向下一个申请的物理页</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> * <span class="title">entry</span>;</span> <span class="comment">// 指向entries[]中首个待分配(空的) poll_table_entry地址</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">entries</span>[0];</span> <span class="comment">// 该page页后面剩余的空间都是待分配的poll_table_entry结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>对每一个fd调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fop-&gt;poll() </span><br><span class="line">poll_wait()</span><br><span class="line">__pollwait()</span><br></pre></td></tr></table></figure></p><p>都会先从poll_wqueues. inline_entries[]中分配一个poll_table_entry结构体，直到该数组用完才会分配物理页挂在链表指针poll_wqueues.table上，然后才会分配一个poll_table_entry结构体。具体用来做什么？这里先简单说说，<code>__pollwait()</code>函数调用时需要3个参数，第一个是特定fd对应的file结构体指针，第二个就是特定fd对应的硬件驱动程序中的等待队列头指针，第3个是调用select()的应用进程中poll_wqueues结构体的poll_table项(该进程监测的所有fd，调用fop-&gt;poll函数时都用这一个poll_table结构体)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> &#123;</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span>            <span class="comment">// 指向特定fd对应的file结构体;</span></span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">long</span> key;            <span class="comment">// 等待特定fd对应硬件设备的事件掩码，如POLLIN、</span></span><br><span class="line"><span class="comment">//  POLLOUT、POLLERR;</span></span><br><span class="line">       <span class="keyword">wait_queue_t</span> wait;           <span class="comment">// 代表调用select()的应用进程，等待在fd对应设备的特定事件</span></span><br><span class="line"><span class="comment">//  (读或者写)的等待队列头上，的等待队列项;</span></span><br><span class="line">       <span class="keyword">wait_queue_head_t</span> *wait_address; <span class="comment">// 设备驱动程序中特定事件的等待队列头；</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>总结一下几点：</p><ol><li>特定的硬件设备驱动程序的事件等待队列头是有限个数的，通常有读事件和写事件的等待队列头；</li><li>一个调用了select()的应用进程只存在一个poll_wqueues结构体；</li><li>应用程序可以有多个fd同时监测其各自的事件发生，但该应用进程中每一个fd有多少个poll_table_entry存在，那就取决于fd对应的驱动程序中有几个事件等待队列头了，也就是说，通常驱动程序的poll函数需要对每一个事件的等待队列头调用poll_wait()函数。比如，如果有读写两个等待队列头，那么在这个应用进程中存在两个poll_table_entry结构体，在这两个事件的等待队列头中分别将两个等待队列项加入。</li></ol><h3 id="3-2-注意项"><a href="#3-2-注意项" class="headerlink" title="3.2 注意项"></a>3.2 注意项</h3><p>对于第3点中，如果驱动程序中有多个事件等待队列头，那么在这种情况下，写设备驱动程序时就要特别小心了，特别是设备有事件就绪，然后唤醒等待队列头中所有应用进程的时候，需要使用另外的宏。</p><p>在这之前看一看<code>__pollwait()</code>函数中填充poll_table_entry结构体时注册的唤醒回调函数pollwake()。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pollwake</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line">       entry = container_of(wait, struct poll_table_entry, wait);</span><br><span class="line">       <span class="comment">// 取得poll_table_entry结构体指针</span></span><br><span class="line">       <span class="keyword">if</span> (key &amp;&amp; !((<span class="keyword">unsigned</span> <span class="keyword">long</span>)key &amp; entry-&gt;key))</span><br><span class="line">       <span class="comment">/*这里的条件判断至关重要，避免应用进程被误唤醒，什么意思？*/</span></span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> __pollwake(wait, mode, sync, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>驱动程序中存在多个事件的等待队列头，并且应用程序中只监测了该硬件的某几项事件，比如，驱动中有读写等待队列头，但应用程序只监测读事件的发生。这种情况下，写驱动程序时候，如果唤醒函数用法不当，就会引起误唤醒的情况。<br>先来看一看我们熟知的一些唤醒函数吧！<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up(x)                    __wake_up(x, TASK_NORMAL, 1, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_interruptible(x)      __wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)</span></span><br></pre></td></tr></table></figure></p><p>注意到这个key了吗？通常我们调用唤醒函数时key为NULL，很容易看出，如果我们在这种情况下，使用上面两种唤醒函数，那么<code>key &amp;&amp; !((unsigned long)key &amp; entry-&gt;key)</code>的判断条件一直都会是假，也就是说，只要设备的几类事件之一有发生，不管应用程序中是否对其有监测，都会在这里顺利通过，将应用程序唤醒，唤醒后，重新调用一遍fop-&gt;poll(注意：第一次和第二次调用该函数时少做了一件事，后面代码详解)函数，得到设备事件掩码。假如恰好在这次唤醒后的一轮调用fop-&gt;poll()函数的循环中，没有其他硬件设备就绪，那么可想而知，从源码上看，do_select()会直接返回0。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mask是每一个fop-&gt;poll()程序返回的设备状态掩码。</span></span><br><span class="line"><span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">       res_in |= bit;         <span class="comment">// fd对应的设备可读</span></span><br><span class="line">       retval++;</span><br><span class="line">       wait = <span class="literal">NULL</span>;              <span class="comment">// 后续有用，避免重复执行__pollwait()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>(in &amp; bit)</code>这个条件就是用来确认用户程序有没有让你监测该事件的, 如果没有retval仍然是0，基于前面的假设，那么do_select()返回给上层的也是0。那又假如应用程序中调用select()的时候没有传入超时值，那岂不是和事实不相符合吗？没有传递超时值，那么select()函数会一直阻塞直到至少有1个fd的状态就绪。</p><p>所以在这种情况下，设备驱动中唤醒函数需要用另外的一组：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_poll(x, m)                            /</span></span><br><span class="line">       __wake_up(x, TASK_NORMAL, <span class="number">1</span>, (<span class="keyword">void</span> *) (m))</span><br><span class="line">       </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up_interruptible_poll(x, m)               /</span></span><br><span class="line">       __wake_up(x, TASK_INTERRUPTIBLE, <span class="number">1</span>, (<span class="keyword">void</span> *) (m))</span><br></pre></td></tr></table></figure></p><p>上述的m值，应该和设备发生的事件相符合。设置poll_table_entry结构体key项的函数是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLEX_SET (POLLPRI)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wait_key_set</span><span class="params">(poll_table *wait, <span class="keyword">unsigned</span> <span class="keyword">long</span> in,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">unsigned</span> <span class="keyword">long</span> out, <span class="keyword">unsigned</span> <span class="keyword">long</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (wait) &#123;</span><br><span class="line">              wait-&gt;key = POLLEX_SET;</span><br><span class="line">              <span class="keyword">if</span> (in &amp; bit)</span><br><span class="line">                     wait-&gt;key |= POLLIN_SET;</span><br><span class="line">              <span class="keyword">if</span> (out &amp; bit)</span><br><span class="line">                     wait-&gt;key |= POLLOUT_SET;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的m值，可以参考上面的宏来设置，注意传递的不是key的指针，而就是其值本身，只不过在wake_up_poll()到pollwake()的传递过程中是将其转换成指针的。</p><p>如果唤醒函数使用后面一组的话，再加上合理设置key值，我相信pollwake()函数中的if一定会严格把关，不让应用程序没有监测的事件唤醒应用进程，从而避免了发生误唤醒。</p><h2 id="4-fop-gt-poll"><a href="#4-fop-gt-poll" class="headerlink" title="4. fop-&gt;poll()"></a>4. fop-&gt;poll()</h2><p>fop-&gt;poll()函数就是file_operations结构体中的poll函数指针项，该函数相信很多人都知道怎么写，网上大把的文章介绍其模板，但是为什么要那么写，而且它做了什么具体的事情？本小节来揭开其神秘面纱，先贴一个模板上来。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">XXX_poll</span><span class="params">(struct file *filp, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">XXX_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    poll_wait(filp, &amp;dev-&gt;r_wait, wait);</span><br><span class="line">    poll_wait(filp ,&amp;dev-&gt;w_wait, wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(...)<span class="comment">//读就绪</span></span><br><span class="line">    ｛</span><br><span class="line">          mask |= POLLIN | POLLRDNORM;</span><br><span class="line">     ｝</span><br><span class="line">    <span class="keyword">if</span>(...)<span class="comment">//写就绪</span></span><br><span class="line">    ｛</span><br><span class="line">          mask |= POLLOUT | POLLRDNORM;</span><br><span class="line">     ｝</span><br><span class="line">    ..</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个poll_wait()函数所做的工作挺简单，就是添加一个等待队列项到poll_wait ()函数传递进去的第二个参数，其代表的是驱动程序中的特定事件的等待队列头。</p><p>下面以字符设备evdev为例，文件drivers/input/evdev.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">evdev_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">client</span>-&gt;<span class="title">evdev</span>;</span></span><br><span class="line"></span><br><span class="line">       poll_wait(file, &amp;evdev-&gt;wait, wait);</span><br><span class="line">       <span class="keyword">return</span> ((client-&gt;head == client-&gt;tail) ? <span class="number">0</span> : (POLLIN | POLLRDNORM)) |</span><br><span class="line">              (evdev-&gt;exist ? <span class="number">0</span> : (POLLHUP | POLLERR));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p &amp;&amp; wait_address)</span><br><span class="line">              p-&gt;qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中wait_address是驱动程序需要提供的等待队列头，来容纳后续等待该硬件设备就绪的进程对应的等待队列项。关键结构体poll_table, 这个结构体名字也取的不好，什么table？其实其中没有table的一丁点概念，容易让人误解呀！<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">       poll_queue_proc qproc;</span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">long</span> key;</span><br><span class="line">&#125; poll_table;</span><br></pre></td></tr></table></figure></p><p>fop-&gt;poll()函数的poll_table参数是从哪里传进来的？阅读代码就可以发现，do_select()函数中存在一个结构体struct poll_wqueues，其内嵌了一个poll_table的结构体，所以在后面的大循环中依次调用各个fd的fop-&gt;poll()传递的poll_table参数都是poll_wqueues.poll_table。</p><p>poll_table结构体的定义其实蛮简单，就一个函数指针，一个key值。这个函数指针在整个select过程中一直不变，而key则会根据不同的fd的监测要求而变化。</p><p>qproc函数初始化在函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do_select()</span><br><span class="line">poll_initwait()</span><br><span class="line">init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait)</span><br></pre></td></tr></table></figure></p><p>中实现，回调函数就是<code>__pollwait()</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">       …</span><br><span class="line">       poll_initwait(&amp;table);</span><br><span class="line">       …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poll_initwait</span><span class="params">(struct poll_wqueues *pwq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);</span><br><span class="line">       …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_poll_funcptr</span><span class="params">(poll_table *pt, poll_queue_proc qproc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       pt-&gt;qproc = qproc;</span><br><span class="line">       pt-&gt;key   = ~<span class="number">0U</span>L; <span class="comment">/* all events enabled */</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a new entry */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __pollwait(struct file *filp, <span class="keyword">wait_queue_head_t</span> *wait_address, poll_table *p)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> = <span class="title">container_of</span>(<span class="title">p</span>, <span class="title">struct</span> <span class="title">poll_wqueues</span>, <span class="title">pt</span>);</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span> = <span class="title">poll_get_entry</span>(<span class="title">pwq</span>);</span></span><br><span class="line">       <span class="keyword">if</span> (!entry)</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">       get_file(filp);</span><br><span class="line">       entry-&gt;filp = filp;         <span class="comment">// 保存对应的file结构体</span></span><br><span class="line">       entry-&gt;wait_address = wait_address;  <span class="comment">// 保存来自设备驱动程序的等待队列头</span></span><br><span class="line">       entry-&gt;key = p-&gt;key;   <span class="comment">// 保存对该fd关心的事件掩码</span></span><br><span class="line">       init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);</span><br><span class="line">       <span class="comment">// 初始化等待队列项，pollwake是唤醒该等待队列项时候调用的函数</span></span><br><span class="line">       entry-&gt;wait.<span class="keyword">private</span> = pwq;</span><br><span class="line">       <span class="comment">// 将poll_wqueues作为该等待队列项的私有数据，后面使用</span></span><br><span class="line">       add_wait_queue(wait_address, &amp;entry-&gt;wait);</span><br><span class="line">       <span class="comment">// 将该等待队列项添加到从驱动程序中传递过来的等待队列头中去。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数首先通过container_of宏来得到结构体poll_wqueues的地址，然后调用poll_get_entry()函数来获得一个poll_table_entry结构体，这个结构体是用来连接驱动和应用进程的关键结构体，其实联系很简单，这个结构体中内嵌了一个等待队列项wait_queue_t，和一个等待队列头 wait_queue_head_t，它就是驱动程序中定义的等待队列头，应用进程就是在这里保存了每一个硬件设备驱动程序中的等待队列头(当然每一个fd都有一个poll_table_entry结构体)。</p><p>很容易想到的是，如果这个设备在别的应用程序中也有使用，又恰好别的应用进程中也是用select()来访问该硬件设备，那么在另外一个应用进程的同一个地方也会调用同样的函数来初始化一个poll_table_entry结构体，然后将这个结构体中内嵌的等待队列项添加到同一份驱动程序的等待队列头中。此后，如果设备就绪了，那么驱动程序中将会唤醒这个对于等待队列头中所有的等待队列项(也就是等待在该设备上的所有应用进程，所有等待的应用进程将会得到同一份数据)。</p><p>上面语句保存了一个应用程序select一个fd的硬件设备时最全的信息，方便在设备就绪的时候容易得到对应的数据。这里的entry-&gt;key值就是为了防止误唤醒而准备的。设置这个key值的地方在函数do_select()中。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line">       f_op = file-&gt;f_op;</span><br><span class="line">       mask = DEFAULT_POLLMASK;</span><br><span class="line">       <span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll) &#123;</span><br><span class="line">              wait_key_set(wait, in, out, bit);   </span><br><span class="line">            mask = (*f_op-&gt;poll)(file, wait);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>fop-&gt;poll()函数的返回值都是有规定的，例如函数evdev_poll()中的返回值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((client-&gt;head == client-&gt;tail) ? <span class="number">0</span> : (POLLIN | POLLRDNORM)) |</span><br><span class="line">              (evdev-&gt;exist ? <span class="number">0</span> : (POLLHUP | POLLERR));</span><br></pre></td></tr></table></figure></p><p>会根据驱动程序中特定的buffer队列标志，来返回设备状态。这里的判断条件是读循环buffer的头尾指针是否相等：client-&gt;head == client-&gt;tail。</p><h2 id="5-poll-wait-函数在select-睡眠前后调用的差异"><a href="#5-poll-wait-函数在select-睡眠前后调用的差异" class="headerlink" title="5. poll_wait()函数在select()睡眠前后调用的差异"></a>5. poll_wait()函数在select()睡眠前后调用的差异</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (p &amp;&amp; wait_address)</span><br><span class="line">              p-&gt;qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个if条件判断，如果驱动程序中没有提供等待队列头wait_address，那么将不会往下执行p-&gt;qproc，也就是不会将当前应用进程的等待队列项添加进驱动程序中对应的等待队列头中。</p><p>如果select()中调用fop-&gt;poll()时传递进来的poll_table是NULL，通常情况下，只要在应用层传递进来的超时时间结构体值不为0，哪怕这个结构体指针你传递NULL，那么在函数do_select()中第一次睡眠之前的那次所有fd的大循环中，调用fop-&gt;poll()函数传递的poll_table是绝对不会为NULL的。但是第一次睡眠唤醒之后的又一次所有fd的大循环中，再次调用fop-&gt;poll()函数时，此时传递的poll_table是NULL，可想而知，这一次只是检查fop-&gt;poll()的返回状态值而已。如果从上层调用select时传递的超时值结构体赋值成0，那么do_select()函数的只会调用一次所有fd的大循环，之后不再进入睡眠，直接返回0给上层，基本上这种情况是没有得到任何有用的状态。</p><p>为了避免应用进程被唤醒之后再次调用pollwait()的时，重复地调用函数<code>__pollwait()</code>，在传递poll_table结构体指针的时候，在睡眠之前保证其为有效地址，而在唤醒之后保证传入的poll_table地址是NULL，因为在唤醒之后，再次调用fop-&gt;poll()的作用只是为了再次检查设备的事件状态而已。具体详见代码。</p><h2 id="6-唤醒应用进程"><a href="#6-唤醒应用进程" class="headerlink" title="6. 唤醒应用进程"></a>6. 唤醒应用进程</h2><p><a href="/2019/08/26/Some-details-about-select-implementation/#3-2-注意项">注意事项</a>中已经讨论过驱动程序唤醒进程的一点注意项，但这里再次介绍睡眠唤醒的整个流程。<br>睡眠时调用函数poll_schedule_timeout()来实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll_schedule_timeout</span><span class="params">(struct poll_wqueues *pwq, <span class="keyword">int</span> state,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">ktime_t</span> *expires, <span class="keyword">unsigned</span> <span class="keyword">long</span> slack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> rc = -EINTR;</span><br><span class="line">       set_current_state(state);</span><br><span class="line">       <span class="keyword">if</span> (!pwq-&gt;triggered)  <span class="comment">// 这个triggered在什么时候被置1的呢?只要有一个fd</span></span><br><span class="line"><span class="comment">// 对应的设备将当前应用进程唤醒后将会把它设置成1</span></span><br><span class="line">              rc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);</span><br><span class="line">       __set_current_state(TASK_RUNNING);</span><br><span class="line">  </span><br><span class="line">       set_mb(pwq-&gt;triggered, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>唤醒的话会调用函数pollwake():<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pollwake</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line">       entry = container_of(wait, struct poll_table_entry, wait);</span><br><span class="line">       <span class="keyword">if</span> (key &amp;&amp; !((<span class="keyword">unsigned</span> <span class="keyword">long</span>)key &amp; entry-&gt;key))</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> __pollwake(wait, mode, sync, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __pollwake(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> = <span class="title">wait</span>-&gt;<span class="title">private</span>;</span></span><br><span class="line">       DECLARE_WAITQUEUE(dummy_wait, pwq-&gt;polling_task);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Although this function is called under waitqueue lock, LOCK</span></span><br><span class="line"><span class="comment">        * doesn't imply write barrier and the users expect write</span></span><br><span class="line"><span class="comment">        * barrier semantics on wakeup functions.  The following</span></span><br><span class="line"><span class="comment">        * smp_wmb() is equivalent to smp_wmb() in try_to_wake_up()</span></span><br><span class="line"><span class="comment">        * and is paired with set_mb() in poll_schedule_timeout.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       smp_wmb();</span><br><span class="line">       pwq-&gt;triggered = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// select()用户进程只要有被唤醒过，就不可能再次进入睡眠，因为这个标志在睡眠的时候有用          </span></span><br><span class="line">       <span class="keyword">return</span> default_wake_function(&amp;dummy_wait, mode, sync, key);</span><br><span class="line">       <span class="comment">// 默认通用的唤醒函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>参考资料：</p><ol><li><p><a href="https://blog.csdn.net/lizhiguo0532/article/details/6568964" target="_blank" rel="noopener">select(poll)系统调用实现解析(一)</a></p></li><li><p><a href="https://blog.csdn.net/lizhiguo0532/article/details/6568968" target="_blank" rel="noopener">select(poll)系统调用实现解析(二)</a></p></li><li><a href="https://blog.csdn.net/lizhiguo0532/article/details/6568969" target="_blank" rel="noopener">select(poll)系统调用实现解析(三)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2019/08/26/select-usage-and-implementation-in-kernel/&quot;&gt;select usage and implementation in kernel&lt;/a&gt;简单介绍了select的内核实现，&lt;a href=&quot;/2019/08/26/file-operations-poll-function/&quot;&gt;file_operations poll function&lt;/a&gt;介绍了file_operations中的 poll函数。在看完 &lt;a href=&quot;https://blog.csdn.net/lizhiguo0532/article/details/6568964&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;select(poll)系统调用实现解析(一)&lt;/a&gt;文章后，发现还是需要介绍下detail。本文内容源于该系列文章。&lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>file_operations poll function</title>
    <link href="http://liujunming.github.io/2019/08/26/file-operations-poll-function/"/>
    <id>http://liujunming.github.io/2019/08/26/file-operations-poll-function/</id>
    <published>2019-08-26T03:31:13.000Z</published>
    <updated>2019-08-30T14:29:00.165Z</updated>
    
    <content type="html"><![CDATA[<p>值得注意的是，本文中的poll并非system call，而是内核中file_operations的poll函数。</p><a id="more"></a><p>强烈建议先阅读<a href="/2019/08/26/select-usage-and-implementation-in-kernel/">select usage and implementation in kernel</a>。</p><p>注：代码中的细节可参见<a href="https://www.oreilly.com/library/view/linux-device-drivers/0596005903/ch06.html" target="_blank" rel="noopener">Advanced Char Driver Operations</a>。</p><p>内容源于：<a href="http://janfan.cn/chinese/2015/01/05/select-poll-impl-inside-the-kernel.html" target="_blank" rel="noopener">select()/poll() 的内核实现</a></p><blockquote><p>For every file descriptor, it calls that fd’s <code>poll()</code> method, which will add the caller to that fd’s wait queue, and return which events (readable, writeable, exception) currently apply to that fd.</p></blockquote><h2 id="1-How-to-add-poll-function-to-the-kernel-module-code"><a href="#1-How-to-add-poll-function-to-the-kernel-module-code" class="headerlink" title="1. How to add poll function to the kernel module code?"></a>1. How to add poll function to the kernel module code?</h2><ol><li><p>Include needed headers:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/poll.h&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>Declare waitqueue variable:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(fortune_wait)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Add <code>fortune_poll()</code> function and add it (as <code>.poll</code> callback) to your file operations structure:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">fortune_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poll_wait(file, &amp;fortune_wait, wait);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>-data-is-ready)</span><br><span class="line">        <span class="keyword">return</span> POLLIN | POLLRDNORM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_test_fops</span> = &#123;</span></span><br><span class="line">    ....</span><br><span class="line">    .poll = fortune_poll,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> Note that you should return <code>POLLIN</code> | <code>POLLRDNORM</code> if you have some new data to read, and 0 in case there is no new data to read.</p></li><li><p>Notify your waitqueue once you have new data:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wake_up_interruptible(&amp;fortune_wait);</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-scull驱动实例"><a href="#2-scull驱动实例" class="headerlink" title="2. scull驱动实例"></a>2. <code>scull</code>驱动实例</h2><p>由于Linux设备驱动的耦合设计，对设备的操作函数都是驱动程序自定义的，我们必须要结合一个具体的实例来看看，才能知道<code>f_op-&gt;poll</code>里面弄得是什么鬼。</p><p>在这里我们以Linux Device Drivers, Third Edition一书中的例子——<code>scull</code>设备的驱动程序为例。</p><blockquote><p><code>scull</code> (Simple Character Utility for Loading Localities). scull is a char driver that acts on a memory area as though it were a device.</p></blockquote><p><code>scull</code>设备不同于硬件设备，它是模拟出来的一块内存，因此对它的读写更快速更自由，内存支持你顺着读倒着读点着读怎么读都可以。 我们以书中“管道”（pipe）式，即FIFO的读写驱动程序为例。</p><p>首先是<code>scull_pipe</code>的结构体，注意<code>wait_queue_head_t</code>这个队列类型，它就是用来记录等待设备I/O事件的进程的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scull_pipe</span> &#123;</span></span><br><span class="line">        <span class="keyword">wait_queue_head_t</span> inq, outq;       <span class="comment">/* read and write queues */</span></span><br><span class="line">        <span class="keyword">char</span> *buffer, *end;                <span class="comment">/* begin of buf, end of buf*/</span></span><br><span class="line">        <span class="keyword">int</span> buffersize;                    <span class="comment">/* used in pointer arithmetic*/</span></span><br><span class="line">        <span class="keyword">char</span> *rp, *wp;                     <span class="comment">/* where to read, where to write */</span></span><br><span class="line">        <span class="keyword">int</span> nreaders, nwriters;            <span class="comment">/* number of openings for r/w */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">async_queue</span>;</span> <span class="comment">/* asynchronous readers */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span>              <span class="comment">/* mutual exclusion semaphore */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>                  <span class="comment">/* Char device structure */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>scull</code>设备的轮询操作函数<code>scull_p_poll</code>，驱动模块加载后，这个函数就被挂到<code>(*poll)</code>函数指针上去了。</p><p>我们可以看到它的确是返回了当前设备的I/O状态，并且调用了内核的<code>poll_wait()</code>函数，这里注意，它把自己的<code>wait_queue_head_t</code>队列也当作参数传进去了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">scull_p_poll</span><span class="params">(struct file *filp, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scull_pipe</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">poll_wait(filp, &amp;dev-&gt;inq,  wait);</span><br><span class="line">poll_wait(filp, &amp;dev-&gt;outq, wait);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;rp != dev-&gt;wp)</span><br><span class="line">mask |= POLLIN | POLLRDNORM;<span class="comment">/* readable */</span></span><br><span class="line"><span class="keyword">if</span> (spacefree(dev))</span><br><span class="line">mask |= POLLOUT | POLLWRNORM;<span class="comment">/* writable */</span></span><br><span class="line">mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"><span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当<code>scull</code>有数据写入时，它会把<code>wait_queue_head_t</code>队列里等待的进程给唤醒。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">scull_p_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">loff_t</span> *f_pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"><span class="comment">/* finally, awake any reader */</span></span><br><span class="line">wake_up_interruptible(&amp;dev-&gt;inq);  <span class="comment">/* blocked in read() and select() */</span></span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可是<code>wait_queue_head_t</code>队列里的进程是什么时候装进去的？ 肯定是<code>poll_wait</code>搞的鬼！</p><h2 id="3-poll-wait与设备的等待队列"><a href="#3-poll-wait与设备的等待队列" class="headerlink" title="3. poll_wait与设备的等待队列"></a>3. <code>poll_wait</code>与设备的等待队列</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class="line">p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do not touch the structure directly, use the access functions</span></span><br><span class="line"><span class="comment"> * poll_does_not_wait() and poll_requested_events() instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">poll_queue_proc _qproc;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _key;</span><br><span class="line">&#125; poll_table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * structures and helpers for f_op-&gt;poll implementations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到，<code>poll_wait()</code>其实就是只是直接调用了<code>struct poll_table_struct</code>结构里绑定的函数指针。 我们需要找到<code>struct poll_table_struct</code>初始化的地方。</p><blockquote><p>The <code>poll_table</code> structure is just a wrapper around a function that builds the actual data structure. That structure, for <code>poll</code> and <code>select</code>, is a linked list of memory pages containing <code>poll_table_entry</code> structures.</p></blockquote><p><code>struct poll_table_struct</code>里的函数指针，是在<code>do_select()</code>初始化的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">poll_table *wait;</span><br><span class="line">poll_initwait(&amp;table);</span><br><span class="line">wait = &amp;table.pt;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poll_initwait</span><span class="params">(struct poll_wqueues *pwq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化poll_table里的函数指针</span></span><br><span class="line">init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);</span><br><span class="line">pwq-&gt;polling_task = current;</span><br><span class="line">pwq-&gt;triggered = <span class="number">0</span>;</span><br><span class="line">pwq-&gt;error = <span class="number">0</span>;</span><br><span class="line">pwq-&gt;table = <span class="literal">NULL</span>;</span><br><span class="line">pwq-&gt;inline_index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(poll_initwait);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_poll_funcptr</span><span class="params">(poll_table *pt, poll_queue_proc qproc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pt-&gt;_qproc = qproc;</span><br><span class="line">pt-&gt;_key   = ~<span class="number">0U</span>L; <span class="comment">/* all events enabled */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在终于知道，<code>__pollwait()</code>函数，就是<code>poll_wait()</code>幕后的真凶。</p><p><code>add_wait_queue()</code>把当前进程添加到设备的等待队列<code>wait_queue_head_t</code>中去。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a new entry */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __pollwait(struct file *filp, <span class="keyword">wait_queue_head_t</span> *wait_address,</span><br><span class="line">poll_table *p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> = <span class="title">container_of</span>(<span class="title">p</span>, <span class="title">struct</span> <span class="title">poll_wqueues</span>, <span class="title">pt</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span> = <span class="title">poll_get_entry</span>(<span class="title">pwq</span>);</span></span><br><span class="line"><span class="keyword">if</span> (!entry)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">entry-&gt;filp = get_file(filp);</span><br><span class="line">entry-&gt;wait_address = wait_address;</span><br><span class="line">entry-&gt;key = p-&gt;_key;</span><br><span class="line">init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);</span><br><span class="line">entry-&gt;wait.<span class="keyword">private</span> = pwq;</span><br><span class="line"><span class="comment">// 把当前进程装到设备的等待队列</span></span><br><span class="line">add_wait_queue(wait_address, &amp;entry-&gt;wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_wait_queue</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</span><br><span class="line">spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">__add_wait_queue(q, wait);</span><br><span class="line">spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add_wait_queue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __add_wait_queue(<span class="keyword">wait_queue_head_t</span> *head, <span class="keyword">wait_queue_t</span> *<span class="keyword">new</span>)</span><br><span class="line">&#123;</span><br><span class="line">list_add(&amp;<span class="keyword">new</span>-&gt;task_list, &amp;head-&gt;task_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Insert a new element after the given list head. The new element does not</span></span><br><span class="line"><span class="comment"> * need to be initialised as empty list.</span></span><br><span class="line"><span class="comment"> * The list changes from:</span></span><br><span class="line"><span class="comment"> *      head → some element → ...</span></span><br><span class="line"><span class="comment"> * to</span></span><br><span class="line"><span class="comment"> *      head → new element → older element → ...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * struct foo *newfoo = malloc(...);</span></span><br><span class="line"><span class="comment"> * list_add(&amp;newfoo-&gt;entry, &amp;bar-&gt;list_of_foos);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param entry The new element to prepend to the list.</span></span><br><span class="line"><span class="comment"> * @param head The existing list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">list_add(struct list_head *entry, struct list_head *head)</span><br><span class="line">&#123;</span><br><span class="line">    __list_add(entry, head, head-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>参考资料： </p><ol><li><a href="http://janfan.cn/chinese/2015/01/05/select-poll-impl-inside-the-kernel.html" target="_blank" rel="noopener">select()/poll() 的内核实现</a></li><li><a href="https://stackoverflow.com/questions/30035776/how-to-add-poll-function-to-the-kernel-module-code" target="_blank" rel="noopener">How to add poll function to the kernel module code?</a></li><li><a href="https://stackoverflow.com/questions/25147181/pollhup-vs-pollnval-or-what-is-pollhup" target="_blank" rel="noopener">POLLHUP vs POLLNVAL, or what is POLLHUP?</a></li><li><a href="https://www.oreilly.com/library/view/linux-device-drivers/0596005903/ch06.html" target="_blank" rel="noopener">Advanced Char Driver Operations</a></li><li><a href="http://www.embeddedlinux.org.cn/ldd3note/_51.htm" target="_blank" rel="noopener">底层数据结构</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;值得注意的是，本文中的poll并非system call，而是内核中file_operations的poll函数。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>system call: select vs poll vs epoll</title>
    <link href="http://liujunming.github.io/2019/08/26/system%20call%20select%20vs%20poll%20vs%20epoll/"/>
    <id>http://liujunming.github.io/2019/08/26/system call select vs poll vs epoll/</id>
    <published>2019-08-26T03:19:46.000Z</published>
    <updated>2019-08-30T14:29:00.168Z</updated>
    
    <content type="html"><![CDATA[<p>建议阅读<a href="https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/#.XWNUOOgzaUk" target="_blank" rel="noopener">LINUX – IO MULTIPLEXING – SELECT VS POLL VS EPOLL</a>中的实例代码。</p><a id="more"></a><hr><p>参考资料：</p><ol><li><a href="https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll/" target="_blank" rel="noopener">Async IO on Linux: select, poll, and epoll</a></li><li><a href="https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/#.XWNUOOgzaUk" target="_blank" rel="noopener">LINUX – IO MULTIPLEXING – SELECT VS POLL VS EPOLL</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建议阅读&lt;a href=&quot;https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/#.XWNUOOgzaUk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LINUX – IO MULTIPLEXING – SELECT VS POLL VS EPOLL&lt;/a&gt;中的实例代码。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>select usage and implementation in kernel</title>
    <link href="http://liujunming.github.io/2019/08/26/select-usage-and-implementation-in-kernel/"/>
    <id>http://liujunming.github.io/2019/08/26/select-usage-and-implementation-in-kernel/</id>
    <published>2019-08-26T01:55:29.000Z</published>
    <updated>2019-08-30T14:29:00.167Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍select的用法及其内核实现。</p><a id="more"></a><h2 id="1-用法"><a href="#1-用法" class="headerlink" title="1. 用法"></a>1. 用法</h2><p>首先要建立起<a href="/2018/12/26/IO-同步，异步，阻塞，非阻塞/#3-I-O-多路复用（-I-O-multiplexing）">IO多路复用</a>的概念。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, \</span></span></span><br><span class="line"><span class="function"><span class="params">fd_set *exceptfds, struct timeval *timeout)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fd_set rfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Watch stdin (fd 0) to see when it has input. */</span></span><br><span class="line">    FD_ZERO(&amp;rfds);</span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;rfds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait up to five seconds. */</span></span><br><span class="line">    tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    retval = select(<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"select()"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Data is available now.\n"</span>);</span><br><span class="line">        <span class="comment">/* FD_ISSET(0, &amp;rfds) will be true. */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No data within five seconds.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-内核实现"><a href="#2-内核实现" class="headerlink" title="2. 内核实现"></a>2. 内核实现</h2><p>这里只讲述内核实现select的核心部分。本部分内容源于：<a href="http://janfan.cn/chinese/2015/01/05/select-poll-impl-inside-the-kernel.html" target="_blank" rel="noopener">select()/poll() 的内核实现</a>。</p><p>kernel version: <a href="https://elixir.bootlin.com/linux/v3.9-rc8/source" target="_blank" rel="noopener">v3.9-rc8</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(select</span><br><span class="line">core_sys_select</span><br><span class="line">do_select</span><br><span class="line">poll_schedule_timeout</span><br></pre></td></tr></table></figure><h3 id="2-1-do-select-循环体"><a href="#2-1-do-select-循环体" class="headerlink" title="2.1 do_select()循环体"></a>2.1 <code>do_select()</code>循环体</h3><p><code>do_select()</code>实质上是一个大的循环体，对每一个主程序要求监听的设备fd（File Descriptor）做一次<code>struct file_operations</code>结构体里的<code>poll</code>操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">f = fdget(i);</span><br><span class="line"><span class="keyword">if</span> (f.file) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br><span class="line">f_op = f.file-&gt;f_op;</span><br><span class="line">mask = DEFAULT_POLLMASK;</span><br><span class="line"><span class="keyword">if</span> (f_op-&gt;poll) &#123;</span><br><span class="line">wait_key_set(wait, in, out,</span><br><span class="line">     bit, busy_flag);</span><br><span class="line"><span class="comment">// 对每个fd进行I/O事件检测</span></span><br><span class="line">mask = (*f_op-&gt;poll)(f.file, wait);</span><br><span class="line">&#125;</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出循环体</span></span><br><span class="line"><span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 进入休眠</span></span><br><span class="line"><span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">to, slack))</span><br><span class="line">timed_out = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p><code>(*f_op-&gt;poll)</code>会返回当前设备fd的状态（比如是否可读可写），根据这个状态，<code>do_select()</code>接着做出不同的动作</p><ul><li>如果设备fd的状态与主程序的感兴趣的I/O事件匹配，则记录下来，do_select()退出循环体，并把结果返回给上层主程序。</li><li>如果不匹配，do_select()发现timeout已经到了或者进程有signal信号打断，也会退出循环，只是返回空的结果给上层应用。</li></ul><p>但如果<code>do_select()</code>发现当前没有事件发生，又还没到timeout，更没signal打扰，内核会在这个循环体里面永远地轮询下去吗？</p><p><code>do_select()</code>把全部fd检测一轮之后如果没有可用I/O事件，会让当前进程去休眠一段时间，等待fd设备或定时器来唤醒自己，然后再继续循环体看看哪些fd可用，以此提高效率。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll_schedule_timeout</span><span class="params">(struct poll_wqueues *pwq, <span class="keyword">int</span> state,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">ktime_t</span> *expires, <span class="keyword">unsigned</span> <span class="keyword">long</span> slack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rc = -EINTR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 休眠</span></span><br><span class="line">set_current_state(state);</span><br><span class="line"><span class="keyword">if</span> (!pwq-&gt;triggered)</span><br><span class="line">rc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Prepare for the next iteration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following set_mb() serves two purposes.  First, it's</span></span><br><span class="line"><span class="comment"> * the counterpart rmb of the wmb in pollwake() such that data</span></span><br><span class="line"><span class="comment"> * written before wake up is always visible after wake up.</span></span><br><span class="line"><span class="comment"> * Second, the full barrier guarantees that triggered clearing</span></span><br><span class="line"><span class="comment"> * doesn't pass event check of the next iteration.  Note that</span></span><br><span class="line"><span class="comment"> * this problem doesn't exist for the first iteration as</span></span><br><span class="line"><span class="comment"> * add_wait_queue() has full barrier semantics.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_mb(pwq-&gt;triggered, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(poll_schedule_timeout);</span><br></pre></td></tr></table></figure></p><h3 id="2-2-struct-file-operations设备驱动的操作函数"><a href="#2-2-struct-file-operations设备驱动的操作函数" class="headerlink" title="2.2 struct file_operations设备驱动的操作函数"></a>2.2 <code>struct file_operations</code>设备驱动的操作函数</h3><p>设备发现I/O事件时会唤醒主程序进程？ 每个设备fd的等待队列在哪？我们什么时候把当前进程添加到它们的等待队列里去了？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mask = (*f_op-&gt;poll)(f.file, wait);</span><br></pre></td></tr></table></figure></p><p>就是上面这行代码干的好事。 不过在此之前，我们得先了解一下系统内核与文件设备的驱动程序之间耦合框架的设计。</p><p>上文对每个设备的操作<code>f_op-&gt;poll</code>，是一个针对每个文件设备特定的内核函数，区别于我们平时用的系统调用<code>poll()</code>。 并且，这个操作是<code>select()</code> <code>poll()</code> <code>epoll()</code>背后实现的共同基础。</p><blockquote><p>Support for any of these calls requires support from the device driver. This support (for all three calls, <code>select()</code> <code>poll()</code> and <code>epoll()</code>) is provided through the driver’s poll method.</p></blockquote><p>Linux的设计很灵活，它并不知道每个具体的文件设备是怎么操作的（怎么打开，怎么读写），但内核让每个设备拥有一个<code>struct file_operations</code>结构体，这个结构体里定义了各种用于操作设备的函数指针，指向操作每个文件设备的驱动程序实现的具体操作函数，即设备驱动的回调函数（callback）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span><span class="title">f_path</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span>*<span class="title">f_inode</span>;</span><span class="comment">/* cached value */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// …</span></span><br><span class="line"></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>)));<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line"><span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line"><span class="comment">// select()轮询设备fd的操作函数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个<code>f_op-&gt;poll</code>对文件设备做了什么事情呢？ 一是调用<code>poll_wait()</code>函数； 二是检测文件设备的当前状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *filp, struct poll_table_struct *pwait)</span></span>;</span><br></pre></td></tr></table></figure></p><blockquote><p>For every file descriptor, it calls that fd’s <code>poll()</code> method, which will add the caller to that fd’s wait queue, and return which events (readable, writeable, exception) currently apply to that fd.</p></blockquote><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>总结一下<code>select()</code>的大概流程。</p><ol><li>先把全部fd扫一遍</li><li>如果发现有可用的fd，跳到5</li><li>如果没有，当前进程去睡觉xx秒</li><li>xx秒后自己醒了，或者状态变化的fd唤醒了自己，跳到1</li><li>结束循环体，返回</li></ol><hr><p>参考资料：</p><ol><li><a href="http://man7.org/linux/man-pages/man2/select.2.html" target="_blank" rel="noopener">man select</a></li><li><a href="http://janfan.cn/chinese/2015/01/05/select-poll-impl-inside-the-kernel.html" target="_blank" rel="noopener">select()/poll() 的内核实现</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍select的用法及其内核实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的工作队列</title>
    <link href="http://liujunming.github.io/2019/08/25/Linux%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/"/>
    <id>http://liujunming.github.io/2019/08/25/Linux中的工作队列/</id>
    <published>2019-08-25T10:37:19.000Z</published>
    <updated>2019-08-30T14:29:00.164Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍下Linux中的工作队列，并给出具体的demo。</p><a id="more"></a><h2 id="1-为什么要有工作队列"><a href="#1-为什么要有工作队列" class="headerlink" title="1. 为什么要有工作队列"></a>1. 为什么要有工作队列</h2><p>可以参见<a href="/2018/12/04/Understanding-the-Linux-Kernel-读书笔记-Interrupts-and-Exceptions/#8-Work-Queues">Work Queues</a>。</p><p>简单来说，工作队列(work queue)是Linux kernel中将工作推后执行的一种机制。这种机制和<a href="/2019/08/21/linux-kernel中tasklet的使用/">Tasklets</a>不同之处在于工作队列是把推后的工作交由一个内核线程去执行，因此工作队列的优势就在于它允许重新调度甚至睡眠。</p><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p>kernel version : <a href="https://elixir.bootlin.com/linux/v5.3-rc5/source" target="_blank" rel="noopener">v5.3-rc5</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_long_t</span> data; <span class="comment">//data用来存储用户的私人数据，此数据即是func的参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line"><span class="keyword">work_func_t</span> func; <span class="comment">//函数指针，由用户实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The <em>work queues</em> allow kernel functions to be activated (much like deferrable functions) and later executed by special kernel threads called <em>worker threads</em>.</p><h2 id="3-demo"><a href="#3-demo" class="headerlink" title="3. demo"></a>3. demo</h2><p>Simple example of workqueue:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> printd() \</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">"workqueue_test: %s %d\n"</span>, __FUNCTION__, __LINE__); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">work_handler(struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_data</span> * <span class="title">data</span> = (<span class="title">struct</span> <span class="title">work_data</span> *)<span class="title">work</span>;</span></span><br><span class="line">    printd();</span><br><span class="line">    kfree(data);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">wq_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_data</span> * <span class="title">data</span>;</span></span><br><span class="line"> </span><br><span class="line">    printd();</span><br><span class="line">    wq = create_workqueue(<span class="string">"wq_test"</span>);</span><br><span class="line">    data = kmalloc(<span class="keyword">sizeof</span>(struct work_data), GFP_KERNEL);</span><br><span class="line">    INIT_WORK(&amp;data-&gt;work, work_handler);</span><br><span class="line">    queue_work(wq, &amp;data-&gt;work);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">wq_exit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    printd();</span><br><span class="line">    flush_workqueue(wq);</span><br><span class="line">    destroy_workqueue(wq);</span><br><span class="line">    printd();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(wq_init);</span><br><span class="line">module_exit(wq_exit);</span><br></pre></td></tr></table></figure><p>Results:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">workqueue_test: wq_init 33</span><br><span class="line">workqueue_test: work_handler 23</span><br><span class="line">workqueue_test: wq_exit 45</span><br><span class="line">workqueue_test: wq_exit 48</span><br></pre></td></tr></table></figure><p>具体函数的api去lxr中查询。</p><hr><p>参考资料：</p><ol><li><a href="https://www.cnblogs.com/wwang/archive/2010/10/27/1862202.html" target="_blank" rel="noopener">Linux中的工作队列</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍下Linux中的工作队列，并给出具体的demo。&lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel wait queue机制</title>
    <link href="http://liujunming.github.io/2019/08/25/Linux-kernel-wait-queue%E6%9C%BA%E5%88%B6/"/>
    <id>http://liujunming.github.io/2019/08/25/Linux-kernel-wait-queue机制/</id>
    <published>2019-08-25T08:37:35.000Z</published>
    <updated>2019-08-30T14:29:00.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>While writing modules there might be situations where one might have to wait for input some condition to occur before proceeding further. Tasks that need such behavior can make use of the sleep functionality available in the kernel.<br>In Linux sleeping is handled by a data structure called wait queue, which is nothing but a list of processes waiting for an input or  event. </p><a id="more"></a><p>等待队列在内核中有很多用途，尤其在中断处理、进程同步及定时。等待队列实现事件上的条件等待；希望等待特定事件的进程把自己放在合适的等待队列，并放弃控制权。</p><h2 id="2-等待队列"><a href="#2-等待队列" class="headerlink" title="2. 等待队列"></a>2. 等待队列</h2><p>本文代码的内核版本为<a href="https://elixir.bootlin.com/linux/v3.14.69/source" target="_blank" rel="noopener">3.14.69</a>。</p><p>研究等待队列这个内核非常基础的数据结构，对于加深理解Linux非常有帮忙，等待队列有两种数据结构：等待队列头(<code>wait_queue_head_t</code>)和等待队列项(<code>wait_queue_t</code>)，两者都有一个<code>list_head</code>类型task_list。双向链表通过task_list将 等待队列头和一系列等待队列项串起来，源码如下所示。</p><h3 id="2-1-struct-wait-queue-head-t"><a href="#2-1-struct-wait-queue-head-t" class="headerlink" title="2.1 struct wait_queue_head_t"></a>2.1 <code>struct wait_queue_head_t</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        lock;  <span class="comment">//用于互斥访问的自旋锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-struct-wait-queue-t"><a href="#2-2-struct-wait-queue-t" class="headerlink" title="2.2 struct wait_queue_t"></a>2.2 <code>struct wait_queue_t</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        flags;</span><br><span class="line">    <span class="keyword">void</span>            *<span class="keyword">private</span>;  <span class="comment">//指向等待队列的进程task_struct</span></span><br><span class="line">    <span class="keyword">wait_queue_func_t</span>    func;  <span class="comment">//调用唤醒函数，缺省为default_wake_function，调用try_to_wake_up将进程更改为可运行状态并设置调度标志</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">task_list</span>;</span> <span class="comment">//链表元素，将wait_queue_t挂到wait_queue_head_t</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br></pre></td></tr></table></figure><p><img src="/images/2019/8/25.jpg" alt></p><h3 id="2-3-add-wait-queue"><a href="#2-3-add-wait-queue" class="headerlink" title="2.3 add_wait_queue"></a>2.3 <code>add_wait_queue</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_wait_queue</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    __add_wait_queue(q, wait);  <span class="comment">//挂到队列头</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __add_wait_queue(<span class="keyword">wait_queue_head_t</span> *head, <span class="keyword">wait_queue_t</span> *<span class="keyword">new</span>)</span><br><span class="line">&#123;</span><br><span class="line">    list_add(&amp;<span class="keyword">new</span>-&gt;task_list, &amp;head-&gt;task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的功能是将wait等待队列项 挂到等待队列头q中。</p><h3 id="2-4-remove-wait-queue"><a href="#2-4-remove-wait-queue" class="headerlink" title="2.4 remove_wait_queue"></a>2.4 remove_wait_queue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_wait_queue</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</span><br><span class="line">    __remove_wait_queue(q, wait);</span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __remove_wait_queue(<span class="keyword">wait_queue_head_t</span> *head, <span class="keyword">wait_queue_t</span> *old)</span><br><span class="line">&#123;</span><br><span class="line">    list_del(&amp;old-&gt;task_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要功能是将wait等待队列项 从等待队列头q中移除。</p><h2 id="3-等待事件"><a href="#3-等待事件" class="headerlink" title="3. 等待事件"></a>3. 等待事件</h2><h3 id="3-1-wait-event-queue-condition"><a href="#3-1-wait-event-queue-condition" class="headerlink" title="3.1 wait_event(queue,condition)"></a>3.1 wait_event(queue,condition)</h3><p>The task will keep waiting on the queue as long as the condition does not become true.If put to sleep using this call, the task can not be interrupted. </p><h3 id="3-2-wait-event-interruptible-queue-condition"><a href="#3-2-wait-event-interruptible-queue-condition" class="headerlink" title="3.2 wait_event_interruptible(queue,condition)"></a>3.2 wait_event_interruptible(queue,condition)</h3><p>similar to wait_event, but it can be interrupted by other signals too. It is always preferable to use this interruptible way of sleeping so that the task can be stopped in case the condition never becomes true. </p><h3 id="3-3-wait-event-timeout-queue-condition-timeout"><a href="#3-3-wait-event-timeout-queue-condition-timeout" class="headerlink" title="3.3 wait_event_timeout(queue,condition,timeout)"></a>3.3 wait_event_timeout(queue,condition,timeout)</h3><p>The task will sleep on the queue until the condition becomes  true or the timeout mentioned expires, which ever occurs first. The timeout is expressed in jiffies. Task can not be interrupted before the timeout if the condition does not become true. </p><h3 id="3-4-wait-event-interruptible-timeout-queue-condition-timeout"><a href="#3-4-wait-event-interruptible-timeout-queue-condition-timeout" class="headerlink" title="3.4 wait_event_interruptible_timeout(queue,condition,timeout)"></a>3.4 wait_event_interruptible_timeout(queue,condition,timeout)</h3><p>Similar to wait_event_timeout but it can be interrupted. </p><p>Once a task has been put to sleep we need to wake it up , which can be done using following : </p><h2 id="4-唤醒队列"><a href="#4-唤醒队列" class="headerlink" title="4. 唤醒队列"></a>4. 唤醒队列</h2><h3 id="4-1-wake-up-queue"><a href="#4-1-wake-up-queue" class="headerlink" title="4.1 wake_up(queue)"></a>4.1 wake_up(queue)</h3><p>In case the task has been put to non interruptible sleep. </p><h3 id="4-2-wake-up-interruptible-queue"><a href="#4-2-wake-up-interruptible-queue" class="headerlink" title="4.2 wake_up_interruptible (queue)"></a>4.2 wake_up_interruptible (queue)</h3><p>In case the task has been put to an interruptible sleep. </p><hr><p>参考资料：</p><ol><li><a href="http://blog.chinaunix.net/uid-27717694-id-4288685.html" target="_blank" rel="noopener"><a href="http://blog.chinaunix.net/uid-27717694-id-4288685.html" target="_blank" rel="noopener">wait queue机制</a></a></li><li>[<a href="http://blog.sina.com.cn/s/blog_694348b00100uf03.html" target="_blank" rel="noopener">linux等待队列wait_queue_head_t和wait_queue_t</a></li><li><a href="http://tuxthink.blogspot.com/2011/04/wait-queues.html" target="_blank" rel="noopener">Wait queues</a></li><li><a href="http://gityuan.com/2018/12/02/linux-wait-queue/" target="_blank" rel="noopener">源码解读Linux等待队列</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;While writing modules there might be situations where one might have to wait for input some condition to occur before proceeding further. Tasks that need such behavior can make use of the sleep functionality available in the kernel.&lt;br&gt;In Linux sleeping is handled by a data structure called wait queue, which is nothing but a list of processes waiting for an input or  event. &lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Intel Trace Hub support</title>
    <link href="http://liujunming.github.io/2019/08/25/Intel-Trace-Hub-support/"/>
    <id>http://liujunming.github.io/2019/08/25/Intel-Trace-Hub-support/</id>
    <published>2019-08-25T07:15:01.000Z</published>
    <updated>2019-08-30T14:29:00.162Z</updated>
    
    <content type="html"><![CDATA[<p>Intel Trace Hub (TH) is a set of hardware blocks that produce, switch and output trace data from multiple hardware and software sources over several types of trace output ports encoded in System Trace Protocol (MIPI STPv2) and is intended to perform full system debugging.</p><a id="more"></a><hr><p>参考资料：</p><ol><li><a href="https://lwn.net/Articles/635900/" target="_blank" rel="noopener">Introduce Intel Trace Hub support</a></li><li><a href="https://software.intel.com/sites/default/files/intel-trace-hub-developers-manual-2.1.2.pdf" target="_blank" rel="noopener">Intel® Trace Hub (Intel® TH) Developer’s Manual</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Intel Trace Hub (TH) is a set of hardware blocks that produce, switch and output trace data from multiple hardware and software sources over several types of trace output ports encoded in System Trace Protocol (MIPI STPv2) and is intended to perform full system debugging.&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>__setup and early_param in kernel</title>
    <link href="http://liujunming.github.io/2019/08/25/setup-and-early-param-in-kernel/"/>
    <id>http://liujunming.github.io/2019/08/25/setup-and-early-param-in-kernel/</id>
    <published>2019-08-25T07:07:44.000Z</published>
    <updated>2019-08-30T14:29:00.167Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>__setup</code> and <code>early_param</code>在内核中的作用是：设置启动参数。</p><p>本文主要内容源于：<a href="https://blog.csdn.net/Tommy_wxie/article/details/8041487" target="_blank" rel="noopener">Linux启动参数及实现 __setup与early_param</a></p><a id="more"></a><p>首先看下<code>__setup</code> and <code>early_param</code>这两个宏长什么样？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> early_param(str, fn)\</span></span><br><span class="line">__setup_param(str, fn, fn, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> early_param(str, fn)\</span></span><br><span class="line">__setup_param(str, fn, fn, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>__setup</code>与<code>early_param</code>不同的是，<code>early_param</code> 宏注册的内核选项必须要在其他内核选项之前被处理。</p><p>在函数<code>start_kernel</code>中，<code>parse_early_param</code>处理<code>early_param</code>定义的参数，<code>parse_args</code>处理<code>__setup</code>定义的参数。</p><hr><p>参考资料：</p><ol><li><a href="https://blog.csdn.net/Tommy_wxie/article/details/8041487" target="_blank" rel="noopener">Linux启动参数及实现 __setup与early_param</a></li><li><a href="https://cole3.github.io/2017/05/29/Linux-kernel-parses-cmdline/" target="_blank" rel="noopener">Linux kernel parses cmdline</a></li><li><a href="http://blog.chinaunix.net/uid-13798723-id-2871394.html" target="_blank" rel="noopener">__setup 在内核中的作用</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;code&gt;__setup&lt;/code&gt; and &lt;code&gt;early_param&lt;/code&gt;在内核中的作用是：设置启动参数。&lt;/p&gt;
&lt;p&gt;本文主要内容源于：&lt;a href=&quot;https://blog.csdn.net/Tommy_wxie/article/details/8041487&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux启动参数及实现 __setup与early_param&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Invoking user-space applications from the kernel</title>
    <link href="http://liujunming.github.io/2019/08/25/Invoking-user-space-applications-from-the-kernel/"/>
    <id>http://liujunming.github.io/2019/08/25/Invoking-user-space-applications-from-the-kernel/</id>
    <published>2019-08-25T06:41:39.000Z</published>
    <updated>2019-08-30T14:29:00.163Z</updated>
    
    <content type="html"><![CDATA[<p>Invoking specific kernel functions (system calls) is a natural part of application development on GNU/Linux. But what about going in the other direction, kernel space calling user space? It turns out that there are a number of applications for this feature that you likely use every day. For example, when the kernel finds a device for which a module needs to be loaded, how does this process occur? Dynamic module loading occurs from the kernel through the <em>usermode-helper</em> process.</p><a id="more"></a><p>Data structure that is used for the API is <code>struct subprocess_info</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/linux/include/kmod.h</span><br><span class="line"></span><br><span class="line">struct subprocess_info &#123;</span><br><span class="line">struct work_struct work;</span><br><span class="line">struct completion* complete;</span><br><span class="line">const char* path;</span><br><span class="line">char** argv;</span><br><span class="line">char** envp;</span><br><span class="line">int wait;</span><br><span class="line">int retval;</span><br><span class="line">int (*init)(struct subprocess_info* info, struct cred* new);</span><br><span class="line">void (*cleanup)(struct subprocess_info* info);</span><br><span class="line">void* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Simple example from the reference:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int umh_test( void )</span><br><span class="line">&#123;</span><br><span class="line">  struct subprocess_info ∗sub_info;</span><br><span class="line">  char ∗argv[] = &#123; &quot;/usr/bin/logger&quot;, &quot;help!&quot;, NULL &#125;;</span><br><span class="line">  static char ∗envp[] = &#123;</span><br><span class="line">        &quot;HOME=/&quot;,</span><br><span class="line">        &quot;TERM=linux&quot;,</span><br><span class="line">        &quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;, NULL &#125;;</span><br><span class="line"></span><br><span class="line">  sub_info = call_usermodehelper_setup( argv[0], argv, envp, GFP_ATOMIC );</span><br><span class="line">  if (sub_info == NULL) return ‑ENOMEM;</span><br><span class="line"></span><br><span class="line">  return call_usermodehelper_exec( sub_info, UMH_WAIT_PROC );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This code will executes <code>/usr/bin/logger</code> executable file. It should be called from device driver, or another kernel space.</p><p>Simpler version of process creation is as follows.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static int umh_test( void )</span><br><span class="line">&#123;</span><br><span class="line">  char ∗argv[] = &#123; &quot;/usr/bin/logger&quot;, &quot;help!&quot;, NULL &#125;;</span><br><span class="line">  static char ∗envp[] = &#123;</span><br><span class="line">        &quot;HOME=/&quot;,</span><br><span class="line">        &quot;TERM=linux&quot;,</span><br><span class="line">        &quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;, NULL &#125;;</span><br><span class="line"></span><br><span class="line">  return call_usermodehelper( argv[0], argv, envp, UMH_WAIT_PROC );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><a href="https://developer.ibm.com/articles/l-user-space-apps/" target="_blank" rel="noopener">Invoking user-space applications from the kernel</a></li><li><a href="https://insujang.github.io/2017-05-10/usermode-helper-api/" target="_blank" rel="noopener">Usermode Helper API</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Invoking specific kernel functions (system calls) is a natural part of application development on GNU/Linux. But what about going in the other direction, kernel space calling user space? It turns out that there are a number of applications for this feature that you likely use every day. For example, when the kernel finds a device for which a module needs to be loaded, how does this process occur? Dynamic module loading occurs from the kernel through the &lt;em&gt;usermode-helper&lt;/em&gt; process.&lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>ioctl() vs unlocked_ioctl() vs compact_ioctl()</title>
    <link href="http://liujunming.github.io/2019/08/25/ioctl-vs-unlocked-ioctl-vs-compact-ioctl/"/>
    <id>http://liujunming.github.io/2019/08/25/ioctl-vs-unlocked-ioctl-vs-compact-ioctl/</id>
    <published>2019-08-25T06:03:54.000Z</published>
    <updated>2019-08-30T14:29:00.166Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录下ioctl() 、 unlocked_ioctl() 和 compact_ioctl()的区别与联系。</p><a id="more"></a><p>可先看完<a href="/2019/07/20/linux-ioctl-函数详解/">linux ioctl()函数详解</a>再看本文。</p><p><code>ioctl()</code> is one of the remaining parts of the kernel which runs under the Big Kernel Lock (BKL). In the past, the usage of the BKL has made it possible for long-running <code>ioctl()</code> methods to create long latencies for unrelated processes.</p><p>Follows an explanation of the patch that introduced <code>unlocked_ioctl</code> and <code>compat_ioctl</code> into 2.6.11. The <a href="http://lwn.net/Articles/394724/" target="_blank" rel="noopener">removal of the <code>ioctl</code> field</a> happened a lot later, in 2.6.36.</p><p>Explanation: When <code>ioctl</code> was executed, it took the <a href="http://en.wikipedia.org/wiki/Giant_lock" target="_blank" rel="noopener">Big Kernel Lock</a> (BKL), so nothing else could execute at the same time. This is very bad on a multiprocessor machine, so there was a big effort to get rid of the BKL. First, <code>unlocked_ioctl</code> was introduced. It lets each driver writer choose what lock to use instead. This can be difficult, so there was a period of transition during which old drivers still worked (using <code>ioctl</code>) but new drivers could use the improved interface (<code>unlocked_ioctl</code>). Eventually all drivers were converted and <code>ioctl</code> could be removed.</p><p><code>compat_ioctl</code> is actually unrelated, even though it was added at the same time. Its purpose is to allow 32-bit userland programs to make <code>ioctl</code> calls on a 64-bit kernel. The meaning of the last argument to <code>ioctl</code> depends on the driver, so there is no way to do a driver-independent conversion.</p><hr><p>参考资料：</p><ol><li><a href="https://unix.stackexchange.com/questions/4711/what-is-the-difference-between-ioctl-unlocked-ioctl-and-compat-ioctl" target="_blank" rel="noopener">What is the difference between ioctl(), unlocked_ioctl() and compat_ioctl()?</a></li><li><a href="https://lwn.net/Articles/119652/" target="_blank" rel="noopener">The new way of ioctl()</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录下ioctl() 、 unlocked_ioctl() 和 compact_ioctl()的区别与联系。&lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>linux kernel中eventfd的使用</title>
    <link href="http://liujunming.github.io/2019/08/24/linux-kernel%E4%B8%ADeventfd%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://liujunming.github.io/2019/08/24/linux-kernel中eventfd的使用/</id>
    <published>2019-08-24T07:04:52.000Z</published>
    <updated>2019-08-24T07:48:39.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是eventfd？"><a href="#什么是eventfd？" class="headerlink" title="什么是eventfd？"></a>什么是eventfd？</h2><p>An “eventfd object” can be used as an event wait/notify mechanism by user-space applications, and by the kernel to notify user-space applications of events. It has been added to kernel since Linux 2.6.22. The object contains an unsigned 64-bit integer (uint64_t) counter that is maintained by the kernel.  This counter is initialized with the value specified in the argument initval.<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eventfd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> initval, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></p><p>本文主要关注eventfd在kernel notify user-space applications中的应用。</p><h2 id="kernel-module中eventfd的使用"><a href="#kernel-module中eventfd的使用" class="headerlink" title="kernel module中eventfd的使用"></a>kernel module中eventfd的使用</h2><p>以下内容来源于Stack Overflow中<a href="https://stackoverflow.com/questions/13607730/writing-to-eventfd-from-kernel-module" target="_blank" rel="noopener">Writing to eventfd from kernel module</a>。</p><p>Each open file on a system could be identified by the pid of one of the processes which opened it and the fd corresponding to that file (within that process’s context). So if my kernel module knows the pid and fd, it can look up the <code>struct * task_struct</code> of the process and from that the <code>struct * files</code> and finally using the fd, it can acquire the pointer to the eventfd’s <code>struct * file</code>. Then, using this last pointer, it can write to the eventfd’s counter.</p><p>Here are the codes for the userspace program and the kernel module that I wrote up to demonstrate the concept (which now work):</p><p><strong>Userspace C code (efd_us.c):</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;     //Definition of uint64_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> efd; <span class="comment">//Eventfd file descriptor</span></span><br><span class="line"><span class="keyword">uint64_t</span> eftd_ctr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> retval;     <span class="comment">//for select()</span></span><br><span class="line">fd_set rfds;        <span class="comment">//for select()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create eventfd</span></span><br><span class="line">    efd = eventfd(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (efd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nUnable to create eventfd! Exiting...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nefd=%d pid=%d"</span>,efd,getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Watch efd</span></span><br><span class="line">    FD_ZERO(&amp;rfds);</span><br><span class="line">    FD_SET(efd, &amp;rfds);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nNow waiting on select()..."</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    retval = select(efd+<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nselect() error. Exiting..."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nselect() says data is available now. Exiting..."</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nreturned from select(), now executing read()..."</span>);</span><br><span class="line">        s = read(efd, &amp;eftd_ctr, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\neventfd read error. Exiting..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\nReturned from read(), value read = %lld"</span>,eftd_ctr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nselect() says that no data was available"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nClosing eventfd. Exiting..."</span>);</span><br><span class="line">    close(efd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Kernel Module C code (efd_lkm.c):</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fdtable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rcupdate.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/eventfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Received from userspace. Process ID and eventfd's File descriptor are enough to uniquely identify an eventfd object.</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="keyword">int</span> efd;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Resolved references...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">userspace_task</span> = <span class="title">NULL</span>;</span> <span class="comment">//...to userspace program's task struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">efd_file</span> = <span class="title">NULL</span>;</span>          <span class="comment">//...to eventfd's file struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventfd_ctx</span> * <span class="title">efd_ctx</span> = <span class="title">NULL</span>;</span>        <span class="comment">//...and finally to eventfd context</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Increment Counter by 1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> plus_one = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_module</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"~~~Received from userspace: pid=%d efd=%d\n"</span>,pid,efd);</span><br><span class="line"></span><br><span class="line">    userspace_task = pid_task(find_vpid(pid), PIDTYPE_PID);</span><br><span class="line">    printk(KERN_ALERT <span class="string">"~~~Resolved pointer to the userspace program's task struct: %p\n"</span>,userspace_task);</span><br><span class="line"></span><br><span class="line">    printk(KERN_ALERT <span class="string">"~~~Resolved pointer to the userspace program's files struct: %p\n"</span>,userspace_task-&gt;files);</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    efd_file = fcheck_files(userspace_task-&gt;files, efd);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    printk(KERN_ALERT <span class="string">"~~~Resolved pointer to the userspace program's eventfd's file struct: %p\n"</span>,efd_file);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    efd_ctx = eventfd_ctx_fileget(efd_file);</span><br><span class="line">    <span class="keyword">if</span> (!efd_ctx) &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">"~~~eventfd_ctx_fileget() Jhol, Bye.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"~~~Resolved pointer to the userspace program's eventfd's context: %p\n"</span>,efd_ctx);</span><br><span class="line"></span><br><span class="line">    eventfd_signal(efd_ctx, plus_one);</span><br><span class="line"></span><br><span class="line">    printk(KERN_ALERT <span class="string">"~~~Incremented userspace program's eventfd's counter by 1\n"</span>);</span><br><span class="line"></span><br><span class="line">    eventfd_ctx_put(efd_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup_module</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"~~~Module Exiting...\n"</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">module_param(pid, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line">module_param(efd, <span class="keyword">int</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>To run this, carry out the following steps:</p><ol><li>Compile the userspace program (efd_us.out) and the kernel module (efd_lkm.ko)</li><li>Run the userspace program (./efd_us.out) and note the pid and efd values that it print. (for eg. “pid=2803 efd=3”. The userspace program will wait endlessly on select()</li><li>Open a new terminal window and insert the kernel module passing the pid and efd as params: <code>sudo insmod efd_lkm.ko pid=2803 efd=3</code></li><li>Switch back to the userspace program window and you will see that the userspace program has broken out of select and exited.</li></ol><p>内核中的函数可以去<a href="https://elixir.bootlin.com/linux/latest/source" target="_blank" rel="noopener">lxr</a>中查看。</p><hr><p>参考资料：</p><ol><li><a href="https://stackoverflow.com/questions/13607730/writing-to-eventfd-from-kernel-module" target="_blank" rel="noopener">Writing to eventfd from kernel module stackoverflow</a></li><li><a href="http://man7.org/linux/man-pages/man2/eventfd.2.html" target="_blank" rel="noopener">Linux Programmer’s Manual EVENTFD</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是eventfd？&quot;&gt;&lt;a href=&quot;#什么是eventfd？&quot; class=&quot;headerlink&quot; title=&quot;什么是eventfd？&quot;&gt;&lt;/a&gt;什么是eventfd？&lt;/h2&gt;&lt;p&gt;An “eventfd object” can be used as an event wait/notify mechanism by user-space applications, and by the kernel to notify user-space applications of events. It has been added to kernel since Linux 2.6.22. The object contains an unsigned 64-bit integer (uint64_t) counter that is maintained by the kernel.  This counter is initialized with the value specified in the argument initval.&lt;br&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>ACPI misc</title>
    <link href="http://liujunming.github.io/2019/08/24/ACPI-misc/"/>
    <id>http://liujunming.github.io/2019/08/24/ACPI-misc/</id>
    <published>2019-08-24T05:13:32.000Z</published>
    <updated>2019-08-24T05:55:14.611Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要整理ACPI相关的misc。记录下较好的文章。</p><a id="more"></a><ul><li><a href="https://metebalci.com/blog/a-minimum-complete-tutorial-of-cpu-power-management-c-states-and-p-states/" target="_blank" rel="noopener">A MINIMUM COMPLETE TUTORIAL OF CPU POWER MANAGEMENT, C-STATES AND P-STATES</a></li><li><a href="https://www.landley.net/kdocs/ols/2007/ols2007v1-pages-205-214.pdf" target="_blank" rel="noopener">How virtualization makes power management different</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要整理ACPI相关的misc。记录下较好的文章。&lt;/p&gt;
    
    </summary>
    
      <category term="系统" scheme="http://liujunming.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="http://liujunming.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>ACPI那些事</title>
    <link href="http://liujunming.github.io/2019/08/24/ACPI%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://liujunming.github.io/2019/08/24/ACPI那些事/</id>
    <published>2019-08-23T16:10:23.000Z</published>
    <updated>2019-08-24T06:24:34.487Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录下APCI的相关概念。</p><a id="more"></a><h2 id="什么是ACPI？"><a href="#什么是ACPI？" class="headerlink" title="什么是ACPI？"></a>什么是ACPI？</h2><p>Advanced Configuration and Power Interface (ACPI) provides an open standard that operating systems can use to discover and configure computer hardware components, to perform power management by (for example) putting unused components to sleep, and to perform status monitoring.</p><p>可以将ACPI理解为一套接口，由Firmware定义，os来调用,这样可以隐藏hardware中detail的信息。主要提供ACPI table给os。</p><p><img src="/images/2019/8/11.png" alt><br>The primary intention of the standard ACPI framework and the hardware register set is to enable power management and system configuration without directly calling firmware natively from the OS.</p><h2 id="为什么要有ACPI"><a href="#为什么要有ACPI" class="headerlink" title="为什么要有ACPI?"></a>为什么要有ACPI?</h2><blockquote><p>Before the development of ACPI, operating systems (OS) primarily used BIOS (Basic Input/Output System) interfaces for power management and device discovery and configuration. This power management approach used the OS’s ability to call the system BIOS natively for power management. The BIOS was also used to discover system devices and load drivers based on probing input/output (I/O) and attempting to match the correct driver to the correct device (plug and play). The location of devices could also be hard coded within the BIOS because the platform itself was non­-enumerable.</p></blockquote><blockquote><p>These solutions were problematic in three key ways. First, the behavior of OS applications could be negatively affected by the BIOS­ configured power management settings, causing systems to go to sleep during presentations or other inconvenient times. Second, the power management interface was proprietary on each system. This required developers to learn how to configure power management for each individual system. Finally, the default settings for various devices could also conflict with each other, causing devices to crash, behave erratically, or become undiscoverable.</p></blockquote><p>ACPI was developed to solve these problems and others.</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="/images/2019/8/15.png" alt><br>ACPI is an interface specification comprised of both software and hardware elements.</p><h2 id="ACPI的组成"><a href="#ACPI的组成" class="headerlink" title="ACPI的组成"></a>ACPI的组成</h2><p><img src="/images/2019/8/12.png" alt><br>Data tables store raw data and are consumed by device drivers. Definition blocks consist of byte code that is executable by an interpreter.</p><p><img src="/images/2019/8/13.png" alt></p><p><img src="/images/2019/8/14.png" alt><br>Functions implemented by ACPI include:</p><ul><li>System/Device/Processor power management</li><li>Device/Processor performance management</li><li>Configuration / Plug and Play</li><li>System event</li><li>Battery management</li><li>Thermal management</li></ul><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>ACPI比较复杂，若想精通，只能去读Spec。</p><p>下面我mark下ACPI的相关资料吧。</p><ul><li><a href="https://uefi.org/sites/default/files/resources/ACPI_6_2.pdf" target="_blank" rel="noopener">Advanced Configuration and Power Interface (ACPI) Specification</a></li><li><a href="https://acpica.org/sites/acpica/files/ACPI-Introduction.pdf" target="_blank" rel="noopener">ACPI-Introduction</a></li><li><a href="https://www.kernel.org/doc/ols/2005/ols2005v1-pages-59-76.pdf" target="_blank" rel="noopener">ols ACPI in Linux</a></li></ul><hr><p>参考资料：</p><ol start="2"><li><a href="https://www.wikiwand.com/en/Advanced_Configuration_and_Power_Interface" target="_blank" rel="noopener">wikiwand</a></li><li><a href="https://acpica.org/sites/acpica/files/ACPI-Introduction.pdf" target="_blank" rel="noopener">ACPI-Introduction</a></li><li><a href="https://social.msdn.microsoft.com/Forums/SECURITY/en-US/2be2b4eb-322e-46ef-9cb7-4435f9cfb895/uefi-and-acpi-bios?forum=wdk" target="_blank" rel="noopener">UEFI and ACPI BIOS</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录下APCI的相关概念。&lt;/p&gt;
    
    </summary>
    
      <category term="系统" scheme="http://liujunming.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="http://liujunming.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>BOOT misc</title>
    <link href="http://liujunming.github.io/2019/08/23/BOOT-misc/"/>
    <id>http://liujunming.github.io/2019/08/23/BOOT-misc/</id>
    <published>2019-08-23T15:00:26.000Z</published>
    <updated>2019-08-23T15:47:58.308Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要整理Boot相关的misc。<br><a id="more"></a></p><p><a href="https://unix.stackexchange.com/questions/5518/what-is-the-difference-between-the-following-kernel-makefile-terms-vmlinux-vml" target="_blank" rel="noopener">What is the difference between the following kernel Makefile terms: vmLinux, vmlinuz, vmlinux.bin, zimage &amp; bzimage?</a></p><ul><li>vmlinux</li></ul><p>This is the Linux kernel in an statically linked executable file format. Generally, you don’t have to worry about this file, it’s just a intermediate step in the boot procedure.</p><p>The raw vmlinux file may be useful for debugging purposes.</p><ul><li>vmlinuz</li></ul><p>The vmlinux file usually gets compressed with <code>zlib</code>. Since 2.6.30 <code>LZMA</code> and <code>bzip2</code> are also available. By adding further boot and decompression capabilities to vmlinuz, the image can be used to boot a system with the vmlinux kernel. The compression of vmlinux can occur with zImage or bzImage.</p><ul><li>zImage(<code>make zImage</code>)</li></ul><p>This is the old format for small kernels (compressed, below 512KB). At boot, this image gets loaded low in memory (the first 640KB of the RAM).</p><ul><li>bzImage(<code>make bzImage</code>)</li></ul><p>The big zImage, was created while the kernel grew and handles bigger images (compressed, over 512KB). The image gets loaded high in memory (above 1MB RAM). As today’s kernels are way over 512KB, this is usually the preferred way.</p><hr><p><a href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#Linux_kernel_config_options_for_UEFI" target="_blank" rel="noopener">Linux kernel config options for UEFI</a></p><hr><p>EFISTUB</p><p>The Linux kernel supports EFISTUB booting which allows EFI firmware to load the kernel as an EFI executable. Refer:<a href="https://wiki.archlinux.org/index.php/EFISTUB" target="_blank" rel="noopener">archlinux EFISTUB</a></p><p>On the x86 and ARM platforms, a kernel zImage/bzImage can masquerade as a PE/COFF image, thereby convincing EFI firmware loaders to load it as an EFI executable. The code that modifies the bzImage header, along with the EFI-specific entry point that the firmware loader jumps to are collectively known as the “EFI boot stub”.<br>By using the EFI boot stub it’s possible to boot a Linux kernel without the use of a conventional EFI boot loader, such as grub or elilo. Since the EFI boot stub performs the jobs of a boot loader, in a certain sense it is the boot loader. Refer:<a href="https://www.kernel.org/doc/Documentation/efi-stub.txt" target="_blank" rel="noopener">The EFI Boot Stub</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要整理Boot相关的misc。&lt;br&gt;
    
    </summary>
    
      <category term="系统" scheme="http://liujunming.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="http://liujunming.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>BOOT那些事</title>
    <link href="http://liujunming.github.io/2019/08/23/BOOT%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://liujunming.github.io/2019/08/23/BOOT那些事/</id>
    <published>2019-08-23T12:19:06.000Z</published>
    <updated>2019-08-25T03:53:32.645Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下BOOT相关的资料。</p><a id="more"></a><p>之前总结过<a href="http://liujunming.top/2019/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">计算机启动相关知识点</a>，但是读完<a href="https://www.happyassassin.net/2014/01/25/uefi-boot-how-does-that-actually-work-then/" target="_blank" rel="noopener">UEFI boot: how does that actually work, then?</a>之后，理解又加深了。</p><p><a href="https://blog.csdn.net/u013201439/article/details/50195743" target="_blank" rel="noopener">计算机到底如何启动？</a>对<a href="https://www.happyassassin.net/2014/01/25/uefi-boot-how-does-that-actually-work-then/" target="_blank" rel="noopener">UEFI boot: how does that actually work, then?</a>做了相关总结，可以结合着看。</p><hr><p>因为之前接触了<code>efibootmgr</code>，所以记录一下。 (Linux distributions contain a tool called <code>efibootmgr</code> which is used to manipulate the configuration of the UEFI boot manager)。</p><hr><p>Firmware为操作系统提供服务的机制有如下几种：</p><ul><li>EFI spec规定的run time service，由uefi提供</li><li>ACPI table</li><li>SMM(system management mode)</li></ul><hr><p><img src="/images/2019/8/10.jpeg" alt><br><a href="https://github.com/tianocore/tianocore.github.io/wiki/PI-Boot-Flow" target="_blank" rel="noopener">PI Boot Flow</a></p><hr><p>在虚拟化场景中，不得不提<a href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF" target="_blank" rel="noopener">OVMF</a>。OVMF is an <a href="https://github.com/tianocore/tianocore.github.io/wiki/EDK-II" target="_blank" rel="noopener">EDK II</a> based project to enable UEFI support for Virtual Machines.</p><p><a href="http://www.linux-kvm.org/downloads/lersek/ovmf-whitepaper-c770f8c.txt" target="_blank" rel="noopener">ovmf whitepaper</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下BOOT相关的资料。&lt;/p&gt;
    
    </summary>
    
      <category term="系统" scheme="http://liujunming.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="http://liujunming.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>linux kernel中tasklet的使用</title>
    <link href="http://liujunming.github.io/2019/08/21/linux-kernel%E4%B8%ADtasklet%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://liujunming.github.io/2019/08/21/linux-kernel中tasklet的使用/</id>
    <published>2019-08-21T11:36:28.000Z</published>
    <updated>2019-08-21T12:17:21.267Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="http://tuxthink.blogspot.com/2011/09/tasklets-1-introduction.html" target="_blank" rel="noopener">Tasklets</a></p><a id="more"></a><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>Tasklets are used in kernel to schedule a function some time in future. The major use of the tasklet is to schedule <a href="http://liujunming.top/2018/12/04/Understanding-the-Linux-Kernel-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Interrupts-and-Exceptions/" target="_blank" rel="noopener">the bottom half of an interrupt service routine</a>. </p><p>Bottom half is the part of the interrupt service routine which is not time critical and can be executed after a little delay from the time interrupt is generated. This helps is releasing the interrupt line quickly and processing more interrupts. </p><p>Let us look at how we can create a tasklet and schedule it in a kernel module. </p><p>The structure, <code>tasklet_struct</code>, declared in interrupt.h looks as follows </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> state;</span><br><span class="line">    <span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The members of the structure that has to be initialized in the module are : </p><ol><li><p><code>func</code> : Pointer to the function that needs to scheduled for execution at a later time </p></li><li><p><code>data</code> : Data to be passed to the function <code>func</code> </p></li></ol><p>The other members are initialized by the kernel as follows:</p><ul><li><code>count</code> : holds a nonzero value if the tasklet is disabled and 0 if it is enabled. </li><li><code>states</code> : <code>TASKLET_STATE_SCHED</code> , which denotes it is scheduled to run. <code>TASKLET_STATE_RUN</code> , which denotes it is running. </li></ul><p>There are two ways of creating a tasklet:<br><strong>1. Creating Statically: (using Macros) </strong></p><ol><li><code>DECLARE_TASKLET(name, func, data)</code>: Creates a tasklet in the enabled state </li><li><code>DECLARE_TASKLET_DISABLED(name, func, data)</code>: Creates a tasklet in the disabled state </li></ol><p>If the tasklets is created using the second macro, it needs to be enabled explicitly. </p><p>For details, just reference this <a href="http://tuxthink.blogspot.com/2011/09/tasklets-3-using-macros.html" target="_blank" rel="noopener">Using Macros</a>.<br><strong>2. Creating in runtime</strong></p><ul><li><code>tasklet_init(name,func,data)</code></li></ul><p>Where “name” is the name of the taskelet, “func” in the function which has to be executed as a part of the tasklet and “data” is the data that has to passed to func. </p><ul><li><p>A tasklet is a softirq and hence runs in an interrupt context. Thus while executing the function you are not allowed to go to sleep and have to use proper locking for any data that is shared with other tasklets. </p></li><li><p>Scheduling a tasklet: </p></li></ul><p>Once the tasklet has been created, it needs to be scheduled which is done by the function <code>tasklet_schedule(&amp;tasklet)</code> </p><ul><li>Enable and Disable : </li></ul><p>The tasklets can be disabled, if they are not running already, using <code>tasklet_disable(&amp;taskelt)</code></p><p>and enabled using <code>tasklet_enble(&amp;tasklet)</code></p><p>When does the tasklet actually get scheduled can not be controlled and is decided by the scheduler depending on the load on the processor. If the processor is free, it might get scheduled immediately. </p><p>For details, just reference this <a href="http://tuxthink.blogspot.com/2011/09/tasklet-2-using-tasklerinit.html" target="_blank" rel="noopener">using tasklet_init</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;http://tuxthink.blogspot.com/2011/09/tasklets-1-introduction.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tasklets&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>acrn-kernel那些事</title>
    <link href="http://liujunming.github.io/2019/08/20/acrn-kernel%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://liujunming.github.io/2019/08/20/acrn-kernel那些事/</id>
    <published>2019-08-20T14:05:59.000Z</published>
    <updated>2019-08-20T14:14:44.703Z</updated>
    
    <content type="html"><![CDATA[<p>学习kernel时，结合文档与patch，效果俱佳。本文将对<a href="https://github.com/projectacrn/acrn-kernel" target="_blank" rel="noopener">acrn-kernel</a>中acrn/vhm的patch进行解析，相信会从中学到许多。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习kernel时，结合文档与patch，效果俱佳。本文将对&lt;a href=&quot;https://github.com/projectacrn/acrn-kernel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;acrn-kernel&lt;/a&gt;中acrn/vhm的patch进行解析，相信会从中学到许多。&lt;/p&gt;
    
    </summary>
    
      <category term="acrn" scheme="http://liujunming.github.io/categories/acrn/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="acrn" scheme="http://liujunming.github.io/tags/acrn/"/>
    
  </entry>
  
  <entry>
    <title>中断基本概念的建立</title>
    <link href="http://liujunming.github.io/2019/08/17/%E4%B8%AD%E6%96%AD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <id>http://liujunming.github.io/2019/08/17/中断基本概念的建立/</id>
    <published>2019-08-17T08:14:01.000Z</published>
    <updated>2019-08-17T09:37:47.587Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍PCI、APIC、MSI基本概念。<a id="more"></a></p><p>中断从设备发送到CPU需要“可编程中断控制器”的转发(MSI除外)。中断控制器发展至今，经历了PIC和APIC两个阶段。</p><h2 id="1-PIC"><a href="#1-PIC" class="headerlink" title="1. PIC"></a>1. PIC</h2><p>也就是8259A芯片。PIC的相关介绍参见<a href="https://book.douban.com/subject/3619896/" target="_blank" rel="noopener">系统虚拟化</a>2.4.1章节。</p><p>明白PIC中重要的寄存器以及PIC向CPU递交中断的流程即可。若想深究，可以参见<a href="https://pdos.csail.mit.edu/6.828/2005/readings/hardware/8259A.pdf" target="_blank" rel="noopener">8259A Programmable Interrupt Controller</a></p><h2 id="2-APIC"><a href="#2-APIC" class="headerlink" title="2. APIC"></a>2. APIC</h2><p>PIC可以在UP(单处理器)平台上工作，但无法用于MP(多处理器)平台。为此，APIC应运而生。</p><p><img src="/images/2019/8/9.png" alt><br>APIC的相关介绍参见<a href="https://book.douban.com/subject/3619896/" target="_blank" rel="noopener">系统虚拟化</a>2.4.1章节。</p><p>APIC的发展历程：<br>APIC-&gt;xAPIC-&gt;x2APIC</p><p>LAPIC处理的中断类型有如下三种：</p><ul><li>Local interrupt - configured by local vector table(LVT)</li><li>External interrupt - from IOAPIC/MSI</li><li>inter-processor interrupt(IPI) - configured by interrupt command register(ICR)</li></ul><p>详细内容请参见SDM(ADVANCED PROGRAMMABLE INTERRUPT CONTROLLER)部分。</p><h2 id="3-MSI"><a href="#3-MSI" class="headerlink" title="3. MSI"></a>3. MSI</h2><h3 id="3-1-What-are-MSIs"><a href="#3-1-What-are-MSIs" class="headerlink" title="3.1 What are MSIs?"></a>3.1 What are MSIs?</h3><p>A Message Signaled Interrupt is a write from the device to a special address which causes an interrupt to be received by the CPU.</p><p>The MSI capability was first specified in PCI 2.2 and was later enhanced in PCI 3.0 to allow each interrupt to be masked individually.  The MSI-X capability was also introduced with PCI 3.0.  It supports more interrupts per device than MSI and allows interrupts to be independently configured.</p><h3 id="3-2-Why-use-MSIs"><a href="#3-2-Why-use-MSIs" class="headerlink" title="3.2 Why use MSIs?"></a>3.2 Why use MSIs?</h3><p>There are three reasons why using MSIs can give an advantage over traditional pin-based interrupts.</p><ol><li><p>Pin-based PCI interrupts are often shared amongst several devices. To support this, the kernel must call each interrupt handler associated with an interrupt, which leads to reduced performance for the system as a whole.  MSIs are never shared, so this problem cannot arise. <a href="http://liujunming.top/2018/12/04/Understanding-the-Linux-Kernel-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Interrupts-and-Exceptions/" target="_blank" rel="noopener">for detail</a></p></li><li><p>When a device writes data to memory, then raises a pin-based interrupt, it is possible that the interrupt may arrive before all the data has arrived in memory (this becomes more likely with devices behind PCI-PCI bridges).  In order to ensure that all the data has arrived in memory, the interrupt handler must read a register on the device which raised the interrupt.  PCI transaction ordering rules require that all the data arrive in memory before the value may be returned from the register. Using MSIs avoids this problem as the interrupt-generating write cannot pass the data writes, so by the time the interrupt is raised, the driver knows that all the data has arrived in memory.</p></li><li><p>PCI devices can only support a single pin-based interrupt per function. Often drivers have to query the device to find out what event has occurred, slowing down interrupt handling for the common case.  With MSIs, a device can support more interrupts, allowing each interrupt to be specialised to a different purpose.  </p></li></ol><h3 id="3-3-misc"><a href="#3-3-misc" class="headerlink" title="3.3 misc"></a>3.3 misc</h3><p>intel系统中，MSI允许PCI设备直接发送中断到LAPIC，不需要通过IOAPIC。</p><p>MSI allows the device to write a small amount of interrupt-describing data to a special memory-mapped I/O address, and the chipset then delivers the corresponding interrupt to a processor.</p><p>A common misconception with MSI is that it allows the device to send data to a processor as part of the interrupt. The data that is sent as part of the memory write transaction is used by the chipset to determine which interrupt to trigger on which processor; that data is not available for the device to communicate additional information to the interrupt handler.</p><p>On Intel systems, the LAPIC must be enabled for the PCI (and PCI Express) MSI/MSI-X to work, even on uniprocessor (single core) systems. In these systems, MSIs are handled by writing the interrupt vector directly into the LAPIC of the processor/core that needs to service the interrupt.</p><p>详细内容请参见SDM(MESSAGE SIGNALLED INTERRUPTS)部分。</p><hr><p>参考资料：</p><ol><li><a href="https://elixir.bootlin.com/linux/v5.3-rc4/source/Documentation/PCI/msi-howto.rst" target="_blank" rel="noopener">msi kernel document</a></li><li><a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts" target="_blank" rel="noopener">msi wikipedia</a></li><li><a href="https://www.binss.me/blog/what-is-apic/" target="_blank" rel="noopener">APIC的那些事儿</a></li><li><a href="https://github.com/GiantVM/doc/tree/master/interrupt_and_io" target="_blank" rel="noopener">interrupt_and_io</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍PCI、APIC、MSI基本概念。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>中断那些事</title>
    <link href="http://liujunming.github.io/2019/08/17/%E4%B8%AD%E6%96%AD%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://liujunming.github.io/2019/08/17/中断那些事/</id>
    <published>2019-08-17T07:59:43.000Z</published>
    <updated>2019-08-17T08:15:11.511Z</updated>
    
    <content type="html"><![CDATA[<p>中断，既熟悉，又陌生。<a id="more"></a></p><p>本系列将逐步更新中断相关文章，将会包含如下内容：</p><ol><li>PIC</li><li>APIC</li><li>MSI/MSI-x</li><li>interrupt软件虚拟化</li><li>interrupt硬件虚拟化<ol><li>interrupt remapping</li><li>posted-interrupt</li></ol></li></ol><ul><li><a href="http://liujunming.top/2019/08/17/%E4%B8%AD%E6%96%AD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%9A%84%E5%BB%BA%E7%AB%8B/" target="_blank" rel="noopener">中断基本概念的建立</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中断，既熟悉，又陌生。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
</feed>
