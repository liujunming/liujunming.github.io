<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2018-09-19T12:13:22.411Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式系统中clock相关知识点</title>
    <link href="http://liujunming.github.io/2018/09/19/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%ADclock%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://liujunming.github.io/2018/09/19/分布式系统中clock相关知识点/</id>
    <published>2018-09-19T06:43:42.000Z</published>
    <updated>2018-09-19T12:13:22.411Z</updated>
    
    <content type="html"><![CDATA[<p>因为网上资料较多，本文主要是总结一下相关资料。</p><h2 id="Time-clocks-and-the-ordering-of-events-in-a-distributed-system"><a href="#Time-clocks-and-the-ordering-of-events-in-a-distributed-system" class="headerlink" title="Time, clocks, and the ordering of events in a distributed system"></a>Time, clocks, and the ordering of events in a distributed system</h2><ul><li>论文： Time, clocks, and the ordering of events in a distributed system</li><li>看paper时可以结合着这片<a href="https://www.cnblogs.com/hzmark/p/- Time_Clocks_Ordering.html" target="_blank" rel="noopener">译文</a></li><li><a href="https://zhuanlan.zhihu.com/p/34057588" target="_blank" rel="noopener">论文笔记</a>总结了该论文</li></ul><h2 id="clock同步"><a href="#clock同步" class="headerlink" title="clock同步"></a>clock同步</h2><ul><li><a href="https://www.cs.rutgers.edu/~pxk/417/notes/content/05-clock-synchronization-slides.pdf" target="_blank" rel="noopener">Clock synchronization</a></li></ul><p>Real-Time Clock (RTC)</p><ul><li><a href="https://www.cs.rutgers.edu/~pxk/417/notes/ptp.html" target="_blank" rel="noopener">Precision Time Protocol - notes</a></li><li><a href="https://www.cs.rutgers.edu/~pxk/417/notes/content/06-logical-clocks-slides.pdf" target="_blank" rel="noopener">Logical clocks</a></li><li><a href="https://www.cs.rutgers.edu/~pxk/417/notes/clocks/index.html" target="_blank" rel="noopener">Vector clocks - notes</a></li></ul><h2 id="Vector-Clock-Version-Clock"><a href="#Vector-Clock-Version-Clock" class="headerlink" title="Vector Clock/Version Clock"></a>Vector Clock/Version Clock</h2><ul><li><a href="http://www.cnblogs.com/foxmailed/p/4985848.html" target="_blank" rel="noopener">吴镝 Vector Clock/Version Clock</a></li></ul><p>Version Clock即为Version Vectors。<br>Vector Clock最初是为了给分布式系统的事件定序发明的，本质上是一种捕获causality的手段，只是他们捕获的是事件的关系。而Version Clock是捕获同一个数据的不同版本之间的causality.</p><ul><li><a href="https://haslab.wordpress.com/2011/07/08/version-vectors-are-not-vector-clocks/" target="_blank" rel="noopener">Version Vectors are not Vector Clocks</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为网上资料较多，本文主要是总结一下相关资料。&lt;/p&gt;
&lt;h2 id=&quot;Time-clocks-and-the-ordering-of-events-in-a-distributed-system&quot;&gt;&lt;a href=&quot;#Time-clocks-and-the-orderin
      
    
    </summary>
    
      <category term="分布式系统" scheme="http://liujunming.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://liujunming.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Designing Data-Intensive Applications 读书笔记 -Replication</title>
    <link href="http://liujunming.github.io/2018/09/18/Designing-Data-Intensive-Applications-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Replication/"/>
    <id>http://liujunming.github.io/2018/09/18/Designing-Data-Intensive-Applications-读书笔记-Replication/</id>
    <published>2018-09-18T05:23:36.000Z</published>
    <updated>2018-09-18T07:58:55.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leader-和-Follower"><a href="#Leader-和-Follower" class="headerlink" title="Leader 和 Follower"></a>Leader 和 Follower</h2><ul><li>用户端写入的时候，必须先经过Leader处理</li><li>其它节点是Follower，Leader写入完毕后会通知他们复制数据，保证一致性</li><li>客户端读的时候，可以随便读，但写的时候只能向Leader写</li></ul><p><img src="/images/2018/9/10.png" alt=""></p><h3 id="同步复制与异步复制"><a href="#同步复制与异步复制" class="headerlink" title="同步复制与异步复制"></a>同步复制与异步复制</h3><p><img src="/images/2018/9/11.png" alt=""><br>上图中Follower1是同步复制，Follower2是异步复制</p><p><strong>同步复制：</strong></p><p>写入请求时，Leader 会一直等到所有 Follower 都确认已经写入后（期间不处理任何写请求），才向客户端返回成功</p><p>优点：保证强一致性</p><p>缺点：如果任何 Follower 挂掉，都会写失败，这在大型系统中是不现实的</p><p>所以在实际的数据库中，使用的都是半同步（semi-synchronous），即一个 Follower 是同步的，其它都是异步；如果同步的那个 Follower 挂了，那么设置一个新的 Follower 为同步模式</p><p><strong>异步复制：</strong></p><p>写入请求时，Leader 自己写入成功后就返回，不等待 Follower</p><p>优点：可以立刻响应写入请求，即使所有 Follower 都挂掉了</p><p>缺点：可能会导致不一致(Leader和Follower中的状态不一样)</p><h3 id="增加新的-Follower"><a href="#增加新的-Follower" class="headerlink" title="增加新的 Follower"></a>增加新的 Follower</h3><p>即如何在集群不断写入数据的同时，加入新的 Follower，让它的数据跟上大部队</p><ol><li>给 Leader 某个时刻的数据做一个快照</li><li>把快照复制到新的 Follower 上</li><li>新的 Follower 连接上 Leader，告诉它从哪个时刻开始同步数据</li><li>直到新 Follower 的数据跟上了 Leader 的步伐（caught up），开始进入工作</li></ol><h3 id="处理节点宕机"><a href="#处理节点宕机" class="headerlink" title="处理节点宕机"></a>处理节点宕机</h3><h4 id="Follower-宕机"><a href="#Follower-宕机" class="headerlink" title="Follower 宕机"></a>Follower 宕机</h4><p>从宕机前的日志开始和 Leader 同步即可，直到Follower 的数据跟上了 Leader 的步伐，开始进入工作</p><h4 id="Leader-宕机"><a href="#Leader-宕机" class="headerlink" title="Leader 宕机"></a>Leader 宕机</h4><p>one of the followers needs to be promoted to be the new leader, clients need to be reconfigured to send their writes to the new leader, and the other followers need to start consuming data changes from the new leader. This process is called <code>failover</code>.</p><p>failover的步骤如下：</p><ol><li>检测 Leader 宕机</li><li>选出新的 Leader</li><li>把系统配置改为新的 Leader</li></ol><h3 id="Implementation-of-Replication-Logs"><a href="#Implementation-of-Replication-Logs" class="headerlink" title="Implementation of Replication Logs"></a>Implementation of Replication Logs</h3><h4 id="Statement-based-replication"><a href="#Statement-based-replication" class="headerlink" title="Statement-based replication"></a>Statement-based replication</h4><p>基于语句的复制，比如在 SQL 中复制 INSERT、UPDATE、DELETE 语句到 Follower。</p><p>存在一些问题：</p><ul><li>NOW()、RANDOM()这样的函数，没法基于语句复制，因为每次运行的结果都不一样</li><li>如果语句依赖自增数，或者跟数据库中现有的数据强相关，那么必须保证语句执行顺序跟 Leader 完全一致，在并发处理多个事务时这一点很难保证</li><li>语句有副作用时，可能会导致不一致的出现</li></ul><h4 id="Write-ahead-log-WAL-shipping"><a href="#Write-ahead-log-WAL-shipping" class="headerlink" title="Write-ahead log (WAL) shipping"></a>Write-ahead log (WAL) shipping</h4><p>本书的第三章讨论了日志结构的储存引擎的实现（SSTable、LSM-Tree 和 B-Tree），如果是这种储存引擎，我们可以把它的每一次写日志都复制到 Follower 上，这样可以保证一致性。</p><p>PostgreSQL 和 Oracle 就是这样实现的，缺陷在于，这种复制方式非常底层，每一条 WAL 包含的信息实际上是“向哪一个硬盘 block 写哪些 bytes”，这就导致 WAL 和储存引擎强相关，也就是必须保证 Leader 和 Follower 的储存引擎底层完全一致，导致集群很难进行版本升级。</p><h4 id="Logical-row-based-log-replication"><a href="#Logical-row-based-log-replication" class="headerlink" title="Logical (row-based) log replication"></a>Logical (row-based) log replication</h4><p>把日志抽象为与底层引擎无关，采用 change data capture，每次有数据更改的时候都记下改了什么，例如记录每次写入的值和行号，MySQL 的 binlog 就是这样实现的。</p><h2 id="复制滞后产生的问题"><a href="#复制滞后产生的问题" class="headerlink" title="复制滞后产生的问题"></a>复制滞后产生的问题</h2><p>对于单 Leader，多 Follower的架构来说，一般是只能向 Leader 写，但可以向任何 Follower 读，这样可以大大增加读的性能。</p><p>但由于写操作需要向 Follower 复制，这里就会产生滞后问题，写完后立刻读，有可能会从 Follower 中读到旧的值（因为此时 Leader 可能还没有同步变化到 Follower 上）。</p><p>当然这种不一致的状态是转临时逝的（如果停止向数据库中写入数据并等待一段时间，从库最终会赶上并与主库保持一致），不会永久存在，也就是所谓的 “最终一致性”。</p><p>因为滞后时间太长引入的不一致性，可不仅是一个理论问题，更是应用设计中会遇到的真实问题。本节将重点介绍三个由复制滞后所带来的问题，并简述解决这些问题的一些方法。</p><h3 id="Reading-Your-Own-Writes"><a href="#Reading-Your-Own-Writes" class="headerlink" title="Reading Your Own Writes"></a>Reading Your Own Writes</h3><p>许多应用让用户提交一些数据，然后查看他们提交的内容。但对于异步复制，问题就来了。如下图所示：如果用户在写入后马上就查看数据，则新数据可能尚未到达副本。对用户而言，看起来好像是刚提交的数据丢失了。<br><img src="/images/2018/9/12.png" alt=""></p><p>在这种情况下，我们需要读写一致性（read-after-write consistency）。这是一个保证，如果用户重新加载页面，他们总会看到他们自己提交的任何更新。它不会对其他用户的写入做出承诺：其他用户的更新可能稍等才会看到。它保证用户自己的输入已被正确保存。</p><p>具体可以有以下策略：</p><ul><li>如果读的字段可能已经发生了变化，那么向 Leader 读取（因为 Leader 的数据一定是最新的）；</li><li>如果读的字段距离上一次变更时间很短，那么向 Leader 读；</li><li>客户端在读请求的时候带上自己最近一次写操作的时间戳，处理这个读请求的服务器看到这个时间戳，就可以知道自己本地的数据是否过时了</li></ul><h3 id="单调读（Monotonic-Reads）"><a href="#单调读（Monotonic-Reads）" class="headerlink" title="单调读（Monotonic Reads）"></a>单调读（Monotonic Reads）</h3><p>客户端进行多次读操作时，这些读操作可能会分配到不同的 Follower 上，所以可能会发生第一次读到了数据，然后第二次读的时候数据又消失了的问题，如下图 User 2345，第一次在 Follower1 上读到了评论，第二次在 Follower2 上没有读到评论：</p><p><img src="/images/2018/9/13.png" alt=""></p><p>所以，客户端读到了新的数据，那么就不能让它读到旧数据。最简单的解决方法就是，把每个客户端的读请求都分配到固定的 Follower 上。</p><h3 id="Consistent-Prefix-Reads"><a href="#Consistent-Prefix-Reads" class="headerlink" title="Consistent Prefix Reads"></a>Consistent Prefix Reads</h3><p>由于服务器之间复制数据可能产生的滞后，数据的时序可能会产生问题。</p><p>比如下图，Mr. Poons 先说了一句话，然后 Mrs. Cake 回复了他，然而对于第三方观察者而言，他们的对话时序可能是混乱的：</p><p><img src="/images/2018/9/14.png" alt=""></p><p>防止这种异常，需要另一种类型的保证：一致前缀读（consistent prefix reads）。 这个保证了：如果一系列写入按某个顺序发生，那么任何人读取这些写入时，也会看见它们以同样的顺序出现。</p><p>​这是分区（partitioned）数据库中的一个特殊问题。如果数据库总是以相同的顺序应用写入，则读取总是会看到一致的前缀，所以这种异常不会发生。但是在许多分布式数据库中，不同的分区独立运行，因此不存在全局写入顺序：当用户从数据库中读取数据时，可能会看到数据库的某些部分处于较旧的状态，而某些处于较新的状态。</p><p>​一种解决方案是，确保任何因果相关的写入都写入相同的分区。对于某些无法高效完成这种操作的应用，还有一些显式跟踪因果依赖关系的算法。</p><h2 id="Multi-Leader-Replication"><a href="#Multi-Leader-Replication" class="headerlink" title="Multi-Leader Replication"></a>Multi-Leader Replication</h2><p>单个 Leader 的缺点在于，如果任何因素导致无法连接 Leader，那么你就无法向数据库写入任何数据了，这会让整个系统非常脆弱，所以我们在一些情境下需要多 Leader 的架构。</p><h3 id="Use-Cases-for-Multi-Leader-Replication"><a href="#Use-Cases-for-Multi-Leader-Replication" class="headerlink" title="Use Cases for Multi-Leader Replication"></a>Use Cases for Multi-Leader Replication</h3><p>下面是一些多 Leader 架构的示例</p><h4 id="多个数据中心"><a href="#多个数据中心" class="headerlink" title="多个数据中心"></a>多个数据中心</h4><p><img src="/images/2018/9/15.png" alt=""></p><p>像上图这种情况，你可以有多个 Leader 分布在不同地方的数据中心，每个数据中心都是一个独立的集群，它们的 Leader 之间会相互同步数据。</p><h4 id="可以离线的客户端"><a href="#可以离线的客户端" class="headerlink" title="可以离线的客户端"></a>可以离线的客户端</h4><p>我们可以把一个支持离线运行的客户端，和服务器端，视为两个“数据中心”，比如一些日历应用，会在本地维护一份数据，直到有网络时，才会和服务器进行数据同步，这就是一个异步的多 Leader 架构。</p><p>CouchDB 就是为此设计的。</p><h4 id="多人协作编辑"><a href="#多人协作编辑" class="headerlink" title="多人协作编辑"></a>多人协作编辑</h4><p>像 Etherpad、Google Docs 这样的应用，允许多人同时编辑同一份文档，每个人都是一个 “Leader”，相互之间同步数据，但这显然会遇到冲突的问题。</p><h3 id="解决写冲突"><a href="#解决写冲突" class="headerlink" title="解决写冲突"></a>解决写冲突</h3><p>多 Leader 之间同步数据，最大的问题就是如何解决写冲突。比如下图中，两个用户都修改了文档的标题，发请求给服务器，都返回了成功，但直到 Leader 之间进行同步时才发现之前的数据有冲突。</p><p><img src="/images/2018/9/16.png" alt=""></p><h4 id="同步冲突检测"><a href="#同步冲突检测" class="headerlink" title="同步冲突检测"></a>同步冲突检测</h4><p>单 Leader 不会发生冲突，因为每次写入都是一个原子化的事务。</p><p>多 Leader 如果采用同步的方式检测冲突，也不会发生冲突。即每次写入时，都向其它的 Leader 检查有没有冲突，如果都没有冲突，那么写入成功。但这样性能极差，也丢掉了多 Leader 架构的好处，还不如用单个 Leader。</p><h4 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h4><p>多 Leader 架构避免冲突最简单的方式就是，让可能产生冲突的请求，都走向同一个 Leader。比如对于同一项资料的修改，都路由到固定的某个 Leader 上。</p><p>这样做的缺陷在于，集群是不断变化的，很难做到长期固定，Leader 的变化就会让这个策略失效。</p><h4 id="收敛至一致的状态"><a href="#收敛至一致的状态" class="headerlink" title="收敛至一致的状态"></a>收敛至一致的状态</h4><p>实现冲突合并解决有多种途径：</p><ul><li>给每个写入一个唯一的ID（例如，一个时间戳，一个长的随机数，一个UUID或者一个键和值的哈希），挑选最高ID的写入作为胜利者，并丢弃其他写入。如果使用时间戳，这种技术被称为最后写入胜利（LWW, last write wins）。虽然这种方法很流行，但是很容易造成数据丢失。</li><li>为每个副本分配一个唯一的ID，ID编号更高的写入具有更高的优先级。这种方法也意味着数据丢失。</li><li>以某种方式将这些值合并在一起 - 例如，按字母顺序排序，然后连接它们（在图5-7中，合并的标题可能类似于“B/C”）。</li><li>在保留所有信息的显式数据结构中记录冲突，并编写解决冲突的应用程序代码（也许通过提示用户的方式）。<br>​ </li></ul><h4 id="自定义冲突解决逻辑"><a href="#自定义冲突解决逻辑" class="headerlink" title="自定义冲突解决逻辑"></a>自定义冲突解决逻辑</h4><p>作为解决冲突最合适的方法可能取决于应用程序，大多数多主复制工具允许使用应用程序代码编写冲突解决逻辑。该代码可以在写入或读取时执行。</p><blockquote><p><strong>自动冲突解决</strong><br>冲突解决规则可能很快变得复杂，并且自定义代码可能容易出错。<br>已经有一些有趣的研究来自动解决由于数据修改引起的冲突。有几个研究值得一提：</p><ul><li>无冲突复制数据类型（Conflict-free replicated datatypes）（CRDT）是可以由多个用户同时编辑的集合，映射，有序列表，计数器等的一系列数据结构，它们以合理的方式自动解决冲突。</li><li>可合并的持久数据结构（Mergeable persistent data structures）显式跟踪历史记录，类似于Git版本控制系统。</li><li>可执行的转换（operational transformation）是Etherpad和Google Docs等合作编辑应用背后的冲突解决算法。</li></ul><p>这些算法在数据库中的实现还很年轻，但很可能将来它们将被集成到更多的复制数据系统中。自动冲突解决方案可以使应用程序处理多领导者数据同步更为简单。</p></blockquote><h3 id="多-Leader-的拓扑结构"><a href="#多-Leader-的拓扑结构" class="headerlink" title="多 Leader 的拓扑结构"></a>多 Leader 的拓扑结构</h3><p>多 Leader 可以有很多种拓扑结构，环形、星形、全连接形。<br><img src="/images/2018/9/17.png" alt=""><br>MySQL 使用的是环形连接。全连接形是最符合直觉的，每个 Leader 都和其它所有 Leader 相互交换数据。<br>另一方面，全连接形拓扑也可能有问题。特别是，一些网络链接可能比其他网络链接更快（例如，由于网络拥塞），结果是一些复制消息可能“超过”其他复制消息，如下图示。</p><p><img src="/images/2018/9/18.png" alt=""></p><p>这是一个因果关系的问题：更新取决于先前的插入，所以我们需要确保所有节点先处理插入，然后再处理更新。</p><p>要正确排序这些事件，可以使用一种称为<strong>version vectors</strong>的技术。</p><h2 id="无-Leader-复制"><a href="#无-Leader-复制" class="headerlink" title="无 Leader 复制"></a>无 Leader 复制</h2><p>无 Leader 复制完全不需要 Leader 的存在，这种架构中，客户端可以向多个节点发起读写请求。</p><h3 id="当有节点挂掉时，如何写入数据库"><a href="#当有节点挂掉时，如何写入数据库" class="headerlink" title="当有节点挂掉时，如何写入数据库"></a>当有节点挂掉时，如何写入数据库</h3><p>只要保证多个节点写入成功，那么客户端就可以认为写入成功。<br><img src="/images/2018/9/19.png" alt=""></p><h4 id="Read-repair-and-anti-entropy"><a href="#Read-repair-and-anti-entropy" class="headerlink" title="Read repair and anti-entropy"></a>Read repair and anti-entropy</h4><p>在读取的时候，可能会存在不一致（因为有部分节点写入失败），这时可以发现不一致并且修复它。或者所有节点都定期检查是否自己的数据跟别人有不一致的地方。</p><h4 id="Quorums-for-reading-and-writing"><a href="#Quorums-for-reading-and-writing" class="headerlink" title="Quorums for reading and writing"></a>Quorums for reading and writing</h4><p>如果有n个副本，每个写入必须由w节点确认才能被认为是成功的，并且我们必须至少为每个读查询r个节点。 只要<code>w + r&gt; n</code>，我们期望在读取时获得最新的值，因为r个读取中至少有一个节点是最新的。</p><h3 id="Quorums-机制的局限性"><a href="#Quorums-机制的局限性" class="headerlink" title="Quorums 机制的局限性"></a>Quorums 机制的局限性</h3><h3 id="Sloppy-Quorums-and-Hinted-Handoff"><a href="#Sloppy-Quorums-and-Hinted-Handoff" class="headerlink" title="Sloppy Quorums and Hinted Handoff"></a>Sloppy Quorums and Hinted Handoff</h3><p><em>sloppy quorum</em>:写和读仍然需要w和r成功的响应，但是那些可能包括不在指定的n个“主”节点中的值。比方说，如果你把自己锁在房子外面，你可能会敲开邻居的门，问你是否可以暂时停留在沙发上。</p><p>​ 一旦网络中断得到解决，代表另一个节点临时接受的一个节点的任何写入都被发送到适当的“本地”节点，这就是hinted handoff。 （一旦你再次找到你的房子的钥匙，你的邻居礼貌地要求你离开沙发回家。）</p><h3 id="Detecting-Concurrent-Writes"><a href="#Detecting-Concurrent-Writes" class="headerlink" title="Detecting Concurrent Writes"></a>Detecting Concurrent Writes</h3><h4 id="Last-write-wins-discarding-concurrent-writes"><a href="#Last-write-wins-discarding-concurrent-writes" class="headerlink" title="Last write wins (discarding concurrent writes)"></a>Last write wins (discarding concurrent writes)</h4><h4 id="The-“happens-before”-relationship-and-concurrency"><a href="#The-“happens-before”-relationship-and-concurrency" class="headerlink" title="The “happens-before” relationship and concurrency"></a>The “happens-before” relationship and concurrency</h4><h4 id="Capturing-the-happens-before-relationship"><a href="#Capturing-the-happens-before-relationship" class="headerlink" title="Capturing the happens-before relationship"></a>Capturing the happens-before relationship</h4><h4 id="Merging-concurrently-written-values"><a href="#Merging-concurrently-written-values" class="headerlink" title="Merging concurrently written values"></a>Merging concurrently written values</h4><h4 id="Version-vectors"><a href="#Version-vectors" class="headerlink" title="Version vectors"></a>Version vectors</h4><hr><p>参考资料：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/36282816" target="_blank" rel="noopener">知乎 Starkwang</a></li><li><a href="https://github.com/Vonng/ddia/blob/master/ch5.md" target="_blank" rel="noopener">Vonng/ddia</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Leader-和-Follower&quot;&gt;&lt;a href=&quot;#Leader-和-Follower&quot; class=&quot;headerlink&quot; title=&quot;Leader 和 Follower&quot;&gt;&lt;/a&gt;Leader 和 Follower&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用户端写
      
    
    </summary>
    
      <category term="分布式系统" scheme="http://liujunming.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://liujunming.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Fenwick Tree/Binary Indexed Tree/树状数组</title>
    <link href="http://liujunming.github.io/2018/09/12/Fenwick-Tree-Binary-Indexed-Tree-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>http://liujunming.github.io/2018/09/12/Fenwick-Tree-Binary-Indexed-Tree-树状数组/</id>
    <published>2018-09-12T07:59:22.000Z</published>
    <updated>2018-09-12T08:12:14.230Z</updated>
    
    <content type="html"><![CDATA[<p>观看<a href="https://www.youtube.com/watch?v=WbafSgetDDk" target="_blank" rel="noopener">花花酱 Fenwick Tree / Binary Indexed Tree</a>的视频，结合<a href="https://visualgo.net/bn/fenwicktree" target="_blank" rel="noopener">Visualizer</a>即可理解Fenwick Tree。</p><p>Fenwick Tree is mainly designed for solving the single point update range sum problems. e.g. what’s the sum between i-th and j-th element while the values of the elements are mutable.</p><p>Init the tree (include building all prefix sums) takes O(nlogn)</p><p>Update the value of an element takes O(logn)</p><p>Query the range sum takes O(logn)</p><p>Space complexity: O(n)</p><p><img src="/images/2018/9/8.png" alt=""></p><p><img src="/images/2018/9/9.png" alt=""></p><p><em>Using Binary Indexed Tree, we can do both tasks in O(Logn) time. The advantages of Binary Indexed Tree over Segment are, requires less space and very easy to implement..</em></p><p>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FenwickTree</span> &#123;</span>    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FenwickTree(<span class="keyword">int</span> n): sums_(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; sums_.size()) &#123;</span><br><span class="line">            sums_[i] += delta;</span><br><span class="line">            i += lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += sums_[i];</span><br><span class="line">            i -= lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><a href="https://www.youtube.com/watch?v=WbafSgetDDk" target="_blank" rel="noopener">花花酱 Fenwick Tree / Binary Indexed Tree</a></li><li><a href="https://zxi.mytechroad.com/blog/sp/fenwick-tree-binary-indexed-tree-sp3/" target="_blank" rel="noopener">代码</a></li><li><a href="https://visualgo.net/bn/fenwicktree" target="_blank" rel="noopener">Visualizer</a></li><li><a href="https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/" target="_blank" rel="noopener">geeksforgeeks</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;观看&lt;a href=&quot;https://www.youtube.com/watch?v=WbafSgetDDk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;花花酱 Fenwick Tree / Binary Indexed Tree&lt;/a&gt;的视频，结合&lt;a
      
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Interval Tree</title>
    <link href="http://liujunming.github.io/2018/09/09/Interval%20Tree/"/>
    <id>http://liujunming.github.io/2018/09/09/Interval Tree/</id>
    <published>2018-09-09T01:41:48.000Z</published>
    <updated>2018-09-12T05:36:24.078Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Interval-Tree"><a href="#Interval-Tree" class="headerlink" title="Interval Tree"></a>Interval Tree</h3><p>首先看下<a href="https://www.youtube.com/watch?v=q0QOYtSsTg4" target="_blank" rel="noopener">Interval Search Trees</a>视频。</p><p>Consider a situation where we have a set of intervals and we need following operations to be implemented efficiently. </p><ol><li>Add an interval</li><li>Remove an interval</li><li>Given an interval x, find if x overlaps with any of the existing intervals.</li></ol><p><em>Interval Tree</em>: The idea is to augment a self-balancing Binary Search Tree (BST) like Red Black Tree, AVL Tree, etc to maintain set of intervals so that all operations can be done in O(Logn) time.</p><p>Every node of Interval Tree stores following information.</p><ol><li>An interval which is represented as a pair <em>[low, high]</em></li><li>Maximum <em>high</em> value in subtree rooted with this node.</li></ol><p>The low value of an interval is used as key to maintain order in BST. The insert and delete operations are same as insert and delete in self-balancing BST used.</p><p><img src="/images/2018/9/7.png" alt=""></p><p>The main operation is to search for an overlapping interval. Following is algorithm for searching an overlapping interval <em>x</em> in an Interval tree rooted with <em>root</em>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Interval overlappingIntervalSearch(root, x)</span><br><span class="line">1) If x overlaps with root&apos;s interval, return the root&apos;s interval.</span><br><span class="line"></span><br><span class="line">2) If left child of root is not empty and the max  in left child </span><br><span class="line">is greater than x&apos;s low value, recur for left child</span><br><span class="line"></span><br><span class="line">3) Else recur for right child.</span><br></pre></td></tr></table></figure><p>此题的具体代码可以参考<a href="https://www.wikiwand.com/en/Interval_tree" target="_blank" rel="noopener">wikiwand</a>中的External_links。</p><hr><p>参考资料：</p><ol><li><a href="https://www.geeksforgeeks.org/interval-tree/" target="_blank" rel="noopener">geeksforgeeks interval-tree</a></li><li><a href="https://www.wikiwand.com/en/Interval_tree" target="_blank" rel="noopener">wikiwand</a></li><li><a href="https://github.com/chaimleib/intervaltree" target="_blank" rel="noopener">intervaltree python</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Interval-Tree&quot;&gt;&lt;a href=&quot;#Interval-Tree&quot; class=&quot;headerlink&quot; title=&quot;Interval Tree&quot;&gt;&lt;/a&gt;Interval Tree&lt;/h3&gt;&lt;p&gt;首先看下&lt;a href=&quot;https://www.y
      
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="http://liujunming.github.io/2018/09/08/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://liujunming.github.io/2018/09/08/线段树/</id>
    <published>2018-09-08T13:55:33.000Z</published>
    <updated>2018-09-10T04:32:42.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线段树的概念"><a href="#线段树的概念" class="headerlink" title="线段树的概念"></a>线段树的概念</h2><p>Tushar的讲解视频<a href="https://www.youtube.com/watch?v=ZBHKZF5w4YU" target="_blank" rel="noopener">Segment Tree Range Minimum Query</a>清晰明了。</p><h2 id="线段树的例子"><a href="#线段树的例子" class="headerlink" title="线段树的例子"></a>线段树的例子</h2><h3 id="Sum-of-given-range"><a href="#Sum-of-given-range" class="headerlink" title="Sum of given range"></a>Sum of given range</h3><p>We have an array arr[0 . . . n-1]. We should be able to</p><ol><li>Find the sum of elements from index l to r where 0 &lt;= l &lt;= r &lt;= n-1</li><li>Change value of a specified element of the array to a new value x. We need to do arr[i] = x where 0 &lt;= i &lt;= n-1.</li></ol><p><strong>Representation of Segment trees</strong></p><ol><li>Leaf Nodes are the elements of the input array.</li><li>Each internal node represents some merging of the leaf nodes. The merging may be different for different problems. For this problem, merging is sum of leaves under a node.</li></ol><p>An array representation of tree is used to represent Segment Trees. For each node at index i, the left child is at index <code>2*i+1</code>, right child at <code>2*i+2</code> and the parent is at<code>(i-1)/2</code>.<br><img src="/images/2018/9/6.png" alt=""><br><strong>Construction of Segment Tree from given array</strong><br>We start with a segment arr[0 . . . n-1]. and every time we divide the current segment into two halves(if it has not yet become a segment of length 1), and then call the same procedure on both halves, and for each such segment, we store the sum in the corresponding node.<br>All levels of the constructed segment tree will be completely filled except the last level. Also, the tree will be a Full Binary Tree because we always divide segments in two halves at every level. Since the constructed tree is always a full binary tree with n leaves, there will be n-1 internal nodes. So total number of nodes will be 2*n – 1.</p><p>Height of the segment tree will be <code>logN</code>. Since the tree is represented using array and relation between parent and child indexes must be maintained, size of memory allocated for segment tree will be  <code>2*pow(2, logN)-1</code>.<br><strong>Query for Sum of given range</strong><br>Once the tree is constructed, how to get the sum using the constructed segment tree. Following is the algorithm to get the sum of elements.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(node, l, r)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> the range of the node is within l <span class="keyword">and</span> r</span><br><span class="line">        <span class="keyword">return</span> value in the node</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> the range of the node is completely outside l <span class="keyword">and</span> r</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> getSum(node's left child, l, r) + </span><br><span class="line">           getSum(node's right child, l, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Update a value</strong><br>Like tree construction and query operations, the update can also be done recursively. We are given an index which needs to be updated. Let <em>diff</em> be the value to be added. We start from root of the segment tree and add <em>diff</em> to all nodes which have given index in their range. If a node doesn’t have given index in its range, we don’t make any changes to that node.<br><strong>Implementation</strong><br>Following is the implementation of segment tree. The program implements construction of segment tree for any given array. It also implements query and update operations.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPP program to show segment tree operations like construction, query </span></span><br><span class="line"><span class="comment">// and update </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to get the middle index from corner indexes. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMid</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;  <span class="keyword">return</span> s + (e -s)/<span class="number">2</span>;  &#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/*  A recursive function to get the sum of values in given range </span></span><br><span class="line"><span class="comment">    of the array. The following are parameters for this function. </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    st    --&gt; Pointer to segment tree </span></span><br><span class="line"><span class="comment">    si    --&gt; Index of current node in the segment tree. Initially </span></span><br><span class="line"><span class="comment">              0 is passed as root is always at index 0 </span></span><br><span class="line"><span class="comment">    ss &amp; se  --&gt; Starting and ending indexes of the segment represented </span></span><br><span class="line"><span class="comment">                 by current node, i.e., st[si] </span></span><br><span class="line"><span class="comment">    qs &amp; qe  --&gt; Starting and ending indexes of query range */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSumUtil</span><span class="params">(<span class="keyword">int</span> *st, <span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> qs, <span class="keyword">int</span> qe, <span class="keyword">int</span> si)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// If segment of this node is a part of given range, then return </span></span><br><span class="line">    <span class="comment">// the sum of the segment </span></span><br><span class="line">    <span class="keyword">if</span> (qs &lt;= ss &amp;&amp; qe &gt;= se) </span><br><span class="line">        <span class="keyword">return</span> st[si]; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If segment of this node is outside the given range </span></span><br><span class="line">    <span class="keyword">if</span> (se &lt; qs || ss &gt; qe) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If a part of this segment overlaps with the given range </span></span><br><span class="line">    <span class="keyword">int</span> mid = getMid(ss, se); </span><br><span class="line">    <span class="keyword">return</span> getSumUtil(st, ss, mid, qs, qe, <span class="number">2</span>*si+<span class="number">1</span>) + </span><br><span class="line">           getSumUtil(st, mid+<span class="number">1</span>, se, qs, qe, <span class="number">2</span>*si+<span class="number">2</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* A recursive function to update the nodes which have the given  </span></span><br><span class="line"><span class="comment">   index in their range. The following are parameters </span></span><br><span class="line"><span class="comment">    st, si, ss and se are same as getSumUtil() </span></span><br><span class="line"><span class="comment">    i    --&gt; index of the element to be updated. This index is  </span></span><br><span class="line"><span class="comment">             in the input array. </span></span><br><span class="line"><span class="comment">   diff --&gt; Value to be added to all nodes which have i in range */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateValueUtil</span><span class="params">(<span class="keyword">int</span> *st, <span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> i, <span class="keyword">int</span> diff, <span class="keyword">int</span> si)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// Base Case: If the input index lies outside the range of  </span></span><br><span class="line">    <span class="comment">// this segment </span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; ss || i &gt; se) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If the input index is in range of this node, then update  </span></span><br><span class="line">    <span class="comment">// the value of the node and its children </span></span><br><span class="line">    st[si] = st[si] + diff; </span><br><span class="line">    <span class="keyword">if</span> (se != ss) &#123; </span><br><span class="line">        <span class="keyword">int</span> mid = getMid(ss, se); </span><br><span class="line">        updateValueUtil(st, ss, mid, i, diff, <span class="number">2</span>*si + <span class="number">1</span>); </span><br><span class="line">        updateValueUtil(st, mid+<span class="number">1</span>, se, i, diff, <span class="number">2</span>*si + <span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The function to update a value in input array and segment tree. </span></span><br><span class="line"><span class="comment">// It uses updateValueUtil() to update the value in segment tree </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateValue</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> *st, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> new_val)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// Check for erroneous input index </span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; n<span class="number">-1</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Invalid Input"</span>); </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Get the difference between new value and old value </span></span><br><span class="line">    <span class="keyword">int</span> diff = new_val - arr[i]; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update the value in array </span></span><br><span class="line">    arr[i] = new_val; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update the values of nodes in segment tree </span></span><br><span class="line">    updateValueUtil(st, <span class="number">0</span>, n<span class="number">-1</span>, i, diff, <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Return sum of elements in range from index qs (quey start) </span></span><br><span class="line"><span class="comment">// to qe (query end).  It mainly uses getSumUtil() </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> *st, <span class="keyword">int</span> n, <span class="keyword">int</span> qs, <span class="keyword">int</span> qe)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// Check for erroneous input values </span></span><br><span class="line">    <span class="keyword">if</span> (qs &lt; <span class="number">0</span> || qe &gt; n<span class="number">-1</span> || qs &gt; qe) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Invalid Input"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> getSumUtil(st, <span class="number">0</span>, n<span class="number">-1</span>, qs, qe, <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A recursive function that constructs Segment Tree for array[ss..se]. </span></span><br><span class="line"><span class="comment">// si is index of current node in segment tree st </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">constructSTUtil</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> *st, <span class="keyword">int</span> si)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// If there is one element in array, store it in current node of </span></span><br><span class="line">    <span class="comment">// segment tree and return </span></span><br><span class="line">    <span class="keyword">if</span> (ss == se) &#123; </span><br><span class="line">        st[si] = arr[ss]; </span><br><span class="line">        <span class="keyword">return</span> arr[ss]; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If there are more than one elements, then recur for left and </span></span><br><span class="line">    <span class="comment">// right subtrees and store the sum of values in this node </span></span><br><span class="line">    <span class="keyword">int</span> mid = getMid(ss, se); </span><br><span class="line">    st[si] =  constructSTUtil(arr, ss, mid, st, si*<span class="number">2</span>+<span class="number">1</span>) + </span><br><span class="line">              constructSTUtil(arr, mid+<span class="number">1</span>, se, st, si*<span class="number">2</span>+<span class="number">2</span>); </span><br><span class="line">    <span class="keyword">return</span> st[si]; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Function to construct segment tree from given array. This function </span></span><br><span class="line"><span class="comment">   allocates memory for segment tree and calls constructSTUtil() to </span></span><br><span class="line"><span class="comment">   fill the allocated memory */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">constructST</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// Allocate memory for the segment tree </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Height of segment tree </span></span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>)(<span class="built_in">ceil</span>(log2(n)));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Maximum size of segment tree </span></span><br><span class="line">    <span class="keyword">int</span> max_size = <span class="number">2</span>*(<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, x) - <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Allocate memory </span></span><br><span class="line">    <span class="keyword">int</span> *st = <span class="keyword">new</span> <span class="keyword">int</span>[max_size]; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Fill the allocated memory st </span></span><br><span class="line">    constructSTUtil(arr, <span class="number">0</span>, n<span class="number">-1</span>, st, <span class="number">0</span>); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Return the constructed segment tree </span></span><br><span class="line">    <span class="keyword">return</span> st; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Driver program to test above functions </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;; </span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Build segment tree from given array </span></span><br><span class="line">    <span class="keyword">int</span> *st = constructST(arr, n); <span class="comment">//确保n大于0</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Print sum of values in array from index 1 to 3 </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Sum of values in given range = "</span>&lt;&lt;getSum(st, n, <span class="number">1</span>, <span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">             </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update: set arr[1] = 10 and update corresponding  </span></span><br><span class="line">    <span class="comment">// segment tree nodes </span></span><br><span class="line">    updateValue(arr, st, n, <span class="number">1</span>, <span class="number">10</span>); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Find sum after the value is updated </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Updated sum of values in given range = "</span>&lt;&lt;getSum(st, n, <span class="number">1</span>, <span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sum of values in given range = 15</span><br><span class="line">Updated sum of values in given range = 22</span><br></pre></td></tr></table></figure></p><p><strong>Time Complexity</strong><br>Time Complexity for tree construction is O(n). There are total 2n-1 nodes, and value of every node is calculated only once in tree construction.</p><p>Time complexity to query is O(logN). To query a sum, we process at most four nodes at every level and number of levels is O(logN).</p><p>The time complexity of update is also O(logN). To update a leaf value, we process one node at every level and number of levels is O(logN).</p><h3 id="Range-Minimum-Query"><a href="#Range-Minimum-Query" class="headerlink" title="Range Minimum Query"></a>Range Minimum Query</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMid</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;  <span class="keyword">return</span> s + (e -s)/<span class="number">2</span>;  &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt;= b ? b : a; &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinUtil</span><span class="params">(<span class="keyword">int</span> *st, <span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> qs, <span class="keyword">int</span> qe, <span class="keyword">int</span> si)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (qs &lt;= ss &amp;&amp; qe &gt;= se) </span><br><span class="line">        <span class="keyword">return</span> st[si]; </span><br><span class="line">    <span class="keyword">if</span> (se &lt; qs || ss &gt; qe) </span><br><span class="line">        <span class="keyword">return</span> INT_MAX; </span><br><span class="line">    <span class="keyword">int</span> mid = getMid(ss, se); </span><br><span class="line">    <span class="keyword">return</span> min(getMinUtil(st, ss, mid, qs, qe, <span class="number">2</span>*si+<span class="number">1</span>), getMinUtil(st, mid+<span class="number">1</span>, se, qs, qe, <span class="number">2</span>*si+<span class="number">2</span>)); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateValueUtil</span><span class="params">(<span class="keyword">int</span> *st, <span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> i, <span class="keyword">int</span> new_val, <span class="keyword">int</span> si)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (i &lt; ss || i &gt; se) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    st[si] = min(st[si], new_val); </span><br><span class="line">    <span class="keyword">if</span> (se != ss) &#123; </span><br><span class="line">        <span class="keyword">int</span> mid = getMid(ss, se); </span><br><span class="line">        updateValueUtil(st, ss, mid, i, new_val, <span class="number">2</span>*si + <span class="number">1</span>); </span><br><span class="line">        updateValueUtil(st, mid+<span class="number">1</span>, se, i, new_val, <span class="number">2</span>*si + <span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateValue</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> *st, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> new_val)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; n<span class="number">-1</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Invalid Input"</span>); </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    arr[i] = new_val; </span><br><span class="line">    updateValueUtil(st, <span class="number">0</span>, n<span class="number">-1</span>, i, new_val, <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> *st, <span class="keyword">int</span> n, <span class="keyword">int</span> qs, <span class="keyword">int</span> qe)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (qs &lt; <span class="number">0</span> || qe &gt; n<span class="number">-1</span> || qs &gt; qe) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Invalid Input"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> getMinUtil(st, <span class="number">0</span>, n<span class="number">-1</span>, qs, qe, <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">constructSTUtil</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> *st, <span class="keyword">int</span> si)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (ss == se) &#123; </span><br><span class="line">        st[si] = arr[ss]; </span><br><span class="line">        <span class="keyword">return</span> arr[ss]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> mid = getMid(ss, se); </span><br><span class="line">    st[si] =  min(constructSTUtil(arr, ss, mid, st, si*<span class="number">2</span>+<span class="number">1</span>), constructSTUtil(arr, mid+<span class="number">1</span>, se, st, si*<span class="number">2</span>+<span class="number">2</span>)); </span><br><span class="line">    <span class="keyword">return</span> st[si]; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">constructST</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>)(<span class="built_in">ceil</span>(log2(n)));  </span><br><span class="line">    <span class="keyword">int</span> max_size = <span class="number">2</span>*(<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, x) - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> *st = <span class="keyword">new</span> <span class="keyword">int</span>[max_size]; </span><br><span class="line">    constructSTUtil(arr, <span class="number">0</span>, n<span class="number">-1</span>, st, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> st; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;; </span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *st = constructST(arr, n); <span class="comment">//确保n大于0</span></span><br><span class="line">    updateValue(arr, st, n, <span class="number">1</span>, <span class="number">-10</span>); </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"min of values in given range = "</span>&lt;&lt;getMin(st, n, <span class="number">1</span>, <span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><a href="https://www.youtube.com/watch?v=ZBHKZF5w4YU" target="_blank" rel="noopener">Tushar Segment Tree Range Minimum Query</a></li><li><a href="https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" target="_blank" rel="noopener">Segment Tree | Set 1 (Sum of given range)</a></li><li><a href="https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/" target="_blank" rel="noopener">Segment Tree | Set 2 (Range Minimum Query)</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线段树的概念&quot;&gt;&lt;a href=&quot;#线段树的概念&quot; class=&quot;headerlink&quot; title=&quot;线段树的概念&quot;&gt;&lt;/a&gt;线段树的概念&lt;/h2&gt;&lt;p&gt;Tushar的讲解视频&lt;a href=&quot;https://www.youtube.com/watch?v=ZB
      
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Best Time to Buy and Sell Stock problem</title>
    <link href="http://liujunming.github.io/2018/09/07/Best-Time-to-Buy-and-Sell-Stock-problem/"/>
    <id>http://liujunming.github.io/2018/09/07/Best-Time-to-Buy-and-Sell-Stock-problem/</id>
    <published>2018-09-07T05:58:38.000Z</published>
    <updated>2018-09-08T12:22:31.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock III</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock IV</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>k=1</strong><br>当最多只能交易一次时，思路如下：<br>Say the given array is:<br>[7, 1, 5, 3, 6, 4]<br>If we plot the numbers of the given array on a graph, we get:<br><img src="/images/2018/9/4.png" alt=""><br>维护两个变量：minprice代表到目前为止，股票的最低价格；maxprofit代表在最多交易一次的情况下，所能获取的最大利益。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>k&gt;1</strong><br>k=1的情况下比较简单，Best Time to Buy and Sell Stock III是Best Time to Buy and Sell Stock IV的特例，因此，我们研究下k&gt;1的情况即可，找到一个通解。</p><p>看完<a href="https://www.youtube.com/watch?v=oDhu5uGq_ic&amp;t=10s" target="_blank" rel="noopener">Buy/Sell Stock With K transactions To Maximize Profit Dynamic Programming</a>即可理解此过程。<br><img src="/images/2018/9/5.png" alt=""></p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/135704/Detail-explanation-of-DP-solution" target="_blank" rel="noopener">Best Time to Buy and Sell Stock III leetcode题解</a>给出了详细的解答过程，如下：<br>DP recursive formula:<br><code>dp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j-1]), j=[0..i-1]</code></p><p>For k transactions, on i-th day,<br>if we don’t trade then the profit is same as previous day dp[k, i-1];<br>and if we bought the share on j-th day where j=[0..i-1], then sell the share on i-th day then the profit is prices[i] - prices[j] + dp[k-1, j-1] .<br>Actually j can be i as well. When j is i, the one more extra item prices[i] - prices[j] + dp[k-1, j] = dp[k-1, i] looks like we just lose one chance of transaction.</p><p>So the straigtforward implementation is:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">0</span> || prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[K+<span class="number">1</span>][prices.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">                    min = Math.min(min, prices[j] - dp[k-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">                dp[k][i] = Math.max(dp[k][i-<span class="number">1</span>], prices[i] - min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[K][prices.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Time complexity is O(kn^2), space complexity is O(kn).</p><p>In the above code, min is repeated calculated. It can be easily improved as:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">0</span> || prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[K+<span class="number">1</span>][prices.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">                min = Math.min(min, prices[i] - dp[k-<span class="number">1</span>][i-<span class="number">1</span>]);</span><br><span class="line">                dp[k][i] = Math.max(dp[k][i-<span class="number">1</span>], prices[i] - min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[K][prices.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Time complexity is O(kn), space complexity is O(kn).</p><hr><p>如果想获取整个股票交易的过程，可参考<a href="https://github.com/mission-peace/interview/blob/master/src/com/interview/dynamic/StockBuySellKTransactions.java" target="_blank" rel="noopener">StockBuySellKTransactions.java</a>中的代码。</p><p>拿张纸，画出动态规划的过程，即可深刻理解该题。</p><hr><p>参考资料：</p><ol><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution/" target="_blank" rel="noopener">leetcode121题解</a></li><li><a href="https://www.youtube.com/watch?v=oDhu5uGq_ic&amp;t=10s" target="_blank" rel="noopener">Buy/Sell Stock With K transactions To Maximize Profit Dynamic Programming</a></li><li><a href="https://github.com/mission-peace/interview/blob/master/src/com/interview/dynamic/StockBuySellKTransactions.java" target="_blank" rel="noopener">StockBuySellKTransactions.java</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/135704/Detail-explanation-of-DP-solution" target="_blank" rel="noopener">Best Time to Buy and Sell Stock III leetcode题解</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题&quot;&gt;&lt;a href=&quot;#题&quot; class=&quot;headerlink&quot; title=&quot;题&quot;&gt;&lt;/a&gt;题&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/des
      
    
    </summary>
    
      <category term="算法" scheme="http://liujunming.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://liujunming.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Minimum Window Substring</title>
    <link href="http://liujunming.github.io/2018/09/06/Minimum-Window-Substring/"/>
    <id>http://liujunming.github.io/2018/09/06/Minimum-Window-Substring/</id>
    <published>2018-09-06T08:51:11.000Z</published>
    <updated>2018-09-07T05:29:41.774Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题"><a href="#题" class="headerlink" title="题"></a>题</h3><p><a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="noopener">Minimum Window Substring</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看完<a href="https://www.youtube.com/watch?v=9qFR2WQGqkU" target="_blank" rel="noopener">Minimum Window Substring【FLAG高频精选面试题讲解】</a>中小姐姐讲的例子，就可以明白此题的思路。</p><p>本题为滑动窗口问题，通过hashmap+快慢指针来解决。</p><p>针对本题，slow和fast为快慢指针，match_count代表字符串T在字符串S中匹配字符的数目，min_len代表the size of the minimum window in S which will contain all the characters in T，index代表最小滑动窗口的开始地址。</p><p>代码是按照<a href="https://www.youtube.com/watch?v=9qFR2WQGqkU" target="_blank" rel="noopener">Minimum Window Substring【FLAG高频精选面试题讲解】</a>来写的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hashmap.count(t[i]))</span><br><span class="line">                hashmap[t[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hashmap[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>, match_count = <span class="number">0</span>, min_len= INT_MAX, index;</span><br><span class="line">        <span class="keyword">for</span>(fast = <span class="number">0</span>; fast &lt; s.size(); ++fast)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s[fast];</span><br><span class="line">            <span class="keyword">if</span>(!hashmap.count(ch))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> count  = hashmap[ch];</span><br><span class="line">            hashmap[ch]--;</span><br><span class="line">            <span class="comment">// match another character</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">1</span>) <span class="comment">//1-&gt;0</span></span><br><span class="line">                match_count++;</span><br><span class="line">            <span class="keyword">while</span>(match_count == hashmap.size())&#123;</span><br><span class="line">                <span class="comment">// find a valid substring</span></span><br><span class="line">                <span class="keyword">if</span>(fast - slow + <span class="number">1</span> &lt; min_len)&#123;</span><br><span class="line">                    min_len = fast - slow + <span class="number">1</span>;</span><br><span class="line">                    index = slow;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> leftmost = s[slow];</span><br><span class="line">                slow++;</span><br><span class="line">                <span class="keyword">if</span>(!hashmap.count(leftmost))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> leftmostCount = hashmap[leftmost];</span><br><span class="line">                hashmap[leftmost]++;</span><br><span class="line">                <span class="keyword">if</span>(leftmostCount == <span class="number">0</span>) <span class="comment">// 0-&gt;1</span></span><br><span class="line">                    match_count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_len == INT_MAX ? <span class="string">""</span> : s.substr(index, min_len);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.youtube.com/watch?v=9qFR2WQGqkU" target="_blank" rel="noopener">Minimum Window Substring【FLAG高频精选面试题讲解】</a></li><li><a href="https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-&#39;substring&#39;-problems" target="_blank" rel="noopener">Here is a 10-line template that can solve most ‘substring’ problems</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题&quot;&gt;&lt;a href=&quot;#题&quot; class=&quot;headerlink&quot; title=&quot;题&quot;&gt;&lt;/a&gt;题&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-window-substring/descriptio
      
    
    </summary>
    
      <category term="算法" scheme="http://liujunming.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://liujunming.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://liujunming.github.io/2018/09/06/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://liujunming.github.io/2018/09/06/拓扑排序/</id>
    <published>2018-09-06T04:35:26.000Z</published>
    <updated>2018-09-06T06:08:23.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拓扑排序的概念"><a href="#拓扑排序的概念" class="headerlink" title="拓扑排序的概念"></a>拓扑排序的概念</h2><p>在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：</p><ol><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ol><p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</p><p>例如，下面这个图：</p><p><img src="/images/2018/9/2.png" alt=""></p><p>它是一个 DAG 图，那么如何写出它的拓扑排序呢？这里说一种比较常用的方法：</p><ol><li>从 DAG 图中选择一个入度为0的顶点并输出。</li><li>从图中删除该顶点和所有以它为起点的有向边。</li><li>重复1和2直到当前的DAG 图为空或当前图中不存在入度为0的顶点为止。后一种情况说明有向图中必然存在环。<br><img src="/images/2018/9/1.png" alt=""><br><img src="/images/2018/9/3.png" alt=""></li></ol><p>于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。</p><p>通常，一个有向无环图可以有一个或多个拓扑排序序列。</p><h2 id="拓扑排序的应用"><a href="#拓扑排序的应用" class="headerlink" title="拓扑排序的应用"></a>拓扑排序的应用</h2><p>拓扑排序通常用来“排序”具有依赖关系的任务。</p><p>比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边&lt;A,B&gt;表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</p><h2 id="拓扑排序的例题"><a href="#拓扑排序的例题" class="headerlink" title="拓扑排序的例题"></a>拓扑排序的例题</h2><ol><li>从 DAG 图中选择一个入度为0的顶点并输出。</li><li>从图中删除该顶点和所有以它为起点的有向边。</li><li>重复1和2直到当前的 DAG 图为空或当前图中不存在入度为0的顶点为止。后一种情况说明有向图中必然存在环。</li></ol><p>根据上述三个步骤即可写出bfs代码。</p><h3 id="Course-Schedule"><a href="#Course-Schedule" class="headerlink" title="Course Schedule"></a><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">Course Schedule</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(numCourses, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> ready = prerequisites[i].first;</span><br><span class="line">            <span class="keyword">int</span> pre = prerequisites[i].second;</span><br><span class="line">            <span class="keyword">if</span> (matrix[pre][ready] == <span class="number">0</span>)</span><br><span class="line">                indegree[ready]++; <span class="comment">//duplicate case</span></span><br><span class="line">            matrix[pre][ready] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">                que.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> course = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[course][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    indegree[i]--;</span><br><span class="line">                    <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">                        que.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count == numCourses;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Course-Schedule-II"><a href="#Course-Schedule-II" class="headerlink" title="Course Schedule II"></a><a href="https://leetcode.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener">Course Schedule II</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(numCourses, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> ready = prerequisites[i].first;</span><br><span class="line">            <span class="keyword">int</span> pre = prerequisites[i].second;</span><br><span class="line">            <span class="keyword">if</span> (matrix[pre][ready] == <span class="number">0</span>)</span><br><span class="line">                indegree[ready]++; <span class="comment">//duplicate case</span></span><br><span class="line">            matrix[pre][ready] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">                que.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> course = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            ret.push_back(course);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[course][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    indegree[i]--;</span><br><span class="line">                    <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">                        que.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ret.size() != numCourses)</span><br><span class="line">            ret.clear();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><a href="https://blog.csdn.net/lisonglisonglisong/article/details/45543451" target="_blank" rel="noopener">拓扑排序（Topological Sorting）</a></li><li><a href="https://leetcode.com/problems/course-schedule/discuss/58516/Easy-BFS-Topological-sort-Java" target="_blank" rel="noopener">Easy BFS Topological sort</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;拓扑排序的概念&quot;&gt;&lt;a href=&quot;#拓扑排序的概念&quot; class=&quot;headerlink&quot; title=&quot;拓扑排序的概念&quot;&gt;&lt;/a&gt;拓扑排序的概念&lt;/h2&gt;&lt;p&gt;在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Direct
      
    
    </summary>
    
      <category term="算法" scheme="http://liujunming.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://liujunming.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://liujunming.github.io/2018/09/05/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://liujunming.github.io/2018/09/05/并查集/</id>
    <published>2018-09-05T03:40:50.000Z</published>
    <updated>2018-09-05T12:49:29.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并查集概念"><a href="#并查集概念" class="headerlink" title="并查集概念"></a>并查集概念</h2><p>并查集是一种用来管理元素分组情况的数据结构。并查集可以高效地进行如下操作。</p><ul><li>查询元素a和元素b是否属于同一组。</li><li>合并元素a和元素b所在的组。</li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisjointSets</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent, rank;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DisjointSets(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">        rank = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == parent[p])</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        parent[p] = find(parent[p]);</span><br><span class="line">        <span class="keyword">return</span> parent[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[rootQ] &gt; rank[rootP]) &#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootP] == rank[rootQ]) &#123;</span><br><span class="line">                rank[rootP]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Disjoint Sets （以下简称DS）的本质是许多棵树。每个圈子里的元素都组成了一棵树。然而我们的表示方法并不是用常规tree node的方法记录的，而是用数组.</p><p>DS里面拥有一个大小为N的vector <code>parent</code>，对于parent[i],存储着第i号元素所属圈子的老大。DS里面的另一个vector <code>rank</code>用来存储树的高度，它的作用会在Union操作中体现出来。</p><p>DS里面经典的两个操作分别是find和Union.</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p> find就是寻找这个圈子的老大（这棵树的root）。对于find来说，在寻找root的过程中，我们不仅要找到root，还要把沿途经过的所有node的parent都变成root，也就是把自己和沿途所有的node都变成root的孩子（同时也变成了深度为1的leaf）。这个操作叫path compression，意义在于下次我们如果寻找这些node的老大，就可以一步到位了（直接通过parent[i]找到root）。这对时间复杂度的优化是非常重要的。</p><h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p> Union是什么？是我们知道了两个元素属于同一个圈子。如果我们的DS已经知道这一点，那么没问题，如果我们的DS不知道这一点，我们要告诉它。并且很重要的是，这里不是针对两个元素，而是要把这两个元素所处的两个圈子融合成一个圈子，这也就是Union叫法的由来。那么我们分别用find找到两个元素所处tree的root，然后通过比较rank[root]的大小看哪棵树更大。最后我们把小的那棵树的root变成大的那棵树的root的孩子。之所以要选择把小的那棵树融合进大的那棵树，是因为我们希望让树的孩子的高度都尽量小。假设小的树的孩子数量是N1，大的树的孩子数量是N2。如果把小数融合进大树，那么我们让N1个node的高度都增加了1，反之我们要让N2个node的高度都增加1。后者明显是违反我们希望让树的孩子的高度都尽量小这个意愿的。<br> <a href="https://www.youtube.com/watch?v=ID00PMy0-vE" target="_blank" rel="noopener">Disjoint Sets using union by rank and path compression Graph Algorithm</a>中以具体的例子演示了Union的过程。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="Friend-Circles"><a href="#Friend-Circles" class="headerlink" title="Friend Circles"></a><a href="https://leetcode.com/problems/friend-circles/description/" target="_blank" rel="noopener">Friend Circles</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DisjointSets</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent, rank;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DisjointSets(<span class="keyword">int</span> num) &#123;</span><br><span class="line">            count = num;</span><br><span class="line">            parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">            rank = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p == parent[p])</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            parent[p] = find(parent[p]);</span><br><span class="line">            <span class="keyword">return</span> parent[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">            <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            count -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootQ] &gt; rank[rootP]) &#123;</span><br><span class="line">                parent[rootP] = rootQ;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootQ] = rootP;</span><br><span class="line">                <span class="keyword">if</span> (rank[rootP] == rank[rootQ]) &#123;</span><br><span class="line">                    rank[rootP]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        DisjointSets ds(M.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = M.size(); i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[i][j]) ds.unionTwo(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ds.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于整个matrix，如果M[i][j]为1，我们则需要告诉DS i和j属于一个圈子。这里因为对称性，我们只需要遍历半个matrix就可以得到所有信息。在DS里面我增加了一个count。count代表现在DS中独立圈子的数量。因为最开始我们什么信息都不知道，假设每个人都属于自己的独立圈子，所以count为人的个数，之后每一次Union操作，如果我们发现i和j所处圈子（的老大）不同（root1 ！= root2），那么说明有两个圈子要合并成一个，那么就少了一个圈子，所以count要减1.最后我们返回count，也就是圈子的数量。</p><h3 id="Number-of-Islands"><a href="#Number-of-Islands" class="headerlink" title="Number of Islands"></a><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener">Number of Islands</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DisjointSets</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent, rank;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DisjointSets(<span class="keyword">int</span> num) &#123;</span><br><span class="line">            count = num;</span><br><span class="line">            parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">            rank = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p == parent[p])</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            parent[p] = find(parent[p]);</span><br><span class="line">            <span class="keyword">return</span> parent[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">            <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            count -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootQ] &gt; rank[rootP]) &#123;</span><br><span class="line">                parent[rootP] = rootQ;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootQ] = rootP;</span><br><span class="line">                <span class="keyword">if</span> (rank[rootP] == rank[rootQ]) &#123;</span><br><span class="line">                    rank[rootP]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(grid.size() == <span class="number">0</span> || grid[<span class="number">0</span>].size() ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    hashMap[i*n+j] = num;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">DisjointSets <span class="title">ds</span><span class="params">(num)</span></span>;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; hashMap.count((i<span class="number">-1</span>)*n+j))&#123;</span><br><span class="line">                        ds.unionTwo(hashMap[(i<span class="number">-1</span>)*n+j], hashMap[i*n+j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i + <span class="number">1</span> &lt; m &amp;&amp; hashMap.count((i+<span class="number">1</span>)*n+j))&#123;</span><br><span class="line">                        ds.unionTwo(hashMap[(i+<span class="number">1</span>)*n+j], hashMap[i*n+j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; hashMap.count(i*n+j<span class="number">-1</span>))&#123;</span><br><span class="line">                        ds.unionTwo(hashMap[i*n+j<span class="number">-1</span>], hashMap[i*n+j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; hashMap.count(i*n+j+<span class="number">1</span>))&#123;</span><br><span class="line">                        ds.unionTwo(hashMap[i*n+j+<span class="number">1</span>], hashMap[i*n+j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ds.getCount();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><a href="https://blog.csdn.net/niushuai666/article/details/6662911" target="_blank" rel="noopener">超有爱的并查集~</a></li><li><a href="https://www.youtube.com/watch?v=ID00PMy0-vE" target="_blank" rel="noopener">Disjoint Sets using union by rank and path compression Graph Algorithm</a></li><li><a href="https://zhuanlan.zhihu.com/p/32112569" target="_blank" rel="noopener">Disjoint Sets / Union Find</a></li><li><a href="https://www.youtube.com/watch?v=JZBQLXgSGfs" target="_blank" rel="noopener">Union Find Kruskal’s Algorithm</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并查集概念&quot;&gt;&lt;a href=&quot;#并查集概念&quot; class=&quot;headerlink&quot; title=&quot;并查集概念&quot;&gt;&lt;/a&gt;并查集概念&lt;/h2&gt;&lt;p&gt;并查集是一种用来管理元素分组情况的数据结构。并查集可以高效地进行如下操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询元素a和元
      
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统中需要记住的数字</title>
    <link href="http://liujunming.github.io/2018/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%9C%80%E8%A6%81%E8%AE%B0%E4%BD%8F%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://liujunming.github.io/2018/07/02/计算机系统中需要记住的数字/</id>
    <published>2018-07-02T01:54:58.000Z</published>
    <updated>2018-07-02T01:54:58.407Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Bloom-Filter的解析</title>
    <link href="http://liujunming.github.io/2018/05/25/Bloom-Filter%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://liujunming.github.io/2018/05/25/Bloom-Filter的解析/</id>
    <published>2018-05-25T05:01:58.000Z</published>
    <updated>2018-06-28T13:54:07.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bloom-Filter概念"><a href="#Bloom-Filter概念" class="headerlink" title="Bloom Filter概念"></a>Bloom Filter概念</h2><p>Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ul><li><p>初始状态<br>Bloom Filter是一个m位的位数组，且数组被0所填充。同时，我们需要定义k个不同的hash函数，每一个hash函数都随机的将每一个输入元素映射到位数组中的一个位上。那么对于一个确定的输入，我们会得到k个索引。</p></li><li><p>插入元素<br>经过k个hash函数的映射，我们会得到k个索引，我们把位数组中这k个位置全部置1（不管其中的位之前是0还是1）</p></li><li>查询元素<br>输入元素经过k个hash函数的映射会得到k个索引，如果位数组中这k个索引任意一处是0，那么就说明这个元素不在集合之中；如果元素处于集合之中，那么当插入元素的时候这k个位都是1。但如果这k个索引处的位都是1，被查询的元素就一定在集合之中吗？答案是不一定，也就是说出现了False Positive的情况。<br><img src="/images/2018/5/6.png" alt=""><br>在上图中，当插入x、y、z这三个元素之后，再来查询w，会发现w不在集合之中，而如果w经过三个hash函数计算得出的结果所得索引处的位全是1，那么Bloom Filter就会告诉你，w在集合之中，实际上这里是误报，w并不在集合之中。</li></ul><h2 id="误报率估计"><a href="#误报率估计" class="headerlink" title="误报率估计"></a>误报率估计</h2><p><img src="/images/2018/5/7.png" alt=""></p><h2 id="Bloom-Filter的实现"><a href="#Bloom-Filter的实现" class="headerlink" title="Bloom Filter的实现"></a>Bloom Filter的实现</h2><p>纸上得来终觉浅，绝知此事要躬行。</p><p><a href="https://github.com/liujunming/Tools/tree/master/BloomFilter" target="_blank" rel="noopener">Bloom Filter的实现</a></p><p>若读者想深入研究Bloom Filter，可以去知网下载《基于LSM-tree键值系统读性能优化》(张月明)。</p><hr><p>参考资料:</p><ol><li><a href="https://my.oschina.net/kiwivip/blog/133498" target="_blank" rel="noopener">Bloom Filter 算法简介</a></li><li><a href="http://www.cnblogs.com/kaituorensheng/p/3669140.html" target="_blank" rel="noopener">实例学习Bloom Filter</a></li><li><a href="https://blog.csdn.net/jiaomeng/article/details/1495500" target="_blank" rel="noopener">Bloom Filter概念和原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Bloom-Filter概念&quot;&gt;&lt;a href=&quot;#Bloom-Filter概念&quot; class=&quot;headerlink&quot; title=&quot;Bloom Filter概念&quot;&gt;&lt;/a&gt;Bloom Filter概念&lt;/h2&gt;&lt;p&gt;Bloom Filter是一种空间效率很高的
      
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>perf内核源码解析</title>
    <link href="http://liujunming.github.io/2018/05/10/perf%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://liujunming.github.io/2018/05/10/perf内核源码解析/</id>
    <published>2018-05-10T04:06:14.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文所演示的内核版本为<a href="https://elixir.bootlin.com/linux/v3.14.69/source" target="_blank" rel="noopener">3.14.69</a>，平台架构为x86架构,主要以<a href="https://www.zybuluo.com/ljm/note/1125361" target="_blank" rel="noopener">通过perf测试进程的内存带宽</a>为例，讲述了在内核的调用过程。</p><h2 id="perf用户态使用"><a href="#perf用户态使用" class="headerlink" title="perf用户态使用"></a>perf用户态使用</h2><p>在用户态，用户可以调用<a href="https://elixir.bootlin.com/linux/v3.14.69/source/kernel/events/core.c#L7094" target="_blank" rel="noopener">perf_event_open</a>系统调用来使用perf。<br>建议读者好好阅读下下面推荐的资料，这样可以对perf_event_open的理解更加深刻些。</p><ol><li><a href="http://man7.org/linux/man-pages/man2/perf_event_open.2.html" target="_blank" rel="noopener">man2　perf_event_open</a></li><li><a href="http://ozlabs.org/~anton/junkcode/perf_events_example1.c" target="_blank" rel="noopener">perf events self profiling example</a></li><li><a href="http://hchen229.iteye.com/blog/585434" target="_blank" rel="noopener">使用performance counter读取硬件或软件Event</a></li><li><a href="https://blog.csdn.net/u012884354/article/details/45720737" target="_blank" rel="noopener">perf_event_open 设置性能监视</a></li></ol><h2 id="perf-event子系统架构"><a href="#perf-event子系统架构" class="headerlink" title="perf event子系统架构"></a>perf event子系统架构</h2><p><img src="/images/2018/5/1.png" alt=""></p><p>The Linux Perf_Event Subsystem consists of the files <a href="https://elixir.bootlin.com/linux/v3.14.69/source/kernel/events/core.c" target="_blank" rel="noopener">core.c</a> and <a href="https://elixir.bootlin.com/linux/v3.14.69/source/arch/x86/kernel/cpu/perf_event.c" target="_blank" rel="noopener">perf_event.c</a>. These files are the interface between the linux kernel and various user space performance monitoring tool.</p><h2 id="perf-event子系统中的数据结构"><a href="#perf-event子系统中的数据结构" class="headerlink" title="perf event子系统中的数据结构"></a>perf event子系统中的数据结构</h2><p>数据结构的定义在<a href="https://elixir.bootlin.com/linux/v3.14.69/source/include/linux/perf_event.h" target="_blank" rel="noopener">perf_event.h</a>文件中。</p><p>The following are some of the important data structures which are used by the perf_event subsystem.</p><p><img src="/images/2018/5/2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct perf_event;</span><br><span class="line">struct perf_event_attr;</span><br><span class="line">struct perf_event_context;</span><br><span class="line">struct pmu;</span><br></pre></td></tr></table></figure><p><strong>Important Fields in the Data Structures</strong></p><h3 id="perf-event"><a href="#perf-event" class="headerlink" title="perf_event"></a>perf_event</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event</span> *<span class="title">group_leader</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmu</span> *<span class="title">pmu</span>;</span></span><br><span class="line">u64 total_time_enabled;</span><br><span class="line">u64 total_time_running;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_attr</span> <span class="title">attr</span>;</span></span><br><span class="line"><span class="keyword">atomic64_t</span> child_count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span> *<span class="title">ctx</span>;</span></span><br><span class="line"><span class="keyword">perf_overflow_handler_t</span> overflow_handler;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>Description:</strong></p><ul><li>group_leader<br>This field specifies the leader of the group of events attached to the process.</li><li>pmu<br>This field points to the generic performance monitoring unit structure.</li><li>total_time_enabled<br>This field specify the total time in nanoseconds that the event has been enabled.</li><li>total_time_running<br>This field specify total time in nanoseconds that the event is running(scheduled onto the<br>CPU)</li><li>owner<br>This field points to the task structure of the process which has monitoring this event.</li></ul><h3 id="perf-event-attr"><a href="#perf-event-attr" class="headerlink" title="perf_event_attr"></a>perf_event_attr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_attr</span> &#123;</span></span><br><span class="line">__u32 type;</span><br><span class="line">__u64 config;</span><br><span class="line">__u64 sample_period;</span><br><span class="line">__u64 sample_freq;</span><br><span class="line">__u64 sample_type;</span><br><span class="line">exclusive : <span class="number">1</span>,</span><br><span class="line">exclude_user : <span class="number">1</span>,</span><br><span class="line">exclude_kernel : <span class="number">1</span>,</span><br><span class="line">exclude_hv : <span class="number">1</span>,</span><br><span class="line">exclude_idle : <span class="number">1</span>,</span><br><span class="line">exclude_host : <span class="number">1</span>,</span><br><span class="line">exclude_guest : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>Description:</strong></p><ul><li>type<br>This field specifies the overall event type.</li><li>config<br>This field specifies which event needs to be monitored. It is used along with type to<br>decide the exact event.</li><li>sample_period, sample_freq<br>Sampling period defines the N value where N is the number of events after which the<br>interrupt is generated. It can be counted in terms of frequency as well.</li><li>sample_type<br>The various bits in this field specify which values to include in the sample.</li><li>exclude_user<br>This bit when enabled the count excludes the user-space events.</li><li>exclude_kernel<br>This bit when enabled the count exclude the kernel-space events.</li></ul><h3 id="perf-event-context"><a href="#perf-event-context" class="headerlink" title="perf_event_context"></a>perf_event_context</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">event_list</span>;</span></span><br><span class="line"><span class="keyword">int</span> nr_events;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span> *<span class="title">parent_ctx</span>;</span></span><br><span class="line">u64 time;</span><br><span class="line">u64 timestamp; &#125;</span><br></pre></td></tr></table></figure><p><strong>Description:</strong></p><ul><li>event_lists<br>This field specifies the list of events.</li><li>nr_events<br>This field specifies the number of events that are currently monitored.</li><li>parent_ctx<br>This fields points to the context of the processes parent.</li><li>time,timestamp<br>These are context clocks, they run when the context is enabled.</li></ul><h3 id="pmu"><a href="#pmu" class="headerlink" title="pmu"></a>pmu</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmu</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> (*pmu_enable) (struct pmu *pmu);</span><br><span class="line"><span class="keyword">void</span> (*pmu_disable) (struct pmu *pmu);</span><br><span class="line"><span class="keyword">void</span> (*start) (struct perf_event *event, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">void</span> (*stop) (struct perf_event *event, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">void</span> (*read) (struct perf_event *event); &#125;</span><br></pre></td></tr></table></figure><p><strong>Description:</strong><br>This structure majorly contains the function pointers to various PMU related functions.</p><ul><li>pmu_enable,pmu_disable<br>These functions are used to fully disable/enable a PMU.</li><li>start,stop<br>These functions are used to start or stop a counter on a PMU.</li><li>read<br>This function is used to update the event value for a particular counter.</li></ul><h2 id="Counting-Support-in-Linux-Perf"><a href="#Counting-Support-in-Linux-Perf" class="headerlink" title="Counting Support in Linux Perf"></a>Counting Support in Linux Perf</h2><p>perf_event assigns one file descriptor per event and either per-thread or per-CPU. The system call perf_event_open() configures the hardware MSRs and creates a file descriptor which can be used for reading the performance measurement data. Once the file descriptor is obtained we can issue subsequent read calls to get the values of the performance counters. These values are then aggregated at the end of the program execution.</p><p>The following is the execution flow for getting the file descriptor.</p><p><img src="/images/2018/5/4.png" alt=""></p><p>For enabling and disabling performance monitoring events we use the ioclt and prctl system calls.</p><p>Execution flow of the read system call:<br> <img src="/images/2018/5/5.png" alt=""></p><h2 id="perf-event-open系统调用的具体过程"><a href="#perf-event-open系统调用的具体过程" class="headerlink" title="perf_event_open系统调用的具体过程"></a>perf_event_open系统调用的具体过程</h2><p><img src="/images/2018/5/3.png" alt=""></p><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><p>好了，背景知识终于介绍完成了，下面介绍下具体的实例，方便读者理解。<br><code>perf stat -e cache-misses -I 1000 -p 2234</code><br>每隔1000ms，会输出2234进程在过去1000ms的cache_misses硬件事件，这是如何做到的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">type:<span class="number">0</span> <span class="comment">//PERF_TYPE_HARDWARE</span></span><br><span class="line">config:<span class="number">3</span> <span class="comment">//PERF_COUNT_HW_CACHE_MISSES</span></span><br></pre></td></tr></table></figure><p>每隔1000ms输出结果是通过用户态程序控制的，阅读完<a href="http://hchen229.iteye.com/blog/585434" target="_blank" rel="noopener">使用performance counter读取硬件或软件Event</a>中的程序即可明白。</p><p>当需要监听2234进程的cache_misses时，实际上是对2234进程中的所有线程进行监听,假设线程的数目为5个，此刻，会调用perf_event_open系统调用5次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">perf_event_read_one</span><span class="params">(struct perf_event *event,</span></span></span><br><span class="line"><span class="function"><span class="params">                 u64 read_format, <span class="keyword">char</span> __user *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u64 enabled, running;</span><br><span class="line">    u64 values[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    values[n++] = perf_event_read_value(event, &amp;enabled, &amp;running);</span><br><span class="line">    printk(<span class="string">"&lt;0&gt;"</span><span class="string">"liujunming  perf_event_read_one value%llu\n"</span>, values[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (read_format &amp; PERF_FORMAT_TOTAL_TIME_ENABLED)</span><br><span class="line">        values[n++] = enabled;</span><br><span class="line">    <span class="keyword">if</span> (read_format &amp; PERF_FORMAT_TOTAL_TIME_RUNNING)</span><br><span class="line">        values[n++] = running;</span><br><span class="line">    <span class="keyword">if</span> (read_format &amp; PERF_FORMAT_ID)</span><br><span class="line">        values[n++] = primary_event_id(event);</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, values, n * <span class="keyword">sizeof</span>(u64)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="keyword">sizeof</span>(u64);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>perf_event_read_value会读取相应线程寄存器中记录的cache_miss值。</p><p>当统计2234进程时，实际上是对它5个线程的cache_misses值进行累加。假设前２秒内，2234进程的cache_misses为10000,前3秒内，2234进程的cache_misses为30000。那么在2~3秒这一秒内，进程的cache_misses即为20000。</p><hr><p>参考资料:</p><ol><li><a href="http://rts.lab.asu.edu/web_438/project_final/CSE_598_Performance_Monitoring_Unit.pdf" target="_blank" rel="noopener">A Study of Performance Monitoring Unit, perf and perf_events subsystem</a></li><li><a href="http://cdmd.cnki.com.cn/Article/CDMD-10358-1011284067.htm" target="_blank" rel="noopener">龙芯多核平台上性能分析工具的设计与实现</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文所演示的内核版本为&lt;a href=&quot;https://elixir.bootlin.com/linux/v3.14.69/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;3.14.69&lt;/a&gt;，平台架构为x86架构,主要以&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>深度解析perf</title>
    <link href="http://liujunming.github.io/2018/04/24/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90perf/"/>
    <id>http://liujunming.github.io/2018/04/24/深度解析perf/</id>
    <published>2018-04-24T12:27:04.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zybuluo.com/ljm/note/1125361" target="_blank" rel="noopener">通过perf测试进程的内存带宽</a></p><h2 id="perf的基本原理"><a href="#perf的基本原理" class="headerlink" title="perf的基本原理"></a>perf的基本原理</h2><p>Perf 是内置于 Linux 内核源码树中的性能剖析（profiling）工具。它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析，可用于性能瓶颈的查找与热点代码的定位。</p><p>以监测“cycles”事件为例，perf的工作过程如下：<br>首先，perf 会通过系统调用sys_perf_event_open在内核中注册一个监测“cycles”事件的性能计数器。内核根据perf提供的信息在PMU(Performance Monitoring Unit)上初始化一个硬件性能计数器（PMC:Performance Monitoring Counter）。PMC随着CPU周期的增加而自动累加。在PMC溢出时，PMU触发一个PMI（Performance Monitoring Interrupt）中断。内核在PMI中断的处理函数中保存PMC的计数值，触发中断时的指令地址（Register IP：Instruction Pointer），当前时间戳以及当前进程的PID，TID，comm等信息。我们把这些信息统称为一个采样（sample）。内核会将收集到的sample放入用于跟用户空间通信的Ring Buffer。用户空间里的perf分析程序采用mmap机制从Ring Buffer中读入采样，并对其解析。perf根据pid，comm等信息可以找到对应的进程。根据IP与ELF文件中的符号表可以查到触发PMI中断的指令所在的函数。</p><p>根据上述的perf采样原理可以得知，perf假设两次采样之间，即两次相邻的PMI中断之间系统执行的是同一个进程的同一个函数。这种假设会带来一定的误差，当读者感觉perf给出的结果不准时，不妨提高采样频率，perf会给出更加精确的结果。</p><h2 id="perf-list简介"><a href="#perf-list简介" class="headerlink" title="perf list简介"></a>perf list简介</h2><p>事件可以分为三种：</p><ol><li>Hardware Event由PMU部件产生，在特定的条件下探测性能事件是否发生以及发生的次数。比如cache命中。</li><li>Software Event是内核产生的事件，分布在各个功能模块中，统计和操作系统相关性能事件。比如进程切换，tick数等。</li><li>Tracepoint Event是内核中静态tracepoint所触发的事件，这些tracepoint用来判断程序运行期间内核的行为细节，比如slab分配器的分配次数等。</li></ol><h2 id="性能事件的属性"><a href="#性能事件的属性" class="headerlink" title="性能事件的属性"></a>性能事件的属性</h2><p>硬件性能事件由处理器中的PMU提供支持。由于现代处理器的主频非常高，再加上深度流水线机制，从性能事件被触发，到处理器响应 PMI中断，流水线上可能已处理过数百条指令。那么PMI中断采到的指令地址就不再是触发性能事件的那条指令的地址了，而且可能具有非常严重的偏差。为了解决这个问题，Intel处理器通过PEBS机制实现了高精度事件采样。PEBS通过硬件在计数器溢出时将处理器现场直接保存到内存（而不是在响应中断时才保存寄存器现场），从而使得 perf能够采到真正触发性能事件的那条指令的地址，提高了采样精度。在默认条件下，perf不使用PEBS机制。用户如果想要使用高精度采样，需要在指定性能事件时，在事件名后添加后缀”:p”或”:pp”。<br>Perf在采样精度上定义了4个级别，如下表所示。</p><table><thead><tr><th>级别</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>无精度保证</td></tr><tr><td>1</td><td>采样指令与触发性能事件的指令之间的偏差为常数（:p）</td></tr><tr><td>2</td><td>需要尽量保证采样指令与触发性能事件的指令之间的偏差为0（:pp）</td></tr><tr><td>3</td><td>保证采样指令与触发性能事件的指令之间的偏差必须为0（:ppp）</td></tr></tbody></table><center>性能事件的精度级别</center><p>目前的X86处理器，包括Intel处理器与AMD处理器均仅能实现前 3 个精度级别。</p><p>除了精度级别以外，性能事件还具有其它几个属性，均可以通过”event:X”的方式予以指定。</p><table><thead><tr><th>标志</th><th>属性</th></tr></thead><tbody><tr><td>u</td><td>仅统计用户空间程序触发的性能事件</td></tr><tr><td>k</td><td>仅统计内核触发的性能事件</td></tr><tr><td>h</td><td>仅统计Hypervisor触发的性能事件</td></tr><tr><td>G</td><td>在KVM虚拟机中，仅统计Guest系统触发的性能事件</td></tr><tr><td>H</td><td>仅统计 Host 系统触发的性能事件</td></tr><tr><td>p</td><td>精度级别</td></tr></tbody></table><center>性能事件的属性</center><hr><p>参考资料:</p><ol><li><a href="http://files.cnblogs.com/files/jiayy/Linux%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%BA%A7%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%E5%B7%A5%E5%85%B7-perf-1.pdf" target="_blank" rel="noopener">Linux 的系统级性能剖析工具‐perf</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.zybuluo.com/ljm/note/1125361&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;通过perf测试进程的内存带宽&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;perf的基本原理&quot;&gt;&lt;a href=&quot;#pe
      
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>自我总结</title>
    <link href="http://liujunming.github.io/2018/04/19/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93/"/>
    <id>http://liujunming.github.io/2018/04/19/自我总结/</id>
    <published>2018-04-19T08:12:33.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直认为自己是在搞系统的，但是忽然发现对系统的好多知识都不够了解。必须做到在计算机系统结构、操作系统内核、网络、分布式系统、算法这些领域都能游刃有余，方能运筹帷幄，决胜千里。</p><p>上了研究生，学习的渠道可能就是博客、论文这些，但是缺乏一个系统的学习流程，后来发现是自己书看的太少了，思考的太少。</p><p>下面列出自己需要看完的书籍吧：</p><ul><li><a href="https://raw.githubusercontent.com/QSCTech/zju-icicles/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%95%99%E6%9D%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E9%87%8F%E5%8C%96%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%94%E7" target="_blank" rel="noopener">计算机体系结构：量化研究方法</a></li></ul><p><a href="https://booksite.elsevier.com/9780123838728/references.php" target="_blank" rel="noopener">Reference Appendices</a><br>两位作者凭借此书，刚刚获得图灵奖，这本书的价值不言而喻。<br><img src="/images/2018/4/11.jpg" alt=""></p><ul><li><p>现代操作系统</p></li><li><p>计算机网络(自顶向下方法)</p></li><li><p>Designing Data-Intensive Applications</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直认为自己是在搞系统的，但是忽然发现对系统的好多知识都不够了解。必须做到在计算机系统结构、操作系统内核、网络、分布式系统、算法这些领域都能游刃有余，方能运筹帷幄，决胜千里。&lt;/p&gt;
&lt;p&gt;上了研究生，学习的渠道可能就是博客、论文这些，但是缺乏一个系统的学习流程，后来发现是
      
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>通过Linux内核使用RDT</title>
    <link href="http://liujunming.github.io/2018/04/18/%E9%80%9A%E8%BF%87Linux%E5%86%85%E6%A0%B8%E4%BD%BF%E7%94%A8RDT/"/>
    <id>http://liujunming.github.io/2018/04/18/通过Linux内核使用RDT/</id>
    <published>2018-04-18T06:40:00.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://liujunming.top/2018/04/11/Intel-RDT%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">Intel RDT特性详解</a>介绍了RDT的基本概念，以及通过PQOS工具使用RDT。本文主要是介绍如何通过内核来使用RDT。</p><p>我的内核版本为<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.14.32.tar.gz" target="_blank" rel="noopener">4.14.32</a>，内核对RDT的支持有版本要求，详情请参考<a href="https://github.com/intel/intel-cmt-cat/wiki" target="_blank" rel="noopener">OS interface feature support</a>。cpu型号为Intel Xeon E5 2650 v4，共两个cpu。</p><h2 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h2><p>RDT技术的选项位于“processor type and feature” -&gt; “Intel Resource Director Technology Allocation support”。</p><p><img src="/images/2018/4/9.png" alt=""></p><p><img src="/images/2018/4/10.png" alt=""></p><h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><p><code>mount -t resctrl resctrl /sys/fs/resctrl</code></p><h2 id="Resource-alloc-and-monitor-groups"><a href="#Resource-alloc-and-monitor-groups" class="headerlink" title="Resource alloc and monitor groups"></a>Resource alloc and monitor groups</h2><h3 id="Resource-groups"><a href="#Resource-groups" class="headerlink" title="Resource groups"></a>Resource groups</h3><ul><li>CTRL_MON groups</li></ul><p>Resource groups are represented as directories in the resctrl file system.  The default group is the root directory which, immediately after mounting, owns all the tasks and cpus in the system and can make full use of all resources.<br>On a system with RDT control features additional directories can be created in the root directory that specify different amounts of each resource. The root and these additional top level directories are referred to as “CTRL_MON” groups.</p><ul><li>MON groups</li></ul><p>On a system with RDT monitoring the root directory and other top level directories contain a directory named “mon_groups” in which additional directories can be created to monitor subsets of tasks in the CTRL_MON group that is their ancestor. These are called “MON” groups.</p><h3 id="All-groups-contain-the-following-files"><a href="#All-groups-contain-the-following-files" class="headerlink" title="All groups contain the following files"></a>All groups contain the following files</h3><ul><li>tasks<br>Reading this file shows the list of all tasks that belong to this group. Writing a task id to the file will add a task to the group.</li><li>cpus<br>是一个16进制整数，每一个bit代表一个CPU核心，比如我这里有10个“f”，意味着该机器有40个core。</li></ul><h4 id="When-control-is-enabled"><a href="#When-control-is-enabled" class="headerlink" title="When control is enabled"></a>When control is enabled</h4><p>When control is enabled all CTRL_MON groups will also contain:</p><ul><li>schemata<br>策略表，每个策略一行，格式为：<br>L3: cache_id0 = cbm; cache_id1 = cbm<br>这里的cache id可以理解为CPU id，而后面的cbm是分配给cpu的L3单元数量。我这块CPU每个socket会有11个L3 cache 单元也就是7ff。就是指在cpu cache的每个组内，group可以使用的cache line的数量。</li></ul><h4 id="When-monitoring-is-enabled"><a href="#When-monitoring-is-enabled" class="headerlink" title="When monitoring is enabled"></a>When monitoring is enabled</h4><p>When monitoring is enabled all MON groups will also contain:</p><ul><li>mon_data<br>This contains a set of files organized by L3 domain and by RDT event. E.g. on a system with two L3 domains there will be subdirectories “mon_L3_00” and “mon_L3_01”.    Each of these directories have one file per event (e.g. “llc_occupancy”, “mbm_total_bytes”, and “mbm_local_bytes”). In a MON group these files provide a read out of the current value of the event for all tasks in the group(在MON组中，这些文件为组中的所有任务提供读取当前事件的值).</li></ul><h2 id="Examples-for-RDT-allocation-usage"><a href="#Examples-for-RDT-allocation-usage" class="headerlink" title="Examples for RDT allocation usage"></a>Examples for RDT allocation usage</h2><p>具体例子请参考<a href="https://www.kernel.org/doc/Documentation/x86/intel_rdt_ui.txt" target="_blank" rel="noopener">intel_rdt_ui.txt</a></p><h2 id="Examples-for-RDT-Monitoring-along-with-allocation-usage"><a href="#Examples-for-RDT-Monitoring-along-with-allocation-usage" class="headerlink" title="Examples for RDT Monitoring along with allocation usage"></a>Examples for RDT Monitoring along with allocation usage</h2><p>具体例子请参考<a href="https://www.kernel.org/doc/Documentation/x86/intel_rdt_ui.txt" target="_blank" rel="noopener">intel_rdt_ui.txt</a></p><hr><p>参考资料：</p><ol><li><a href="https://www.kernel.org/doc/Documentation/x86/intel_rdt_ui.txt" target="_blank" rel="noopener">intel_rdt_ui.txt</a></li><li><a href="http://www.litrin.net/2017/02/21/linux-4-10%E4%B8%ADcat%E7%9A%84%E4%BD%BF%E7%94%A8/2/" target="_blank" rel="noopener">Linux 4.10中CAT的使用</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://liujunming.top/2018/04/11/Intel-RDT%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Intel RDT特性详解&lt;/a
      
    
    </summary>
    
      <category term="计算机系统" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机系统" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统资料</title>
    <link href="http://liujunming.github.io/2018/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%96%99/"/>
    <id>http://liujunming.github.io/2018/04/17/分布式系统资料/</id>
    <published>2018-04-17T01:47:04.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>汇总分布式系统的资料。</p><ul><li><a href="https://www.cs.rutgers.edu/~pxk/417/notes/index.html" target="_blank" rel="noopener">rutgers Distributed Systems </a></li><li><a href="http://www.scs.stanford.edu/17au-cs244b/" target="_blank" rel="noopener">Stanford Distributed Systems</a></li><li><a href="http://nil.csail.mit.edu/6.824/2017/index.html" target="_blank" rel="noopener">Mit Distributed Systems</a></li><li><a href="https://github.com/feixiao/Distributed-Systems" target="_blank" rel="noopener">MIT课程《Distributed Systems 》学习和翻译</a></li><li><a href="https://github.com/zhenlohuang/awesome-distributed-systems" target="_blank" rel="noopener">awesome-distributed-systems</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;汇总分布式系统的资料。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cs.rutgers.edu/~pxk/417/notes/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;rutgers Distribute
      
    
    </summary>
    
      <category term="分布式系统" scheme="http://liujunming.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://liujunming.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Intel RDT特性详解</title>
    <link href="http://liujunming.github.io/2018/04/11/Intel-RDT%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
    <id>http://liujunming.github.io/2018/04/11/Intel-RDT特性详解/</id>
    <published>2018-04-11T01:24:01.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>英特尔至强 E5-2600 v4在对外宣传时候号称“为云而生”的，除了其强大的性能和众多核心外，主要亮点就是Resource Director Technology（RDT）新技术的加入。使得其有理由宣称“为云而生”。<br>我们知道在一个虚拟化环境中，宿主机的资源（包括CPU cache和内存带宽）都是共享的。但是如果有一个消耗cache的应用快速消耗了L3缓存，或者一个应用消耗了系统大量内存带宽，那么如何保证其他虚拟机应用呢？如何限制这些“可恶”的邻居呢？<br>针对上诉问题，以前都是通过控制虚拟机逻辑资源来实现，但是调整的粒度实在太粗，针对处理器缓存这样敏感而稀缺的资源，几乎是无能为力的。为此英特尔推出了RDT技术，希望可以解决这个问题。<br>那么看下RDT到底是什么神奇技术。</p><h2 id="技术组成"><a href="#技术组成" class="headerlink" title="技术组成"></a>技术组成</h2><p>RDT技术有其实有5个功能模块，分别是</p><ul><li>Cache Monitoring Technology (CMT)缓存监测技术</li><li>Cache Allocation Technology (CAT)缓存分配技术</li><li>Memory Bandwidth Monitoring (MBM)内存带宽监测技术</li><li>Memory Bandwidth Allocation (MBA)内存带宽分配技术</li><li>Code and Data Prioritization (CDP)代码和数据分区技术</li></ul><p>5个模块可以分为监控和控制两大类，CMT和MBM为监控技术，而CAT、MBA和CDP为控制技术。<br>RDT允许OS或VMM来监控线程，应用或VM使用的cache/内存带宽空间。通过分析cache/内存带宽使用率，OS或VMM可以优化调度策略提高效能，使得高级优化技术可以实现。</p><h2 id="为什么需要RDT"><a href="#为什么需要RDT" class="headerlink" title="为什么需要RDT"></a>为什么需要RDT</h2><p>配合这几个技术，OS能够知道应用使用了多少CACHE空间，内存带宽，从而给虚拟机的虚拟处理器分配真实的CPU资源。结合CMT和CAT，缓存可做到实时监测和使用，能够让处理器的资源向虚拟机中最重要、最紧迫的任务分配。CDP可以限制数据在LLC中的存储，从而将空间节省出来给代码存储。</p><h2 id="具体功能"><a href="#具体功能" class="headerlink" title="具体功能"></a>具体功能</h2><p>下面我们来看下RDT的一个具体功能。<br>以下方截图来说明，如下：<br><img src="/images/2018/4/8.png" alt=""><br>我们可以发现cores 0-5关联到了RMID 47-42,进 行了每个核监控,提供了CMT/MBM数据。</p><h3 id="RMID"><a href="#RMID" class="headerlink" title="RMID"></a>RMID</h3><p>OS或VMM会给每个应用或虚拟机标记一个软件定义的ID，叫做RMID（Resource Monitoring ID），通过RMID可以同时监控运行在多处理器上相互独立的线程。</p><h2 id="RDT的使用"><a href="#RDT的使用" class="headerlink" title="RDT的使用"></a>RDT的使用</h2><h3 id="工具软件"><a href="#工具软件" class="headerlink" title="工具软件"></a>工具软件</h3><p>使用Intel开源的工具来实现，不需要内核支持。通过这个软件包可以使用CAT,CMT,MBM,CDP功能。<br>工具软件<a href="https://github.com/intel/intel-cmt-cat" target="_blank" rel="noopener">下载链接</a><br>（注：下面的指令均在root下运行）</p><ul><li><code>make &amp;&amp; make install</code></li></ul><hr><p>WARN: Error opening file ‘/dev/cpu/0/msr’!<br>ERROR: CDP detection error!<br>ERROR: Fatal error encounter in CAT discovery!<br>ERROR: discover_capabilities() error 1<br>Error initializing PQoS library!<br>出现上述错误，则执行如下指令：</p><ul><li><code>modprobe msr</code></li></ul><p>具体使用教程参考<a href="https://github.com/intel/intel-cmt-cat/wiki/Usage-Examples" target="_blank" rel="noopener">Usage Examples</a></p><hr><p>参考资料：</p><ol><li><a href="http://linuxperformance.top/index.php/archives/21/" target="_blank" rel="noopener">Intel RDT特性详解</a></li><li><a href="http://www.litrin.net/2018/01/02/kernel-4-14%E7%9A%84rdt%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">Kernel 4.14的RDT配置</a></li><li><a href="http://www.litrin.net/2017/02/15/intel-rdt/" target="_blank" rel="noopener">Intel RDT</a></li><li><a href="http://www.litrin.net/2017/02/21/linux-4-10%E4%B8%ADcat%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">Linux 4.10中CAT的使用</a></li><li><a href="https://www.kernel.org/doc/Documentation/x86/intel_rdt_ui.txt" target="_blank" rel="noopener">intel_rdt_ui.txt</a></li><li><a href="https://github.com/intel/intel-cmt-cat" target="_blank" rel="noopener">intel-cmt-cat</a></li><li><a href="https://github.com/intel/intel-cmt-cat/wiki" target="_blank" rel="noopener">intel-cmt-cat wiki</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前沿&quot;&gt;&lt;a href=&quot;#前沿&quot; class=&quot;headerlink&quot; title=&quot;前沿&quot;&gt;&lt;/a&gt;前沿&lt;/h2&gt;&lt;p&gt;英特尔至强 E5-2600 v4在对外宣传时候号称“为云而生”的，除了其强大的性能和众多核心外，主要亮点就是Resource Directo
      
    
    </summary>
    
      <category term="计算机系统" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机系统" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CPU Cache</title>
    <link href="http://liujunming.github.io/2018/04/09/CPU-Cache/"/>
    <id>http://liujunming.github.io/2018/04/09/CPU-Cache/</id>
    <published>2018-04-09T06:49:44.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要转载自卢钧轶(cenalulu)<br>原文地址：<a href="http://cenalulu.github.io/linux/all-about-cpu-cache/" target="_blank" rel="noopener">http://cenalulu.github.io/linux/all-about-cpu-cache/</a></p><h2 id="为什么要有CPU-Cache"><a href="#为什么要有CPU-Cache" class="headerlink" title="为什么要有CPU Cache"></a>为什么要有CPU Cache</h2><p>随着工艺的提升最近几十年CPU的频率不断提升，而受制于制造工艺和成本限制，目前计算机的内存主要是DRAM并且在访问速度上没有质的突破。因此，CPU的处理速度和内存的访问速度差距越来越大，甚至可以达到上万倍。同时又由于内存数据访问的热点集中性，在CPU和内存之间用较为快速而成本较高的SDRAM做一层缓存，就显得性价比极高了。</p><h2 id="为什么要有多级CPU-Cache"><a href="#为什么要有多级CPU-Cache" class="headerlink" title="为什么要有多级CPU Cache"></a>为什么要有多级CPU Cache</h2><p>随着科技发展，热点数据的体积越来越大，单纯的增加一级缓存大小的性价比已经很低了。因此，就慢慢出现了在一级缓存(L1 Cache)和内存之间又增加一层访问速度和成本都介于两者之间的二级缓存(L2 Cache)。下面是一段从<a href="http://futuretech.blinkenlights.nl/misc/cpumemory.pdf" target="_blank" rel="noopener">What Every Programmer Should Know About Memory</a>中摘录的解释：</p><blockquote><p>Soon after the introduction of the cache the system got more complicated. The speed difference between the cache and the main memory increased again, to a point that another level of cache was added, bigger and slower than the first-level cache. Only increasing the size of the first-level cache was not an option for economical reasons.</p></blockquote><p>此外，又由于程序指令和程序数据的行为和热点分布差异很大，因此L1 Cache也被划分成L1i (i for instruction)和L1d (d for data)两种专门用途的缓存。 下面<a href="https://datatake.files.wordpress.com/2015/01/cpu-cache-access-in-cpu-cycles.png" target="_blank" rel="noopener">一张图</a>可以看出各级缓存之间的响应时间差距，以及内存到底有多慢！</p><p><img src="https://datatake.files.wordpress.com/2015/01/cpu-cache-access-in-cpu-cycles.png" alt=""></p><p>CPU包含多个核，每个核又有独自的一级缓存和二级缓存，各个核心之间共享三级缓存，并统一通过总线与内存进行交互。</p><p><img src="/images/2018/4/1.png" alt=""></p><h2 id="Cache-Line"><a href="#Cache-Line" class="headerlink" title="Cache Line"></a>Cache Line</h2><p>整个Cache被分成多个Line，每个Line通常是32byte或64byte。<br>Cache Line是Cache和内存交换数据的最小单位。</p><p><img src="/images/2018/4/2.png" alt=""></p><p>每个Cache Line包含三个部分:</p><ul><li>Valid：当前缓存是否有效</li><li>Tag：对应的内存地址</li><li>Block：缓存数据</li></ul><p><img src="/images/2018/4/3.png" alt=""></p><p><strong>了解Cache Line的概念对我们程序猿有什么帮助？</strong> 我们来看下面这个C语言中<a href="https://www.quora.com/What-are-some-things-that-programmers-know-but-not-computer-scientists/answer/Josh-Taylor-26?srid=XtLV&amp;share=1" target="_blank" rel="noopener">常用的循环优化</a>例子 下面两段代码中，第一段代码在C语言中总是比第二段代码的执行速度要快。具体的原因相信你仔细阅读了Cache Line的介绍后就很容易理解了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num;    </span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">        arr[i][j] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num;    </span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">        arr[j][i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CPU-Cache-是如何存放数据的"><a href="#CPU-Cache-是如何存放数据的" class="headerlink" title="CPU Cache 是如何存放数据的"></a>CPU Cache 是如何存放数据的</h2><p>假设我们有一块4MB的区域用于缓存，每个缓存对象的唯一标识是它所在的物理内存地址。每个缓存对象大小是64Bytes，所有可以被缓存对象的大小总和（即物理内存总大小）为4GB。那么我们该如何设计这个缓存？</p><h3 id="Fully-Associative-全关联映射"><a href="#Fully-Associative-全关联映射" class="headerlink" title="Fully Associative(全关联映射)"></a>Fully Associative(全关联映射)</h3><p>Fully Associative 字面意思是全关联。在CPU Cache中的含义是：如果在一个Cache集内，任何一个内存地址的数据可以被缓存在任何一个Cache Line里，那么我们成这个cache是Fully Associative。从定义中我们可以得出这样的结论：给到一个内存地址，要知道他是否存在于Cache中，需要遍历所有Cache Line并比较缓存内容的内存地址。而Cache的本意就是为了在尽可能少得CPU Cycle内取到数据。那么想要设计一个快速的Fully Associative的Cache几乎是不可能的。</p><p><img src="/images/2018/4/4.png" alt=""></p><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>和Fully Associative完全相反，使用Direct Mapped模式的Cache给定一个内存地址，就唯一确定了一条Cache Line。设计复杂度低且速度快。那么为什么Cache不使用这种模式呢？直接映射方式的缺点是不够灵活，因每个主存只能固定地对应某个缓存快，即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分的利用。此外，如果程序恰好重复要访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而降低命中率。</p><p><img src="/images/2018/4/5.png" alt=""></p><h3 id="组相连映射"><a href="#组相连映射" class="headerlink" title="组相连映射"></a>组相连映射</h3><p>为了避免以上两种设计模式的缺陷，N-Way Set Associative缓存就出现了。他的原理是把一个缓存按照N个Cache Line作为一组（set），缓存按组划为等分。这样一个64位系统的内存地址在4MB二级缓存中就划成了三个部分（见下图），低位6个bit表示在Cache Line中的偏移量，中间12bit表示Cache组号（set index），剩余的高位46bit就是内存地址的唯一id。这样的设计相较前两种设计有以下两点好处：(16路组相连)</p><ul><li>给定一个内存地址可以唯一对应一个set，对于set中只需遍历16个元素就可以确定对象是否在缓存中（Full Associative中比较次数随内存大小线性增加）</li><li>每2^18(512K)*64=32M的连续热点数据才会导致一个set内的conflict（Direct Mapped中512K的连续热点数据就会出现conflict）</li></ul><p><img src="/images/2018/4/6.png" alt=""></p><p><img src="/images/2018/4/7.png" alt=""></p><h2 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h2><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>随机确定要替换的块</p><h3 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h3><p>选择最先调入的块进行替换</p><h3 id="LRU（最近最少使用）"><a href="#LRU（最近最少使用）" class="headerlink" title="LRU（最近最少使用）"></a>LRU（最近最少使用）</h3><p>根据块的使用情况，选择最近最少使用的块进行替换，反映了程序的局部性规律</p><h2 id="写模式"><a href="#写模式" class="headerlink" title="写模式"></a>写模式</h2><h3 id="Write-through（直写模式）"><a href="#Write-through（直写模式）" class="headerlink" title="Write-through（直写模式）"></a>Write-through（直写模式）</h3><p>在数据更新时，同时写入缓存Cache和后端存储(如下一级cache或者内存)。此模式的优点是操作简单；缺点是因为数据修改需要同时写入存储，数据写入速度较慢。</p><h3 id="Write-back（回写模式）"><a href="#Write-back（回写模式）" class="headerlink" title="Write-back（回写模式）"></a>Write-back（回写模式）</h3><p>在数据更新时只写入缓存Cache。只在数据被替换出缓存时，被修改的缓存数据才会被写到后端存储。此模式的优点是数据写入速度快，因为不需要写存储；缺点是一旦更新后的数据未被写入存储时出现系统掉电的情况，数据将无法找回。</p><hr><p>参考资料:</p><ol><li><a href="http://cenalulu.github.io/linux/all-about-cpu-cache/" target="_blank" rel="noopener">关于CPU Cache – 程序猿需要知道的那些事</a></li><li><a href="https://www.jianshu.com/p/061a5d66ea20" target="_blank" rel="noopener">CPU Cache结构</a></li><li>《计算机组成原理》（第2版） 唐朔飞 编著</li><li><a href="http://witmax.cn/cache-writing-policies.html" target="_blank" rel="noopener">Cache写机制：Write-through与Write-back</a></li><li><a href="https://coolshell.cn/articles/10249.html" target="_blank" rel="noopener">7个示例科普CPU CACHE</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要转载自卢钧轶(cenalulu)&lt;br&gt;原文地址：&lt;a href=&quot;http://cenalulu.github.io/linux/all-about-cpu-cache/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cenalul
      
    
    </summary>
    
      <category term="计算机系统" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机系统" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Jeff Dean系统资料整理</title>
    <link href="http://liujunming.github.io/2018/04/09/Jeff-Dean%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    <id>http://liujunming.github.io/2018/04/09/Jeff-Dean系统资料整理/</id>
    <published>2018-04-09T06:47:30.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/22081653" target="_blank" rel="noopener">Jeff Dean的传说</a>。</p><ul><li><a href="https://scholar.google.com/citations?user=NMS69lQAAAAJ&amp;hl=zh-CN&amp;oi=ao" target="_blank" rel="noopener">Jeff Dean谷歌学术</a></li><li><a href="https://dblp.uni-trier.de/pers/hd/d/Dean:Jeffrey" target="_blank" rel="noopener">Jeff Dean dblp</a></li><li><p><a href="https://www.youtube.com/watch?v=modXC5IWTJI&amp;t=269s" target="_blank" rel="noopener">Building Software Systems At Google and Lessons Learned</a></p><p>Building Software Systems At Google and Lessons Learned为Jeff Dean 在Stanford大学做的一个非常精彩的演讲。<a href="http://www.slideshare.net/parallellabs/building-software-systems-at-google-and-lessons-learned" target="_blank" rel="noopener">slides</a></p></li><li><p><a href="https://gist.github.com/hellerbarde/2843375" target="_blank" rel="noopener">Latency numbers every programmer should know</a><br>需要记住的数字。最新:<a href="https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html" target="_blank" rel="noopener">Latency Numbers Every Programmer Should Know</a></p></li><li><p><a href="http://infolab.stanford.edu/infoseminar/archive/WinterY2013/dean.pdf" target="_blank" rel="noopener">Large-Scale Data and Computation: Challenges and Opportunities</a></p></li></ul><hr><p>参考资料：</p><ol><li><a href="https://coolshell.cn/articles/3301.html" target="_blank" rel="noopener">JEFF DEAN的STANFORD演讲</a></li><li><a href="http://www.parallellabs.com/2010/12/02/jeff-dean-on-google-system-architecture/" target="_blank" rel="noopener">Jeff Dean关于Google系统架构的讲座</a></li><li><a href="http://hedengcheng.com/?p=828#more-828" target="_blank" rel="noopener">何登成 2013年个人微博推荐技术资料汇总</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/22081653&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jeff Dean的传说&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://scholar.
      
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构:树的归纳总结</title>
    <link href="http://liujunming.github.io/2018/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%9A%84%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/"/>
    <id>http://liujunming.github.io/2018/03/20/数据结构-树的归纳总结/</id>
    <published>2018-03-20T10:59:03.000Z</published>
    <updated>2018-06-28T13:47:41.207Z</updated>
    
    <content type="html"><![CDATA[<p>最近，因为要准备找工作，所以本文特意总结归纳一下数据结构中重要的一块：树。</p><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树（BST：Binary Search Tree）是一种特殊的二叉树，它改善了二叉树节点查找的效率。二叉查找树有以下性质：</p><p>对于任意一个节点 n，</p><ul><li>其左子树（left subtree）下的每个后代节点（descendant node）的值都小于节点 n 的值；</li><li>其右子树（right subtree）下的每个后代节点的值都大于节点 n 的值。</li></ul><p>所谓节点 n 的子树，可以将其看作是以节点 n 为根节点的树。子树的所有节点都是节点 n 的后代，而子树的根则是节点 n 本身。</p><p>BST的查找、插入、删除操作的运行时间与BST的拓扑结构有关，最佳情况是O(log­ n)，而最坏情况是 O(n)。</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html" target="_blank" rel="noopener">AVL树</a>是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p><p>引入平衡二叉树的目的是为了提高二叉查找树的搜索的效率,减少树的平均搜索长度。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><a href="https://github.com/liujunming/Data-Structure/tree/master/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">红黑树</a>是一种自平衡二叉查找树，典型的用途是实现关联数组。</p><p>红黑树的性质:</p><ol><li>节点是红色或黑色</li><li>根是黑色</li><li>所有叶子都是黑色</li><li>每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</li></ol><p>红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，性能整体来说要优于AVL树。</p><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>在计算机科学中，<a href="http://liujunming.top/2016/07/12/Trie%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Trie</a>，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p><p><img src="/images/2018/3/6.png" alt=""></p><center>一个保存了8个键的trie结构，”A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, and “inn”.</center><h2 id="基数树-Radix-Tree"><a href="#基数树-Radix-Tree" class="headerlink" title="基数树(Radix Tree)"></a>基数树(Radix Tree)</h2><p>基数树，或称压缩前缀树，是一种更节省空间的Trie。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。</p><p><img src="/images/2018/3/7.png" alt=""></p><p>在Linux内核中，<a href="http://liujunming.top/2017/06/25/address-space-%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/" target="_blank" rel="noopener">一个address_space对象对应一个基树</a>。</p><h2 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h2><p>详情请从参考<a href="http://liujunming.top/2016/05/13/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">B树和B+树的定义以及应用</a>。</p><p>对于在内存中的查找结构而言，红黑树的效率已经非常好了。但是如果是数据量非常大的查找呢？将这些数据全部放入内存组织成红黑树结构显然是不实际的。实际上，像OS中的文件目录存储，数据库中的文件索引结构的存储…. 都不可能在内存中建立查找结构，必须在磁盘中建立好这个结构。那么在这个背景下，红黑树显然不是一种好的选择。</p><p>在磁盘中组织查找结构，从任何一个结点指向其他结点都有可能读取一次磁盘数据，再将数据写入内存进行比较。大家都知道，频繁的磁盘IO操作，效率是很低下的(机械运动比电子运动要慢不知道多少)。显而易见，所有的二叉树的查找结构在磁盘中都是低效的。因此，B树很好的解决了这一个问题。</p><hr><p>参考资料：</p><ol><li><a href="https://troywu0.gitbooks.io/spark/content/b-%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-avl%E6%A0%91-%E6%AF%94%E8%BE%83.html" target="_blank" rel="noopener">b-树-红黑树-二叉搜索树-avl树-比较</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近，因为要准备找工作，所以本文特意总结归纳一下数据结构中重要的一块：树。&lt;/p&gt;
&lt;h2 id=&quot;二叉查找树&quot;&gt;&lt;a href=&quot;#二叉查找树&quot; class=&quot;headerlink&quot; title=&quot;二叉查找树&quot;&gt;&lt;/a&gt;二叉查找树&lt;/h2&gt;&lt;p&gt;二叉查找树（BST：Bin
      
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
