<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2021-09-11T10:23:43.034Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notes about kernel compile and config</title>
    <link href="http://liujunming.github.io/2021/09/11/Notes-about-kernel-compile/"/>
    <id>http://liujunming.github.io/2021/09/11/Notes-about-kernel-compile/</id>
    <published>2021-09-11T02:40:20.000Z</published>
    <updated>2021-09-11T10:23:43.034Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录内核编译配置的相关内容。<a id="more"></a></p><h3 id="proc-config-gz"><a href="#proc-config-gz" class="headerlink" title="/proc/config.gz"></a>/proc/config.gz</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat /proc/config.gz</span><br></pre></td></tr></table></figure><p>Linux 可以在内核本身存储用于内核构建的 gzip 内核配置文件副本，并通过 /proc/config.gz 提供给用户。也就是说，/proc/config.gz 就是当前的 Linux 内核配置文件，并且是用 gzip 格式压缩过的。</p><p>但不是所有的 Linux 发行版都有 /proc/config.gz 文件，大部分常见的 Linux 发行版就没有提供，比如 Ubuntu。只有当内核配置 <code>CONFIG_IKCONFIG</code> 和 <code>CONFIG_IKCONFIG_PROC</code> 为<code>y</code>，才会在 /proc 中出现 config.gz 文件。当然，即使大多数发行版没有提供 /proc/config.gz，仍然可以通过 /boot 查看内核配置信息。</p><h3 id="boot-内核配置信息"><a href="#boot-内核配置信息" class="headerlink" title="/boot 内核配置信息"></a>/boot 内核配置信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /boot/config-5.4.0-80-generic</span><br><span class="line"></span><br><span class="line">cat /boot/config-$(uname -r)</span><br></pre></td></tr></table></figure><h3 id="make-oldconfig"><a href="#make-oldconfig" class="headerlink" title="make oldconfig"></a>make oldconfig</h3><p>It reads the existing <code>.config</code> file that was used for an old kernel and prompts the user for options in the current kernel source that are not found in the file. This is useful when taking an existing configuration and moving it to a new kernel.</p><p>使用其他 (通常是较旧的) 内核版本的 <code>.config</code> 文件时，需要先更新它。可以使用 <code>make oldconfig</code> 命令，以交互方式询问对新配置的选择。</p><p><code>make olddefconfig</code> 的含义为：采用已有的<code>.config</code>文件的参数作为默认参数，同时升级依赖属性，新属性设置为默认值不再提醒。</p><h3 id="mkinitramfs"><a href="#mkinitramfs" class="headerlink" title="mkinitramfs"></a>mkinitramfs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkinitramfs -o /boot/initrd.img 2.6.24-16</span><br><span class="line"></span><br><span class="line">mkinitramfs -o &lt;full_path_to_initrd&gt; &lt;kernel_version&gt;</span><br></pre></td></tr></table></figure><p>Note: 2.6.24-16是需要创建initramfs的kernel版本号，如果是给当前kernel制作initramfs，可以用<code>uname -r</code>查看当前的版本号。提供kernel版本号的主要目的是为了在initramfs中添加指定kernel的驱动模块。<code>mkinitramfs</code>会把<code>/lib/modules/${kernel_version}/</code>目录下的一些启动会用到的模块添加到initramfs中。</p><h3 id="load-a-module-in-initrd"><a href="#load-a-module-in-initrd" class="headerlink" title="load a module in initrd"></a>load a module in initrd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/initramfs-tools/modules</span><br><span class="line"># List of modules that you want to include in your initramfs.</span><br><span class="line"># They will be loaded at boot time in the order below.</span><br><span class="line">#</span><br><span class="line"># Syntax:  module_name [args ...]</span><br><span class="line">#</span><br><span class="line"># You must run update-initramfs(8) to effect this change.</span><br><span class="line">#</span><br><span class="line"># Examples:</span><br><span class="line">#</span><br><span class="line"># raid1</span><br><span class="line"># sd_mod</span><br></pre></td></tr></table></figure><p>Add the names of the modules to <code>/etc/initramfs-tools/modules</code> . This added the modules to the initrd file. Update the initrd file by  <code>update-initramfs -u</code> </p><p><code>update-initramfs -u</code>更新当前kernel的initramfs。在添加模块时，initramfs tools只会添加一些必要模块，用户可以通过在<code>/etc/initramfs-tools/modules</code>文件中加入模块名称来指定必须添加的模块。</p><h3 id="INSTALL-MOD-PATH"><a href="#INSTALL-MOD-PATH" class="headerlink" title="INSTALL_MOD_PATH"></a>INSTALL_MOD_PATH</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make modules_install INSTALL_MOD_PATH=out/</span><br></pre></td></tr></table></figure><p>The <code>INSTALL_MOD_PATH</code> variable is needed to install the modules in the target root filesystem instead of your host root filesystem.</p><h3 id="Linux-内核编译-LOCALVERSION-配置"><a href="#Linux-内核编译-LOCALVERSION-配置" class="headerlink" title="Linux 内核编译 LOCALVERSION 配置"></a>Linux 内核编译 LOCALVERSION 配置</h3><ul><li><p><code>LOCALVERSION</code> 可以在版本号之后追加后缀信息, 如果再定义 <code>CONFIG_LOCALVERSION_AUTO</code>, 将在最后进一步追加 <code>git</code> 版本号为后缀信息.</p></li><li><p>不定义<code>CONFIG_LOCALVERSION_AUTO</code> 将不显示 <code>git</code> 仓库信息, 如果此时 <code>LOCALVERSION</code> 变量也未定义, 将追加 “+”.</p></li><li><p>如果既不想添加后缀, 又不想有 <code>&quot;+&quot;</code> 号 : 不定义<code>CONFIG_LOCALVERSION_AUTO</code>, 将 <code>LOCALVERSION</code> 变量定义为空 : <code>LOCALVERSION=</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8 bindeb-pkg LOCALVERSION=</span><br></pre></td></tr></table></figure></li></ul><hr><p>参考资料:</p><ol><li><a href="https://www.cnblogs.com/liuyawei/p/4024614.html" target="_blank" rel="noopener">Linux内核编译和替换小结</a></li><li><a href="https://blog.csdn.net/lu_embedded/article/details/108908577" target="_blank" rel="noopener">/proc/config.gz 是什么</a> </li><li><a href="https://stackoverflow.com/questions/4178526/what-does-make-oldconfig-do-exactly-in-the-linux-kernel-makefile" target="_blank" rel="noopener">What does “make oldconfig” do exactly in the Linux kernel makefile?</a></li><li><a href="https://askubuntu.com/questions/676707/how-to-load-a-module-in-initrd" target="_blank" rel="noopener">How to load a module in initrd?</a></li><li><a href="https://www.cnblogs.com/wwang/archive/2010/10/27/1862222.html" target="_blank" rel="noopener">制作initramfs/initrd镜像</a></li><li><a href="https://github.com/gatieme/LDD-LinuxDeviceDrivers/tree/master/study/problem/build/local_version" target="_blank" rel="noopener">Linux 内核编译 LOCALVERSION 配置(分析内核版本号自动添加的”+”号)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录内核编译配置的相关内容。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>深入理解FLR</title>
    <link href="http://liujunming.github.io/2021/09/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3FLR/"/>
    <id>http://liujunming.github.io/2021/09/11/深入理解FLR/</id>
    <published>2021-09-11T00:21:12.000Z</published>
    <updated>2021-09-11T09:36:04.131Z</updated>
    
    <content type="html"><![CDATA[<p>本文将结合spec与kernel代码来介绍FLR。<a id="more"></a><br>FLR主要针对的是支持多个功能的PCIe设备（Multi-Fun PCIe Device），可以实现只对特定的Function复位，而其他的Function不受影响。</p><h3 id="check-FLR-capability"><a href="#check-FLR-capability" class="headerlink" title="check FLR capability"></a>check FLR capability</h3><p><img src="/images/2021/09/3.PNG" alt><br><img src="/images/2021/09/4.PNG" alt></p><p><a href="https://elixir.bootlin.com/linux/v5.10.63/source/drivers/pci/pci.c#L4556" target="_blank" rel="noopener">pcie_has_flr</a></p><h3 id="initiate-a-PCIe-function-level-reset"><a href="#initiate-a-PCIe-function-level-reset" class="headerlink" title="initiate a PCIe function level reset"></a>initiate a PCIe function level reset</h3><p><img src="/images/2021/09/5.PNG" alt><br><img src="/images/2021/09/6.PNG" alt></p><p><a href="https://elixir.bootlin.com/linux/v5.10.63/source/drivers/pci/pci.c#L4576" target="_blank" rel="noopener">pcie_flr</a></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -vvvxxx -s 00:02.0</span><br></pre></td></tr></table></figure><p><img src="/images/2021/09/2.PNG" alt></p><hr><p>参考资料:</p><ol><li><a href="http://blog.chinaaet.com/justlxy/p/5100057845" target="_blank" rel="noopener">PCIe扫盲——复位机制介绍(FLR)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将结合spec与kernel代码来介绍FLR。
    
    </summary>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/categories/PCI-PCIe/"/>
    
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
  </entry>
  
  <entry>
    <title>Summary of PCI&amp;PCIe device function reset</title>
    <link href="http://liujunming.github.io/2021/09/10/Summary-of-PCI-device-reset/"/>
    <id>http://liujunming.github.io/2021/09/10/Summary-of-PCI-device-reset/</id>
    <published>2021-09-10T10:20:31.000Z</published>
    <updated>2021-09-11T01:17:51.344Z</updated>
    
    <content type="html"><![CDATA[<p>本文将总结PCI&amp;PCIe device function reset的相关内容。<br><a id="more"></a></p><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><p>当pass-thru device时，需要reset device function。<a href="https://elixir.bootlin.com/linux/v5.10.63/source/drivers/vfio/pci/vfio_pci.c#L329" target="_blank" rel="noopener">code</a></p><p>内核中，reset a PCI device function的函数是<a href="https://elixir.bootlin.com/linux/v5.10.63/source/drivers/pci/pci.c#L5050" target="_blank" rel="noopener">__pci_reset_function_locked</a>，如有兴趣，可以深入研究。</p><h3 id="2-Spec"><a href="#2-Spec" class="headerlink" title="2. Spec"></a>2. Spec</h3><p><img src="/images/2021/09/1.PNG" alt></p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>There are two main types of resets - conventional reset, and function-level reset. There are also two types of conventional resets, fundamental resets and non-fundamental resets. </p><h4 id="3-1-conventional-reset"><a href="#3-1-conventional-reset" class="headerlink" title="3.1 conventional reset"></a>3.1 conventional reset</h4><h5 id="3-1-1-cold-reset"><a href="#3-1-1-cold-reset" class="headerlink" title="3.1.1 cold reset"></a>3.1.1 cold reset</h5><p>A cold reset is a fundamental reset that takes place after power is applied to a PCIe device.<br>因为主电源断开后重新连接导致的复位。</p><h5 id="3-1-2-warm-reset"><a href="#3-1-2-warm-reset" class="headerlink" title="3.1.2 warm reset"></a>3.1.2 warm reset</h5><p>A warm reset is a fundamental reset that is triggered without disconnecting power from the device.<br>在不关闭主电源的情况下，产生的复位。</p><h5 id="3-1-3-hot-reset"><a href="#3-1-3-hot-reset" class="headerlink" title="3.1.3 hot reset"></a>3.1.3 hot reset</h5><p>A hot reset is a conventional reset that is triggered across a PCI express link. A hot reset is triggered either when a link is forced into electrical idle or by sending TS1 and TS2 ordered sets with the hot reset bit set. Software can initiate a hot reset by setting and then clearing the <strong>secondary bus reset</strong> bit in the bridge control register in the PCI configuration space of the bridge port upstream of the device.</p><h4 id="3-2-function-level-reset"><a href="#3-2-function-level-reset" class="headerlink" title="3.2 function-level reset"></a>3.2 function-level reset</h4><p>A function-level reset (FLR) is a reset that affects only a single function of a PCI express device. It must not reset the entire PCIe device. Implementing function-level resets is not required by the PCIe specification. A function-level reset is initiated by setting the initiate function-level reset bit in the function’s device control register in the PCI express capability structure in the PCI configuration space.<br>当PCIe设备使用FLR方式进行复位时，有些与PCIe链路相关的状态和寄存器并不会被复位；还有一些特殊的配置寄存器不能被FLR方式复位，如Max_Payload_Size、RCB和一些与电源管理、流量控制和链路控制直接相关的寄存器。</p><h3 id="4-sysfs-interface"><a href="#4-sysfs-interface" class="headerlink" title="4. sysfs interface"></a>4. sysfs interface</h3><p><a href="https://elixir.bootlin.com/linux/v5.10.63/source/Documentation/ABI/testing/sysfs-bus-pci#L124" target="_blank" rel="noopener">/sys/bus/pci/devices/…/reset</a></p><p><a href="https://elixir.bootlin.com/linux/v5.10.63/source/drivers/pci/pci-sysfs.c#L1312" target="_blank" rel="noopener">reset_store</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reset_store</span><br><span class="line">pci_reset_function</span><br><span class="line">__pci_reset_function_locked</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><a href="http://blog.chinaaet.com/justlxy/p/5100057844" target="_blank" rel="noopener">PCIe扫盲——复位机制介绍</a></li><li><a href="https://unix.stackexchange.com/questions/73908/how-to-reset-cycle-power-to-a-pcie-device" target="_blank" rel="noopener">How to Reset/Cycle Power to a PCIe Device?</a></li><li><a href="https://www.pinlue.com/article/2020/03/2519/4210053341853.html" target="_blank" rel="noopener">PCIe总线的两种复位方式</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将总结PCI&amp;amp;PCIe device function reset的相关内容。&lt;br&gt;
    
    </summary>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/categories/PCI-PCIe/"/>
    
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
  </entry>
  
  <entry>
    <title>Notes about guest memory pinning when direct assignment of I/O devices</title>
    <link href="http://liujunming.github.io/2021/07/29/Notes-about-guest-memory-pinning-when-direct-assignment-of-I-0-devices/"/>
    <id>http://liujunming.github.io/2021/07/29/Notes-about-guest-memory-pinning-when-direct-assignment-of-I-0-devices/</id>
    <published>2021-07-29T11:36:36.000Z</published>
    <updated>2021-07-29T13:56:48.075Z</updated>
    
    <content type="html"><![CDATA[<p>当pass-thru device时，Hypervisor会建立dma remapping，但是存在一个问题就是:it requires the hypervisor to statically pin the entire guest memory.<a id="more"></a> 原因如下:</p><p><img src="/images/2021/07/24.PNG" alt><br>[ATC’11 vIOMMU: Efficient IOMMU Emulation]</p><p><img src="/images/2021/07/22.PNG" alt></p><p><img src="/images/2021/07/23.PNG" alt><br><a href="http://awilliam.github.io/presentations/KVM-Forum-2016/#/2/19" target="_blank" rel="noopener">http://awilliam.github.io/presentations/KVM-Forum-2016/#/2/19</a></p><p><img src="/images/2021/07/25.PNG" alt></p><p>优化的工作有:</p><ol><li>ATC’11 vIOMMU: Efficient IOMMU Emulation</li><li>ATC’20 coIOMMU: A Virtual IOMMU with Cooperative DMA Buffer Tracking for Efficient Memory Management in Direct I/O</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当pass-thru device时，Hypervisor会建立dma remapping，但是存在一个问题就是:it requires the hypervisor to statically pin the entire guest memory.
    
    </summary>
    
      <category term="VT-d" scheme="http://liujunming.github.io/categories/VT-d/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Intel VMCS Shadowing technology</title>
    <link href="http://liujunming.github.io/2021/07/22/Introduction-to-Intel-VMCS-Shadowing-technology/"/>
    <id>http://liujunming.github.io/2021/07/22/Introduction-to-Intel-VMCS-Shadowing-technology/</id>
    <published>2021-07-22T01:46:58.000Z</published>
    <updated>2021-07-22T12:47:52.756Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2021/07/21/Introduction-to-nested-virtualization/">Introduction to nested virtualization</a>一文介绍了嵌套虚拟化的基本概念。本文介绍的Intel VMCS Shadowing technology这一硬件技术，正是为了提高嵌套虚拟化系统的性能而应运而生的。<a id="more"></a></p><h3 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h3><p>The motivation of VMCS Shadowing: Eliminate VM Exits on guest VMCS accesses</p><p><img src="/images/2021/07/19.PNG" alt></p><p><img src="/images/2021/07/20.PNG" alt></p><p><img src="/images/2021/07/21.PNG" alt></p><h3 id="2-implementation"><a href="#2-implementation" class="headerlink" title="2. implementation"></a>2. implementation</h3><ul><li>Shadow VMCS is processor-dependent and must be accessed by L0 or L1 using VMREAD and VMWRITE instructions only</li><li>To avoid hardware dependencies:<ul><li>Software defined VMCS1→2 format is part of L1 address space</li><li>Processor-specific shadow VMCS format is part of L0 address space</li></ul></li><li>L0 synchronize the shadow VMCS content with the software-controlled VMCS1→2 format</li><li>Design simplifies live migration of L1, which does not depended on the shadow VMCS layout</li></ul><h3 id="3-sync-process"><a href="#3-sync-process" class="headerlink" title="3. sync process"></a>3. sync process</h3><ul><li>Before running L2 after switching from L1 we need to update all the changes L1 did, from the shadow VMCS to VMCS1→2</li><li>Before switching back to L1 after running L2 we need to sync from VMCS1→2 to the shadow VMCS</li></ul><h3 id="4-reducing-syncing-cost"><a href="#4-reducing-syncing-cost" class="headerlink" title="4. reducing syncing cost"></a>4. reducing syncing cost</h3><p>When Intel VMCS shadowing is used, the L0 VMM has no idea which of the more than 130 VMCS fields were accessed, since it was not involved in those accessed. The L0 VMM must therefore synchronize every filed that could have possibly been accessed, even though most of the fields are never touched.</p><p>Results from Intel Labs profiling across a wide variety of VMMs, show that approximately 90% of VMCS fields are never read and more than 95% percent are never written. As a result, for most VMMs, a full VMCS synchronization can take approximately 15 times longer than necessary.</p><p><strong>Idea: Shadow only the necessary fields</strong></p><p>To reduce this synchronization overhead, Intel incorporated an addtional feature into Intel VMCS Shadowing called VMREAD and VMWRITE bitmaps. These bitmaps allow for selective access to the shadow VMCS. The L0 VMM can tune the bitmaps so that the 5-10 percent of VMCS fields that are commonly accessed are written directly to the shadow VMCS, while the very rarely accessed fields are synchronized through the slower path that is managed by the L0 VMM.</p><p>By using the VMREAD/VMWRITE bitmaps, the L0 VMM gets the best of both worlds. Nearly all of the accesses go directly to the fast shadow VMCS and very few extraneous fields need to be synchronized. </p><hr><p>参考资料:</p><ol><li><a href="https://events.static.linuxfound.org/sites/events/files/cojp13_nakajima.pdf" target="_blank" rel="noopener">Making Nested Virtualization Real by Using Hardware Virtualization Features</a></li><li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/intel-vmcs-shadowing-paper.pdf" target="_blank" rel="noopener">intel-vmcs-shadowing-paper</a></li><li><a href="https://events19.linuxfoundation.org/wp-content/uploads/2017/12/Improving-KVM-x86-Nested-Virtualization-Liran-Alon-Oracle.pdf" target="_blank" rel="noopener">Improving-KVM-x86-Nested-Virtualization-Liran-Alon-Oracle</a></li><li><a href="https://docs.google.com/file/d/0BzyAwvVlQckeMTd2T2RBT2cweDg/edit?resourcekey=0-FfuT4IueJf7OFC4KmykJdA" target="_blank" rel="noopener">KVM forum 2013 Nested virtualization:shadow turtles</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2021/07/21/Introduction-to-nested-virtualization/&quot;&gt;Introduction to nested virtualization&lt;/a&gt;一文介绍了嵌套虚拟化的基本概念。本文介绍的Intel VMCS Shadowing technology这一硬件技术，正是为了提高嵌套虚拟化系统的性能而应运而生的。
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="嵌套虚拟化" scheme="http://liujunming.github.io/tags/%E5%B5%8C%E5%A5%97%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to nested virtualization</title>
    <link href="http://liujunming.github.io/2021/07/21/Introduction-to-nested-virtualization/"/>
    <id>http://liujunming.github.io/2021/07/21/Introduction-to-nested-virtualization/</id>
    <published>2021-07-21T11:20:41.000Z</published>
    <updated>2021-07-22T12:47:52.757Z</updated>
    
    <content type="html"><![CDATA[<p>一直听闻嵌套虚拟化这一技术，但是从未深入研究过其底层原理。借此机会，本文将一探嵌套虚拟化。</p><p>嵌套虚拟化的绝佳入门材料为ODSI’10上的论文<a href="https://www.usenix.org/conference/osdi10/turtles-project-design-and-implementation-nested-virtualization" target="_blank" rel="noopener">The Turtles Project: Design and Implementation of Nested Virtualization</a>。本文内容主要是<a href="https://www.usenix.org/legacy/events/osdi10/tech/full_papers/Ben-Yehuda.pdf" target="_blank" rel="noopener">paper</a>和<a href="https://www.usenix.org/legacy/events/osdi10/tech/slides/ben-yehuda.pdf" target="_blank" rel="noopener">slides</a>的notes。<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>In nested virtualization, a hypervisor can run multiple other hypervisors with their associated virtual machines. 通俗地来说，套娃。</p><p>接下来将从CPU虚拟化，内存虚拟化，IO虚拟化这三个方面去介绍嵌套虚拟化的原理。</p><h3 id="2-CPU-Nested-VMX-Virtualization"><a href="#2-CPU-Nested-VMX-Virtualization" class="headerlink" title="2. CPU: Nested VMX Virtualization"></a>2. CPU: Nested VMX Virtualization</h3><p>Approach for nested virtualization <em>multiplexes</em> multiple levels of virtualization (multiple hypervisors) on the single level of architectural support available. </p><p><img src="/images/2021/07/3.PNG" alt></p><p><img src="/images/2021/07/4.PNG" alt></p><p><img src="/images/2021/07/5.PNG" alt></p><p><img src="/images/2021/07/6.PNG" alt></p><p><img src="/images/2021/07/7.PNG" alt></p><h4 id="2-1-VMX-Trap-and-Emulate"><a href="#2-1-VMX-Trap-and-Emulate" class="headerlink" title="2.1 VMX Trap and Emulate"></a>2.1 VMX Trap and Emulate</h4><p><img src="/images/2021/07/15.PNG" alt></p><h4 id="2-2-VMCS-Shadowing"><a href="#2-2-VMCS-Shadowing" class="headerlink" title="2.2 VMCS Shadowing"></a>2.2 VMCS Shadowing</h4><p><img src="/images/2021/07/16.PNG" alt></p><p><img src="/images/2021/07/17.PNG" alt></p><h4 id="2-3-VMEntry-and-VMExit-Emulation"><a href="#2-3-VMEntry-and-VMExit-Emulation" class="headerlink" title="2.3 VMEntry and VMExit Emulation"></a>2.3 VMEntry and VMExit Emulation</h4><p><img src="/images/2021/07/18.PNG" alt></p><h4 id="2-4-summary"><a href="#2-4-summary" class="headerlink" title="2.4 summary"></a>2.4 summary</h4><p><img src="/images/2021/07/8.PNG" alt></p><p><img src="/images/2021/07/9.PNG" alt></p><h3 id="3-MMU-Multi-dimensional-Paging"><a href="#3-MMU-Multi-dimensional-Paging" class="headerlink" title="3. MMU: Multi-dimensional Paging"></a>3. MMU: Multi-dimensional Paging</h3><p><img src="/images/2021/07/10.PNG" alt></p><p><img src="/images/2021/07/11.PNG" alt></p><p><img src="/images/2021/07/12.PNG" alt></p><h3 id="4-I-O-Multi-level-Device-Assignment"><a href="#4-I-O-Multi-level-Device-Assignment" class="headerlink" title="4. I/O: Multi-level Device Assignment"></a>4. I/O: Multi-level Device Assignment</h3><p><img src="/images/2021/07/13.PNG" alt></p><p><img src="/images/2021/07/14.PNG" alt></p><h3 id="5-Summary"><a href="#5-Summary" class="headerlink" title="5. Summary"></a>5. Summary</h3><ol><li><p>Approach for CPU virtualization works by having the lowest hypervisor inspect the trap and forward it to the hypervisors above it for emulation.  </p></li><li><p>For efficient memory virtualization, we developed multi-dimensional paging, which collapses the different memory translation tables into the one or two tables provided by the MMU.</p></li><li><p>For efficient I/O virtualization, we bypass multiple levels of hypervisor I/O stacks to provide nested guests with direct assignment of I/O devices via multilevel device assignment. </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直听闻嵌套虚拟化这一技术，但是从未深入研究过其底层原理。借此机会，本文将一探嵌套虚拟化。&lt;/p&gt;
&lt;p&gt;嵌套虚拟化的绝佳入门材料为ODSI’10上的论文&lt;a href=&quot;https://www.usenix.org/conference/osdi10/turtles-project-design-and-implementation-nested-virtualization&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Turtles Project: Design and Implementation of Nested Virtualization&lt;/a&gt;。本文内容主要是&lt;a href=&quot;https://www.usenix.org/legacy/events/osdi10/tech/full_papers/Ben-Yehuda.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;paper&lt;/a&gt;和&lt;a href=&quot;https://www.usenix.org/legacy/events/osdi10/tech/slides/ben-yehuda.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;slides&lt;/a&gt;的notes。
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="嵌套虚拟化" scheme="http://liujunming.github.io/tags/%E5%B5%8C%E5%A5%97%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Notes about PCI Express Configuration Space</title>
    <link href="http://liujunming.github.io/2021/07/02/Notes-about-extended-PCIE-configuration-space/"/>
    <id>http://liujunming.github.io/2021/07/02/Notes-about-extended-PCIE-configuration-space/</id>
    <published>2021-07-02T08:12:43.000Z</published>
    <updated>2021-07-02T14:48:47.135Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录PCI Express Configuration Space相关笔记。<a id="more"></a></p><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><blockquote><p><strong>The PCI Express bus extends the Configuration Space from 256 bytes to 4096 bytes</strong>. This extended configuration space <em>cannot</em> be accessed using the legacy PCI method (through ports 0xCF8 and 0xCFC).</p></blockquote><p>In the beginning there was a configuration space, for each PCI device function, of 256 bytes.<br>This space was accessed using the PCI legacy mechanism (we can ignore the fact there were two mechanisms) at ports 0xcf8 and 0xcfc.</p><p>The PCIe extended this space from 256 bytes to 4KiB and introduced a new mechanism to access the configuration space (<em>all</em> of it).</p><p>So, to recap:</p><ul><li>There is a single PCI configuration space of 4KiB. It is divided into a <em>PCI 3.0 Compatible region</em> (from 0x000 to 0x0ff) and PCIe extended configuration region (from 0x100 to 0xfff).</li><li>There are two mechanism to access the PCI configuration space. One is the legacy mechanism at 0xcf8/0xcfc the other one is a memory mapped area.</li><li>The Legacy mechanism can only access the compatibility region (the first 256 bytes).</li><li>The ECAM can access all of the space.</li></ul><h3 id="2-ECAM"><a href="#2-ECAM" class="headerlink" title="2. ECAM"></a>2. ECAM</h3><p>Enhanced Configuration Access Mechanism (ECAM)</p><blockquote><p>PCI Express extends the Configuration Space to 4096 bytes per Function as compared to 256 bytes allowed by PCI Local Bus Specification.</p><p>PCI Express Configuration Space is divided into a PCI 3.0 compatible region, which consists of the first 256 bytes of a Function’s Configuration Space, and a PCI Express Extended Configuration Space which consists of the remaining Configuration Space .</p><p>The PCI 3.0 compatible Configuration Space can be accessed using either the mechanism defined in the PCI Local Bus Specification or the PCI Express Enhanced Configuration Access Mechanism (ECAM).</p><p><strong>Accesses made using either access mechanism are equivalent. The PCI Express Extended Configuration Space can only be accessed by using the ECAM.</strong></p></blockquote><p>The base address of the MMIO area for the configuration space of each PCIe devices in a PCI segment group is given in the <a href="https://wiki.osdev.org/PCI_Express#Enhanced_Configuration_Mechanism" target="_blank" rel="noopener">ACPI table MCFG</a>.</p><p>The MCFG table lists, for each PCI segment group, the first and last (inclusive) bus number of the PCI segment group and the base address of the PCI Express enhanced configuration space.</p><p>The MCFG table is setup by the BIOS/UEFI based upon the value of the <code>PCIEXBAR</code> (offset 60h) in the Host Bridge PCI configuration space.</p><h3 id="3-Verification"><a href="#3-Verification" class="headerlink" title="3. Verification"></a>3. Verification</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ lspci -xxx -s 00:0.0</span><br><span class="line">00:00.0 Host bridge: Intel Corporation Xeon E3-1200 v6/7th Gen Core Processor Host Bridge/DRAM Registers (rev 02)</span><br><span class="line">00: 86 80 04 59 06 00 90 20 02 00 00 06 00 00 00 00</span><br><span class="line">10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">20: 00 00 00 00 00 00 00 00 00 00 00 00 86 80 70 20</span><br><span class="line">30: 00 00 00 00 e0 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">40: 01 90 d1 fe 00 00 00 00 01 00 d1 fe 00 00 00 00</span><br><span class="line">50: c1 02 00 00 31 80 00 00 47 00 f0 8f 01 00 00 8b</span><br><span class="line">60: 01 00 00 e0 00 00 00 00 01 80 d1 fe 00 00 00 00</span><br><span class="line">70: 00 00 00 fe 01 00 00 00 00 0c 00 fe 7f 00 00 00</span><br><span class="line">80: 11 00 00 00 00 00 00 00 1a 00 00 00 00 00 00 00</span><br><span class="line">90: 01 00 00 fe 01 00 00 00 01 00 f0 6d 02 00 00 00</span><br><span class="line">a0: 01 00 00 00 02 00 00 00 01 00 00 6e 02 00 00 00</span><br><span class="line">b0: 01 00 00 8c 01 00 80 8b 01 00 00 8b 01 00 00 90</span><br><span class="line">c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">e0: 09 00 10 01 21 60 61 7a dc 80 15 14 00 c0 06 00</span><br><span class="line">f0: 00 00 00 00 c8 0f 09 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p><img src="/images/2021/07/1.PNG" alt><br><img src="/images/2021/07/2.PNG" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/iomem | grep MMCONFIG</span><br><span class="line">e0000000-efffffff : PCI MMCONFIG 0000 [bus 00-ff]</span><br><span class="line"></span><br><span class="line">$ dmesg | grep -i MCFG</span><br><span class="line">[    0.011632] ACPI: MCFG 0x000000008A5D0060 00003C (v01 INTEL  NUC7i5DN 00000043 MSFT 00000097)</span><br><span class="line"></span><br><span class="line">$ dmesg | grep -i MMCONFIG</span><br><span class="line">[    0.149772] PCI: MMCONFIG for domain 0000 [bus 00-ff] at [mem 0xe0000000-0xefffffff] (base 0xe0000000)</span><br><span class="line">[    0.149772] PCI: MMCONFIG at [mem 0xe0000000-0xefffffff] reserved in E820</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://stackoverflow.com/questions/57457283/how-to-access-pcie-configuration-space-ecam" target="_blank" rel="noopener">How to access PCIe configuration space?</a></li><li><a href="https://stackoverflow.com/questions/52136259/how-to-access-pci-express-configuration-space-via-mmio" target="_blank" rel="noopener">How to access pci express configuration space via MMIO?</a></li><li><a href="https://stackoverflow.com/questions/6341540/how-to-read-extended-pcie-configuration-space-in-linux" target="_blank" rel="noopener">How to read extended PCIE configuration space in Linux?</a></li><li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/datasheets/10th-gen-core-families-datasheet-vol-2-datasheet.pdf" target="_blank" rel="noopener">10th gen core families datasheet vol 2 datasheet</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录PCI Express Configuration Space相关笔记。
    
    </summary>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/categories/PCI-PCIe/"/>
    
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
  </entry>
  
  <entry>
    <title>Notes about EFI Shell</title>
    <link href="http://liujunming.github.io/2021/07/01/Notes-about-EFI-Shell/"/>
    <id>http://liujunming.github.io/2021/07/01/Notes-about-EFI-Shell/</id>
    <published>2021-07-01T01:54:26.000Z</published>
    <updated>2021-07-01T10:11:28.349Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录EFI Shell相关的materials与常用的一些指令。<a id="more"></a></p><h3 id="1-materials"><a href="#1-materials" class="headerlink" title="1. materials"></a>1. materials</h3><p><a href="https://docstore.mik.ua/manuals/hp-ux/en/5991-1247B/ch04s13.html" target="_blank" rel="noopener">Command Reference for EFI Shell Commands</a><br><a href="https://manuais.iessanclemente.net/images/a/a6/EFI-ShellCommandManual.pdf" target="_blank" rel="noopener">Shell Command Reference Manual</a><br><a href="https://www.intel.com/content/dam/support/us/en/documents/motherboards/server/sb/efi_instructions.pdf" target="_blank" rel="noopener">Basic Instructions for Using the Extensible Firmware Interface</a><br><a href="https://kb.stonegroup.co.uk/index.php?View=entry&amp;EntryID=84" target="_blank" rel="noopener">How to Access the EFI Shell to carry out Systems Diagnostics or Updates</a></p><h3 id="2-常用指令"><a href="#2-常用指令" class="headerlink" title="2. 常用指令"></a>2. 常用指令</h3><p>EFI commands are very similar to common DOS and Linux commands. The most frequently<br>used commands include: </p><ul><li><code>ls</code> (or <code>dir</code>): Lists the directory contents.</li><li><code>cd</code>: Changes the directory.</li><li><code>cp</code>: Copies one or more files/directories to another location.</li><li><code>move</code>: Moves one or more files/directories to the destination.</li><li><code>rm</code>: Deletes one or more files or directories.</li><li><code>map</code>: Displays, resets, or deletes mappings with the verbose option.</li><li><code>map –r</code>: Commonly used to refresh mapped drives.</li><li><code>edit</code>: Starts a basic text editor with on-screen function key help.</li><li><code>set</code>: Displays (set), creates (set sname value), deletes (set –d), or changes EFI environment variables.</li><li><code>cls</code>: Clears the screen and can also change the background color.</li><li><code>echo</code>: Displays results on the screen.</li><li><code>help</code>: Displays help information.</li><li><code>exit</code>: Leaves the EFI shell and returns to the BIOS utility.</li><li><code>reset</code>: Resets the system with a warm reboot or complete shutdown. </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drivers –b</span><br></pre></td></tr></table></figure><p>“-b” option for any UEFI command is a screen “pause” option so that you do not miss what you are trying to find because of it scrolling by.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录EFI Shell相关的materials与常用的一些指令。
    
    </summary>
    
      <category term="Firmware" scheme="http://liujunming.github.io/categories/Firmware/"/>
    
    
      <category term="Firmware" scheme="http://liujunming.github.io/tags/Firmware/"/>
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>PCI Expansion ROM</title>
    <link href="http://liujunming.github.io/2021/06/30/PCI-Expansion-ROM/"/>
    <id>http://liujunming.github.io/2021/06/30/PCI-Expansion-ROM/</id>
    <published>2021-06-30T07:01:55.000Z</published>
    <updated>2021-09-10T11:09:27.597Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍PCI Expansion ROM相关内容，转载于<a href="https://blog.csdn.net/pwl999/article/details/78208065" target="_blank" rel="noopener">PCI&amp;PCIE ExpansionOption ROM</a>。<a id="more"></a></p><h3 id="1-What-is-Expansion-ROM"><a href="#1-What-is-Expansion-ROM" class="headerlink" title="1. What is Expansion ROM"></a>1. What is Expansion ROM</h3><p>Expansion rom是pci/pcie设备可选的一个外接的eprom芯片，用来存储相应pci设备的初始化代码或者系统启动代码。BIOS在POST(Power-on Self Test)阶段，会扫描pci设备是否有expansion rom，有的话将其拷贝到ram中执行。在PCI规范中称为expansion rom，在BIOS术语里面称为option rom。</p><h3 id="2-PCI配置空间关于Expansion-ROM的定义"><a href="#2-PCI配置空间关于Expansion-ROM的定义" class="headerlink" title="2. PCI配置空间关于Expansion ROM的定义"></a>2. PCI配置空间关于Expansion ROM的定义</h3><p>The four-byte register at offset 30h in a type 00h predefined header is defined to handle the base address and size information for this expansion ROM.  </p><p><img src="/images/2021/06/20.PNG" alt></p><p>关于“Expansion rom base address”寄存器的具体定义细节如下：</p><p><img src="/images/2021/06/21.PNG" alt></p><p>bit11-bit31定义expansion rom映射到memeory空间的高位地址bit11-bit31。bit0表示是否使能expansion rom，1使能为使能，需要注意的是expansion rom和pci其他的bar空间是共享地址解码的，所以一旦使能expansion rom就不能对其他的bar空间进行操作。expansion rom空间大小的计算方法和其他的“base address register”一样，往基址寄存器写全1，然后再回读进行计算。</p><p>软件把“Expansion rom base address”寄存器的基地址配置成相应的memeory空间地址并使能expansion rom以后，就可以对设备的expansion rom进行读访问了。软件将expansion rom中包含的可执行代码拷贝到ram中执行，不用关心这些可执行代码具体干些什么事情。</p><h3 id="3-Expansion-ROM的组织结构"><a href="#3-Expansion-ROM的组织结构" class="headerlink" title="3. Expansion ROM的组织结构"></a>3. Expansion ROM的组织结构</h3><p>Expansion rom的组织结构有相应的规范。一个可能包含多个rom image，可以支持多个不同类型的pci设备，每种设备也可以支持不同架构cpu的可执行代码。多个image在一个expansion rom芯片中的组织如下图所示，其中每份image的开始地址都是以512bytes对齐的：</p><p><img src="/images/2021/06/22.PNG" alt><br>一份标准的image由两部分组成：PCI Expansion ROM Header Format和PCI Data Structure Format。具体的格式定义如下图:<br><img src="/images/2021/06/23.png" alt></p><h3 id="4-Expansion-ROM的初始化过程"><a href="#4-Expansion-ROM的初始化过程" class="headerlink" title="4. Expansion ROM的初始化过程"></a>4. Expansion ROM的初始化过程</h3><p>BIOS的POST阶段，扫描并执行pci设备的expansion rom的过程大概分以下几步：</p><ol><li>首先判断pci设备是否实现“Expansion rom base address”寄存器，有则进行下一步判断；</li><li>如果有实现了expansion rom的基址寄存器，则配置和使能expansion rom，然后查找expansion rom是否有”AA55”的标示字符，如果有则说明设备有真实的expansion rom芯片存在；</li><li>如果expansion rom已经存在，则扫描是否有适合本设备和本CPU架构的image代码存在；</li><li>如果有适合本环境的image代码存在，则把相应的代码拷贝到ram的合适位置，并跳入header format中指定的初始化入口执行；</li><li>最后关闭expansion rom的使能。</li></ol><p>关于image代码的长度有3个概念：一是Image size这部分包括整个image的长度；一是Initialization size，这部分是将expansion rom拷贝到ram中执行，需要拷贝的长度；一是Runtime size，这部分的程序可以驻留在内存中，供运行时系统软件和OS调用。为了降低常驻代码对ram的占用，常用的做法是:在init功能执行完成以后，执行代码自己把长度修改为常驻程序最少需要占用的Runtime size。如果不需要常驻程序，直接把Runtime size修改成0。<br>对应的关系是：Image size &gt;= Initialization size &gt;= Runtime size。相应的组织架构如下图：<br><img src="/images/2021/06/24.png" alt></p><hr><p>参考资料:</p><ol><li>PCI Local Bus Specification Revision 3.0</li><li><a href="https://blog.csdn.net/pwl999/article/details/78208065" target="_blank" rel="noopener">PCI&amp;PCIE ExpansionOption ROM</a></li><li><a href="https://blog.csdn.net/huangkangying/article/details/8932463" target="_blank" rel="noopener">BIOS之Option ROM详解</a></li><li>PCI Firmware Specification Revision 3.0 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍PCI Expansion ROM相关内容，转载于&lt;a href=&quot;https://blog.csdn.net/pwl999/article/details/78208065&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PCI&amp;amp;PCIE ExpansionOption ROM&lt;/a&gt;。
    
    </summary>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/categories/PCI-PCIe/"/>
    
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
  </entry>
  
  <entry>
    <title>QEMU fw_cfg</title>
    <link href="http://liujunming.github.io/2021/06/30/QEMU-fw-cfg/"/>
    <id>http://liujunming.github.io/2021/06/30/QEMU-fw-cfg/</id>
    <published>2021-06-29T18:44:40.000Z</published>
    <updated>2021-06-29T19:44:31.474Z</updated>
    
    <content type="html"><![CDATA[<p>QEMU Firmware Configuration (fw_cfg) Device<a id="more"></a></p><p>QEMU provides a facility for passing strings and files into the VM. This facility is useful for passing kernel parameters, files, or other resources into a guest.</p><p>在Intel Graphics Device (IGD) assignment with vfio-pci中，有<a href="https://github.com/qemu/qemu/blob/master/docs/igd-assign.txt#L102" target="_blank" rel="noopener">“etc/igd-opregion”</a> 这一fw_cfg: This fw_cfg file exposes the OpRegion for the IGD device. 问题来了，这一fw_cfg的内容是哪里来的呢？</p><p>QEUM源码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfio_pci_igd_opregion_init</span><span class="params">(VFIOPCIDevice *vdev,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct vfio_region_info *info, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    vdev-&gt;igd_opregion = g_malloc0(info-&gt;size);</span><br><span class="line">    ret = pread(vdev-&gt;vbasedev.fd, vdev-&gt;igd_opregion,</span><br><span class="line">                info-&gt;size, info-&gt;offset);</span><br><span class="line">    <span class="keyword">if</span> (ret != info-&gt;size) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">"failed to read IGD OpRegion"</span>);</span><br><span class="line">        g_free(vdev-&gt;igd_opregion);</span><br><span class="line">        vdev-&gt;igd_opregion = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Provide fw_cfg with a copy of the OpRegion which the VM firmware is to</span></span><br><span class="line"><span class="comment">     * allocate 32bit reserved memory for, copy these contents into, and write</span></span><br><span class="line"><span class="comment">     * the reserved memory base address to the device ASLS register at 0xFC.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fw_cfg_add_file(fw_cfg_find(), <span class="string">"etc/igd-opregion"</span>,</span><br><span class="line">                    vdev-&gt;igd_opregion, info-&gt;size);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vfio_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ret = vfio_get_dev_region_info(&amp;vdev-&gt;vbasedev,</span><br><span class="line">    VFIO_REGION_TYPE_PCI_VENDOR_TYPE | PCI_VENDOR_ID_INTEL,</span><br><span class="line">        VFIO_REGION_SUBTYPE_INTEL_IGD_OPREGION, &amp;opregion);    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kernel vfio源码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vfio_pci_igd_opregion_init</span><span class="params">(struct vfio_pci_device *vdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">ret = vfio_pci_register_dev_region(vdev,</span><br><span class="line">PCI_VENDOR_ID_INTEL | VFIO_REGION_TYPE_PCI_VENDOR_TYPE,</span><br><span class="line">VFIO_REGION_SUBTYPE_INTEL_IGD_OPREGION,</span><br><span class="line">&amp;vfio_pci_igd_regops, size + rvds, VFIO_REGION_INFO_FLAG_READ, base);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vfio_pci_regops</span> <span class="title">vfio_pci_igd_regops</span> = &#123;</span></span><br><span class="line">.rw= vfio_pci_igd_rw,</span><br><span class="line">.release= vfio_pci_igd_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">vfio_pci_igd_rw</span><span class="params">(struct vfio_pci_device *vdev, <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos, <span class="keyword">bool</span> iswrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = VFIO_PCI_OFFSET_TO_INDEX(*ppos) - VFIO_PCI_NUM_REGIONS;</span><br><span class="line"><span class="keyword">void</span> *base = vdev-&gt;region[i].data;</span><br><span class="line"><span class="keyword">loff_t</span> pos = *ppos &amp; VFIO_PCI_OFFSET_MASK;</span><br><span class="line">u16 version;</span><br><span class="line">u64 rvda;</span><br><span class="line">u32 rvds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos &gt;= vdev-&gt;region[i].size || iswrite)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">count = min(count, (<span class="keyword">size_t</span>)(vdev-&gt;region[i].size - pos));</span><br><span class="line"></span><br><span class="line">version = le16_to_cpu(*(__le16 *)(base + OPREGION_VERSION));</span><br><span class="line">rvda = le64_to_cpu(*(__le64 *)(base + OPREGION_RVDA));</span><br><span class="line">rvds = le32_to_cpu(*(__le32 *)(base + OPREGION_RVDS));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vdev-&gt;region[i].subtype == VFIO_REGION_SUBTYPE_INTEL_IGD_OPREGION &amp;&amp;</span><br><span class="line">    version == <span class="number">0x0200</span> &amp;&amp; rvda &amp;&amp; rvds) &#123;</span><br><span class="line">u32 addr = cpu_to_le32(*(__le32 *)(vdev-&gt;vconfig + OPREGION_PCI_ADDR));</span><br><span class="line"><span class="keyword">void</span> *vbt_base;</span><br><span class="line"><span class="keyword">void</span> *opregionvbt;</span><br><span class="line"></span><br><span class="line">vbt_base = memremap(rvda, rvds, MEMREMAP_WB);</span><br><span class="line"><span class="keyword">if</span> (!vbt_base)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">opregionvbt = kzalloc(vdev-&gt;region[i].size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!opregionvbt) &#123;</span><br><span class="line">memunmap(vbt_base);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Stitch VBT after OpRegion if noncontigious */</span></span><br><span class="line"><span class="built_in">memcpy</span>(opregionvbt, base, OPREGION_SIZE);</span><br><span class="line"><span class="built_in">memcpy</span>(opregionvbt + OPREGION_SIZE, vbt_base, rvds);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Patch OpRegion 2.0 to 2.1 */</span></span><br><span class="line">*(__le16 *)(opregionvbt + OPREGION_VERSION) = <span class="number">0x0201</span>;</span><br><span class="line"><span class="comment">/* Patch RVDA location after OpRegion */</span></span><br><span class="line">*(__le64 *)(opregionvbt + OPREGION_RVDA) = OPREGION_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(buf, opregionvbt + pos, count)) &#123;</span><br><span class="line">kfree(opregionvbt);</span><br><span class="line">memunmap(vbt_base);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kfree(opregionvbt);</span><br><span class="line">memunmap(vbt_base);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(buf, base + pos, count))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*ppos += count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>参考资料:</p><ol><li><a href="https://wiki.osdev.org/QEMU_fw_cfg" target="_blank" rel="noopener">https://wiki.osdev.org/QEMU_fw_cfg</a></li><li><a href="https://github.com/qemu/qemu/blob/master/docs/specs/fw_cfg.txt" target="_blank" rel="noopener">https://github.com/qemu/qemu/blob/master/docs/specs/fw_cfg.txt</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QEMU Firmware Configuration (fw_cfg) Device
    
    </summary>
    
      <category term="QEMU" scheme="http://liujunming.github.io/categories/QEMU/"/>
    
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>The usage of VFIO</title>
    <link href="http://liujunming.github.io/2021/06/29/The-usage-of-VFIO/"/>
    <id>http://liujunming.github.io/2021/06/29/The-usage-of-VFIO/</id>
    <published>2021-06-29T01:45:26.000Z</published>
    <updated>2021-07-01T10:11:28.350Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍the usage of VFIO。<a id="more"></a></p><h3 id="1-prerequisite"><a href="#1-prerequisite" class="headerlink" title="1. prerequisite"></a>1. prerequisite</h3><p><a href="/2021/06/16/The-motivation-of-VFIO/">The motivation of VFIO</a></p><p>建议阅读Alex的slides:<a href="http://awilliam.github.io/presentations/KVM-Forum-2016/#/" target="_blank" rel="noopener">An Introduction to PCI Device Assignment with VFIO</a>，不妨多读几遍。若有兴趣，可以观看<a href="https://www.youtube.com/watch?v=WFkdTFTOTpA" target="_blank" rel="noopener">视频</a>。</p><h3 id="2-device-group-container"><a href="#2-device-group-container" class="headerlink" title="2. device, group, container"></a>2. device, group, container</h3><p><img src="/images/2021/06/14.PNG" alt></p><h4 id="2-1-device"><a href="#2-1-device" class="headerlink" title="2.1 device"></a>2.1 device</h4><p>Device 指的是我们要操作的硬件设备。</p><h4 id="2-2-group"><a href="#2-2-group" class="headerlink" title="2.2 group"></a>2.2 group</h4><p>Group 是IOMMU能够进行DMA隔离的最小硬件单元，一个group内可能只有一个device，也可能有多个device，这取决于物理平台上硬件的IOMMU拓扑结构。 设备直通的时候一个group里面的设备必须都直通给一个虚拟机。 不能够让一个group里的多个device分别从属于2个不同的VM，也不允许部分device在host上而另一部分被分配到guest里。 另外，VFIO中的group和iommu group可以认为是同一个概念。</p><h4 id="2-3-container"><a href="#2-3-container" class="headerlink" title="2.3 container"></a>2.3 container</h4><p>While the group is the minimum granularity that must be used to ensure secure user access, it’s not necessarily the preferred granularity.  In IOMMUs which make use of page tables, it may be possible to share a set of page tables between different groups, reducing the overhead both to the platform (reduced TLB thrashing, reduced duplicate page tables), and to the user (programming only a single set of translations).  For this reason, VFIO makes use of a container class, which may hold one or more groups.  A container is created by simply opening the <code>/dev/vfio/vfio</code> character device.</p><p>从上图可以看出，一个或多个device从属于某个group，而一个或多个group又从属于一个container。 如果要将一个device直通给VM，那么先要找到这个设备从属的iommu group，然后将整个group加入到container中即可。</p><h3 id="3-VFIO-Usage-Example"><a href="#3-VFIO-Usage-Example" class="headerlink" title="3. VFIO Usage Example"></a>3. VFIO Usage Example</h3><p>To check device subordination, check all IOMMU groups by looking into below sysfs, and identify the device to pass-through. Below example shows IOMMU group 3 has two devices at 0:14.0 and 0:14.2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tree /sys/kernel/iommu_groups/</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">├── 3</span><br><span class="line">│   ├── devices</span><br><span class="line">│   │   ├── 0000:00:14.0 -&gt; ../../../../devices/pci0000:00/0000:00:14.0</span><br><span class="line">│   │   └── 0000:00:14.2 -&gt; ../../../../devices/pci0000:00/0000:00:14.2</span><br><span class="line">│   ├── reserved_regions</span><br><span class="line">│   └── type</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Assume user wants to access PCI device 0000:00:02.0:</p><pre><code>$ readlink /sys/bus/pci/devices/0000:00:02.0/iommu_group../../../kernel/iommu_groups/1</code></pre><p>This device is therefore in IOMMU group 1.  This device is on the pci bus, therefore the user will make use of <code>vfio-pci</code>to manage the group:</p><pre><code># modprobe vfio-pci</code></pre><p>Binding this device to the <code>vfio-pci</code> driver creates the VFIO group character devices for this group:</p><pre><code>$ lspci -n -s 0000:00:02.000:02.0 0300: 8086:5916 (rev 02)# echo 0000:00:02.0 &gt; /sys/bus/pci/devices/0000:00:02.0/driver/unbind# echo 8086 5916 &gt; /sys/bus/pci/drivers/vfio-pci/new_id</code></pre><p>Now we need to look at what other devices are in the group to free it for use by VFIO:</p><pre><code>$ ls -l /sys/bus/pci/devices/0000:00:02.0/iommu_group/devicestotal 0lrwxrwxrwx 1 root root 0 6月  29 10:54 0000:00:02.0 -&gt; ../../../../devices/pci0000:00/0000:00:02.0</code></pre><p>No other devices are in the group.</p><p>The final step is to provide the user with access to the group if unprivileged operation is desired (note that <code>/dev/vfio/vfio</code> provides no capabilities on its own and is therefore expected to be set to mode 0666 by the system):</p><pre><code># chown user:user /dev/vfio/1</code></pre><p>The user now has full access to all the devices and the iommu for this group and can access them as follows:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> container, group, device, i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfio_group_status</span> <span class="title">group_status</span> =</span></span><br><span class="line"><span class="class">&#123;</span> .argsz = <span class="keyword">sizeof</span>(group_status) &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfio_iommu_type1_info</span> <span class="title">iommu_info</span> = &#123;</span> .argsz = <span class="keyword">sizeof</span>(iommu_info) &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfio_iommu_type1_dma_map</span> <span class="title">dma_map</span> = &#123;</span> .argsz = <span class="keyword">sizeof</span>(dma_map) &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfio_device_info</span> <span class="title">device_info</span> = &#123;</span> .argsz = <span class="keyword">sizeof</span>(device_info) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new container */</span></span><br><span class="line">container = open(<span class="string">"/dev/vfio/vfio"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ioctl(container, VFIO_GET_API_VERSION) != VFIO_API_VERSION)</span><br><span class="line"><span class="comment">/* Unknown API version */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ioctl(container, VFIO_CHECK_EXTENSION, VFIO_TYPE1_IOMMU))</span><br><span class="line"><span class="comment">/* Doesn't support the IOMMU driver we want. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open the group */</span></span><br><span class="line">group = open(<span class="string">"/dev/vfio/1"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test the group is viable and available */</span></span><br><span class="line">ioctl(group, VFIO_GROUP_GET_STATUS, &amp;group_status);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(group_status.flags &amp; VFIO_GROUP_FLAGS_VIABLE))</span><br><span class="line"><span class="comment">/* Group is not viable (ie, not all devices bound for vfio) */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add the group to the container */</span></span><br><span class="line">ioctl(group, VFIO_GROUP_SET_CONTAINER, &amp;container);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable the IOMMU model we want */</span></span><br><span class="line">ioctl(container, VFIO_SET_IOMMU, VFIO_TYPE1_IOMMU);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get addition IOMMU info */</span></span><br><span class="line">ioctl(container, VFIO_IOMMU_GET_INFO, &amp;iommu_info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate some space and setup a DMA mapping */</span></span><br><span class="line">dma_map.vaddr = mmap(<span class="number">0</span>, <span class="number">1024</span> * <span class="number">1024</span>, PROT_READ | PROT_WRITE,</span><br><span class="line">     MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">dma_map.size = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">dma_map.iova = <span class="number">0</span>; <span class="comment">/* 1MB starting at 0x0 from device view */</span></span><br><span class="line">dma_map.flags = VFIO_DMA_MAP_FLAG_READ | VFIO_DMA_MAP_FLAG_WRITE;</span><br><span class="line"></span><br><span class="line">ioctl(container, VFIO_IOMMU_MAP_DMA, &amp;dma_map);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get a file descriptor for the device */</span></span><br><span class="line">device = ioctl(group, VFIO_GROUP_GET_DEVICE_FD, <span class="string">"0000:00:02.0"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test and setup the device */</span></span><br><span class="line">ioctl(device, VFIO_DEVICE_GET_INFO, &amp;device_info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; device_info.num_regions; i++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfio_region_info</span> <span class="title">reg</span> = &#123;</span> .argsz = <span class="keyword">sizeof</span>(reg) &#125;;</span><br><span class="line"></span><br><span class="line">reg.index = i;</span><br><span class="line"></span><br><span class="line">ioctl(device, VFIO_DEVICE_GET_REGION_INFO, &amp;reg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setup mappings... read/write offsets, mmaps</span></span><br><span class="line"><span class="comment"> * For PCI devices, config space is a region */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; device_info.num_irqs; i++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfio_irq_info</span> <span class="title">irq</span> = &#123;</span> .argsz = <span class="keyword">sizeof</span>(irq) &#125;;</span><br><span class="line"></span><br><span class="line">irq.index = i;</span><br><span class="line"></span><br><span class="line">ioctl(device, VFIO_DEVICE_GET_IRQ_INFO, &amp;irq);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setup IRQs... eventfds, VFIO_DEVICE_SET_IRQS */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Gratuitous device reset and go... */</span></span><br><span class="line">ioctl(device, VFIO_DEVICE_RESET);</span><br></pre></td></tr></table></figure></p><h3 id="4-regions"><a href="#4-regions" class="headerlink" title="4. regions"></a>4. regions</h3><p><img src="/images/2021/06/16.PNG" alt><br><img src="/images/2021/06/15.PNG" alt></p><h3 id="5-full-picture"><a href="#5-full-picture" class="headerlink" title="5. full picture"></a>5. full picture</h3><p><img src="/images/2021/06/17.PNG" alt><br><img src="/images/2021/06/19.PNG" alt><br><img src="/images/2021/06/18.PNG" alt></p><h3 id="6-VFIO-框架简介"><a href="#6-VFIO-框架简介" class="headerlink" title="6. VFIO 框架简介"></a>6. VFIO 框架简介</h3><p>整个VFIO框架设计十分简洁清晰，可以用下面的一幅图描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------+</span><br><span class="line">|                                           |</span><br><span class="line">|             VFIO Interface                |</span><br><span class="line">|                                           |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">|                     |                     |</span><br><span class="line">|     vfio_iommu      |      vfio_pci       |</span><br><span class="line">|                     |                     |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">|                     |                     |</span><br><span class="line">|    iommu driver     |    pci_bus driver   |</span><br><span class="line">|                     |                     |</span><br><span class="line">+---------------------+---------------------+</span><br></pre></td></tr></table></figure><p>最上层的是VFIO Interface Layer，它负责向用户态提供统一访问的接口，用户态通过约定的ioctl设置和调用VFIO的各种能力。 </p><p>中间层分别是vfio_iommu和vfio_pci。vfio_iommu是VFIO对iommu层的统一封装，主要用来实现DMA Remapping的功能，即管理IOMMU页表的能力。 vfio_pci是VFIO对pci设备驱动的统一封装，它和用户态进程一起配合完成设备资源访问，具体包括PCI配置空间模拟、PCI Bar空间重定向，Interrupt Remapping等。</p><p>最下面的一层则是硬件驱动调用层，iommu driver是与硬件平台相关的实现，例如它可能是intel iommu driver或amd iommu driver或者ppc iommu driver。vfio_pci会调用到host上的pci_bus driver来实现设备的注册和反注册等操作。</p><hr><p> 参考资料:</p><ol><li><a href="https://www.kernel.org/doc/Documentation/vfio.txt" target="_blank" rel="noopener">kernel vfio.txt</a></li><li><a href="https://awilliam.github.io/presentations/KVM-Forum-2016/#/" target="_blank" rel="noopener">An Introduction to PCI Device Assignment with VFIO</a></li><li><a href="https://luohao-brian.gitbooks.io/interrupt-virtualization/content/vfio-she-bei-zhi-tong-jian-jie.html" target="_blank" rel="noopener">VFIO 设备直通简介</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍the usage of VFIO。
    
    </summary>
    
      <category term="VFIO" scheme="http://liujunming.github.io/categories/VFIO/"/>
    
    
      <category term="VFIO" scheme="http://liujunming.github.io/tags/VFIO/"/>
    
  </entry>
  
  <entry>
    <title>Dive into VBT</title>
    <link href="http://liujunming.github.io/2021/06/25/Deep-into-VBT/"/>
    <id>http://liujunming.github.io/2021/06/25/Deep-into-VBT/</id>
    <published>2021-06-25T04:51:56.000Z</published>
    <updated>2021-06-25T09:25:24.516Z</updated>
    
    <content type="html"><![CDATA[<p>本文将深入解析VBT中的相关内容。<a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><span class="line">$ intel_vbt_decode i915_vbt</span><br><span class="line">VBT header:</span><br><span class="line">        VBT signature:          &quot;$VBT SKYLAKE        &quot;</span><br><span class="line">        VBT version:            0x0064 (1.0)</span><br><span class="line">        VBT header size:        0x0030 (48)</span><br><span class="line">        VBT size:               0x1159 (4441)</span><br><span class="line">        VBT checksum:           0xd9</span><br><span class="line">        BDB offset:             0x00000030 (48)</span><br><span class="line"></span><br><span class="line">BDB header:</span><br><span class="line">        BDB signature:          &quot;BIOS_DATA_BLOCK &quot;</span><br><span class="line">        BDB version:            211</span><br><span class="line">        BDB header size:        0x0016 (22)</span><br><span class="line">        BDB size:               0x1128 (4392)</span><br><span class="line"></span><br><span class="line">BDB blocks present:</span><br><span class="line">          1   2   3   6   7   8   9  10  12  13  17  18  20  26  27  28</span><br><span class="line">         31  32  40  41  42  43  44  46 252 253 254</span><br><span class="line"></span><br><span class="line">BDB block 1 - General features block:</span><br><span class="line">        Panel fitting: text &amp; graphics</span><br><span class="line">        Flexaim: yes</span><br><span class="line">        Message: yes</span><br><span class="line">        Clear screen: 0</span><br><span class="line">        DVO color flip required: no</span><br><span class="line">        External VBT: no</span><br><span class="line">        Enable SSC: no</span><br><span class="line">        LFP on override: no</span><br><span class="line">        Disable SSC on clone: no</span><br><span class="line">        Underscan support for VGA timings: no</span><br><span class="line">        Dynamic CD clock: yes</span><br><span class="line">        Hotplug support in VBIOS: no</span><br><span class="line">        Disable smooth vision: no</span><br><span class="line">        Single DVI for CRT/DVI: no</span><br><span class="line">        Enable 180 degree rotation: no</span><br><span class="line">        Inverted FDI Rx polarity: no</span><br><span class="line">        Extended VBIOS mode: no</span><br><span class="line">        Copy iLFP DTD to SDVO LVDS DTD: no</span><br><span class="line">        Best fit panel timing algorithm: no</span><br><span class="line">        Ignore strap state: no</span><br><span class="line">        Legacy monitor detect: yes</span><br><span class="line">        Integrated CRT: no</span><br><span class="line">        Integrated TV: no</span><br><span class="line">        Integrated EFP: no</span><br><span class="line">        DP SSC enable: no</span><br><span class="line">        DP SSC dongle supported: no</span><br><span class="line"></span><br><span class="line">BDB block 2 - General definitions block:</span><br><span class="line">        CRT DDC GMBUS addr: 0x02</span><br><span class="line">        Use ACPI DPMS CRT power states: no</span><br><span class="line">        Skip CRT detect at boot: no</span><br><span class="line">        Use DPMS on AIM devices: yes</span><br><span class="line">        Boot display type: 0x0000</span><br><span class="line">        Child device size: 38</span><br><span class="line">        Child device count: 8</span><br><span class="line">        Child device info:</span><br><span class="line">                Device handle: 0x0008 (LFP 1 (eDP))</span><br><span class="line">                Device type: 0x1806 (unknown)</span><br><span class="line">                        Internal connector</span><br><span class="line">                        DisplayPort output</span><br><span class="line">                        Digital output</span><br><span class="line">                I2C speed: 0x00</span><br><span class="line">                DP onboard redriver: 0x00</span><br><span class="line">                DP ondock redriver: 0x00</span><br><span class="line">                HDMI level shifter value: 0x00</span><br><span class="line">                HDMI max data rate: 0x00</span><br><span class="line">                Offset to DTD buffer for edidless CHILD: 0x00</span><br><span class="line">                Edidless EFP: no</span><br><span class="line">                Compression enable: no</span><br><span class="line">                Compression method CPS: no</span><br><span class="line">                Dual pipe ganged eDP: no</span><br><span class="line">                Compression structure index: 0x00)</span><br><span class="line">                Slave DDI port: 0x00 (HDMI-A)</span><br><span class="line">                AIM offset: 0</span><br><span class="line">                DVO Port: 0x0a (DP-A)</span><br><span class="line">                AIM I2C pin: 0x00</span><br><span class="line">                AIM Slave address: 0x00</span><br><span class="line">                DDC pin: 0x03</span><br><span class="line">                EDID buffer ptr: 0x00</span><br><span class="line">                DVO config: 0x00</span><br><span class="line">                EFP routed through dock: no</span><br><span class="line">                Lane reversal: no</span><br><span class="line">                Onboard LSPCON: no</span><br><span class="line">                Iboost enable: no</span><br><span class="line">                HPD sense invert: no</span><br><span class="line">                HDMI compatible? no</span><br><span class="line">                DP compatible? no</span><br><span class="line">                TMDS compatible? no</span><br><span class="line">                Aux channel: 0x40</span><br><span class="line">                Dongle detect: 0x00</span><br><span class="line">                Pipe capabilities: 0x00</span><br><span class="line">                SDVO stall signal available: no</span><br><span class="line">                Hotplug connect status: 0x00</span><br><span class="line">                Integrated encoder instead of SDVO: yes</span><br><span class="line">                DVO wiring: 0x00</span><br><span class="line">                MIPI bridge type: 00 (unknown)</span><br><span class="line">                Device class extension: 0x00</span><br><span class="line">                DVO function: 0x00</span><br><span class="line">                DP USB type C support: no</span><br><span class="line">                2X DP GPIO index: 0x00</span><br><span class="line">                2X DP GPIO pin number: 0x00</span><br><span class="line">                IBoost level for HDMI: 0x02</span><br><span class="line">                IBoost level for DP/eDP: 0x00</span><br><span class="line">        Child device info:</span><br><span class="line">                Device handle: 0x0004 (EFP 1 (HDMI/DVI/DP))</span><br><span class="line">                Device type: 0x60d6 (DisplayPort/HDMI/DVI)</span><br><span class="line">                        Power management</span><br><span class="line">                        Hotplug signaling</span><br><span class="line">                        HDMI output</span><br><span class="line">                        Content protection</span><br><span class="line">                        High speed link</span><br><span class="line">                        TMDS/DVI signaling</span><br><span class="line">                        DisplayPort output</span><br><span class="line">                        Digital output</span><br><span class="line">                I2C speed: 0x00</span><br><span class="line">                DP onboard redriver: 0x10</span><br><span class="line">                DP ondock redriver: 0x10</span><br><span class="line">                HDMI level shifter value: 0x08</span><br><span class="line">                HDMI max data rate: 0x00</span><br><span class="line">                Offset to DTD buffer for edidless CHILD: 0x8ea</span><br><span class="line">                Edidless EFP: no</span><br><span class="line">                Compression enable: no</span><br><span class="line">                Compression method CPS: no</span><br><span class="line">                Dual pipe ganged eDP: no</span><br><span class="line">                Compression structure index: 0x00)</span><br><span class="line">                Slave DDI port: 0x00 (HDMI-A)</span><br><span class="line">                AIM offset: 0</span><br><span class="line">                DVO Port: 0x07 (DP-B)</span><br><span class="line">                AIM I2C pin: 0x00</span><br><span class="line">                AIM Slave address: 0x00</span><br><span class="line">                DDC pin: 0x05</span><br><span class="line">                EDID buffer ptr: 0x00</span><br><span class="line">                DVO config: 0x00</span><br><span class="line">                EFP routed through dock: no</span><br><span class="line">                Lane reversal: no</span><br><span class="line">                Onboard LSPCON: yes</span><br><span class="line">                Iboost enable: no</span><br><span class="line">                HPD sense invert: no</span><br><span class="line">                HDMI compatible? no</span><br><span class="line">                DP compatible? no</span><br><span class="line">                TMDS compatible? no</span><br><span class="line">                Aux channel: 0x10</span><br><span class="line">                Dongle detect: 0x01</span><br><span class="line">                Pipe capabilities: 0x00</span><br><span class="line">                SDVO stall signal available: no</span><br><span class="line">                Hotplug connect status: 0x00</span><br><span class="line">                Integrated encoder instead of SDVO: yes</span><br><span class="line">                DVO wiring: 0x01</span><br><span class="line">                MIPI bridge type: 00 (unknown)</span><br><span class="line">                Device class extension: 0x00</span><br><span class="line">                DVO function: 0x00</span><br><span class="line">                DP USB type C support: no</span><br><span class="line">                2X DP GPIO index: 0x00</span><br><span class="line">                2X DP GPIO pin number: 0x00</span><br><span class="line">                IBoost level for HDMI: 0x02</span><br><span class="line">                IBoost level for DP/eDP: 0x00</span><br><span class="line">        Child device info:</span><br><span class="line">                Device handle: 0x0040 (EFP 2 (HDMI/DVI/DP))</span><br><span class="line">                Device type: 0x60d6 (DisplayPort/HDMI/DVI)</span><br><span class="line">                        Power management</span><br><span class="line">                        Hotplug signaling</span><br><span class="line">                        HDMI output</span><br><span class="line">                        Content protection</span><br><span class="line">                        High speed link</span><br><span class="line">                        TMDS/DVI signaling</span><br><span class="line">                        DisplayPort output</span><br><span class="line">                        Digital output</span><br><span class="line">                I2C speed: 0x00</span><br><span class="line">                DP onboard redriver: 0x10</span><br><span class="line">                DP ondock redriver: 0x10</span><br><span class="line">                HDMI level shifter value: 0x08</span><br><span class="line">                HDMI max data rate: 0x00</span><br><span class="line">                Offset to DTD buffer for edidless CHILD: 0x8fc</span><br><span class="line">                Edidless EFP: no</span><br><span class="line">                Compression enable: no</span><br><span class="line">                Compression method CPS: no</span><br><span class="line">                Dual pipe ganged eDP: no</span><br><span class="line">                Compression structure index: 0x00)</span><br><span class="line">                Slave DDI port: 0x00 (HDMI-A)</span><br><span class="line">                AIM offset: 0</span><br><span class="line">                DVO Port: 0x08 (DP-C)</span><br><span class="line">                AIM I2C pin: 0x00</span><br><span class="line">                AIM Slave address: 0x00</span><br><span class="line">                DDC pin: 0x04</span><br><span class="line">                EDID buffer ptr: 0x00</span><br><span class="line">                DVO config: 0x00</span><br><span class="line">                EFP routed through dock: no</span><br><span class="line">                Lane reversal: no</span><br><span class="line">                Onboard LSPCON: yes</span><br><span class="line">                Iboost enable: no</span><br><span class="line">                HPD sense invert: no</span><br><span class="line">                HDMI compatible? no</span><br><span class="line">                DP compatible? no</span><br><span class="line">                TMDS compatible? no</span><br><span class="line">                Aux channel: 0x20</span><br><span class="line">                Dongle detect: 0x01</span><br><span class="line">                Pipe capabilities: 0x00</span><br><span class="line">                SDVO stall signal available: no</span><br><span class="line">                Hotplug connect status: 0x00</span><br><span class="line">                Integrated encoder instead of SDVO: yes</span><br><span class="line">                DVO wiring: 0x02</span><br><span class="line">                MIPI bridge type: 00 (unknown)</span><br><span class="line">                Device class extension: 0x00</span><br><span class="line">                DVO function: 0x00</span><br><span class="line">                DP USB type C support: no</span><br><span class="line">                2X DP GPIO index: 0x00</span><br><span class="line">                2X DP GPIO pin number: 0x00</span><br><span class="line">                IBoost level for HDMI: 0x02</span><br><span class="line">                IBoost level for DP/eDP: 0x00</span><br><span class="line">        Child device info:</span><br><span class="line">                Device handle: 0x0020 (EFP 3 (HDMI/DVI/DP))</span><br><span class="line">                Device type: 0x60d6 (DisplayPort/HDMI/DVI)</span><br><span class="line">                        Power management</span><br><span class="line">                        Hotplug signaling</span><br><span class="line">                        HDMI output</span><br><span class="line">                        Content protection</span><br><span class="line">                        High speed link</span><br><span class="line">                        TMDS/DVI signaling</span><br><span class="line">                        DisplayPort output</span><br><span class="line">                        Digital output</span><br><span class="line">                I2C speed: 0x00</span><br><span class="line">                DP onboard redriver: 0x10</span><br><span class="line">                DP ondock redriver: 0x10</span><br><span class="line">                HDMI level shifter value: 0x08</span><br><span class="line">                HDMI max data rate: 0x00</span><br><span class="line">                Offset to DTD buffer for edidless CHILD: 0x90e</span><br><span class="line">                Edidless EFP: no</span><br><span class="line">                Compression enable: no</span><br><span class="line">                Compression method CPS: no</span><br><span class="line">                Dual pipe ganged eDP: no</span><br><span class="line">                Compression structure index: 0x00)</span><br><span class="line">                Slave DDI port: 0x00 (HDMI-A)</span><br><span class="line">                AIM offset: 0</span><br><span class="line">                DVO Port: 0x09 (DP-D)</span><br><span class="line">                AIM I2C pin: 0x00</span><br><span class="line">                AIM Slave address: 0x00</span><br><span class="line">                DDC pin: 0x06</span><br><span class="line">                EDID buffer ptr: 0x00</span><br><span class="line">                DVO config: 0x00</span><br><span class="line">                EFP routed through dock: no</span><br><span class="line">                Lane reversal: no</span><br><span class="line">                Onboard LSPCON: no</span><br><span class="line">                Iboost enable: no</span><br><span class="line">                HPD sense invert: no</span><br><span class="line">                HDMI compatible? no</span><br><span class="line">                DP compatible? no</span><br><span class="line">                TMDS compatible? no</span><br><span class="line">                Aux channel: 0x30</span><br><span class="line">                Dongle detect: 0x01</span><br><span class="line">                Pipe capabilities: 0x00</span><br><span class="line">                SDVO stall signal available: no</span><br><span class="line">                Hotplug connect status: 0x00</span><br><span class="line">                Integrated encoder instead of SDVO: yes</span><br><span class="line">                DVO wiring: 0x03</span><br><span class="line">                MIPI bridge type: 00 (unknown)</span><br><span class="line">                Device class extension: 0x00</span><br><span class="line">                DVO function: 0x00</span><br><span class="line">                DP USB type C support: no</span><br><span class="line">                2X DP GPIO index: 0x00</span><br><span class="line">                2X DP GPIO pin number: 0x00</span><br><span class="line">                IBoost level for HDMI: 0x02</span><br><span class="line">                IBoost level for DP/eDP: 0x00</span><br><span class="line"></span><br><span class="line">BDB block 3 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 6 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 7 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 8 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 9 - PSR block:</span><br><span class="line">        Panel 14 *</span><br><span class="line">                Full link: no</span><br><span class="line">                Require AUX to wakeup: no</span><br><span class="line">                Lines to wait before link standby: 0</span><br><span class="line">                Idle frames to for PSR enable: 0</span><br><span class="line">                TP1 wakeup time: 200 usec (0x2)</span><br><span class="line">                TP2/TP3 wakeup time: 200 usec (0x2)</span><br><span class="line"></span><br><span class="line">BDB block 10 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 12 - Driver feature data block:</span><br><span class="line">        Boot Device Algorithm: os default</span><br><span class="line">        Block display switching when DVD active: yes</span><br><span class="line">        Allow display switching when in Full Screen DOS: no</span><br><span class="line">        Hot Plug DVO: yes</span><br><span class="line">        Dual View Zoom: no</span><br><span class="line">        Driver INT 15h hook: no</span><br><span class="line">        Enable Sprite in Clone Mode: yes</span><br><span class="line">        Use 00000110h ID for Primary LFP: no</span><br><span class="line">        Boot Mode X: 1024</span><br><span class="line">        Boot Mode Y: 768</span><br><span class="line">        Boot Mode Bpp: 8</span><br><span class="line">        Boot Mode Refresh: 60</span><br><span class="line">        Enable LFP as primary: no</span><br><span class="line">        Selective Mode Pruning: no</span><br><span class="line">        Dual-Frequency Graphics Technology: yes</span><br><span class="line">        Default Render Clock Frequency: high</span><br><span class="line">        NT 4.0 Dual Display Clone Support: no</span><br><span class="line">        Default Power Scheme user interface: CUI</span><br><span class="line">        Sprite Display Assignment when Overlay is Active in Clone Mode: secondary</span><br><span class="line">        Display Maintain Aspect Scaling via CUI: yes</span><br><span class="line">        Preserve Aspect Ratio: no</span><br><span class="line">        Enable SDVO device power down: no</span><br><span class="line">        CRT hotplug: yes</span><br><span class="line">        LVDS config: No LVDS</span><br><span class="line">        Define Display statically: no</span><br><span class="line">        Legacy CRT max X: 0</span><br><span class="line">        Legacy CRT max Y: 0</span><br><span class="line">        Legacy CRT max refresh: 85</span><br><span class="line"></span><br><span class="line">BDB block 13 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 17 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 18 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 20 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 26 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 27 - eDP block:</span><br><span class="line">        Panel 14 *</span><br><span class="line">                Power Sequence: T3 2000 T7 200 T9 2000 T10 500 T12 5000</span><br><span class="line">                Panel color depth: 18 bpp</span><br><span class="line">                eDP sDRRS MSA Delay: Lane 1</span><br><span class="line">                Fast link params:</span><br><span class="line">                        rate: 1.62G</span><br><span class="line">                        lanes: x2 mode</span><br><span class="line">                        pre-emphasis: none</span><br><span class="line">                        vswing: 0.4V</span><br><span class="line">                Stereo 3D feature: no</span><br><span class="line">                T3 optimization: yes</span><br><span class="line">                Vswing/preemphasis table selection: Low power (200 mV)</span><br><span class="line">                Fast link training: no</span><br><span class="line">                DPCD 600h write required: no</span><br><span class="line">                PWM delays:</span><br><span class="line">                        PWM on to backlight enable: 110</span><br><span class="line">                        Backlight disable to PWM off: 110</span><br><span class="line">                Full link params provided: no</span><br><span class="line">                Full link params:</span><br><span class="line">                        pre-emphasis: none</span><br><span class="line">                        vswing: 0.4V</span><br><span class="line"></span><br><span class="line">BDB block 28 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 31 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 32 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 40 - LVDS options block:</span><br><span class="line">        Panel type: 14</span><br><span class="line">        LVDS EDID available: yes</span><br><span class="line">        Pixel dither: yes</span><br><span class="line">        PFIT auto ratio: yes</span><br><span class="line">        PFIT enhanced graphics mode: no</span><br><span class="line">        PFIT enhanced text mode: no</span><br><span class="line">        PFIT mode: 3</span><br><span class="line"></span><br><span class="line">BDB block 41 - LVDS timing pointer data:</span><br><span class="line">        Number of entries: 3</span><br><span class="line"></span><br><span class="line">BDB block 42 - LVDS panel data block:</span><br><span class="line">  Number of entries: 19 (preferred block marked with &apos;*&apos;)</span><br><span class="line">*       panel type 14: 1920x1080 clock 148500000</span><br><span class="line">                info:</span><br><span class="line">                  LVDS: 0x00000300</span><br><span class="line">                  PP_ON_DELAYS: 0x025807d0</span><br><span class="line">                  PP_OFF_DELAYS: 0x01f407d0</span><br><span class="line">                  PP_DIVISOR: 0x00270f05</span><br><span class="line">                  PFIT: 0x38711880</span><br><span class="line">                timings: 1920 2008 2053 2200 1080 1083 1089 1125 148500.00 (good)</span><br><span class="line"></span><br><span class="line">BDB block 43 - Backlight info block:</span><br><span class="line">        Inverter type: 2</span><br><span class="line">             polarity: 0</span><br><span class="line">             PWM freq: 600</span><br><span class="line">        Minimum brightness: 0</span><br><span class="line"></span><br><span class="line">BDB block 44 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 46 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 252 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 253 - Unknown, no decoding available:</span><br><span class="line"></span><br><span class="line">BDB block 254 - Unknown, no decoding available:</span><br></pre></td></tr></table></figure><h3 id="LFP"><a href="#LFP" class="headerlink" title="LFP"></a>LFP</h3><p>Local Flat Panel, normally used on mobile platforms only</p><p><a href="https://01.org/sites/default/files/documentation/acpi_igd_opregion_spec_0.pdf" target="_blank" rel="noopener">https://01.org/sites/default/files/documentation/acpi_igd_opregion_spec_0.pdf</a></p><h3 id="EFP"><a href="#EFP" class="headerlink" title="EFP"></a>EFP</h3><p>External Flat Panel</p><p><img src="/images/2021/06/9.PNG" alt></p><p><a href="https://01.org/sites/default/files/documentation/acpi_igd_opregion_spec_0.pdf" target="_blank" rel="noopener">https://01.org/sites/default/files/documentation/acpi_igd_opregion_spec_0.pdf</a></p><h3 id="Child-device"><a href="#Child-device" class="headerlink" title="Child device"></a>Child device</h3><p>A child device is a combination of one or more displays.</p><h3 id="eDP"><a href="#eDP" class="headerlink" title="eDP"></a>eDP</h3><p><img src="/images/2021/06/10.PNG" alt></p><p>eDP is an internal interface designed to connect the PC motherboard to the embedded display in a mobile PC.</p><p><a href="https://www.prnewswire.com/news-releases/displayport-dp-edp-and-idp-set-to-change-display-and-pc-landscapes-115091459.html" target="_blank" rel="noopener">DisplayPort: DP, eDP, and iDP Set to Change Display and PC Landscapes</a></p><h3 id="LVDS"><a href="#LVDS" class="headerlink" title="LVDS"></a>LVDS</h3><p><img src="/images/2021/06/11.PNG" alt></p><p>Many LVDS panels don’t bother to include an EDID rom, or the vendor didn’t bother to hook up the DDC wire; presumably it’s cheaper for them to stick more data in the VBIOS than add hardware.  However, there are some LVDS panels with EDID roms which contain <em>incorrect</em> mode data for the panel (amazing, I know), and so the driver prefers to use the VBT data when both are present.</p><p><a href="https://lore.kernel.org/patchwork/patch/268835/" target="_blank" rel="noopener">https://lore.kernel.org/patchwork/patch/268835/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将深入解析VBT中的相关内容。
    
    </summary>
    
      <category term="GPU" scheme="http://liujunming.github.io/categories/GPU/"/>
    
    
      <category term="GPU" scheme="http://liujunming.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>Notes about DisplayPort</title>
    <link href="http://liujunming.github.io/2021/06/25/Notes-about-DisplayPort/"/>
    <id>http://liujunming.github.io/2021/06/25/Notes-about-DisplayPort/</id>
    <published>2021-06-25T03:26:51.000Z</published>
    <updated>2021-06-25T09:58:01.214Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录DisplayPort的相关notes。<a id="more"></a></p><h3 id="DPCD"><a href="#DPCD" class="headerlink" title="DPCD"></a>DPCD</h3><p>DPCD(DisplayPort Configuration Data): a virtual memory with addresses 0x00000 - 0xFFFFF.</p><p>The message transfer between DP source and sink occur by reads and writes to the DisplayPort Configuration Data (DPCD) register of the sink device.</p><p>By reading certain registers in the DPCD, the source will be aware of the capabilities of the sink. During the process of establishing the data links, the Link Training, source writes to DPCD to indicate the target link configuration and sink in turn writes the result of each link training stage.</p><p><a href="http://www.dssrl.com/unigraf/eng/Pdf/DisplayPortUse.pdf" target="_blank" rel="noopener">All you need to know about DisplayPort</a><br><a href="https://www.unigraf.fi/resource/what-do-you-need-to-test-in-displayport-interface/" target="_blank" rel="noopener">What do you need to test in DisplayPort interface?</a><br><a href="https://glenwing.github.io/docs/DP-1.2.pdf" target="_blank" rel="noopener">spec:VESA DisplayPort Standard Version 1.2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录DisplayPort的相关notes。
    
    </summary>
    
      <category term="GPU" scheme="http://liujunming.github.io/categories/GPU/"/>
    
    
      <category term="GPU" scheme="http://liujunming.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Display</title>
    <link href="http://liujunming.github.io/2021/06/25/Notes-about-Display/"/>
    <id>http://liujunming.github.io/2021/06/25/Notes-about-Display/</id>
    <published>2021-06-25T03:10:46.000Z</published>
    <updated>2021-06-27T14:55:56.547Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录GPU display的相关notes。<a id="more"></a></p><h3 id="Ls-Pcon"><a href="#Ls-Pcon" class="headerlink" title="Ls-Pcon"></a>Ls-Pcon</h3><p>LSPCON(Level Shifter/Protocol Converter)是一个convertor，intel 的HDMI 2.0 solution 是通过DP to HDMI 2.0 转的，中间就是LSPCON。<br><img src="/images/2021/06/8.png" alt></p><p><a href="https://zhidao.baidu.com/question/1865983457773662747.html" target="_blank" rel="noopener">LSPCon是由谁来控制？</a><br><a href="https://www.intel.com/content/dam/support/us/en/documents/graphics/HDR_Intel_Graphics_TechWhitePaper.pdf" target="_blank" rel="noopener">HDR Intel Graphics TechWhitePaper</a></p><h3 id="DDC"><a href="#DDC" class="headerlink" title="DDC"></a>DDC</h3><p>The Display Data Channel, or DDC, is a collection of protocols for digital communication between a computer display and a graphics adapter.</p><p><a href="https://en.wikipedia.org/wiki/Display_Data_Channel" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Display_Data_Channel</a></p><p>DDC (Display Data Channel) is a defined Standard by VESA. While DDC is just the description of the interface, the true data that is exchanged between graphic adapter card and monitor is called EDID (Extended Display Information Data).</p><p><a href="https://www.blackbox.be/ben-be/page/25829/Resources/Technical-Resources/Black-Box-Explains/multimedia/ddc-display-data-channel" target="_blank" rel="noopener">https://www.blackbox.be/ben-be/page/25829/Resources/Technical-Resources/Black-Box-Explains/multimedia/ddc-display-data-channel</a></p><h3 id="DDI"><a href="#DDI" class="headerlink" title="DDI"></a>DDI</h3><p>Digital Display Interface</p><p>The DDIs contain the DisplayPort transport control and other port logic to interface to the DDI physical pins.</p><p><img src="/images/2021/06/12.PNG" alt></p><p><a href="https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-bxt-vol07-display.pdf" target="_blank" rel="noopener">https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-bxt-vol07-display.pdf</a></p><h3 id="MIPI-DSI-Display-Serial-Interface"><a href="#MIPI-DSI-Display-Serial-Interface" class="headerlink" title="MIPI DSI(Display Serial Interface)"></a>MIPI DSI(Display Serial Interface)</h3><p>The Mobile Industry Processor Interface, also known as MIPI, is a high-speed differential protocol that is commonly used in cellphones. Specifically, the MIPI Display Serial Interface (DSI) technology is designed for display communication.</p><p><img src="/images/2021/06/13.PNG" alt></p><p><a href="https://focuslcds.com/the-mipi-and-lvds-display-interfaces/" target="_blank" rel="noopener">https://focuslcds.com/the-mipi-and-lvds-display-interfaces/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录GPU display的相关notes。
    
    </summary>
    
      <category term="GPU" scheme="http://liujunming.github.io/categories/GPU/"/>
    
    
      <category term="GPU" scheme="http://liujunming.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>Notes about AUX</title>
    <link href="http://liujunming.github.io/2021/06/24/Notes-about-AUX/"/>
    <id>http://liujunming.github.io/2021/06/24/Notes-about-AUX/</id>
    <published>2021-06-24T03:13:04.000Z</published>
    <updated>2021-06-24T12:07:39.820Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录AUX的相关notes。<a id="more"></a></p><p><img src="/images/2021/06/5.PNG" alt></p><p><img src="/images/2021/06/6.PNG" alt></p><p><img src="/images/2021/06/7.PNG" alt></p><p>For the handshake between the source and the sink, DP has a dedicated bus, the AUX Channel. Since the source device controls the process, it makes requests for the sink. </p><hr><p>参考资料:</p><ol><li><a href="https://tmetrix.com/wp-content/uploads/How-to-monitor-AUX-Channel-Communication-of-Displayport-interfaces.pdf" target="_blank" rel="noopener">How to Monitor AUX Channel Communication of DisplayPort Interfaces</a></li><li><a href="https://www.unigraf.fi/resource/what-do-you-need-to-test-in-displayport-interface/" target="_blank" rel="noopener">What do you need to test in DisplayPort interface?</a></li><li><a href="http://www.dssrl.com/unigraf/eng/Pdf/DisplayPortUse.pdf" target="_blank" rel="noopener">DisplayPortUse</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录AUX的相关notes。
    
    </summary>
    
      <category term="GPU" scheme="http://liujunming.github.io/categories/GPU/"/>
    
    
      <category term="GPU" scheme="http://liujunming.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>Notes about EDID</title>
    <link href="http://liujunming.github.io/2021/06/24/Notes-about-EDID/"/>
    <id>http://liujunming.github.io/2021/06/24/Notes-about-EDID/</id>
    <published>2021-06-24T02:58:29.000Z</published>
    <updated>2021-06-24T12:07:39.820Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录EDID的相关notes。<a id="more"></a></p><h3 id="1-What-is-EDID"><a href="#1-What-is-EDID" class="headerlink" title="1. What is EDID ?"></a>1. What is EDID ?</h3><p>Extended Display Identification Data (EDID) is a metadata format for display devices to describe their capabilities to a video source (e.g Monitor/ TV panels). The data format is defined by a standard published by the Video Electronics Standards Association (VESA).</p><ul><li>Specific to a dispaly</li><li>Stores a list of capabilities for the display</li><li>Includes vendor and product information, display parameters, times, preferences, gamma, colorimetry, audio capabilities, extension blocks</li></ul><p>EDID is implemented for DVI, HDMI, and DisplayPort. Some very cheap monitors still (for cost saving) do not implement EDID standard (in which case VBT entries for such monitors are required).</p><h3 id="2-How-to-dump-EDID-in-Linux"><a href="#2-How-to-dump-EDID-in-Linux" class="headerlink" title="2. How to dump EDID in Linux?"></a>2. How to dump EDID in Linux?</h3><p>Linux i915 graphics driver has capability to do it.</p><h4 id="2-1-To-Locate"><a href="#2-1-To-Locate" class="headerlink" title="2.1 To Locate"></a>2.1 To Locate</h4><p>You need to find for which display connector you want to dump EDID.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ find /sys/devices/pci0000:00/0000:00:02.0 | grep -i edid</span><br><span class="line">/sys/devices/pci0000:00/0000:00:02.0/drm/card0/card0-DP-2/edid</span><br><span class="line">/sys/devices/pci0000:00/0000:00:02.0/drm/card0/card0-DP-1/edid</span><br></pre></td></tr></table></figure><h4 id="2-2-To-Dump"><a href="#2-2-To-Dump" class="headerlink" title="2.2 To Dump"></a>2.2 To Dump</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/devices/pci0000:00/0000:00:02.0/drm/card0/card0-DP-1/edid &gt; edid-dump</span><br></pre></td></tr></table></figure><h3 id="3-Decode-in-human-readable"><a href="#3-Decode-in-human-readable" class="headerlink" title="3. Decode in human readable"></a>3. Decode in human readable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">$edid-decode &lt; edid-dump</span><br><span class="line">Extracted contents:</span><br><span class="line">header:          00 ff ff ff ff ff ff 00</span><br><span class="line">serial number:   4a 8b 32 bc 01 01 01 01 30 1c</span><br><span class="line">version:         01 03</span><br><span class="line">basic params:    80 00 00 78 3e</span><br><span class="line">chroma info:     ee 91 a3 54 4c 99 26 0f 50 54</span><br><span class="line">established:     21 08 00</span><br><span class="line">standard:        d1 c0 a9 c0 8b c0 81 c0 61 c0 59 c0 4b c0 3b c0</span><br><span class="line">descriptor 1:    02 3a 80 18 71 38 2d 40 58 2c 25 00 58 c3 10 00 00 1e</span><br><span class="line">descriptor 2:    00 00 00 fc 00 52 54 4b 20 46 48 44 20 48 44 52 0a 20</span><br><span class="line">descriptor 3:    00 00 00 ff 00 64 65 6d 6f 73 65 74 2d 31 0a 20 30 20</span><br><span class="line">descriptor 4:    00 00 00 fd 00 32 41 22 54 13 01 0a 20 20 20 20 20 20</span><br><span class="line">extensions:      01</span><br><span class="line">checksum:        26</span><br><span class="line"></span><br><span class="line">Manufacturer: RTK Model bc32 Serial Number 16843009</span><br><span class="line">Made week 48 of 2018</span><br><span class="line">EDID version: 1.3</span><br><span class="line">Digital display</span><br><span class="line">Image size is variable</span><br><span class="line">Gamma: 2.20</span><br><span class="line">DPMS levels: Off</span><br><span class="line">Supported color formats: RGB 4:4:4, YCrCb 4:4:4, YCrCb 4:2:2</span><br><span class="line">Default (sRGB) color space is primary color space</span><br><span class="line">First detailed timing is preferred timing</span><br><span class="line">Established timings supported:</span><br><span class="line">  640x480@60Hz</span><br><span class="line">  800x600@60Hz</span><br><span class="line">  1024x768@60Hz</span><br><span class="line">Standard timings supported:</span><br><span class="line">  1920x1080@60Hz</span><br><span class="line">  1600x900@60Hz</span><br><span class="line">  1360x765@60Hz</span><br><span class="line">  1280x720@60Hz</span><br><span class="line">  1024x576@60Hz</span><br><span class="line">  960x540@60Hz</span><br><span class="line">  848x477@60Hz</span><br><span class="line">  720x405@60Hz</span><br><span class="line">Detailed mode: Clock 148.500 MHz, 344 mm x 195 mm</span><br><span class="line">               1920 2008 2052 2200 hborder 0</span><br><span class="line">               1080 1082 1087 1125 vborder 0</span><br><span class="line">               +hsync +vsync</span><br><span class="line">Monitor name: RTK</span><br><span class="line">Serial number: demoset-1</span><br><span class="line">Monitor ranges (bare limits): 50-65Hz V, 34-84kHz H, max dotclock 190MHz</span><br><span class="line">Has 1 extension blocks</span><br><span class="line">Checksum: 0x26 (valid)</span><br><span class="line"></span><br><span class="line">CEA extension block</span><br><span class="line">Extension version: 3</span><br><span class="line">39 bytes of CEA data</span><br><span class="line">  Video data block</span><br><span class="line">    VIC   3 720x480@60Hz</span><br><span class="line">    VIC  62 1280x720@30Hz</span><br><span class="line">    VIC  19 1280x720@50Hz</span><br><span class="line">    VIC   4 1280x720@60Hz</span><br><span class="line">    VIC  15 1440x480@60Hz</span><br><span class="line">    VIC  34 1920x1080@30Hz</span><br><span class="line">    VIC  31 1920x1080@50Hz</span><br><span class="line">    VIC  16 1920x1080@60Hz</span><br><span class="line">  Extended tag: video capability data block</span><br><span class="line">    YCbCr quantization: Selectable (via AVI YQ) (1)</span><br><span class="line">    RGB quantization: Selectable (via AVI Q) (1)</span><br><span class="line">    PT scan behaviour: Always Overscannned (1)</span><br><span class="line">    IT scan behaviour: Always Overscannned (1)</span><br><span class="line">    CE scan behaviour: Always Overscannned (1)</span><br><span class="line">  Extended tag: Colorimetry data block</span><br><span class="line">    xvYCC601</span><br><span class="line">    xvYCC709</span><br><span class="line">    sYCC601</span><br><span class="line">    AdobeYCC601</span><br><span class="line">    AdobeRGB</span><br><span class="line">    BT2020cYCC</span><br><span class="line">    BT2020YCC</span><br><span class="line">    BT2020RGB</span><br><span class="line">  Audio data block</span><br><span class="line">    Linear PCM, max channels 2</span><br><span class="line">    Supported sample rates (kHz): 192 176.4 96 88.2 48 44.1 32</span><br><span class="line">    Supported sample sizes (bits): 24 20 16</span><br><span class="line">  Speaker allocation data block</span><br><span class="line">    Speaker map: FL/FR</span><br><span class="line">  Vendor-specific data block, OUI 000c03 (HDMI)</span><br><span class="line">    Source physical address 1.0.0.0</span><br><span class="line">    DC_36bit</span><br><span class="line">    DC_30bit</span><br><span class="line">    DC_Y444</span><br><span class="line">    Maximum TMDS clock: 300MHz</span><br><span class="line">  Extended tag: HDR static metadata data block</span><br><span class="line">    Electro optical transfer functions:</span><br><span class="line">      Traditional gamma - SDR luminance range</span><br><span class="line">      Traditional gamma - HDR luminance range</span><br><span class="line">      SMPTE ST2084</span><br><span class="line">    Supported static metadata descriptors:</span><br><span class="line">      Static metadata type 1</span><br><span class="line">    Desired content max luminance: 105</span><br><span class="line">    Desired content max frame-average luminance: 105</span><br><span class="line">    Desired content min luminance: 79</span><br><span class="line">Underscans PC formats by default</span><br><span class="line">Basic audio support</span><br><span class="line">Supports YCbCr 4:4:4</span><br><span class="line">Supports YCbCr 4:2:2</span><br><span class="line">2 native detailed modes</span><br><span class="line">Detailed mode: Clock 108.000 MHz, 344 mm x 195 mm</span><br><span class="line">               1600 1624 1704 1800 hborder 0</span><br><span class="line">                900  901  904 1000 vborder 0</span><br><span class="line">               +hsync +vsync</span><br><span class="line">Detailed mode: Clock 85.500 MHz, 344 mm x 195 mm</span><br><span class="line">               1366 1436 1579 1792 hborder 0</span><br><span class="line">                768  771  774  798 vborder 0</span><br><span class="line">               +hsync +vsync</span><br><span class="line">Detailed mode: Clock 74.250 MHz, 344 mm x 195 mm</span><br><span class="line">               1280 1390 1430 1650 hborder 0</span><br><span class="line">                720  725  730  750 vborder 0</span><br><span class="line">               +hsync +vsync</span><br><span class="line">Checksum: 0x4 (valid)</span><br><span class="line"></span><br><span class="line">EDID block does NOT conform to EDID 1.3!</span><br><span class="line">        Detailed block string not properly terminated</span><br><span class="line">EDID block does not conform at all!</span><br><span class="line">        Detailed blocks filled with garbage</span><br><span class="line">        Range descriptor contains garbage</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://glenwing.github.io/docs/VESA-EEDID-A2.pdf" target="_blank" rel="noopener">VESA ENHANCED EXTENDED DISPLAY IDENTIFICATION DATA STANDARD</a></li><li><a href="https://www.extron.com/article/uedid" target="_blank" rel="noopener">Understanding EDID - Extended Display Identification Data</a></li><li><a href="https://www.youtube.com/watch?v=babx06TSc8Y" target="_blank" rel="noopener">What is EDID? (Extended Display Identification Data)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录EDID的相关notes。
    
    </summary>
    
      <category term="GPU" scheme="http://liujunming.github.io/categories/GPU/"/>
    
    
      <category term="GPU" scheme="http://liujunming.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>Video BIOS Table (VBT)</title>
    <link href="http://liujunming.github.io/2021/06/18/Video-BIOS-Table-VBT/"/>
    <id>http://liujunming.github.io/2021/06/18/Video-BIOS-Table-VBT/</id>
    <published>2021-06-18T01:12:18.000Z</published>
    <updated>2021-06-18T10:48:07.300Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容源于:<br><a href="https://github.com/ZoranStojsavljevic/Video-BIOS-Table-parser-assembler/wiki/Video-BIOS-Table-(VBT)" target="_blank" rel="noopener">https://github.com/ZoranStojsavljevic/Video-BIOS-Table-parser-assembler/wiki/Video-BIOS-Table-(VBT)</a> 并对相关内容做出补充。<br><a id="more"></a></p><h3 id="1-Definition-of-Video-BIOS-Table-VBT"><a href="#1-Definition-of-Video-BIOS-Table-VBT" class="headerlink" title="1. Definition of Video BIOS Table (VBT)"></a>1. Definition of Video BIOS Table (VBT)</h3><p>The Video BIOS Table, or VBT, provides platform and board specific configuration information to the driver that is not discoverable or available through other means. By other means the most used method here is to read EDID table from the attached monitor, over Display Data Channel (DDC) using two pin I2C serial interface.</p><p>The VBT configuration is related to display hardware. The VBT is available via the ACPI OpRegion or, on older systems, in the PCI ROM (Option ROM).</p><p>The VBT consists of a VBT Header, a BIOS Data Block (BDB) Header, and a number of BIOS Data Blocks (BDBs) that contain the actual configuration information (supposed to replace the absence of EDID structure with the older monitors). The VBT Header, and thus the VBT, begins with “$VBT” signature. The VBT Header contains the offset of the BDB Header. The BDB header starts with the “BIOS_DATA_BLOCK” signature. The data blocks are concatenated after the BDB Header (not always in exact order, and certain BDBs might be missing, not implemented for such type of HW platforms). The data blocks have a 1-byte Block ID, 2-byte Block Size, and Block Size bytes of data (Block 53, the MIPI Sequence Block is an exception).</p><p>The GFX driver parses the VBT during load. The relevant information is stored in GFX driver private data for ease of use, and the actual VBT is not read after that.</p><h3 id="2-EDID-Structure"><a href="#2-EDID-Structure" class="headerlink" title="2. EDID Structure"></a>2. EDID Structure</h3><p>To understand better what is Video BIOS Table, reader should read the following document: <a href="http://www.extron.com/company/article.aspx?id=uedid" target="_blank" rel="noopener">Understanding EDID - Extended Display Identification Data</a>.</p><p>Please, do note that EDID is implemented for DVI, HDMI, and DisplayPort (Present Time). Some very cheap monitors still (for cost saving) do not implement EDID standard (in which case VBT entries for such monitors are required).</p><h3 id="3-VBT-OSes-Windows-and-Linux-Support"><a href="#3-VBT-OSes-Windows-and-Linux-Support" class="headerlink" title="3. VBT OSes (Windows and Linux) Support"></a>3. VBT OSes (Windows and Linux) Support</h3><p>As stated previously, VBT means Video BIOS Table. It’s a 100% Intel specific table of configuration options for Intel’s Video BIOS and Intel’s graphics drivers. Since VBT is not related to the concept of a Video BIOS or any standard, it cannot be replaced by something (GOP) that continues standards story.</p><p>There is no detailed public documentation, but as it’s used by the Linux driver, at least the structure and some of the values are publicly “documented” <a href="https://www.kernel.org/doc/html/latest/gpu/i915.html#video-bios-table-vbt" target="_blank" rel="noopener">drm/i915 Intel GFX Driver</a>. Developers of the i915 Linux driver stated that they are not willing to support systems without a VBT. Most features of the i915 driver work without a VBT by chance. But anything board specific, like integrated panels in laptops, will likely not work. Windows won’t even try to get things running without VBT.</p><h3 id="4-VBT-Legacy-BIOS-mode-support"><a href="#4-VBT-Legacy-BIOS-mode-support" class="headerlink" title="4. VBT Legacy BIOS mode support"></a>4. VBT Legacy BIOS mode support</h3><p>As far as legacy BIOS concerned, the context is placed in the x86 Real Mode of operation. VBT is used with the legacy Video BIOS (vBIOS), which is placed as Option ROM at the address 0xC0000 (till maximal address 0xCFFFF), thus maximum size of 64KB.</p><h3 id="5-VBT-UEFI-mode-support"><a href="#5-VBT-UEFI-mode-support" class="headerlink" title="5. VBT UEFI mode support"></a>5. VBT UEFI mode support</h3><p><a href="http://www.uefi.org/sites/default/files/resources/UPFS11_P4_UEFI_GOP_AMD.pdf" target="_blank" rel="noopener">The GOP driver</a> is a replacement for legacy video BIOS and enables the use of UEFI pre-boot firmware without CSM. The GOP driver can be 32-bit, 64-bit, or IA-64 with no binary compatibility. UEFI pre-boot firmware architecture (32-/64-bit) must match the GOP driver architecture (32-/64-bit). The Intel Embedded Graphics Drivers’ GOP driver can either be fast boot (speed optimized and platform specific) or generic (platform agnostic for selective platforms).</p><p>Here is a quick comparison between GOP and video BIOS:</p><ul><li>Video BIOS: 64 KB limit. 16-bit execution. CSM is needed with UEFI system firmware. Performance inferior to GOP CSM. The VBIOS works with both 32- and 64-bit architectures.</li><li>GOP: No 64 KB limit. 32-bit protected mode. No need for CSM. Speed optimized (fast boot). The UEFI pre-boot firmware architecture (32-/64-bit) must match the GOP driver.</li></ul><h3 id="6-VBT-location"><a href="#6-VBT-location" class="headerlink" title="6. VBT  location"></a>6. VBT  location</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexdump -C /sys/kernel/debug/dri/0/i915_vbt</span><br></pre></td></tr></table></figure><p>VBT table is easily locatable. It is located in the <code>/sys</code> directory: <code>/sys/kernel/debug/dri/0/i915_vbt</code>(since kernel version 4.5).</p><p>Please, read the following web page for more information: <a href="https://manpages.debian.org/experimental/intel-gpu-tools/intel_vbt_decode.1.en.html" target="_blank" rel="noopener">intel_vbt_decode</a>.</p><h3 id="7-Intel-GPU-Tools"><a href="#7-Intel-GPU-Tools" class="headerlink" title="7. Intel GPU Tools"></a>7. Intel GPU Tools</h3><p>VBT is also documented by intel-gpu-tools. There’s intel_vbt_decode available, <a href="https://cgit.freedesktop.org/xorg/app/intel-gpu-tools/tree/tools/intel_vbt_decode.c" target="_blank" rel="noopener">intel_vbt_decode.c</a>  will print all tables in human readable form.</p><p>After <a href="https://zoomadmin.com/HowToInstall/UbuntuPackage/intel-gpu-tools" target="_blank" rel="noopener">installation</a>, type<code>man intel_vbt_decode</code> for more detailed information.</p><h3 id="8-Extension"><a href="#8-Extension" class="headerlink" title="8. Extension"></a>8. Extension</h3><p><a href="https://01.org/sites/default/files/documentation/acpi_igd_opregion_spec_0.pdf" target="_blank" rel="noopener">Intel Integrated Graphics Device OpRegion Specification</a></p><p><a href="https://lwn.net/Articles/429319/" target="_blank" rel="noopener">ACPI/Intel: Rework Opregion support</a></p><p>From patch <a href="https://patchwork.kernel.org/project/intel-gfx/patch/20210208170253.29968-1-fred.gao@intel.com/" target="_blank" rel="noopener">vfio/pci: Add support for opregion v2.1+</a>, we can know:</p><ol><li>Before OpRegion v2.0(version 2.0), VBT data is stored in OpRegion mailbox #4,</li><li>For OpRegion v2.0 or v2.1+:<ul><li>When VBT size is less than 6KB, the VBT will be stored on OpRegion Mailbox 4</li><li>when VBT size exceeds 6KB:<ul><li>For OpRegion v2.0, the OpRegion Mailbox 3 RVDA store the absolute address of raw VBT data from OpRegion base</li><li>For OpRegion v2.1+, the OpRegion Mailbox 3 RVDA store the relative address of raw VBT data from OpRegion base</li></ul></li></ul></li></ol><hr><p>参考资料:</p><ol><li><a href="https://en.wikipedia.org/wiki/Video_BIOS" target="_blank" rel="noopener">Video BIOS</a></li><li><a href="https://en.wikipedia.org/wiki/Real_mode" target="_blank" rel="noopener">Real Mode</a></li><li><a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface" target="_blank" rel="noopener">UEFI</a></li><li><a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface" target="_blank" rel="noopener">ACPI</a></li><li><a href="https://en.wikipedia.org/wiki/Open_Firmware" target="_blank" rel="noopener">Open Firmware</a></li><li><a href="https://en.wikipedia.org/wiki/OpenBIOS" target="_blank" rel="noopener">OpenBIOS</a></li><li><a href="https://en.wikipedia.org/wiki/UEFI_Platform_Initialization" target="_blank" rel="noopener">Platform Initialization Specification</a></li><li><a href="https://en.wikipedia.org/wiki/System_Management_BIOS" target="_blank" rel="noopener">SMBIOS</a></li><li><a href="https://en.wikipedia.org/wiki/System_Management_Mode" target="_blank" rel="noopener">SMM</a></li><li><a href="https://en.wikipedia.org/wiki/Coreboot" target="_blank" rel="noopener">Coreboot</a></li><li><a href="https://en.wikipedia.org/wiki/Category:Graphics_software" target="_blank" rel="noopener">Category:Graphics software</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容源于:&lt;br&gt;&lt;a href=&quot;https://github.com/ZoranStojsavljevic/Video-BIOS-Table-parser-assembler/wiki/Video-BIOS-Table-(VBT)&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ZoranStojsavljevic/Video-BIOS-Table-parser-assembler/wiki/Video-BIOS-Table-(VBT)&lt;/a&gt; 并对相关内容做出补充。&lt;br&gt;
    
    </summary>
    
      <category term="GPU" scheme="http://liujunming.github.io/categories/GPU/"/>
    
    
      <category term="GPU" scheme="http://liujunming.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>CSM booting in UEFI</title>
    <link href="http://liujunming.github.io/2021/06/17/CSM-in-BIOS/"/>
    <id>http://liujunming.github.io/2021/06/17/CSM-in-BIOS/</id>
    <published>2021-06-17T08:05:11.000Z</published>
    <updated>2021-06-17T10:20:35.426Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface#CSM_booting" target="_blank" rel="noopener">CSM or Compatibility Support Module</a> is something that allows booting in legacy BIOS mode on UEFI systems.<br><a id="more"></a></p><p>From Wikipedia:</p><blockquote><p>To ensure backward compatibility, most UEFI firmware implementations on PC-class machines also support booting in legacy BIOS mode from MBR-partitioned disks, through the <em>Compatibility Support Module (CSM)</em> that provides legacy BIOS compatibility. In this scenario, booting is performed in the same way as on legacy BIOS-based systems.</p></blockquote><blockquote><p>The <em>Compatibility Support Module</em> allows legacy operating systems and some legacy <a href="https://en.wikipedia.org/wiki/Option_ROM" target="_blank" rel="noopener">option ROMs</a> that do not support UEFI to still be used.</p></blockquote><hr><p>参考资料:</p><ol><li><a href="https://superuser.com/questions/857117/what-is-csm-option" target="_blank" rel="noopener">What is CSM option</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface#CSM_booting&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSM or Compatibility Support Module&lt;/a&gt; is something that allows booting in legacy BIOS mode on UEFI systems.&lt;br&gt;
    
    </summary>
    
      <category term="Firmware" scheme="http://liujunming.github.io/categories/Firmware/"/>
    
    
      <category term="Firmware" scheme="http://liujunming.github.io/tags/Firmware/"/>
    
  </entry>
  
  <entry>
    <title>DMA Remapping:Memory Type</title>
    <link href="http://liujunming.github.io/2021/06/17/DMA-Remapping-Memory-Type/"/>
    <id>http://liujunming.github.io/2021/06/17/DMA-Remapping-Memory-Type/</id>
    <published>2021-06-17T04:45:20.000Z</published>
    <updated>2021-06-17T10:20:35.426Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录Intel VT-d spec中，“DMA Remapping”一章中“Memory Type”一节的相关笔记<a id="more"></a><br><img src="/images/2021/06/4.PNG" alt><br>devices operating inside  processor coherency domain ，这种devices(比如IGD,Intel processor Graphics Device)可以直接访问CPU L3 cache，对于这种devices，Memory-type才有意义。对于devices operating outside  processor coherency domain，可以忽略Memory-type。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录Intel VT-d spec中，“DMA Remapping”一章中“Memory Type”一节的相关笔记
    
    </summary>
    
      <category term="VT-d" scheme="http://liujunming.github.io/categories/VT-d/"/>
    
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
  <entry>
    <title>The motivation of VFIO</title>
    <link href="http://liujunming.github.io/2021/06/16/The-motivation-of-VFIO/"/>
    <id>http://liujunming.github.io/2021/06/16/The-motivation-of-VFIO/</id>
    <published>2021-06-16T12:18:55.000Z</published>
    <updated>2021-06-17T11:22:08.430Z</updated>
    
    <content type="html"><![CDATA[<p>这一年多以来陆陆续续听到了VFIO这个技术，知道它可以用来：(1)虚拟化下pass-thru device；(2)实现用户态驱动，如DPDK，SPDK等。但是，从未深入研究过VFIO。接下来，准备写一系列的博客来介绍这项技术。本文将介绍the motivation of VFIO。<a id="more"></a>本文内容主要源于大佬的slides。</p><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><blockquote><p>The VFIO driver is an IOMMU/device agnostic framework for exposing direct device access to userspace, in a secure, IOMMU protected environment.  In other words, this allows safe , non-privileged, userspace drivers.</p><p>Why do we want that?  Virtual machines often make use of direct device access (“device assignment”) when configured for the highest possible I/O performance.  From a device and host perspective, this simply turns the VM into a userspace driver, with the benefits of significantly reduced latency, higher bandwidth, and direct use of bare-metal device drivers.</p><p>Some applications, particularly in the high performance computing field, also benefit from low-overhead, direct device access from userspace.  Examples include network adapters (often non-TCP/IP based) and compute accelerators.  Prior to VFIO, these drivers had to either go through the full development cycle to become proper upstream driver, be maintained out of tree, or make use of the UIO framework, which has no notion of IOMMU protection, limited interrupt support, and requires root privileges to access things like PCI configuration space.</p><p>The VFIO driver framework intends to unify these, replacing both the KVM PCI specific device assignment code as well as provide a more secure, more featureful userspace driver environment than UIO.</p></blockquote><p>The use cases of VFIO are straightforward. Both of them need to directly access device:</p><ul><li><p>Virtualization guest OS</p></li><li><p>High performance user-level IO stacks such as DPDK</p></li></ul><p>VFIO claims that it replaced two exsiting things:</p><ul><li>UIO</li><li>KVM Legacy PCI Assignment</li></ul><h3 id="2-VFIO-vs-UIO"><a href="#2-VFIO-vs-UIO" class="headerlink" title="2. VFIO vs UIO"></a>2. VFIO vs UIO</h3><p>UIO, i.e. Userspace I/O.</p><h4 id="2-1-Basic-target-of-UIO-Enable-userspace-device-drivers"><a href="#2-1-Basic-target-of-UIO-Enable-userspace-device-drivers" class="headerlink" title="2.1 Basic target of UIO: Enable userspace device drivers:"></a>2.1 Basic target of UIO: Enable userspace device drivers:</h4><ul><li>Remap device MMIO to userspace</li><li>Remap kernel physical memory to userspace</li><li>Remap kernel virtual memory to userspace</li></ul><h4 id="2-2-What-is-missing"><a href="#2-2-What-is-missing" class="headerlink" title="2.2 What is missing:"></a>2.2 What is missing:</h4><ul><li>IRQ (partial support, polling mostly)</li><li>DMA</li></ul><h4 id="2-3-Why-DMA-capability-not-provided"><a href="#2-3-Why-DMA-capability-not-provided" class="headerlink" title="2.3 Why DMA capability not provided?"></a>2.3 Why DMA capability not provided?</h4><ul><li>IOMMU not considered from the beginning</li></ul><h4 id="2-4-Why-VFIO-is-different"><a href="#2-4-Why-VFIO-is-different" class="headerlink" title="2.4 Why VFIO is different?"></a>2.4 Why VFIO is different?</h4><ul><li>Full DMA capability from userspace</li><li>Full interrupt support to userspace</li></ul><h3 id="3-VFIO-vs-Legacy-PCI-Assignment"><a href="#3-VFIO-vs-Legacy-PCI-Assignment" class="headerlink" title="3. VFIO vs Legacy PCI Assignment"></a>3. VFIO vs Legacy PCI Assignment</h3><h4 id="3-1-Legacy-Assignment-the-Pros"><a href="#3-1-Legacy-Assignment-the-Pros" class="headerlink" title="3.1 Legacy Assignment: the Pros"></a>3.1 Legacy Assignment: the Pros</h4><ul><li>straight forward implementation</li></ul><h4 id="3-2-Legacy-Assignment-the-Cons"><a href="#3-2-Legacy-Assignment-the-Cons" class="headerlink" title="3.2 Legacy Assignment: the Cons"></a>3.2 Legacy Assignment: the Cons</h4><ul><li>the minimum granularity is PCI BDF<ul><li>How about a PCIe-to-PCI Bridge?</li><li>A device capable of Peer-to-Peer, but without ACS capability?</li></ul></li></ul><p><strong>“How about a PCIe-to-PCI Bridge?”的解释:</strong></p><p>设备利用自己的Source Identifier(包含Bus、Device、Func)来找到页表项以完成地址映射，不过如下特殊情况需要考虑:<br>对于由PCIe switch扩展出的PCI桥及桥下设备，在发送DMA请求时，Source Identifier是PCIe switch的，这样的话该PCI桥及桥下所有设备都会使用PCIe switch的Source Identifier去定位Context Entry，找到的页表也是同一个，如果将这个PCI桥下的不同设备分给不同虚机，由于会使用同一份页表，这样会产生问题。针对这种情况，当前PCI桥及桥下的所有设备必须分配给同一个虚机，这就是VFIO中group的概念。</p><p><strong>“A device capable of Peer-to-Peer, but without ACS capability?”的解释:</strong></p><p><a href="/2019/11/24/Introduction-to-PCIe-Access-Control-Services/#2-What-is-ACS">ACS的基本介绍</a></p><blockquote><p>This isolation is not always at the granularity of a single device though.  Even when an IOMMU is capable of this, properties of devices, interconnects, and IOMMU topologies can each reduce this isolation. For instance, an individual device may be part of a larger multi-function enclosure.  While the IOMMU may be able to distinguish between devices within the enclosure, the enclosure may not require transactions between devices to reach the IOMMU.  Examples of this could be anything from a multi-function PCI device with backdoors between functions to a non-PCI-ACS (Access Control Services) capable bridge allowing redirection without reaching the IOMMU. </p></blockquote><p>For VFIO, this isolation granularity is vfio_group instead of a single device.不会存在同一个group内的devices分配给多个虚拟机的情况。</p><h4 id="3-3-Why-VFIO-is-different"><a href="#3-3-Why-VFIO-is-different" class="headerlink" title="3.3 Why VFIO is different?"></a>3.3 Why VFIO is different?</h4><ul><li>the minimum granularity is vfio_group, which is derived from iommu_group</li><li>A PCIe-to-PCI hierarchy belongs to one group</li><li>Devices capable of Peer-to-Peer but without ACS capability, these devices belongs to one group(比如Device1和Device2之间可以Peer-to-Peer，但是没有ACS capability，如果将Device1 pass-thru给虚拟机1，将Device2 pass-thru给虚拟机2，就可能会破坏虚拟机的隔离性。因此需要将Device1和Device2放入同一个vfio_group中)</li></ul><hr><p>参考资料:</p><ol><li><a href="https://gdoc.pub/doc/e/2PACX-1vSsskD0A2XgHoZhaYLAkS7lmCOrfxkGXk1WTovWEAyeoELVdBjrE-NzD8h-NvJfKhxMpUg2aXzaD-XG" target="_blank" rel="noopener">Notes about Virtualization Yizhou Shan</a></li><li><a href="https://www.kernel.org/doc/Documentation/vfio.txt" target="_blank" rel="noopener">Kernel documentation: VFIO</a></li><li><a href="https://blog.csdn.net/hx_op/article/details/104029622" target="_blank" rel="noopener">VFIO概述</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一年多以来陆陆续续听到了VFIO这个技术，知道它可以用来：(1)虚拟化下pass-thru device；(2)实现用户态驱动，如DPDK，SPDK等。但是，从未深入研究过VFIO。接下来，准备写一系列的博客来介绍这项技术。本文将介绍the motivation of VFIO。
    
    </summary>
    
      <category term="VFIO" scheme="http://liujunming.github.io/categories/VFIO/"/>
    
    
      <category term="VFIO" scheme="http://liujunming.github.io/tags/VFIO/"/>
    
  </entry>
  
</feed>
