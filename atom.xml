<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2018-09-05T12:49:29.151Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并查集</title>
    <link href="http://liujunming.github.io/2018/09/05/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://liujunming.github.io/2018/09/05/并查集/</id>
    <published>2018-09-05T03:40:50.000Z</published>
    <updated>2018-09-05T12:49:29.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并查集概念"><a href="#并查集概念" class="headerlink" title="并查集概念"></a>并查集概念</h2><p>并查集是一种用来管理元素分组情况的数据结构。并查集可以高效地进行如下操作。</p><ul><li>查询元素a和元素b是否属于同一组。</li><li>合并元素a和元素b所在的组。</li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisjointSets</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent, rank;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DisjointSets(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">        rank = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == parent[p])</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        parent[p] = find(parent[p]);</span><br><span class="line">        <span class="keyword">return</span> parent[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[rootQ] &gt; rank[rootP]) &#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootP] == rank[rootQ]) &#123;</span><br><span class="line">                rank[rootP]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Disjoint Sets （以下简称DS）的本质是许多棵树。每个圈子里的元素都组成了一棵树。然而我们的表示方法并不是用常规tree node的方法记录的，而是用数组.</p><p>DS里面拥有一个大小为N的vector <code>parent</code>，对于parent[i],存储着第i号元素所属圈子的老大。DS里面的另一个vector <code>rank</code>用来存储树的高度，它的作用会在Union操作中体现出来。</p><p>DS里面经典的两个操作分别是find和Union.</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p> find就是寻找这个圈子的老大（这棵树的root）。对于find来说，在寻找root的过程中，我们不仅要找到root，还要把沿途经过的所有node的parent都变成root，也就是把自己和沿途所有的node都变成root的孩子（同时也变成了深度为1的leaf）。这个操作叫path compression，意义在于下次我们如果寻找这些node的老大，就可以一步到位了（直接通过parent[i]找到root）。这对时间复杂度的优化是非常重要的。</p><h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p> Union是什么？是我们知道了两个元素属于同一个圈子。如果我们的DS已经知道这一点，那么没问题，如果我们的DS不知道这一点，我们要告诉它。并且很重要的是，这里不是针对两个元素，而是要把这两个元素所处的两个圈子融合成一个圈子，这也就是Union叫法的由来。那么我们分别用find找到两个元素所处tree的root，然后通过比较rank[root]的大小看哪棵树更大。最后我们把小的那棵树的root变成大的那棵树的root的孩子。之所以要选择把小的那棵树融合进大的那棵树，是因为我们希望让树的孩子的高度都尽量小。假设小的树的孩子数量是N1，大的树的孩子数量是N2。如果把小数融合进大树，那么我们让N1个node的高度都增加了1，反之我们要让N2个node的高度都增加1。后者明显是违反我们希望让树的孩子的高度都尽量小这个意愿的。<br> <a href="https://www.youtube.com/watch?v=ID00PMy0-vE" target="_blank" rel="noopener">Disjoint Sets using union by rank and path compression Graph Algorithm</a>中以具体的例子演示了Union的过程。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="Friend-Circles"><a href="#Friend-Circles" class="headerlink" title="Friend Circles"></a><a href="https://leetcode.com/problems/friend-circles/description/" target="_blank" rel="noopener">Friend Circles</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DisjointSets</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent, rank;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DisjointSets(<span class="keyword">int</span> num) &#123;</span><br><span class="line">            count = num;</span><br><span class="line">            parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">            rank = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p == parent[p])</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            parent[p] = find(parent[p]);</span><br><span class="line">            <span class="keyword">return</span> parent[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">            <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            count -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootQ] &gt; rank[rootP]) &#123;</span><br><span class="line">                parent[rootP] = rootQ;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootQ] = rootP;</span><br><span class="line">                <span class="keyword">if</span> (rank[rootP] == rank[rootQ]) &#123;</span><br><span class="line">                    rank[rootP]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        DisjointSets ds(M.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = M.size(); i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[i][j]) ds.unionTwo(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ds.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于整个matrix，如果M[i][j]为1，我们则需要告诉DS i和j属于一个圈子。这里因为对称性，我们只需要遍历半个matrix就可以得到所有信息。在DS里面我增加了一个count。count代表现在DS中独立圈子的数量。因为最开始我们什么信息都不知道，假设每个人都属于自己的独立圈子，所以count为人的个数，之后每一次Union操作，如果我们发现i和j所处圈子（的老大）不同（root1 ！= root2），那么说明有两个圈子要合并成一个，那么就少了一个圈子，所以count要减1.最后我们返回count，也就是圈子的数量。</p><h3 id="Number-of-Islands"><a href="#Number-of-Islands" class="headerlink" title="Number of Islands"></a><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener">Number of Islands</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DisjointSets</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent, rank;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DisjointSets(<span class="keyword">int</span> num) &#123;</span><br><span class="line">            count = num;</span><br><span class="line">            parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">            rank = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p == parent[p])</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            parent[p] = find(parent[p]);</span><br><span class="line">            <span class="keyword">return</span> parent[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">            <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            count -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootQ] &gt; rank[rootP]) &#123;</span><br><span class="line">                parent[rootP] = rootQ;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootQ] = rootP;</span><br><span class="line">                <span class="keyword">if</span> (rank[rootP] == rank[rootQ]) &#123;</span><br><span class="line">                    rank[rootP]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(grid.size() == <span class="number">0</span> || grid[<span class="number">0</span>].size() ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    hashMap[i*n+j] = num;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">DisjointSets <span class="title">ds</span><span class="params">(num)</span></span>;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; hashMap.count((i<span class="number">-1</span>)*n+j))&#123;</span><br><span class="line">                        ds.unionTwo(hashMap[(i<span class="number">-1</span>)*n+j], hashMap[i*n+j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i + <span class="number">1</span> &lt; m &amp;&amp; hashMap.count((i+<span class="number">1</span>)*n+j))&#123;</span><br><span class="line">                        ds.unionTwo(hashMap[(i+<span class="number">1</span>)*n+j], hashMap[i*n+j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; hashMap.count(i*n+j<span class="number">-1</span>))&#123;</span><br><span class="line">                        ds.unionTwo(hashMap[i*n+j<span class="number">-1</span>], hashMap[i*n+j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; hashMap.count(i*n+j+<span class="number">1</span>))&#123;</span><br><span class="line">                        ds.unionTwo(hashMap[i*n+j+<span class="number">1</span>], hashMap[i*n+j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ds.getCount();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><a href="https://blog.csdn.net/niushuai666/article/details/6662911" target="_blank" rel="noopener">超有爱的并查集~</a></li><li><a href="https://www.youtube.com/watch?v=ID00PMy0-vE" target="_blank" rel="noopener">Disjoint Sets using union by rank and path compression Graph Algorithm</a></li><li><a href="https://zhuanlan.zhihu.com/p/32112569" target="_blank" rel="noopener">Disjoint Sets / Union Find</a></li><li><a href="https://www.youtube.com/watch?v=JZBQLXgSGfs" target="_blank" rel="noopener">Union Find Kruskal’s Algorithm</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并查集概念&quot;&gt;&lt;a href=&quot;#并查集概念&quot; class=&quot;headerlink&quot; title=&quot;并查集概念&quot;&gt;&lt;/a&gt;并查集概念&lt;/h2&gt;&lt;p&gt;并查集是一种用来管理元素分组情况的数据结构。并查集可以高效地进行如下操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询元素a和元
      
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统中需要记住的数字</title>
    <link href="http://liujunming.github.io/2018/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%9C%80%E8%A6%81%E8%AE%B0%E4%BD%8F%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://liujunming.github.io/2018/07/02/计算机系统中需要记住的数字/</id>
    <published>2018-07-02T01:54:58.000Z</published>
    <updated>2018-07-02T01:54:58.407Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Bloom-Filter的解析</title>
    <link href="http://liujunming.github.io/2018/05/25/Bloom-Filter%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://liujunming.github.io/2018/05/25/Bloom-Filter的解析/</id>
    <published>2018-05-25T05:01:58.000Z</published>
    <updated>2018-06-28T13:54:07.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bloom-Filter概念"><a href="#Bloom-Filter概念" class="headerlink" title="Bloom Filter概念"></a>Bloom Filter概念</h2><p>Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ul><li><p>初始状态<br>Bloom Filter是一个m位的位数组，且数组被0所填充。同时，我们需要定义k个不同的hash函数，每一个hash函数都随机的将每一个输入元素映射到位数组中的一个位上。那么对于一个确定的输入，我们会得到k个索引。</p></li><li><p>插入元素<br>经过k个hash函数的映射，我们会得到k个索引，我们把位数组中这k个位置全部置1（不管其中的位之前是0还是1）</p></li><li>查询元素<br>输入元素经过k个hash函数的映射会得到k个索引，如果位数组中这k个索引任意一处是0，那么就说明这个元素不在集合之中；如果元素处于集合之中，那么当插入元素的时候这k个位都是1。但如果这k个索引处的位都是1，被查询的元素就一定在集合之中吗？答案是不一定，也就是说出现了False Positive的情况。<br><img src="/images/2018/5/6.png" alt=""><br>在上图中，当插入x、y、z这三个元素之后，再来查询w，会发现w不在集合之中，而如果w经过三个hash函数计算得出的结果所得索引处的位全是1，那么Bloom Filter就会告诉你，w在集合之中，实际上这里是误报，w并不在集合之中。</li></ul><h2 id="误报率估计"><a href="#误报率估计" class="headerlink" title="误报率估计"></a>误报率估计</h2><p><img src="/images/2018/5/7.png" alt=""></p><h2 id="Bloom-Filter的实现"><a href="#Bloom-Filter的实现" class="headerlink" title="Bloom Filter的实现"></a>Bloom Filter的实现</h2><p>纸上得来终觉浅，绝知此事要躬行。</p><p><a href="https://github.com/liujunming/Tools/tree/master/BloomFilter" target="_blank" rel="noopener">Bloom Filter的实现</a></p><p>若读者想深入研究Bloom Filter，可以去知网下载《基于LSM-tree键值系统读性能优化》(张月明)。</p><hr><p>参考资料:</p><ol><li><a href="https://my.oschina.net/kiwivip/blog/133498" target="_blank" rel="noopener">Bloom Filter 算法简介</a></li><li><a href="http://www.cnblogs.com/kaituorensheng/p/3669140.html" target="_blank" rel="noopener">实例学习Bloom Filter</a></li><li><a href="https://blog.csdn.net/jiaomeng/article/details/1495500" target="_blank" rel="noopener">Bloom Filter概念和原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Bloom-Filter概念&quot;&gt;&lt;a href=&quot;#Bloom-Filter概念&quot; class=&quot;headerlink&quot; title=&quot;Bloom Filter概念&quot;&gt;&lt;/a&gt;Bloom Filter概念&lt;/h2&gt;&lt;p&gt;Bloom Filter是一种空间效率很高的
      
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>perf内核源码解析</title>
    <link href="http://liujunming.github.io/2018/05/10/perf%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://liujunming.github.io/2018/05/10/perf内核源码解析/</id>
    <published>2018-05-10T04:06:14.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文所演示的内核版本为<a href="https://elixir.bootlin.com/linux/v3.14.69/source" target="_blank" rel="noopener">3.14.69</a>，平台架构为x86架构,主要以<a href="https://www.zybuluo.com/ljm/note/1125361" target="_blank" rel="noopener">通过perf测试进程的内存带宽</a>为例，讲述了在内核的调用过程。</p><h2 id="perf用户态使用"><a href="#perf用户态使用" class="headerlink" title="perf用户态使用"></a>perf用户态使用</h2><p>在用户态，用户可以调用<a href="https://elixir.bootlin.com/linux/v3.14.69/source/kernel/events/core.c#L7094" target="_blank" rel="noopener">perf_event_open</a>系统调用来使用perf。<br>建议读者好好阅读下下面推荐的资料，这样可以对perf_event_open的理解更加深刻些。</p><ol><li><a href="http://man7.org/linux/man-pages/man2/perf_event_open.2.html" target="_blank" rel="noopener">man2　perf_event_open</a></li><li><a href="http://ozlabs.org/~anton/junkcode/perf_events_example1.c" target="_blank" rel="noopener">perf events self profiling example</a></li><li><a href="http://hchen229.iteye.com/blog/585434" target="_blank" rel="noopener">使用performance counter读取硬件或软件Event</a></li><li><a href="https://blog.csdn.net/u012884354/article/details/45720737" target="_blank" rel="noopener">perf_event_open 设置性能监视</a></li></ol><h2 id="perf-event子系统架构"><a href="#perf-event子系统架构" class="headerlink" title="perf event子系统架构"></a>perf event子系统架构</h2><p><img src="/images/2018/5/1.png" alt=""></p><p>The Linux Perf_Event Subsystem consists of the files <a href="https://elixir.bootlin.com/linux/v3.14.69/source/kernel/events/core.c" target="_blank" rel="noopener">core.c</a> and <a href="https://elixir.bootlin.com/linux/v3.14.69/source/arch/x86/kernel/cpu/perf_event.c" target="_blank" rel="noopener">perf_event.c</a>. These files are the interface between the linux kernel and various user space performance monitoring tool.</p><h2 id="perf-event子系统中的数据结构"><a href="#perf-event子系统中的数据结构" class="headerlink" title="perf event子系统中的数据结构"></a>perf event子系统中的数据结构</h2><p>数据结构的定义在<a href="https://elixir.bootlin.com/linux/v3.14.69/source/include/linux/perf_event.h" target="_blank" rel="noopener">perf_event.h</a>文件中。</p><p>The following are some of the important data structures which are used by the perf_event subsystem.</p><p><img src="/images/2018/5/2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct perf_event;</span><br><span class="line">struct perf_event_attr;</span><br><span class="line">struct perf_event_context;</span><br><span class="line">struct pmu;</span><br></pre></td></tr></table></figure><p><strong>Important Fields in the Data Structures</strong></p><h3 id="perf-event"><a href="#perf-event" class="headerlink" title="perf_event"></a>perf_event</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event</span> *<span class="title">group_leader</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmu</span> *<span class="title">pmu</span>;</span></span><br><span class="line">u64 total_time_enabled;</span><br><span class="line">u64 total_time_running;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_attr</span> <span class="title">attr</span>;</span></span><br><span class="line"><span class="keyword">atomic64_t</span> child_count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span> *<span class="title">ctx</span>;</span></span><br><span class="line"><span class="keyword">perf_overflow_handler_t</span> overflow_handler;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>Description:</strong></p><ul><li>group_leader<br>This field specifies the leader of the group of events attached to the process.</li><li>pmu<br>This field points to the generic performance monitoring unit structure.</li><li>total_time_enabled<br>This field specify the total time in nanoseconds that the event has been enabled.</li><li>total_time_running<br>This field specify total time in nanoseconds that the event is running(scheduled onto the<br>CPU)</li><li>owner<br>This field points to the task structure of the process which has monitoring this event.</li></ul><h3 id="perf-event-attr"><a href="#perf-event-attr" class="headerlink" title="perf_event_attr"></a>perf_event_attr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_attr</span> &#123;</span></span><br><span class="line">__u32 type;</span><br><span class="line">__u64 config;</span><br><span class="line">__u64 sample_period;</span><br><span class="line">__u64 sample_freq;</span><br><span class="line">__u64 sample_type;</span><br><span class="line">exclusive : <span class="number">1</span>,</span><br><span class="line">exclude_user : <span class="number">1</span>,</span><br><span class="line">exclude_kernel : <span class="number">1</span>,</span><br><span class="line">exclude_hv : <span class="number">1</span>,</span><br><span class="line">exclude_idle : <span class="number">1</span>,</span><br><span class="line">exclude_host : <span class="number">1</span>,</span><br><span class="line">exclude_guest : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>Description:</strong></p><ul><li>type<br>This field specifies the overall event type.</li><li>config<br>This field specifies which event needs to be monitored. It is used along with type to<br>decide the exact event.</li><li>sample_period, sample_freq<br>Sampling period defines the N value where N is the number of events after which the<br>interrupt is generated. It can be counted in terms of frequency as well.</li><li>sample_type<br>The various bits in this field specify which values to include in the sample.</li><li>exclude_user<br>This bit when enabled the count excludes the user-space events.</li><li>exclude_kernel<br>This bit when enabled the count exclude the kernel-space events.</li></ul><h3 id="perf-event-context"><a href="#perf-event-context" class="headerlink" title="perf_event_context"></a>perf_event_context</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">event_list</span>;</span></span><br><span class="line"><span class="keyword">int</span> nr_events;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span> *<span class="title">parent_ctx</span>;</span></span><br><span class="line">u64 time;</span><br><span class="line">u64 timestamp; &#125;</span><br></pre></td></tr></table></figure><p><strong>Description:</strong></p><ul><li>event_lists<br>This field specifies the list of events.</li><li>nr_events<br>This field specifies the number of events that are currently monitored.</li><li>parent_ctx<br>This fields points to the context of the processes parent.</li><li>time,timestamp<br>These are context clocks, they run when the context is enabled.</li></ul><h3 id="pmu"><a href="#pmu" class="headerlink" title="pmu"></a>pmu</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmu</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> (*pmu_enable) (struct pmu *pmu);</span><br><span class="line"><span class="keyword">void</span> (*pmu_disable) (struct pmu *pmu);</span><br><span class="line"><span class="keyword">void</span> (*start) (struct perf_event *event, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">void</span> (*stop) (struct perf_event *event, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">void</span> (*read) (struct perf_event *event); &#125;</span><br></pre></td></tr></table></figure><p><strong>Description:</strong><br>This structure majorly contains the function pointers to various PMU related functions.</p><ul><li>pmu_enable,pmu_disable<br>These functions are used to fully disable/enable a PMU.</li><li>start,stop<br>These functions are used to start or stop a counter on a PMU.</li><li>read<br>This function is used to update the event value for a particular counter.</li></ul><h2 id="Counting-Support-in-Linux-Perf"><a href="#Counting-Support-in-Linux-Perf" class="headerlink" title="Counting Support in Linux Perf"></a>Counting Support in Linux Perf</h2><p>perf_event assigns one file descriptor per event and either per-thread or per-CPU. The system call perf_event_open() configures the hardware MSRs and creates a file descriptor which can be used for reading the performance measurement data. Once the file descriptor is obtained we can issue subsequent read calls to get the values of the performance counters. These values are then aggregated at the end of the program execution.</p><p>The following is the execution flow for getting the file descriptor.</p><p><img src="/images/2018/5/4.png" alt=""></p><p>For enabling and disabling performance monitoring events we use the ioclt and prctl system calls.</p><p>Execution flow of the read system call:<br> <img src="/images/2018/5/5.png" alt=""></p><h2 id="perf-event-open系统调用的具体过程"><a href="#perf-event-open系统调用的具体过程" class="headerlink" title="perf_event_open系统调用的具体过程"></a>perf_event_open系统调用的具体过程</h2><p><img src="/images/2018/5/3.png" alt=""></p><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><p>好了，背景知识终于介绍完成了，下面介绍下具体的实例，方便读者理解。<br><code>perf stat -e cache-misses -I 1000 -p 2234</code><br>每隔1000ms，会输出2234进程在过去1000ms的cache_misses硬件事件，这是如何做到的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">type:<span class="number">0</span> <span class="comment">//PERF_TYPE_HARDWARE</span></span><br><span class="line">config:<span class="number">3</span> <span class="comment">//PERF_COUNT_HW_CACHE_MISSES</span></span><br></pre></td></tr></table></figure><p>每隔1000ms输出结果是通过用户态程序控制的，阅读完<a href="http://hchen229.iteye.com/blog/585434" target="_blank" rel="noopener">使用performance counter读取硬件或软件Event</a>中的程序即可明白。</p><p>当需要监听2234进程的cache_misses时，实际上是对2234进程中的所有线程进行监听,假设线程的数目为5个，此刻，会调用perf_event_open系统调用5次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">perf_event_read_one</span><span class="params">(struct perf_event *event,</span></span></span><br><span class="line"><span class="function"><span class="params">                 u64 read_format, <span class="keyword">char</span> __user *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u64 enabled, running;</span><br><span class="line">    u64 values[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    values[n++] = perf_event_read_value(event, &amp;enabled, &amp;running);</span><br><span class="line">    printk(<span class="string">"&lt;0&gt;"</span><span class="string">"liujunming  perf_event_read_one value%llu\n"</span>, values[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (read_format &amp; PERF_FORMAT_TOTAL_TIME_ENABLED)</span><br><span class="line">        values[n++] = enabled;</span><br><span class="line">    <span class="keyword">if</span> (read_format &amp; PERF_FORMAT_TOTAL_TIME_RUNNING)</span><br><span class="line">        values[n++] = running;</span><br><span class="line">    <span class="keyword">if</span> (read_format &amp; PERF_FORMAT_ID)</span><br><span class="line">        values[n++] = primary_event_id(event);</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, values, n * <span class="keyword">sizeof</span>(u64)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="keyword">sizeof</span>(u64);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>perf_event_read_value会读取相应线程寄存器中记录的cache_miss值。</p><p>当统计2234进程时，实际上是对它5个线程的cache_misses值进行累加。假设前２秒内，2234进程的cache_misses为10000,前3秒内，2234进程的cache_misses为30000。那么在2~3秒这一秒内，进程的cache_misses即为20000。</p><hr><p>参考资料:</p><ol><li><a href="http://rts.lab.asu.edu/web_438/project_final/CSE_598_Performance_Monitoring_Unit.pdf" target="_blank" rel="noopener">A Study of Performance Monitoring Unit, perf and perf_events subsystem</a></li><li><a href="http://cdmd.cnki.com.cn/Article/CDMD-10358-1011284067.htm" target="_blank" rel="noopener">龙芯多核平台上性能分析工具的设计与实现</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文所演示的内核版本为&lt;a href=&quot;https://elixir.bootlin.com/linux/v3.14.69/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;3.14.69&lt;/a&gt;，平台架构为x86架构,主要以&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>深度解析perf</title>
    <link href="http://liujunming.github.io/2018/04/24/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90perf/"/>
    <id>http://liujunming.github.io/2018/04/24/深度解析perf/</id>
    <published>2018-04-24T12:27:04.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zybuluo.com/ljm/note/1125361" target="_blank" rel="noopener">通过perf测试进程的内存带宽</a></p><h2 id="perf的基本原理"><a href="#perf的基本原理" class="headerlink" title="perf的基本原理"></a>perf的基本原理</h2><p>Perf 是内置于 Linux 内核源码树中的性能剖析（profiling）工具。它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析，可用于性能瓶颈的查找与热点代码的定位。</p><p>以监测“cycles”事件为例，perf的工作过程如下：<br>首先，perf 会通过系统调用sys_perf_event_open在内核中注册一个监测“cycles”事件的性能计数器。内核根据perf提供的信息在PMU(Performance Monitoring Unit)上初始化一个硬件性能计数器（PMC:Performance Monitoring Counter）。PMC随着CPU周期的增加而自动累加。在PMC溢出时，PMU触发一个PMI（Performance Monitoring Interrupt）中断。内核在PMI中断的处理函数中保存PMC的计数值，触发中断时的指令地址（Register IP：Instruction Pointer），当前时间戳以及当前进程的PID，TID，comm等信息。我们把这些信息统称为一个采样（sample）。内核会将收集到的sample放入用于跟用户空间通信的Ring Buffer。用户空间里的perf分析程序采用mmap机制从Ring Buffer中读入采样，并对其解析。perf根据pid，comm等信息可以找到对应的进程。根据IP与ELF文件中的符号表可以查到触发PMI中断的指令所在的函数。</p><p>根据上述的perf采样原理可以得知，perf假设两次采样之间，即两次相邻的PMI中断之间系统执行的是同一个进程的同一个函数。这种假设会带来一定的误差，当读者感觉perf给出的结果不准时，不妨提高采样频率，perf会给出更加精确的结果。</p><h2 id="perf-list简介"><a href="#perf-list简介" class="headerlink" title="perf list简介"></a>perf list简介</h2><p>事件可以分为三种：</p><ol><li>Hardware Event由PMU部件产生，在特定的条件下探测性能事件是否发生以及发生的次数。比如cache命中。</li><li>Software Event是内核产生的事件，分布在各个功能模块中，统计和操作系统相关性能事件。比如进程切换，tick数等。</li><li>Tracepoint Event是内核中静态tracepoint所触发的事件，这些tracepoint用来判断程序运行期间内核的行为细节，比如slab分配器的分配次数等。</li></ol><h2 id="性能事件的属性"><a href="#性能事件的属性" class="headerlink" title="性能事件的属性"></a>性能事件的属性</h2><p>硬件性能事件由处理器中的PMU提供支持。由于现代处理器的主频非常高，再加上深度流水线机制，从性能事件被触发，到处理器响应 PMI中断，流水线上可能已处理过数百条指令。那么PMI中断采到的指令地址就不再是触发性能事件的那条指令的地址了，而且可能具有非常严重的偏差。为了解决这个问题，Intel处理器通过PEBS机制实现了高精度事件采样。PEBS通过硬件在计数器溢出时将处理器现场直接保存到内存（而不是在响应中断时才保存寄存器现场），从而使得 perf能够采到真正触发性能事件的那条指令的地址，提高了采样精度。在默认条件下，perf不使用PEBS机制。用户如果想要使用高精度采样，需要在指定性能事件时，在事件名后添加后缀”:p”或”:pp”。<br>Perf在采样精度上定义了4个级别，如下表所示。</p><table><thead><tr><th>级别</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>无精度保证</td></tr><tr><td>1</td><td>采样指令与触发性能事件的指令之间的偏差为常数（:p）</td></tr><tr><td>2</td><td>需要尽量保证采样指令与触发性能事件的指令之间的偏差为0（:pp）</td></tr><tr><td>3</td><td>保证采样指令与触发性能事件的指令之间的偏差必须为0（:ppp）</td></tr></tbody></table><center>性能事件的精度级别</center><p>目前的X86处理器，包括Intel处理器与AMD处理器均仅能实现前 3 个精度级别。</p><p>除了精度级别以外，性能事件还具有其它几个属性，均可以通过”event:X”的方式予以指定。</p><table><thead><tr><th>标志</th><th>属性</th></tr></thead><tbody><tr><td>u</td><td>仅统计用户空间程序触发的性能事件</td></tr><tr><td>k</td><td>仅统计内核触发的性能事件</td></tr><tr><td>h</td><td>仅统计Hypervisor触发的性能事件</td></tr><tr><td>G</td><td>在KVM虚拟机中，仅统计Guest系统触发的性能事件</td></tr><tr><td>H</td><td>仅统计 Host 系统触发的性能事件</td></tr><tr><td>p</td><td>精度级别</td></tr></tbody></table><center>性能事件的属性</center><hr><p>参考资料:</p><ol><li><a href="http://files.cnblogs.com/files/jiayy/Linux%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%BA%A7%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%E5%B7%A5%E5%85%B7-perf-1.pdf" target="_blank" rel="noopener">Linux 的系统级性能剖析工具‐perf</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.zybuluo.com/ljm/note/1125361&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;通过perf测试进程的内存带宽&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;perf的基本原理&quot;&gt;&lt;a href=&quot;#pe
      
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>自我总结</title>
    <link href="http://liujunming.github.io/2018/04/19/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93/"/>
    <id>http://liujunming.github.io/2018/04/19/自我总结/</id>
    <published>2018-04-19T08:12:33.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直认为自己是在搞系统的，但是忽然发现对系统的好多知识都不够了解。必须做到在计算机系统结构、操作系统内核、网络、分布式系统、算法这些领域都能游刃有余，方能运筹帷幄，决胜千里。</p><p>上了研究生，学习的渠道可能就是博客、论文这些，但是缺乏一个系统的学习流程，后来发现是自己书看的太少了，思考的太少。</p><p>下面列出自己需要看完的书籍吧：</p><ul><li><a href="https://raw.githubusercontent.com/QSCTech/zju-icicles/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%95%99%E6%9D%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E9%87%8F%E5%8C%96%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%94%E7" target="_blank" rel="noopener">计算机体系结构：量化研究方法</a></li></ul><p><a href="https://booksite.elsevier.com/9780123838728/references.php" target="_blank" rel="noopener">Reference Appendices</a><br>两位作者凭借此书，刚刚获得图灵奖，这本书的价值不言而喻。<br><img src="/images/2018/4/11.jpg" alt=""></p><ul><li><p>现代操作系统</p></li><li><p>计算机网络(自顶向下方法)</p></li><li><p>Designing Data-Intensive Applications</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直认为自己是在搞系统的，但是忽然发现对系统的好多知识都不够了解。必须做到在计算机系统结构、操作系统内核、网络、分布式系统、算法这些领域都能游刃有余，方能运筹帷幄，决胜千里。&lt;/p&gt;
&lt;p&gt;上了研究生，学习的渠道可能就是博客、论文这些，但是缺乏一个系统的学习流程，后来发现是
      
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>通过Linux内核使用RDT</title>
    <link href="http://liujunming.github.io/2018/04/18/%E9%80%9A%E8%BF%87Linux%E5%86%85%E6%A0%B8%E4%BD%BF%E7%94%A8RDT/"/>
    <id>http://liujunming.github.io/2018/04/18/通过Linux内核使用RDT/</id>
    <published>2018-04-18T06:40:00.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://liujunming.top/2018/04/11/Intel-RDT%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">Intel RDT特性详解</a>介绍了RDT的基本概念，以及通过PQOS工具使用RDT。本文主要是介绍如何通过内核来使用RDT。</p><p>我的内核版本为<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.14.32.tar.gz" target="_blank" rel="noopener">4.14.32</a>，内核对RDT的支持有版本要求，详情请参考<a href="https://github.com/intel/intel-cmt-cat/wiki" target="_blank" rel="noopener">OS interface feature support</a>。cpu型号为Intel Xeon E5 2650 v4，共两个cpu。</p><h2 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h2><p>RDT技术的选项位于“processor type and feature” -&gt; “Intel Resource Director Technology Allocation support”。</p><p><img src="/images/2018/4/9.png" alt=""></p><p><img src="/images/2018/4/10.png" alt=""></p><h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><p><code>mount -t resctrl resctrl /sys/fs/resctrl</code></p><h2 id="Resource-alloc-and-monitor-groups"><a href="#Resource-alloc-and-monitor-groups" class="headerlink" title="Resource alloc and monitor groups"></a>Resource alloc and monitor groups</h2><h3 id="Resource-groups"><a href="#Resource-groups" class="headerlink" title="Resource groups"></a>Resource groups</h3><ul><li>CTRL_MON groups</li></ul><p>Resource groups are represented as directories in the resctrl file system.  The default group is the root directory which, immediately after mounting, owns all the tasks and cpus in the system and can make full use of all resources.<br>On a system with RDT control features additional directories can be created in the root directory that specify different amounts of each resource. The root and these additional top level directories are referred to as “CTRL_MON” groups.</p><ul><li>MON groups</li></ul><p>On a system with RDT monitoring the root directory and other top level directories contain a directory named “mon_groups” in which additional directories can be created to monitor subsets of tasks in the CTRL_MON group that is their ancestor. These are called “MON” groups.</p><h3 id="All-groups-contain-the-following-files"><a href="#All-groups-contain-the-following-files" class="headerlink" title="All groups contain the following files"></a>All groups contain the following files</h3><ul><li>tasks<br>Reading this file shows the list of all tasks that belong to this group. Writing a task id to the file will add a task to the group.</li><li>cpus<br>是一个16进制整数，每一个bit代表一个CPU核心，比如我这里有10个“f”，意味着该机器有40个core。</li></ul><h4 id="When-control-is-enabled"><a href="#When-control-is-enabled" class="headerlink" title="When control is enabled"></a>When control is enabled</h4><p>When control is enabled all CTRL_MON groups will also contain:</p><ul><li>schemata<br>策略表，每个策略一行，格式为：<br>L3: cache_id0 = cbm; cache_id1 = cbm<br>这里的cache id可以理解为CPU id，而后面的cbm是分配给cpu的L3单元数量。我这块CPU每个socket会有11个L3 cache 单元也就是7ff。就是指在cpu cache的每个组内，group可以使用的cache line的数量。</li></ul><h4 id="When-monitoring-is-enabled"><a href="#When-monitoring-is-enabled" class="headerlink" title="When monitoring is enabled"></a>When monitoring is enabled</h4><p>When monitoring is enabled all MON groups will also contain:</p><ul><li>mon_data<br>This contains a set of files organized by L3 domain and by RDT event. E.g. on a system with two L3 domains there will be subdirectories “mon_L3_00” and “mon_L3_01”.    Each of these directories have one file per event (e.g. “llc_occupancy”, “mbm_total_bytes”, and “mbm_local_bytes”). In a MON group these files provide a read out of the current value of the event for all tasks in the group(在MON组中，这些文件为组中的所有任务提供读取当前事件的值).</li></ul><h2 id="Examples-for-RDT-allocation-usage"><a href="#Examples-for-RDT-allocation-usage" class="headerlink" title="Examples for RDT allocation usage"></a>Examples for RDT allocation usage</h2><p>具体例子请参考<a href="https://www.kernel.org/doc/Documentation/x86/intel_rdt_ui.txt" target="_blank" rel="noopener">intel_rdt_ui.txt</a></p><h2 id="Examples-for-RDT-Monitoring-along-with-allocation-usage"><a href="#Examples-for-RDT-Monitoring-along-with-allocation-usage" class="headerlink" title="Examples for RDT Monitoring along with allocation usage"></a>Examples for RDT Monitoring along with allocation usage</h2><p>具体例子请参考<a href="https://www.kernel.org/doc/Documentation/x86/intel_rdt_ui.txt" target="_blank" rel="noopener">intel_rdt_ui.txt</a></p><hr><p>参考资料：</p><ol><li><a href="https://www.kernel.org/doc/Documentation/x86/intel_rdt_ui.txt" target="_blank" rel="noopener">intel_rdt_ui.txt</a></li><li><a href="http://www.litrin.net/2017/02/21/linux-4-10%E4%B8%ADcat%E7%9A%84%E4%BD%BF%E7%94%A8/2/" target="_blank" rel="noopener">Linux 4.10中CAT的使用</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://liujunming.top/2018/04/11/Intel-RDT%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Intel RDT特性详解&lt;/a
      
    
    </summary>
    
      <category term="计算机系统" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机系统" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统资料</title>
    <link href="http://liujunming.github.io/2018/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%96%99/"/>
    <id>http://liujunming.github.io/2018/04/17/分布式系统资料/</id>
    <published>2018-04-17T01:47:04.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>汇总分布式系统的资料。</p><ul><li><a href="https://www.cs.rutgers.edu/~pxk/417/notes/index.html" target="_blank" rel="noopener">rutgers Distributed Systems </a></li><li><a href="http://www.scs.stanford.edu/17au-cs244b/" target="_blank" rel="noopener">Stanford Distributed Systems</a></li><li><a href="http://nil.csail.mit.edu/6.824/2017/index.html" target="_blank" rel="noopener">Mit Distributed Systems</a></li><li><a href="https://github.com/feixiao/Distributed-Systems" target="_blank" rel="noopener">MIT课程《Distributed Systems 》学习和翻译</a></li><li><a href="https://github.com/zhenlohuang/awesome-distributed-systems" target="_blank" rel="noopener">awesome-distributed-systems</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;汇总分布式系统的资料。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cs.rutgers.edu/~pxk/417/notes/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;rutgers Distribute
      
    
    </summary>
    
      <category term="分布式系统" scheme="http://liujunming.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://liujunming.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Intel RDT特性详解</title>
    <link href="http://liujunming.github.io/2018/04/11/Intel-RDT%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
    <id>http://liujunming.github.io/2018/04/11/Intel-RDT特性详解/</id>
    <published>2018-04-11T01:24:01.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>英特尔至强 E5-2600 v4在对外宣传时候号称“为云而生”的，除了其强大的性能和众多核心外，主要亮点就是Resource Director Technology（RDT）新技术的加入。使得其有理由宣称“为云而生”。<br>我们知道在一个虚拟化环境中，宿主机的资源（包括CPU cache和内存带宽）都是共享的。但是如果有一个消耗cache的应用快速消耗了L3缓存，或者一个应用消耗了系统大量内存带宽，那么如何保证其他虚拟机应用呢？如何限制这些“可恶”的邻居呢？<br>针对上诉问题，以前都是通过控制虚拟机逻辑资源来实现，但是调整的粒度实在太粗，针对处理器缓存这样敏感而稀缺的资源，几乎是无能为力的。为此英特尔推出了RDT技术，希望可以解决这个问题。<br>那么看下RDT到底是什么神奇技术。</p><h2 id="技术组成"><a href="#技术组成" class="headerlink" title="技术组成"></a>技术组成</h2><p>RDT技术有其实有5个功能模块，分别是</p><ul><li>Cache Monitoring Technology (CMT)缓存监测技术</li><li>Cache Allocation Technology (CAT)缓存分配技术</li><li>Memory Bandwidth Monitoring (MBM)内存带宽监测技术</li><li>Memory Bandwidth Allocation (MBA)内存带宽分配技术</li><li>Code and Data Prioritization (CDP)代码和数据分区技术</li></ul><p>5个模块可以分为监控和控制两大类，CMT和MBM为监控技术，而CAT、MBA和CDP为控制技术。<br>RDT允许OS或VMM来监控线程，应用或VM使用的cache/内存带宽空间。通过分析cache/内存带宽使用率，OS或VMM可以优化调度策略提高效能，使得高级优化技术可以实现。</p><h2 id="为什么需要RDT"><a href="#为什么需要RDT" class="headerlink" title="为什么需要RDT"></a>为什么需要RDT</h2><p>配合这几个技术，OS能够知道应用使用了多少CACHE空间，内存带宽，从而给虚拟机的虚拟处理器分配真实的CPU资源。结合CMT和CAT，缓存可做到实时监测和使用，能够让处理器的资源向虚拟机中最重要、最紧迫的任务分配。CDP可以限制数据在LLC中的存储，从而将空间节省出来给代码存储。</p><h2 id="具体功能"><a href="#具体功能" class="headerlink" title="具体功能"></a>具体功能</h2><p>下面我们来看下RDT的一个具体功能。<br>以下方截图来说明，如下：<br><img src="/images/2018/4/8.png" alt=""><br>我们可以发现cores 0-5关联到了RMID 47-42,进 行了每个核监控,提供了CMT/MBM数据。</p><h3 id="RMID"><a href="#RMID" class="headerlink" title="RMID"></a>RMID</h3><p>OS或VMM会给每个应用或虚拟机标记一个软件定义的ID，叫做RMID（Resource Monitoring ID），通过RMID可以同时监控运行在多处理器上相互独立的线程。</p><h2 id="RDT的使用"><a href="#RDT的使用" class="headerlink" title="RDT的使用"></a>RDT的使用</h2><h3 id="工具软件"><a href="#工具软件" class="headerlink" title="工具软件"></a>工具软件</h3><p>使用Intel开源的工具来实现，不需要内核支持。通过这个软件包可以使用CAT,CMT,MBM,CDP功能。<br>工具软件<a href="https://github.com/intel/intel-cmt-cat" target="_blank" rel="noopener">下载链接</a><br>（注：下面的指令均在root下运行）</p><ul><li><code>make &amp;&amp; make install</code></li></ul><hr><p>WARN: Error opening file ‘/dev/cpu/0/msr’!<br>ERROR: CDP detection error!<br>ERROR: Fatal error encounter in CAT discovery!<br>ERROR: discover_capabilities() error 1<br>Error initializing PQoS library!<br>出现上述错误，则执行如下指令：</p><ul><li><code>modprobe msr</code></li></ul><p>具体使用教程参考<a href="https://github.com/intel/intel-cmt-cat/wiki/Usage-Examples" target="_blank" rel="noopener">Usage Examples</a></p><hr><p>参考资料：</p><ol><li><a href="http://linuxperformance.top/index.php/archives/21/" target="_blank" rel="noopener">Intel RDT特性详解</a></li><li><a href="http://www.litrin.net/2018/01/02/kernel-4-14%E7%9A%84rdt%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">Kernel 4.14的RDT配置</a></li><li><a href="http://www.litrin.net/2017/02/15/intel-rdt/" target="_blank" rel="noopener">Intel RDT</a></li><li><a href="http://www.litrin.net/2017/02/21/linux-4-10%E4%B8%ADcat%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">Linux 4.10中CAT的使用</a></li><li><a href="https://www.kernel.org/doc/Documentation/x86/intel_rdt_ui.txt" target="_blank" rel="noopener">intel_rdt_ui.txt</a></li><li><a href="https://github.com/intel/intel-cmt-cat" target="_blank" rel="noopener">intel-cmt-cat</a></li><li><a href="https://github.com/intel/intel-cmt-cat/wiki" target="_blank" rel="noopener">intel-cmt-cat wiki</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前沿&quot;&gt;&lt;a href=&quot;#前沿&quot; class=&quot;headerlink&quot; title=&quot;前沿&quot;&gt;&lt;/a&gt;前沿&lt;/h2&gt;&lt;p&gt;英特尔至强 E5-2600 v4在对外宣传时候号称“为云而生”的，除了其强大的性能和众多核心外，主要亮点就是Resource Directo
      
    
    </summary>
    
      <category term="计算机系统" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机系统" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CPU Cache</title>
    <link href="http://liujunming.github.io/2018/04/09/CPU-Cache/"/>
    <id>http://liujunming.github.io/2018/04/09/CPU-Cache/</id>
    <published>2018-04-09T06:49:44.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要转载自卢钧轶(cenalulu)<br>原文地址：<a href="http://cenalulu.github.io/linux/all-about-cpu-cache/" target="_blank" rel="noopener">http://cenalulu.github.io/linux/all-about-cpu-cache/</a></p><h2 id="为什么要有CPU-Cache"><a href="#为什么要有CPU-Cache" class="headerlink" title="为什么要有CPU Cache"></a>为什么要有CPU Cache</h2><p>随着工艺的提升最近几十年CPU的频率不断提升，而受制于制造工艺和成本限制，目前计算机的内存主要是DRAM并且在访问速度上没有质的突破。因此，CPU的处理速度和内存的访问速度差距越来越大，甚至可以达到上万倍。同时又由于内存数据访问的热点集中性，在CPU和内存之间用较为快速而成本较高的SDRAM做一层缓存，就显得性价比极高了。</p><h2 id="为什么要有多级CPU-Cache"><a href="#为什么要有多级CPU-Cache" class="headerlink" title="为什么要有多级CPU Cache"></a>为什么要有多级CPU Cache</h2><p>随着科技发展，热点数据的体积越来越大，单纯的增加一级缓存大小的性价比已经很低了。因此，就慢慢出现了在一级缓存(L1 Cache)和内存之间又增加一层访问速度和成本都介于两者之间的二级缓存(L2 Cache)。下面是一段从<a href="http://futuretech.blinkenlights.nl/misc/cpumemory.pdf" target="_blank" rel="noopener">What Every Programmer Should Know About Memory</a>中摘录的解释：</p><blockquote><p>Soon after the introduction of the cache the system got more complicated. The speed difference between the cache and the main memory increased again, to a point that another level of cache was added, bigger and slower than the first-level cache. Only increasing the size of the first-level cache was not an option for economical reasons.</p></blockquote><p>此外，又由于程序指令和程序数据的行为和热点分布差异很大，因此L1 Cache也被划分成L1i (i for instruction)和L1d (d for data)两种专门用途的缓存。 下面<a href="https://datatake.files.wordpress.com/2015/01/cpu-cache-access-in-cpu-cycles.png" target="_blank" rel="noopener">一张图</a>可以看出各级缓存之间的响应时间差距，以及内存到底有多慢！</p><p><img src="https://datatake.files.wordpress.com/2015/01/cpu-cache-access-in-cpu-cycles.png" alt=""></p><p>CPU包含多个核，每个核又有独自的一级缓存和二级缓存，各个核心之间共享三级缓存，并统一通过总线与内存进行交互。</p><p><img src="/images/2018/4/1.png" alt=""></p><h2 id="Cache-Line"><a href="#Cache-Line" class="headerlink" title="Cache Line"></a>Cache Line</h2><p>整个Cache被分成多个Line，每个Line通常是32byte或64byte。<br>Cache Line是Cache和内存交换数据的最小单位。</p><p><img src="/images/2018/4/2.png" alt=""></p><p>每个Cache Line包含三个部分:</p><ul><li>Valid：当前缓存是否有效</li><li>Tag：对应的内存地址</li><li>Block：缓存数据</li></ul><p><img src="/images/2018/4/3.png" alt=""></p><p><strong>了解Cache Line的概念对我们程序猿有什么帮助？</strong> 我们来看下面这个C语言中<a href="https://www.quora.com/What-are-some-things-that-programmers-know-but-not-computer-scientists/answer/Josh-Taylor-26?srid=XtLV&amp;share=1" target="_blank" rel="noopener">常用的循环优化</a>例子 下面两段代码中，第一段代码在C语言中总是比第二段代码的执行速度要快。具体的原因相信你仔细阅读了Cache Line的介绍后就很容易理解了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num;    </span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">        arr[i][j] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num;    </span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">        arr[j][i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CPU-Cache-是如何存放数据的"><a href="#CPU-Cache-是如何存放数据的" class="headerlink" title="CPU Cache 是如何存放数据的"></a>CPU Cache 是如何存放数据的</h2><p>假设我们有一块4MB的区域用于缓存，每个缓存对象的唯一标识是它所在的物理内存地址。每个缓存对象大小是64Bytes，所有可以被缓存对象的大小总和（即物理内存总大小）为4GB。那么我们该如何设计这个缓存？</p><h3 id="Fully-Associative-全关联映射"><a href="#Fully-Associative-全关联映射" class="headerlink" title="Fully Associative(全关联映射)"></a>Fully Associative(全关联映射)</h3><p>Fully Associative 字面意思是全关联。在CPU Cache中的含义是：如果在一个Cache集内，任何一个内存地址的数据可以被缓存在任何一个Cache Line里，那么我们成这个cache是Fully Associative。从定义中我们可以得出这样的结论：给到一个内存地址，要知道他是否存在于Cache中，需要遍历所有Cache Line并比较缓存内容的内存地址。而Cache的本意就是为了在尽可能少得CPU Cycle内取到数据。那么想要设计一个快速的Fully Associative的Cache几乎是不可能的。</p><p><img src="/images/2018/4/4.png" alt=""></p><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>和Fully Associative完全相反，使用Direct Mapped模式的Cache给定一个内存地址，就唯一确定了一条Cache Line。设计复杂度低且速度快。那么为什么Cache不使用这种模式呢？直接映射方式的缺点是不够灵活，因每个主存只能固定地对应某个缓存快，即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分的利用。此外，如果程序恰好重复要访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而降低命中率。</p><p><img src="/images/2018/4/5.png" alt=""></p><h3 id="组相连映射"><a href="#组相连映射" class="headerlink" title="组相连映射"></a>组相连映射</h3><p>为了避免以上两种设计模式的缺陷，N-Way Set Associative缓存就出现了。他的原理是把一个缓存按照N个Cache Line作为一组（set），缓存按组划为等分。这样一个64位系统的内存地址在4MB二级缓存中就划成了三个部分（见下图），低位6个bit表示在Cache Line中的偏移量，中间12bit表示Cache组号（set index），剩余的高位46bit就是内存地址的唯一id。这样的设计相较前两种设计有以下两点好处：(16路组相连)</p><ul><li>给定一个内存地址可以唯一对应一个set，对于set中只需遍历16个元素就可以确定对象是否在缓存中（Full Associative中比较次数随内存大小线性增加）</li><li>每2^18(512K)*64=32M的连续热点数据才会导致一个set内的conflict（Direct Mapped中512K的连续热点数据就会出现conflict）</li></ul><p><img src="/images/2018/4/6.png" alt=""></p><p><img src="/images/2018/4/7.png" alt=""></p><h2 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h2><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>随机确定要替换的块</p><h3 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h3><p>选择最先调入的块进行替换</p><h3 id="LRU（最近最少使用）"><a href="#LRU（最近最少使用）" class="headerlink" title="LRU（最近最少使用）"></a>LRU（最近最少使用）</h3><p>根据块的使用情况，选择最近最少使用的块进行替换，反映了程序的局部性规律</p><h2 id="写模式"><a href="#写模式" class="headerlink" title="写模式"></a>写模式</h2><h3 id="Write-through（直写模式）"><a href="#Write-through（直写模式）" class="headerlink" title="Write-through（直写模式）"></a>Write-through（直写模式）</h3><p>在数据更新时，同时写入缓存Cache和后端存储(如下一级cache或者内存)。此模式的优点是操作简单；缺点是因为数据修改需要同时写入存储，数据写入速度较慢。</p><h3 id="Write-back（回写模式）"><a href="#Write-back（回写模式）" class="headerlink" title="Write-back（回写模式）"></a>Write-back（回写模式）</h3><p>在数据更新时只写入缓存Cache。只在数据被替换出缓存时，被修改的缓存数据才会被写到后端存储。此模式的优点是数据写入速度快，因为不需要写存储；缺点是一旦更新后的数据未被写入存储时出现系统掉电的情况，数据将无法找回。</p><hr><p>参考资料:</p><ol><li><a href="http://cenalulu.github.io/linux/all-about-cpu-cache/" target="_blank" rel="noopener">关于CPU Cache – 程序猿需要知道的那些事</a></li><li><a href="https://www.jianshu.com/p/061a5d66ea20" target="_blank" rel="noopener">CPU Cache结构</a></li><li>《计算机组成原理》（第2版） 唐朔飞 编著</li><li><a href="http://witmax.cn/cache-writing-policies.html" target="_blank" rel="noopener">Cache写机制：Write-through与Write-back</a></li><li><a href="https://coolshell.cn/articles/10249.html" target="_blank" rel="noopener">7个示例科普CPU CACHE</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要转载自卢钧轶(cenalulu)&lt;br&gt;原文地址：&lt;a href=&quot;http://cenalulu.github.io/linux/all-about-cpu-cache/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cenalul
      
    
    </summary>
    
      <category term="计算机系统" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机系统" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Jeff Dean系统资料整理</title>
    <link href="http://liujunming.github.io/2018/04/09/Jeff-Dean%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    <id>http://liujunming.github.io/2018/04/09/Jeff-Dean系统资料整理/</id>
    <published>2018-04-09T06:47:30.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/22081653" target="_blank" rel="noopener">Jeff Dean的传说</a>。</p><ul><li><a href="https://scholar.google.com/citations?user=NMS69lQAAAAJ&amp;hl=zh-CN&amp;oi=ao" target="_blank" rel="noopener">Jeff Dean谷歌学术</a></li><li><a href="https://dblp.uni-trier.de/pers/hd/d/Dean:Jeffrey" target="_blank" rel="noopener">Jeff Dean dblp</a></li><li><p><a href="https://www.youtube.com/watch?v=modXC5IWTJI&amp;t=269s" target="_blank" rel="noopener">Building Software Systems At Google and Lessons Learned</a></p><p>Building Software Systems At Google and Lessons Learned为Jeff Dean 在Stanford大学做的一个非常精彩的演讲。<a href="http://www.slideshare.net/parallellabs/building-software-systems-at-google-and-lessons-learned" target="_blank" rel="noopener">slides</a></p></li><li><p><a href="https://gist.github.com/hellerbarde/2843375" target="_blank" rel="noopener">Latency numbers every programmer should know</a><br>需要记住的数字。最新:<a href="https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html" target="_blank" rel="noopener">Latency Numbers Every Programmer Should Know</a></p></li><li><p><a href="http://infolab.stanford.edu/infoseminar/archive/WinterY2013/dean.pdf" target="_blank" rel="noopener">Large-Scale Data and Computation: Challenges and Opportunities</a></p></li></ul><hr><p>参考资料：</p><ol><li><a href="https://coolshell.cn/articles/3301.html" target="_blank" rel="noopener">JEFF DEAN的STANFORD演讲</a></li><li><a href="http://www.parallellabs.com/2010/12/02/jeff-dean-on-google-system-architecture/" target="_blank" rel="noopener">Jeff Dean关于Google系统架构的讲座</a></li><li><a href="http://hedengcheng.com/?p=828#more-828" target="_blank" rel="noopener">何登成 2013年个人微博推荐技术资料汇总</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/22081653&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jeff Dean的传说&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://scholar.
      
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构:树的归纳总结</title>
    <link href="http://liujunming.github.io/2018/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%9A%84%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/"/>
    <id>http://liujunming.github.io/2018/03/20/数据结构-树的归纳总结/</id>
    <published>2018-03-20T10:59:03.000Z</published>
    <updated>2018-06-28T13:47:41.207Z</updated>
    
    <content type="html"><![CDATA[<p>最近，因为要准备找工作，所以本文特意总结归纳一下数据结构中重要的一块：树。</p><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树（BST：Binary Search Tree）是一种特殊的二叉树，它改善了二叉树节点查找的效率。二叉查找树有以下性质：</p><p>对于任意一个节点 n，</p><ul><li>其左子树（left subtree）下的每个后代节点（descendant node）的值都小于节点 n 的值；</li><li>其右子树（right subtree）下的每个后代节点的值都大于节点 n 的值。</li></ul><p>所谓节点 n 的子树，可以将其看作是以节点 n 为根节点的树。子树的所有节点都是节点 n 的后代，而子树的根则是节点 n 本身。</p><p>BST的查找、插入、删除操作的运行时间与BST的拓扑结构有关，最佳情况是O(log­ n)，而最坏情况是 O(n)。</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html" target="_blank" rel="noopener">AVL树</a>是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p><p>引入平衡二叉树的目的是为了提高二叉查找树的搜索的效率,减少树的平均搜索长度。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><a href="https://github.com/liujunming/Data-Structure/tree/master/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">红黑树</a>是一种自平衡二叉查找树，典型的用途是实现关联数组。</p><p>红黑树的性质:</p><ol><li>节点是红色或黑色</li><li>根是黑色</li><li>所有叶子都是黑色</li><li>每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</li></ol><p>红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，性能整体来说要优于AVL树。</p><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>在计算机科学中，<a href="http://liujunming.top/2016/07/12/Trie%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Trie</a>，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p><p><img src="/images/2018/3/6.png" alt=""></p><center>一个保存了8个键的trie结构，”A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, and “inn”.</center><h2 id="基数树-Radix-Tree"><a href="#基数树-Radix-Tree" class="headerlink" title="基数树(Radix Tree)"></a>基数树(Radix Tree)</h2><p>基数树，或称压缩前缀树，是一种更节省空间的Trie。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。</p><p><img src="/images/2018/3/7.png" alt=""></p><p>在Linux内核中，<a href="http://liujunming.top/2017/06/25/address-space-%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/" target="_blank" rel="noopener">一个address_space对象对应一个基树</a>。</p><h2 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h2><p>详情请从参考<a href="http://liujunming.top/2016/05/13/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">B树和B+树的定义以及应用</a>。</p><p>对于在内存中的查找结构而言，红黑树的效率已经非常好了。但是如果是数据量非常大的查找呢？将这些数据全部放入内存组织成红黑树结构显然是不实际的。实际上，像OS中的文件目录存储，数据库中的文件索引结构的存储…. 都不可能在内存中建立查找结构，必须在磁盘中建立好这个结构。那么在这个背景下，红黑树显然不是一种好的选择。</p><p>在磁盘中组织查找结构，从任何一个结点指向其他结点都有可能读取一次磁盘数据，再将数据写入内存进行比较。大家都知道，频繁的磁盘IO操作，效率是很低下的(机械运动比电子运动要慢不知道多少)。显而易见，所有的二叉树的查找结构在磁盘中都是低效的。因此，B树很好的解决了这一个问题。</p><hr><p>参考资料：</p><ol><li><a href="https://troywu0.gitbooks.io/spark/content/b-%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-avl%E6%A0%91-%E6%AF%94%E8%BE%83.html" target="_blank" rel="noopener">b-树-红黑树-二叉搜索树-avl树-比较</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近，因为要准备找工作，所以本文特意总结归纳一下数据结构中重要的一块：树。&lt;/p&gt;
&lt;h2 id=&quot;二叉查找树&quot;&gt;&lt;a href=&quot;#二叉查找树&quot; class=&quot;headerlink&quot; title=&quot;二叉查找树&quot;&gt;&lt;/a&gt;二叉查找树&lt;/h2&gt;&lt;p&gt;二叉查找树（BST：Bin
      
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>linux kernel中哈希链表的解析</title>
    <link href="http://liujunming.github.io/2018/03/12/linux-kernel%E4%B8%AD%E5%93%88%E5%B8%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://liujunming.github.io/2018/03/12/linux-kernel中哈希链表的解析/</id>
    <published>2018-03-12T04:48:12.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>先来直观的比较下普通链表和哈希链表：<br><img src="/images/2018/3/5.png" alt=""></p><h2 id="普通链表"><a href="#普通链表" class="headerlink" title="普通链表"></a>普通链表</h2><p>普通链表的表头和节点相同<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>详情请参考<a href="http://fromwiz.com/share/s/1PYo-Q2jm4ra2b6ROu1eWFn11kdCyt0v54f82YHTYf0dOuhd" target="_blank" rel="noopener">内核数据结构之链表</a>。</p><h2 id="哈希链表"><a href="#哈希链表" class="headerlink" title="哈希链表"></a>哈希链表</h2><p>哈希链表头<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>哈希链表节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>Linux链表设计者认为双指针表头双循环链表对于HASH表来说过于浪费，因而另行设计了一套用于HASH表的hlist数据结构，即单指针表头双循环链表。hlist表头仅有一个指向首节点的指针，而没有指向尾节点的指针，这样在海量的HASH表中存储的表头就能减少一半的空间消耗。</p><p>这里还需要注意：struct hlist_node **pprev，也就是说pprev是指向前一个节点(也可以是表头)中next指针的指针。</p><p><strong>Q：</strong> 为什么不使用struct hlist_node *prev，即让prev指向前一个节点呢？<br><strong>A：</strong> 因为这时候表头(hlist_head)和节点(hlist_node)的数据结构不同。如果使用struct hlist_node *prev，只适用于前一个为节点的情况，而不适用于前一个为表头的情况。如果每次操作都要考虑指针类型转换，会是一件麻烦的事情。所以，我们需要一种统一的操作，而不用考虑前一个元素是节点还是表头。<br>struct hlist_node **pprev，pprev指向前一个元素的next指针，不用管前一个元素是节点还是表头。当我们需要操作前一个元素(节点或表头)，可以统一使用*(node-&gt;pprev)来访问和修改前一元素的next(或first)指针。</p><p>原理图如下：<br><img src="/images/2018/3/6" alt=""></p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="(1) 初始化"></a>(1) 初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Double linked lists with a single pointer list head.</span></span><br><span class="line"><span class="comment"> * Mostly useful for hash tables where the two pointer list head is too wasteful.</span></span><br><span class="line"><span class="comment"> * You lose the ability to access the tail in O(1).</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLIST_HEAD_INIT &#123; .first = NULL &#125;  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLIST_HEAD (name) struct hlist_head name = &#123; .first = NULL &#125;  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)</span></span><br></pre></td></tr></table></figure><h3 id="2-插入"><a href="#2-插入" class="headerlink" title="(2) 插入"></a>(2) 插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* next must be != NULL */</span>  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_add_before</span><span class="params">(struct hlist_node *n, struct hlist_node *next)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    n-&gt;pprev = next-&gt;pprev;  </span><br><span class="line">    n-&gt;next = next;  </span><br><span class="line">    next-&gt;pprev = &amp;n-&gt;next;  </span><br><span class="line">    *(n-&gt;pprev) = n;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-删除"><a href="#3-删除" class="headerlink" title="(3) 删除"></a>(3) 删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __hlist_del(struct hlist_node *n)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span> = <span class="title">n</span>-&gt;<span class="title">next</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> **<span class="title">prev</span> = <span class="title">n</span>-&gt;<span class="title">pprev</span>;</span>  </span><br><span class="line">    *pprev = next;  </span><br><span class="line">    <span class="keyword">if</span> (next)  </span><br><span class="line">        next-&gt;pprev = pprev;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-遍历"><a href="#4-遍历" class="headerlink" title="(4) 遍历"></a>(4) 遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *) 0)-&gt;MEMBER)  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * container_of - cast a member of a structure out to the containing structure</span></span><br><span class="line"><span class="comment"> * @ptr: the pointer to the member.</span></span><br><span class="line"><span class="comment"> * @type: the type of the container struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member: the name of the member within the struct.</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;    \  </span></span><br><span class="line">    const typeof(((type *) 0)-&gt;member) * __mptr = (ptr);    \  </span><br><span class="line">    (type *) ((<span class="keyword">char</span> *) __mptr - offsetof(type, member)); &#125;)  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_entry(ptr, type, member) container_of(ptr, type, member)  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each(pos, head) \  </span></span><br><span class="line">    <span class="keyword">for</span> (pos = (head)-&gt;first; pos; pos = pos-&gt;next)  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_for_each_entry - iterate over list of given type</span></span><br><span class="line"><span class="comment"> * @tpos: the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @pos: the &amp;struct hlist_node to use a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head: the head for your list.</span></span><br><span class="line"><span class="comment"> * @member: the name of the hlist_node within the struct.</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_entry(tpos, pos, head, member)    \  </span></span><br><span class="line">    <span class="keyword">for</span> (pos = (head)-&gt;first;    \  </span><br><span class="line">           pos &amp;&amp; (&#123; tpos = hlist_entry(pos, typeof(*tpos), member); <span class="number">1</span>;&#125;);    \  </span><br><span class="line">           pos = pos-&gt;next)</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><p><a href="http://blog.csdn.net/zhangskd/article/details/11225301" target="_blank" rel="noopener">哈希链表及其变种</a></p></li><li><p><a href="http://cxd2014.github.io/2015/10/26/KernelList/" target="_blank" rel="noopener">Linux内核链表</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前沿&quot;&gt;&lt;a href=&quot;#前沿&quot; class=&quot;headerlink&quot; title=&quot;前沿&quot;&gt;&lt;/a&gt;前沿&lt;/h2&gt;&lt;p&gt;先来直观的比较下普通链表和哈希链表：&lt;br&gt;&lt;img src=&quot;/images/2018/3/5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>系统性能分析工具</title>
    <link href="http://liujunming.github.io/2018/03/06/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://liujunming.github.io/2018/03/06/系统性能分析工具/</id>
    <published>2018-03-06T00:29:13.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在系统运行过程中，我们往往会对某实验结果感到困惑，此刻，我们需要利用一些系统性能分析工具进行分析，查看问题的来源。下面，就介绍几种常用的工具：</p><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况。top命令的详解请参考<a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="noopener">这篇文章</a>。</p><h2 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h2><p>perf 是用来进行软件性能分析的工具,使用 perf，你可以分析程序运行期间发生的硬件事件，比如 instructions retired ，processor clock cycles 等；你也可以分析软件事件，比如 page fault 和进程切换。<br>这使得 perf 拥有了众多的性能分析能力，举例来说，使用 perf 可以计算每个时钟周期内的指令数，称为 IPC，IPC 偏低表明代码没有很好地利用 CPU。perf 还可以对程序进行函数级别的采样，从而了解程序的性能瓶颈究竟在哪里等等。</p><h3 id="perf-的基本使用"><a href="#perf-的基本使用" class="headerlink" title="perf 的基本使用"></a>perf 的基本使用</h3><p>perf的安装：<br>sudo apt-get install linux-tools-common linux-tools-generic linux-tools-`uname -r`</p><p>说明一个工具的最佳途径是列举一个例子。</p><p>考查下面这个例子程序。其中函数 longa() 是个很长的循环，比较浪费时间。函数 foo1 和 foo2 将分别调用该函数 10 次，以及 100 次。</p><p>清单 1. 测试程序 t1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">  j=i; <span class="comment">//am I silly or crazy? I feel boring and desperate.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span> ; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">       longa();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)</span><br><span class="line">     longa();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  foo1();</span><br><span class="line">  foo2();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>找到这个程序的性能瓶颈无需任何工具，肉眼的阅读便可以完成。Longa() 是这个程序的关键，只要提高它的速度，就可以极大地提高整个程序的运行效率。</p><p>但因为其简单，却正好可以用来演示 perf 的基本使用。</p><h3 id="perf-stat"><a href="#perf-stat" class="headerlink" title="perf stat"></a>perf stat</h3><p>做任何事都最好有条有理。老手往往能够做到不慌不忙，循序渐进，而新手则往往东一下，西一下，不知所措。</p><p>面对一个问题程序，最好采用自顶向下的策略。先整体看看该程序运行时各种统计事件的大概，再针对某些方向深入细节。而不要一下子扎进琐碎细节，会一叶障目的。</p><p>有些程序慢是因为计算量太大，其多数时间都应该在使用 CPU 进行计算，这叫做 CPU bound 型；有些程序慢是因为过多的 IO，这种时候其 CPU 利用率应该不高，这叫做 IO bound 型；对于 CPU bound 程序的调优和 IO bound 的调优是不同的。</p><p>如果你认同这些说法的话，perf stat 应该是你最先使用的一个工具。它通过概括精简的方式提供被调试程序运行的整体情况和汇总数据。</p><p>还记得我们前面准备的那个例子程序么？现在将它编译为可执行文件 t1<br><code>gcc -o t1 -g test.c</code></p><p>下面演示了 perf stat 针对程序 t1 的输出：<br><code>perf stat ./t1</code><br><img src="/images/2018/3/1.png" alt=""><br>上面告诉我们，程序 t1 是一个 CPU bound 型，因为 task-clock-msecs 接近 1。</p><p>对 t1 进行调优应该要找到热点 ( 即最耗时的代码片段 )，再看看是否能够提高热点代码的效率。</p><p>缺省情况下，除了 task-clock-msecs 之外，perf stat 还给出了其他几个最常用的统计信息：</p><p>Task-clock-msecs：CPU 利用率，该值高，说明程序的多数时间花费在 CPU 计算上而非 IO。</p><p>Context-switches：进程切换次数，记录了程序运行过程中发生了多少次进程切换，频繁的进程切换是应该避免的。</p><p>Cache-references: cache 命中的次数</p><p>Cache-misses：cache 失效的次数,反应了程序运行过程中总体的 cache 利用情况，如果该值过高，说明程序的 cache 利用不好。</p><p>CPU-migrations：表示进程 t1 运行过程中发生了多少次 CPU 迁移，即被调度器从一个 CPU 转移到另外一个 CPU 上运行。</p><p>Cycles：处理器时钟，一条机器指令可能需要多个 cycles。</p><p>Instructions: 机器指令数目。</p><p>IPC：是 Instructions/Cycles 的比值，该值越大越好，说明程序充分利用了处理器的特性。</p><h3 id="perf-top"><a href="#perf-top" class="headerlink" title="perf top"></a>perf top</h3><p>使用 perf stat 的时候，往往你已经有一个调优的目标。比如我刚才写的那个程序 t1。</p><p>也有些时候，你只是发现系统性能无端下降，并不清楚究竟哪个进程占据了系统大部分资源。</p><p>此时需要一个类似 top 的命令，列出所有值得怀疑的进程，从中找到需要进一步审查的家伙。类似法制节目中办案民警常常做的那样，通过查看监控录像从茫茫人海中找到行为古怪的那些人，而不是到大街上抓住每一个人来审问。</p><p>perf top 用于实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程。</p><p>让我们再设计一个例子来演示吧。</p><p>不知道你怎么想，反正我觉得做一件有益的事情很难，但做点儿坏事儿却非常容易。我很快就想到了如代码清单 2 所示的一个程序：</p><p>清单 2. 一个死循环<br><code>while (1) i++;</code></p><p>我叫他 t2。启动 t2，然后用 perf top 来观察：</p><p>下面是 perf top 的输出：<br><img src="/images/2018/3/2.png" alt=""></p><p>很容易便发现 t2 是需要关注的可疑程序。不过其作案手法太简单：肆无忌惮地浪费着 CPU。所以我们不用再做什么其他的事情便可以找到问题所在。但现实生活中，影响性能的程序一般都不会如此愚蠢，所以我们往往还需要使用其他的 perf 工具进一步分析。</p><h3 id="使用-perf-record-和perf-report"><a href="#使用-perf-record-和perf-report" class="headerlink" title="使用 perf record 和perf report"></a>使用 perf record 和perf report</h3><p>使用 top 和 stat 之后，你可能已经大致有数了。要进一步分析，便需要一些粒度更细的信息。比如说你已经断定目标程序计算量较大，也许是因为有些代码写的不够精简。那么面对长长的代码文件，究竟哪几行代码需要进一步修改呢？这便需要使用 perf record 记录单个函数级别的统计信息，并使用 perf report 来显示统计结果。</p><p>你的调优应该将注意力集中到百分比高的热点代码片段上，假如一段代码只占用整个程序运行时间的 0.1%，即使你将其优化到仅剩一条机器指令，恐怕也只能将整体的程序性能提高 0.1%。俗话说，好钢用在刀刃上，不必我多说了。</p><p>仍以 t1 为例。<br><code>perf record – e cpu-clock ./t1</code><br><code>perf report</code></p><p> perf report 示例结果如下图所示：<br><img src="/images/2018/3/3.png" alt=""></p><p>不出所料，热点是 longa( ) 函数。</p><p>但代码是非常复杂的，t1 程序中的 foo1() 也是一个潜在的调优对象，为什么要调用 100 次那个无聊的 longa() 函数呢？但我们在上图中无法发现 foo1 和 foo2，更无法了解他们的区别了。</p><p>使用 perf 的 -g 选项便可以得到需要的信息：<br><code>perf record – e cpu-clock – g ./t1</code><br><code>perf report</code></p><p>perf – g report 示例结果如下图所示：<br><img src="/images/2018/3/4.png" alt=""></p><p>通过对调用图的分析，能很方便地看到 91% 的时间都花费在 foo1() 函数中，因为它调用了 100 次 longa() 函数，因此假如 longa() 是个无法优化的函数，那么程序员就应该考虑优化 foo1，减少对 longa() 的调用次数。</p><hr><p>参考资料：</p><ol><li><a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="noopener">top命令</a></li><li><a href="http://linux.51yip.com/search/perf" target="_blank" rel="noopener">perf linux指令</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/" target="_blank" rel="noopener">perf – Linux下的系统性能调优工具</a></li><li><a href="http://files.cnblogs.com/files/jiayy/Linux%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%BA%A7%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%E5%B7%A5%E5%85%B7-perf-1.pdf" target="_blank" rel="noopener">Linux 的系统级性能剖析工具‐perf </a></li><li><a href="http://www.brendangregg.com/perf.html" target="_blank" rel="noopener">perf Examples</a></li><li><a href="https://www.cnblogs.com/arnoldlu/p/6241297.html" target="_blank" rel="noopener">系统级性能分析工具perf的介绍与使用</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在系统运行过程中，我们往往会对某实验结果感到困惑，此刻，我们需要利用一些系统性能分析工具进行分析，查看问题的来源。下面，就介绍几种常用的工具：&lt;/p&gt;
&lt;h2 id=&quot;top&quot;&gt;&lt;a href=&quot;#top&quot; class=&quot;headerlink&quot; title=&quot;top&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础技术：DeviceMapper</title>
    <link href="http://liujunming.github.io/2018/01/19/Docker%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%EF%BC%9ADeviceMapper/"/>
    <id>http://liujunming.github.io/2018/01/19/Docker基础技术：DeviceMapper/</id>
    <published>2018-01-19T11:47:56.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自:<a href="https://coolshell.cn/articles/17200.html" target="_blank" rel="noopener">DOCKER基础技术：DEVICEMAPPER</a></p><p>在上一篇<a href="https://coolshell.cn/articles/17061.html" target="_blank" rel="noopener">介绍AUFS的文章</a>中，大家可以看到，Docker的分层镜像是怎么通过UnionFS这种文件系统做到的，但是，因为Docker首选的AUFS并不在Linux的内核主干里，所以，对于非Ubuntu的Linux分发包，比如CentOS，就无法使用AUFS作为Docker的文件系统了。于是作为第二优先级的DeviceMapper就被拿出来做分层镜像的一个实现。<br><img src="/images/2018/1/9.jpg" alt=""></p><h2 id="Device-Mapper-简介"><a href="#Device-Mapper-简介" class="headerlink" title="Device Mapper 简介"></a>Device Mapper 简介</h2><p>DeviceMapper自Linux 2.6被引入，成为了Linux最重要的一个技术。它是内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构，它包含三个重要的对象概念，Mapped Device、Mapping Table、Target device。</p><p>Mapped Device 是一个逻辑抽象，可以理解成为内核向外提供的逻辑设备，它通过Mapping Table描述的映射关系和 Target Device 建立映射。Target device 表示的是 Mapped Device 所映射的物理空间段，对 Mapped Device 所表示的逻辑设备来说，就是该逻辑设备映射到的一个物理设备。</p><p>Mapping Table里有 Mapped Device 逻辑的起始地址、范围、和表示在 Target Device 所在物理设备的地址偏移量以及Target 类型等信息（注：这些地址和偏移量都是以磁盘的扇区为单位的，即 512 个字节大小，所以，当你看到128的时候，其实表示的是128*512=64K）。</p><p>DeviceMapper 中的逻辑设备Mapped Device不但可以映射一个或多个物理设备Target Device，还可以映射另一个Mapped Device，于是，就是构成了一个迭代或递归的情况，就像文件系统中的目录里除了文件还可以有目录，理论上可以无限嵌套下去。</p><p>DeviceMapper在内核中通过一个个模块化的 Target Driver 插件实现对 IO 请求的过滤或者重新定向等工作，当前已经实现的插件包括软 Raid、加密、多路径、镜像、快照等，这体现了在 Linux 内核设计中策略和机制分离的原则。如下图所示。从图中，我们可以<strong>看到DeviceMapper只是一个框架，在这个框架上，我们可以插入各种各样的策略</strong>，在这诸多“插件”中，<strong>有一个东西叫Thin Provisioning Snapshot，这是Docker使用DeviceMapper中最重要的模块</strong>。</p><p><img src="/images/2018/1/10.gif" alt=""></p><center>图片来源：<a href="http://people.redhat.com/agk/talks/FOSDEM_2005/" target="_blank" rel="noopener">http://people.redhat.com/agk/talks/FOSDEM_2005/</a></center><h2 id="Thin-Provisioning-简介"><a href="#Thin-Provisioning-简介" class="headerlink" title="Thin Provisioning 简介"></a>Thin Provisioning 简介</h2><p>Thin Provisioning要怎么翻译成中文，真是一件令人头痛的事，我就不翻译了。这个技术是虚拟化技术中的一种。它是什么意思呢？你可以联想一下我们计算机中的内存管理中用到的——“虚拟内存技术”——操作系统给每个进程N多N多用不完的内址地址，但是呢，我们知道，物理内存是没有那么多的，如果按照进程内存和物理内存一一映射来玩的话，那么，我们得要多少的物理内存啊。所以，操作系统引入了虚拟内存的设计，意思是，我逻辑上给你无限多的内存，但是实际上是实报实销，因为我知道你一定用不了那么多，于是，达到了内存使用率提高的效果。（今天云计算中很多所谓的虚拟化其实完全都是在用和“虚拟内存”相似的Thin Provisioning的技术）</p><p>好了，话题拉回来，我们这里说的是存储。看下面两个图（<a href="http://www.architecting.it/2009/06/04/enterprise-computing-why-thin-provisioning-is-not-the-holy-grail-for-utilisation/" target="_blank" rel="noopener">图片来源</a>），第一个是Fat Provisioning，第二个是Thin Provisioning，其很好的说明了是个怎么一回事（和虚拟内存是一个概念）</p><p><img src="/images/2018/1/10.jpg" alt=""></p><p><img src="/images/2018/1/11.jpg" alt=""></p><p>那么，Docker是怎么使用Thin Provisioning这个技术做到像UnionFS那样的分层镜像的呢？答案是，Docker使用了Thin Provisioning的Snapshot的技术。下面我们来介绍一下Thin Provisioning的Snapshot。</p><h2 id="Thin-Provisioning-Snapshot-演示"><a href="#Thin-Provisioning-Snapshot-演示" class="headerlink" title="Thin Provisioning Snapshot 演示"></a>Thin Provisioning Snapshot 演示</h2><p>下面，我们用一系列的命令来演示一下Device Mapper的Thin Provisioning Snapshot是怎么玩的,请切换到root用户运行命令。</p><p>首先，我们需要先建两个文件，一个是data.img，另一个是meta.data.img：<br><code>dd if=/dev/zero of=/tmp/data.img bs=1K count=1 seek=10M</code><br><code>dd if=/dev/zero of=/tmp/meta.data.img bs=1K count=1 seek=100K</code></p><p><img src="/images/2018/1/12.png" alt=""></p><p>注意命令中seek选项，表示在备份时对of后面的部分也就是目标文件跳过多少块再开始写内容。因为bs是1K个字节，即块大小为1KB，所以当seek=10M时，也就是在备份时对data.img跳过10M个块（即10GB）再开始写内容。但此刻data.img在硬盘上占有空间只有1k的内容，当向其写入内容时，才会在硬盘上为其分配空间。我们可以用ls命令看一下data.img和meta.data.img实际分配的空间。</p><p><code>ls -lsh /tmp/data.img</code><br><code>ls -lsh /tmp/meta.data.img</code></p><p><img src="/images/2018/1/13.png" alt=""></p><p>然后，我们为这些文件创建<a href="http://liujunming.top/2018/01/17/%E5%9B%9E%E7%8E%AF%E8%AE%BE%E5%A4%87loopback-device/" target="_blank" rel="noopener">loopback设备</a>。</p><p><code>losetup /dev/loop2015 /tmp/data.img</code><br><code>losetup /dev/loop2016 /tmp/meta.data.img</code></p><p><code>losetup -a</code></p><p><img src="/images/2018/1/14.png" alt=""></p><p>现在，我们为设备建一个Thin Provisioning的Pool，用dmsetup命令</p><p><code>dmsetup create hchen-thin-pool --table &quot;0 20971520 thin-pool /dev/loop2016 /dev/loop2015 128 65536 1 skip_block_zeroing&quot;</code></p><p>其中的参数解释如下（更多信息可参看<a href="https://github.com/torvalds/linux/blob/master/Documentation/device-mapper/thin-provisioning.txt" target="_blank" rel="noopener">Thin Provisioning的man page</a>）：</p><ul><li>dmsetup create是用来创建thin pool的命令</li><li>hchen-thin-pool 是自定义的一个pool名，不冲突就好。</li><li>–table是这个pool的参数设置<ul><li>0代表数据起始的sector号</li><li>20971520数据结束的sector号，一个sector是512字节，所以，20971520个正好是10GB</li><li>/dev/loop2016是meta文件的设备（前面我们建好了）</li><li>/dev/loop2015是data文件的设备（前面我们建好了）</li><li>128是最小的可分配的sector数</li><li>65536是最少可用sector的water mark，也就是一个threshold</li><li>1 代表有一个附加参数</li><li>skip_block_zeroing是个附加参数，表示略过用0填充的块</li></ul></li></ul><p>然后，我们就可以看到一个Device Mapper的设备了：<br><code>ll /dev/mapper/hchen-thin-pool</code></p><p><img src="/images/2018/1/15.png" alt=""></p><p>我们的初始化工作还没有完成，接下来，还要创建一个Thin Provisioning 的 Volume：</p><p><code>dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_thin 0&quot;</code><br><code>dmsetup create hchen-thin-volumn-001 --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 0&quot;</code></p><p>其中：</p><ul><li>第一个命令中的create_thin是关键字，后面的0表示这个Volume的device 的 id</li><li>第二个命令，是真正的为这个Volumn创建一个可以mount的设备，名字叫hchen-thin-volumn-001。</li></ul><p>好了，在mount前，我们还要格式化一下：<br><code>mkfs.ext4 /dev/mapper/hchen-thin-volumn-001</code><br><img src="/images/2018/1/16.png" alt=""></p><p>好了，我们可以mount了（下面的命令中，我还创建了一个文件）<br><code>mkdir -p /mnt/base</code><br><code>mount /dev/mapper/hchen-thin-volumn-001 /mnt/base</code><br><code>echo &quot;hello world, I am a base&quot; &gt; /mnt/base/id.txt</code><br><code>cat /mnt/base/id.txt</code><br><img src="/images/2018/1/17.png" alt=""><br>好了，接下来，我们来看看snapshot怎么搞：<br><code>dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_snap 1 0&quot;</code><br><code>dmsetup create mysnap1 --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 1&quot;</code></p><p><code>ll /dev/mapper/mysnap1</code><br><img src="/images/2018/1/18.png" alt=""><br>上面的命令中：</p><ul><li>第一条命令是向hchen-thin-pool发一个create_snap的消息，后面跟两个id，第一个是新的dev id，第二个是要从哪个已有的dev id上做snapshot（0这个dev id是我们前面就创建了了）</li><li>第二条命令是创建一个mysnap1的device，并可以被mount。</li></ul><p>下面我们来看看：<br><code>mkdir -p /mnt/mysnap1</code><br><code>mount /dev/mapper/mysnap1 /mnt/mysnap1</code></p><p><code>ll /mnt/mysnap1/</code></p><p><code>cat /mnt/mysnap1/id.txt</code></p><p><img src="/images/2018/1/19.png" alt=""></p><p>我们来修改一下/mnt/mysnap1/id.txt，并加上一个snap1.txt的文件：<br><code>echo &quot;I am snap1&quot; &gt;&gt; /mnt/mysnap1/id.txt</code><br><code>echo &quot;I am snap1&quot; &gt; /mnt/mysnap1/snap1.txt</code></p><p><code>cat /mnt/mysnap1/id.txt</code></p><p><code>cat /mnt/mysnap1/snap1.txt</code></p><p><img src="/images/2018/1/20.png" alt=""></p><p>我们再看一下/mnt/base，你会发现没有什么变化：<br><code>ls /mnt/base</code><br><code>cat /mnt/base/id.txt</code></p><p><img src="/images/2018/1/21.png" alt=""></p><p>你是不是已经看到了分层镜像的样子了？</p><p>你还可以继续在刚才的snapshot上再建一个snapshot<br><code>dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_snap 2 1&quot;</code><br><code>dmsetup create mysnap2  --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 2&quot;</code></p><p><code>ll /dev/mapper/mysnap2</code></p><p><code>mkdir -p /mnt/mysnap2</code><br><code>mount /dev/mapper/mysnap2 /mnt/mysnap2</code><br><code>ls /mnt/mysnap2</code></p><p><img src="/images/2018/1/22.png" alt=""></p><p>好了，我相信你看到了分层镜像的样子了。</p><p>看完演示，我们再来补点理论知识吧：</p><ul><li>Snapshot来自LVM（<a href="http://liujunming.top/2018/01/18/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86-LVM/" target="_blank" rel="noopener">Logic Volumn Manager</a>），它可以在不中断服务的情况下为某个device打一个快照。</li><li>Snapshot是Copy-On-Write的，也就是说，只有发生了修改，才会对对应的内容进行拷贝。</li></ul><p>另外，这里有篇文章<a href="http://searchstorage.techtarget.com/tip/Storage-thin-provisioning-benefits-and-challenges" target="_blank" rel="noopener">Storage thin provisioning benefits and challenges</a>可以前往一读。</p><h2 id="Docker的DeviceMapper"><a href="#Docker的DeviceMapper" class="headerlink" title="Docker的DeviceMapper"></a>Docker的DeviceMapper</h2><p>上面基本上就是Docker的玩法了。</p><p><code>ls -alhs /var/lib/docker/devicemapper/devicemapper</code><br><img src="/images/2018/1/24.png" alt=""></p><p>下面是相关的thin-pool。其中，有个一大串hash的device是正在启动的容器：<br><code>sudo ll /dev/mapper/dock*</code><br><img src="/images/2018/1/25.png" alt=""></p><p>我们可以看一下它的device id（Docker都把它们记下来了）：<br><code>cat /var/lib/docker/devicemapper/metadata/29ef919ba2a241fa4fdb024fb66923522cea89e155162ca83b454212569b8f21</code><br><img src="/images/2018/1/26.png" alt=""></p><p>device_id是1326，size是10737418240，除以512，就是20971520 个 sector，我们用这些信息来做个snapshot看看（注：我用了一个比较大的dev id – 2048）：<br><code>dmsetup message &quot;/dev/mapper/docker-thinpool&quot; 0 &quot;create_snap 2048 1326&quot;</code><br><code>dmsetup create dockersnap --table &quot;0 20971520 thin /dev/mapper/docker-thinpool 2048&quot;</code><br><code>mkdir /mnt/docker</code><br><code>mount /dev/mapper/dockersnap /mnt/docker/</code><br><code>ls /mnt/docker/</code><br><code>ls /mnt/docker/rootfs/</code><br><img src="/images/2018/1/27.png" alt=""></p><p>我们在docker的容器里用findmnt命令也可以看到相关的mount的情况（因为太长，下面只是摘要）：<br><code>findmnt</code><br><img src="/images/2018/1/28.png" alt=""></p><p>如果你在使用loopback的devicemapper的话，当你的存储出现了问题后，正确的解决方案是：<br><code>rm -rf /var/lib/docker</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文转载自:&lt;a href=&quot;https://coolshell.cn/articles/17200.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DOCKER基础技术：DEVICEMAPPER&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在上一篇&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="容器" scheme="http://liujunming.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="容器" scheme="http://liujunming.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="docker" scheme="http://liujunming.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>逻辑卷管理(LVM)</title>
    <link href="http://liujunming.github.io/2018/01/18/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86-LVM/"/>
    <id>http://liujunming.github.io/2018/01/18/逻辑卷管理-LVM/</id>
    <published>2018-01-18T03:57:34.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>LVM是 Logical Volume Manager（逻辑卷管理）的简写，它是Linux环境下对磁盘分区进行管理的一种机制。通过使用 LVM，所有物理磁盘和分区，无论它们的大小和分布方式如何，都被抽象为单一存储（single storage）源。例如，在图 1 所示的物理到逻辑映射布局中，最大的磁盘是 80GB 的，那么用户如何创建更大（比如 150GB）的文件系统呢？<br><img src="/images/2018/1/4.gif" alt=""></p><center>图 1. 物理到逻辑的映射</center><p>LVM 可以将分区和磁盘聚合成一个虚拟磁盘（virtual disk），从而用小的存储空间组成一个统一的大空间。这个虚拟磁盘在 LVM 术语中称为卷组（volume group）。</p><p>建立比最大的磁盘还大的文件系统并不是这种高级存储管理方法的惟一用途。还可以使用 LVM 完成以下任务：</p><ul><li>在磁盘池中添加磁盘和分区，对现有的文件系统进行在线扩展</li><li>用一个 160GB 磁盘替换两个 80GB 磁盘，而不需要让系统离线，也不需要在磁盘之间手工转移数据</li><li>当存储空间超过所需的空间容量时，从池中去除磁盘，从而缩小文件系统</li><li>使用快照（snapshot）执行一致的备份</li></ul><h2 id="LVM-的结构"><a href="#LVM-的结构" class="headerlink" title="LVM 的结构"></a>LVM 的结构</h2><p>LVM 被组织为三种元素：</p><ul><li>卷（Volume）：物理卷和逻辑卷和卷组</li><li>区段（Extent）：物理区段和逻辑区段</li><li>设备映射器（Device mapper）：Linux 内核模块</li></ul><h3 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h3><p>Linux LVM 组织为物理卷（PV）、卷组（VG）和逻辑卷（LV）。物理卷 是物理磁盘或物理磁盘分区（比如 /dev/hda 或 /dev/hdb1）。卷组是物理卷的集合。卷组可以在逻辑上划分成多个逻辑卷。<br>图 2 显示一个三个磁盘构成的布局。<br><img src="/images/2018/1/5.gif" alt=""></p><center>图 2. 物理到逻辑卷的映射</center><p>物理磁盘 0 上的所有四个分区（/dev/hda[1-4]）以及完整的物理磁盘 1（/dev/hdb）和物理磁盘 2（/dev/hdd）作为物理卷添加到卷组 VG0 中。<br>卷组是实现 n-to-m 映射的关键（也就是，将 n 个 PV 看作 m 个 LV）。在将 PV 分配给卷组之后， 就可以创建任意大小的逻辑卷（只要不超过 VG 的大小）。在图 2 的示例中，创建了一个称为 LV0 的逻辑卷，并给其他 LV 留下了一些空间（这些空间也可以用来应付 LV0 以后的增长）。</p><p>LVM 中的逻辑卷就相当于物理磁盘分区；在实际使用中，它们就是物理磁盘分区。</p><p>在创建 LV 之后，可以使用任何文件系统对它进行格式化并将它挂载在某个挂载点上，然后就可以开始使用它了。图 3 显示一个经过格式化的逻辑卷 LV0 被挂载在 /var。</p><p><img src="/images/2018/1/6.gif" alt=""></p><center>图 3. 物理卷到文件系统的映射</center><h3 id="区段"><a href="#区段" class="headerlink" title="区段"></a>区段</h3><p>为了实现 n-to-m 物理到逻辑卷映射，PV 和 VG 的基本块必须具有相同的大小；这些基本块称为物理区段（PE）和逻辑区段（LE）。尽管 n 个物理卷映射到 m 个逻辑卷，但是 PE 和 LE 总是一对一映射的。<br><img src="/images/2018/1/7.gif" alt=""></p><center>图 4. 物理到逻辑区段的映射</center><p>如果决定创建第二个 LV（LV1），那么最终的 PE 布局可能像图 5 这样。<br><img src="/images/2018/1/8.gif" alt=""></p><p><center>图 5. 物理到逻辑区段的映射</center></p><h3 id="设备映射器"><a href="#设备映射器" class="headerlink" title="设备映射器"></a>设备映射器</h3><p>设备映射器（也称为 dm_mod）是一个 Linux 内核模块，最早出现在 2.6.9 内核中。它的作用是对设备进行映射。</p><h2 id="用快照执行备份"><a href="#用快照执行备份" class="headerlink" title="用快照执行备份"></a>用快照执行备份</h2><p>如果在备份过程期间数据没有发生变化，那么就能够获得一致的备份。如果不在备份期间停止系统，就很难保证数据没有变化。</p><p>Linux LVM 实现了一种称为快照（Snapshot）的特性，它的作用就像是 “拍摄” 逻辑卷在某一时刻的照片。通过使用快照， 可以获得同一 LV 的两个拷贝 —— 一个可以用于备份，另一个继续用于日常操作。</p><p>快照有两大优点：</p><ol><li>快照的创建非常快，不需要停止生产环境</li><li>建立两个拷贝，但是它们的大小并不一样。快照使用的空间仅仅是存储两个 LV 之间的差异所需的空间</li></ol><hr><p>参考资料：</p><ol><li><a href="https://www.ibm.com/developerworks/cn/linux/l-lvm2/#artrelatedtopics" target="_blank" rel="noopener">逻辑卷管理</a></li><li><a href="https://segmentfault.com/a/1190000009249534" target="_blank" rel="noopener">LVM、物理卷、逻辑卷、卷组、快照</a></li><li><a href="http://blog.csdn.net/jinbusi_blog/article/details/73718740" target="_blank" rel="noopener">lvm介绍，及基本管理命令</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LVM是 Logical Volume Manager（逻辑卷管理）的简写，它是Linux环境下对磁盘分区进行管理的一种机制。通过使用 LVM，所有物理磁盘和分区，无论它们的大小和分布方式如何，都被抽象为单一存储（single storage）源。例如，在图 1 所示的物理
      
    
    </summary>
    
      <category term="文件系统" scheme="http://liujunming.github.io/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="文件系统" scheme="http://liujunming.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>回环设备loopback device</title>
    <link href="http://liujunming.github.io/2018/01/17/%E5%9B%9E%E7%8E%AF%E8%AE%BE%E5%A4%87loopback-device/"/>
    <id>http://liujunming.github.io/2018/01/17/回环设备loopback-device/</id>
    <published>2018-01-17T12:34:33.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>你有没有想过在Linux的文件管理系统中再创建一个文件系统，这时你就需要用到回环设备（loop device）。</p><p>在Linux中，<strong>回环设备允许用户以一个普通磁盘文件虚拟一个块设备</strong>。设想一个磁盘设备，对它的所有读写操作都将被重定向到读写一个名为 disk-image 的普通文件而非操作实际磁盘或分区的轨道和扇区。当然，disk-image这个名字你可以任意取，但这个文件必须存在于一个实际的磁盘上，而这个实际的磁盘必须比虚拟的磁盘（disk-image）容量更大。</p><p>回环设备的使用与其它任何块设备相同。特别是，你可以在这个设备上创建文件系统并像普通的磁盘一样将它挂载在系统中。这样的一个将全部内容保存在一个普通文件中的文件系统，被称为虚拟文件系统（virtual file system）。</p><p>下面就来演示用磁盘文件创建一个Linux回环文件系统的步骤。</p><h2 id="创建一个用于承载虚拟文件系统的空文件"><a href="#创建一个用于承载虚拟文件系统的空文件" class="headerlink" title="创建一个用于承载虚拟文件系统的空文件"></a>创建一个用于承载虚拟文件系统的空文件</h2><p>这个文件的大小将成为挂载后文件系统的大小。创建指定大小文件的简单方法是通过 <code>dd</code> 命令。这个命令以块为单位（通常为 512 字节，或者你也可以自定义块大小）从一个文件向另一个文件复制数据。/dev/zero 文件则是一个很好的数据来源。</p><p>要建立一个 30 MB 大小（zero-filled）的名为 disk-image 的文件可以通过以下命令：<br><code>dd if=/dev/zero of=/tmp/disk-image bs=1M count=30</code></p><h2 id="创建一个loop-device"><a href="#创建一个loop-device" class="headerlink" title="创建一个loop device"></a>创建一个loop device</h2><p>使用losetup命令创建一个loop device<br><code>sudo losetup /dev/loop0 /tmp/disk-image</code></p><h2 id="创建一个文件系统"><a href="#创建一个文件系统" class="headerlink" title="创建一个文件系统"></a>创建一个文件系统</h2><p><code>sudo mkfs -t ext2 /dev/loop0</code><br><img src="/images/2018/1/1.png" alt=""></p><h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><p>创建一个目录 /tmp/virtualfs，这个目录将被用于挂载我们的文件系统:<br><code>mkdir /tmp/virtualfs</code></p><p><code>sudo mount /dev/loop0 /tmp/virtualfs</code><br>这时，这个设备应该已经被挂载，就如同一个普通的30M 空间的磁盘一样。<br><code>df -h /tmp/virtualfs</code><br><img src="/images/2018/1/2.png" alt=""></p><h2 id="使用该磁盘"><a href="#使用该磁盘" class="headerlink" title="使用该磁盘"></a>使用该磁盘</h2><p>你可以向其它任何磁盘一样使用这个设备：<br>要记住的是只有超级用户可以使用环回设备,所以此刻需要切换到root用户<br><code>cd /tmp/virtualfs</code><br><code>echo &#39;Hello, world!&#39; &gt; test.txt</code><br><code>ls -l</code><br><code>cat test.txt</code><br><img src="/images/2018/1/3.png" alt=""></p><h2 id="卸载文件系统"><a href="#卸载文件系统" class="headerlink" title="卸载文件系统"></a>卸载文件系统</h2><p><code>sudo umount -l /dev/loop0</code><br><code>sudo losetup -d /dev/loop0</code><br><code>rm /tmp/disk-image</code></p><hr><p>参考资料：</p><ol><li><a href="http://blog.csdn.net/baimafujinji/article/details/78810042" target="_blank" rel="noopener">csdn baimafujinji</a></li><li><a href="http://blog.csdn.net/zgyrelax/article/details/17579411" target="_blank" rel="noopener">csdn zgyrelax</a></li><li><a href="http://www.zphj1987.com/2015/03/22/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAloop-device/" target="_blank" rel="noopener">zphj1987</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你有没有想过在Linux的文件管理系统中再创建一个文件系统，这时你就需要用到回环设备（loop device）。&lt;/p&gt;
&lt;p&gt;在Linux中，&lt;strong&gt;回环设备允许用户以一个普通磁盘文件虚拟一个块设备&lt;/strong&gt;。设想一个磁盘设备，对它的所有读写操作都将被重定
      
    
    </summary>
    
      <category term="文件系统" scheme="http://liujunming.github.io/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="文件系统" scheme="http://liujunming.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>filebench 环境搭建</title>
    <link href="http://liujunming.github.io/2017/12/24/filebench-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://liujunming.github.io/2017/12/24/filebench-环境搭建/</id>
    <published>2017-12-24T08:25:27.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="filebench"><a href="#filebench" class="headerlink" title="filebench"></a>filebench</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><code>wget https://jaist.dl.sourceforge.net/project/filebench/1.5-alpha3/filebench-1.5-alpha3.tar.gz</code></p><p><code>tar -zxf filebench-1.5-alpha3.tar.gz -C /usr/local</code></p><p><code>apt-get install gcc</code></p><p><code>apt-get install flex bison</code></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>cd /usr/local/filebench-1.5-alpha3</code></p><p><code>./configure</code></p><p><code>make</code></p><p><code>make install</code></p><p>安装完成后的界面：<br><img src="/images/2017/12/1.jpeg" alt=""></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><code>cd /usr/local/share/filebench/workloads</code></p><p><code>filebench -f webserver.f</code></p><h3 id="Workload-model-language解析"><a href="#Workload-model-language解析" class="headerlink" title="Workload model language解析"></a>Workload model language解析</h3><p>以videoserver.f为例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">set $dir=/tmp</span><br><span class="line">set $eventrate=96</span><br><span class="line">set $filesize=10g</span><br><span class="line">set $nthreads=48</span><br><span class="line">set $numactivevids=32</span><br><span class="line">set $numpassivevids=194</span><br><span class="line">set $reuseit=false</span><br><span class="line">set $readiosize=256k</span><br><span class="line">set $writeiosize=1m</span><br><span class="line"></span><br><span class="line">set $passvidsname=passivevids</span><br><span class="line">set $actvidsname=activevids</span><br><span class="line"></span><br><span class="line">set $repintval=10</span><br><span class="line"></span><br><span class="line">eventgen rate=$eventrate</span><br><span class="line"></span><br><span class="line">define fileset name=$actvidsname,path=$dir,size=$filesize,entries=$numactivevids,dirwidth=4,prealloc,paralloc,reuse=$reuseit</span><br><span class="line">define fileset name=$passvidsname,path=$dir,size=$filesize,entries=$numpassivevids,dirwidth=20,prealloc=50,paralloc,reuse=$reuseit</span><br><span class="line"></span><br><span class="line">define process name=vidwriter,instances=1</span><br><span class="line">&#123;</span><br><span class="line">  thread name=vidwriter,memsize=10m,instances=1</span><br><span class="line">  &#123;</span><br><span class="line">    flowop deletefile name=vidremover,filesetname=$passvidsname</span><br><span class="line">    flowop createfile name=wrtopen,filesetname=$passvidsname,fd=1</span><br><span class="line">    flowop writewholefile name=newvid,iosize=$writeiosize,fd=1,srcfd=1</span><br><span class="line">    flowop closefile name=wrtclose, fd=1</span><br><span class="line">    flowop delay name=replaceinterval, value=$repintval</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define process name=vidreaders,instances=1</span><br><span class="line">&#123;</span><br><span class="line">  thread name=vidreaders,memsize=10m,instances=$nthreads</span><br><span class="line">  &#123;</span><br><span class="line">    flowop read name=vidreader,filesetname=$actvidsname,iosize=$readiosize</span><br><span class="line">    flowop bwlimit name=serverlimit, target=vidreader</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo  &quot;Video Server Version 3.0 personality successfully loaded&quot;</span><br><span class="line"></span><br><span class="line">run</span><br></pre></td></tr></table></figure></p><p>workload最后必须要有run。</p><p>define fileset定义数据集：prealloc代表在实际的filebench工作负载启动之前预先分配的文件的百分比；reuse若设置为true，则如果在文件系统中存在相对应的文件，则filebench将重新使用该文件。</p><p>在workload中，run默认时间为60s，如果希望达到指定IO操作数就结束filebench，则可以使用<code>finishoncount</code>，语法为：</p><p><code>flowop finishoncount name=&lt;name&gt;,value=&lt;ops&gt;</code></p><ul><li>name = Mandatory. Name of the flowop.</li><li>value= Mandatory. The number of operations to finish on.</li></ul><hr><p>参考资料：</p><ol><li><a href="https://github.com/filebench/filebench" target="_blank" rel="noopener">github filebench</a></li><li><a href="http://blog.csdn.net/microsoft2014/article/details/60145433" target="_blank" rel="noopener">Filebench的安装与使用</a></li><li><a href="https://github.com/filebench/filebench/wiki/Workload-model-language" target="_blank" rel="noopener">Workload model language</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;filebench&quot;&gt;&lt;a href=&quot;#filebench&quot; class=&quot;headerlink&quot; title=&quot;filebench&quot;&gt;&lt;/a&gt;filebench&lt;/h2&gt;&lt;h3 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="benchmark" scheme="http://liujunming.github.io/categories/benchmark/"/>
    
    
      <category term="benchmark" scheme="http://liujunming.github.io/tags/benchmark/"/>
    
  </entry>
  
  <entry>
    <title>Device mapper direct-lvm 配置</title>
    <link href="http://liujunming.github.io/2017/12/24/Device-mapper-direct-lvm-%E9%85%8D%E7%BD%AE/"/>
    <id>http://liujunming.github.io/2017/12/24/Device-mapper-direct-lvm-配置/</id>
    <published>2017-12-24T07:21:04.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文只介绍Device mapper direct-lvm模式的配置，关于容器的其他知识在后续博客中会有介绍。</p><p>以下过程将创建配置为thin pool的logical volume，以用作存储池的备份。 现在假定在<code>/dev/sda3</code>上有一个备用块设备，并具有足够的可用空间来完成任务。该过程还假定Docker守护进程处于stopped状态。</p><h3 id="1-确定要使用的块设备"><a href="#1-确定要使用的块设备" class="headerlink" title="1. 确定要使用的块设备"></a>1. 确定要使用的块设备</h3><p>确保<code>/dev/sda3</code>有足够的空闲空间，同时确认<code>/dev/sda3</code>是空闲分区。</p><h3 id="2-Stop-Docker"><a href="#2-Stop-Docker" class="headerlink" title="2. Stop Docker"></a>2. Stop Docker</h3><p><code>systemctl stop docker</code></p><p>且需要删除所有镜像和容器，有重要资料，请做好备份：<br><code>rm -rf /var/lib/docker/*</code></p><h3 id="3-创建-physical-volume"><a href="#3-创建-physical-volume" class="headerlink" title="3. 创建 physical volume"></a>3. 创建 physical volume</h3><p> <code>pvcreate /dev/sda3</code></p><h3 id="4-创建docker-volume-group"><a href="#4-创建docker-volume-group" class="headerlink" title="4. 创建docker volume group"></a>4. 创建docker volume group</h3><p><code>vgcreate docker /dev/sda3</code></p><h3 id="5-创建能够组成thin-pool的两个logical-volume"><a href="#5-创建能够组成thin-pool的两个logical-volume" class="headerlink" title="5. 创建能够组成thin-pool的两个logical volume"></a>5. 创建能够组成thin-pool的两个logical volume</h3><p><code>lvcreate --wipesignatures y -n thinpool docker -l 95%VG</code></p><p><code>lvcreate --wipesignatures y -n thinpoolmeta docker -l 1%VG</code></p><h3 id="6-创建thin-pool"><a href="#6-创建thin-pool" class="headerlink" title="6. 创建thin-pool"></a>6. 创建thin-pool</h3><p><code>lvconvert -y --zero n -c 64K --thinpool docker/thinpool --poolmetadata docker/thinpoolmeta</code></p><h3 id="7-配置thin-pool的自动扩展"><a href="#7-配置thin-pool的自动扩展" class="headerlink" title="7. 配置thin-pool的自动扩展"></a>7. 配置thin-pool的自动扩展</h3><p>修改lvm配置文件<br><code>vim /etc/lvm/profile/docker-thinpool.profile</code><br>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activation&#123;</span><br><span class="line">   thin_pool_autoextend_threshold=80</span><br><span class="line">   thin_pool_autoextend_percent=20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="8-激活配置文件"><a href="#8-激活配置文件" class="headerlink" title="8. 激活配置文件"></a>8. 激活配置文件</h3><p><code>lvchange --metadataprofiledocker-thinpool docker/thinpool</code></p><h3 id="9-启用对主机上-logical-volume的监视"><a href="#9-启用对主机上-logical-volume的监视" class="headerlink" title="9. 启用对主机上 logical volume的监视"></a>9. 启用对主机上 logical volume的监视</h3><p><code>lvs -o+seg_monitor</code></p><h3 id="10-使用脚本配置devicemapper-storage-driver"><a href="#10-使用脚本配置devicemapper-storage-driver" class="headerlink" title="10. 使用脚本配置devicemapper storage driver"></a>10. 使用脚本配置devicemapper storage driver</h3><p><code>vim /etc/docker/daemon.json</code></p><p>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;storage-driver&quot;: &quot;devicemapper&quot;,</span><br><span class="line">    &quot;storage-opts&quot;: [</span><br><span class="line">    &quot;dm.thinpooldev=/dev/mapper/docker-thinpool&quot;,</span><br><span class="line">    &quot;dm.use_deferred_removal=true&quot;,</span><br><span class="line">    &quot;dm.use_deferred_deletion=true&quot;,</span><br><span class="line">    &quot;dm.fs=ext4&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="11-开启Docker"><a href="#11-开启Docker" class="headerlink" title="11. 开启Docker"></a>11. 开启Docker</h3><p><code>service docker start</code></p><h4 id="12-验证Docker是否正在使用新的配置"><a href="#12-验证Docker是否正在使用新的配置" class="headerlink" title="12. 验证Docker是否正在使用新的配置"></a>12. 验证Docker是否正在使用新的配置</h4><p><code>docker info</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 17.03.1-ce</span><br><span class="line">Storage Driver: devicemapper</span><br><span class="line"> Pool Name: docker-thinpool</span><br><span class="line"> Pool Blocksize: 524.3 kB</span><br><span class="line"> Base Device Size: 10.74 GB</span><br><span class="line"> Backing Filesystem: ext4</span><br><span class="line"> Data file:</span><br><span class="line"> Metadata file:</span><br><span class="line"> Data Space Used: 19.92 MB</span><br><span class="line"> Data Space Total: 102 GB</span><br><span class="line"> Data Space Available: 102 GB</span><br><span class="line"> Metadata Space Used: 147.5 kB</span><br><span class="line"> Metadata Space Total: 1.07 GB</span><br><span class="line"> Metadata Space Available: 1.069 GB</span><br><span class="line"> Thin Pool Minimum Free Space: 10.2 GB</span><br><span class="line"> Udev Sync Supported: true</span><br><span class="line"> Deferred Removal Enabled: true</span><br><span class="line"> Deferred Deletion Enabled: true</span><br><span class="line"> Deferred Deleted Device Count: 0</span><br><span class="line"> Library Version: 1.02.135-RHEL7 (2016-11-16)</span><br></pre></td></tr></table></figure></p><p>如果Docker配置正确，Data file和Metadata file将是空白的，pool name将是docker-thinpool。<br>如果显示不对，重启主机后再测试。</p><hr><p>参考资料:</p><ol><li><a href="https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#configure-direct-lvm-mode-for-production" target="_blank" rel="noopener">Use the Device mapper storage driver</a></li><li><a href="http://blog.csdn.net/a85880819/article/details/52457702" target="_blank" rel="noopener">Devicemapper的direct-lvm模式</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文只介绍Device mapper direct-lvm模式的配置，关于容器的其他知识在后续博客中会有介绍。&lt;/p&gt;
&lt;p&gt;以下过程将创建配置为thin pool的logical volume，以用作存储池的备份。 现在假定在&lt;code&gt;/dev/sda3&lt;/code&gt;上
      
    
    </summary>
    
      <category term="容器" scheme="http://liujunming.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="容器" scheme="http://liujunming.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="docker" scheme="http://liujunming.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Sysbench环境搭建</title>
    <link href="http://liujunming.github.io/2017/11/27/Sysbench%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://liujunming.github.io/2017/11/27/Sysbench环境搭建/</id>
    <published>2017-11-27T10:01:14.000Z</published>
    <updated>2018-06-25T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sysbench"><a href="#sysbench" class="headerlink" title="sysbench"></a>sysbench</h2><p>本文只介绍sysbench的使用教程，详细介绍见参考资料。</p><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><ul><li><code>sudo apt-get install mysql-server</code></li></ul><p>安装过程中需要设置密码，我们设置为123。</p><ul><li>更改mysql配置文件</li></ul><p><code>vim /etc/mysql/mysql.conf.d/mysqld.cnf</code>或者<code>vim /etc/mysql/my.cnf</code><br>这一步依照自己的需求而定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size = 16M</span><br><span class="line">query_cache_type        = 0 #关闭mysql cache</span><br><span class="line">query_cache_size        = 0M</span><br></pre></td></tr></table></figure></p><p>更改完配置文件之后，需要重启mysql:<code>sudo service  mysql restart</code></p><h3 id="安装sysbench"><a href="#安装sysbench" class="headerlink" title="安装sysbench"></a>安装sysbench</h3><ul><li><code>sudo apt-get install sysbench</code></li></ul><h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><ul><li>进入mysql</li></ul><p><code>mysql -u root -p</code></p><ul><li>创建数据库 </li></ul><p><code>create database sbtest;</code></p><ul><li><p>创建测试数据 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysbench --test=oltp --oltp-test-mode=nontrx --mysql-table-engine=innodb --mysql-user=root --db-driver=mysql --num-threads=8 --max-requests=5000000  --oltp-nontrx-mode=select --mysql-db=sbtest  --oltp-table-size=7000000 --oltp-table-name=sbtest  --mysql-host=127.0.0.1 --mysql-socket=/var/run/mysqld/mysqld.sock --mysql-password=123 prepare</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time sysbench --test=oltp --oltp-test-mode=nontrx --mysql-table-engine=innodb --mysql-user=root --db-driver=mysql --num-threads=8 --max-requests=5000000  --oltp-nontrx-mode=select --mysql-db=sbtest  --oltp-table-size=7000000 --oltp-table-name=sbtest  --mysql-host=127.0.0.1 --mysql-socket=/var/run/mysqld/mysqld.sock --mysql-password=123 run</span><br></pre></td></tr></table></figure></li></ul><p>性能指标为每秒处理的事务数：<br><img src="/images/2017/11/1.png" alt=""></p><ul><li>注意事项：</li></ul><p>如果需要提前将测试数据读入内存，可使用如下指令：<br><code>use sbtest;</code><br><code>select count(id) from (select * from sbtest)aa;</code></p><p>如果需要重新创建测试数据，则需要删除原先的数据：<br><code>drop table sbtest;</code></p><p>查看cache hit情况可使用如下指令：<br><code>show global status like &#39;innodb%read%&#39;;</code></p><hr><p>参考资料:</p><ol><li><a href="http://www.cnblogs.com/zhoujinyi/archive/2013/04/19/3029134.html" target="_blank" rel="noopener">sysbench 安装、使用和测试</a></li><li><a href="http://imysql.cn/node/312" target="_blank" rel="noopener">sysbench的安装和做性能测试</a></li><li><a href="http://blog.csdn.net/cy309173854/article/details/53112904" target="_blank" rel="noopener">sysbench压力测试工具使用方法</a></li><li><a href="http://blog.csdn.net/lijingkuan/article/details/72801097" target="_blank" rel="noopener">sysbench简单使用介绍</a></li><li><a href="http://keithlan.github.io/2016/12/16/sysbench_mysql/" target="_blank" rel="noopener">使用sysbench对mysql进行测试</a></li><li><a href="http://imysql.com/2015/03/27/mysql-faq-why-should-we-disable-query-cache.shtml" target="_blank" rel="noopener">为什么要关闭query cache，如何关闭</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sysbench&quot;&gt;&lt;a href=&quot;#sysbench&quot; class=&quot;headerlink&quot; title=&quot;sysbench&quot;&gt;&lt;/a&gt;sysbench&lt;/h2&gt;&lt;p&gt;本文只介绍sysbench的使用教程，详细介绍见参考资料。&lt;/p&gt;
&lt;h3 id=&quot;安装my
      
    
    </summary>
    
      <category term="benchmark" scheme="http://liujunming.github.io/categories/benchmark/"/>
    
    
      <category term="benchmark" scheme="http://liujunming.github.io/tags/benchmark/"/>
    
  </entry>
  
</feed>
