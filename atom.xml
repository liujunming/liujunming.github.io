<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2022-01-08T09:49:32.476Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notes about FPU implementation in Linux kernel</title>
    <link href="http://liujunming.github.io/2022/01/08/Notes-about-FPU-implementation-in-Linux-kernel/"/>
    <id>http://liujunming.github.io/2022/01/08/Notes-about-FPU-implementation-in-Linux-kernel/</id>
    <published>2022-01-08T00:43:20.000Z</published>
    <updated>2022-01-08T09:49:32.476Z</updated>
    
    <content type="html"><![CDATA[<p>本文将结合kernel <a href="https://elixir.bootlin.com/linux/v5.15-rc6/source" target="_blank" rel="noopener">v5.15-rc6</a>，记录下FPU相关的笔记。<a id="more"></a></p><p>建议先阅读<a href="/2021/11/12/Notes-about-XSAVE-feature-set/">Notes about XSAVE feature set</a>。</p><h3 id="TIF-NEED-FPU-LOAD"><a href="#TIF-NEED-FPU-LOAD" class="headerlink" title="TIF_NEED_FPU_LOAD"></a>TIF_NEED_FPU_LOAD</h3><ul><li><p>If <code>TIF_NEED_FPU_LOAD</code> is cleared then the CPU’s FPU registers hold current thread’s FPU registers. </p></li><li><p>If <code>TIF_NEED_FPU_LOAD</code> is set then CPU’s FPU registers may not hold current()’s FPU registers. It is required to load the registers before returning to userland or using the content otherwise.</p></li></ul><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">schedule(kernel/sched/core.c)</span><br><span class="line">    __schedule(kernel/sched/core.c)</span><br><span class="line">    pick_next_task(kernel/sched/core.c)</span><br><span class="line">        context_switch(kernel/sched/core.c)</span><br><span class="line">            switch_to(arch/x86/include/<span class="keyword">asm</span>/switch_to.h)</span><br><span class="line">            __switch_to_asm(arch/x86/entry/entry_64.S)</span><br><span class="line">                    __switch_to(arch/x86/kernel/process_64.c)</span><br><span class="line">                        switch_fpu_prepare</span><br></pre></td></tr></table></figure><h3 id="Defer-FPU-state-load-until-return-to-userspace"><a href="#Defer-FPU-state-load-until-return-to-userspace" class="headerlink" title="Defer FPU state load until return to userspace"></a>Defer FPU state load until return to userspace</h3><p><a href="https://lore.kernel.org/lkml/20181107194858.9380-24-bigeasy@linutronix.de/" target="_blank" rel="noopener">https://lore.kernel.org/lkml/20181107194858.9380-24-bigeasy@linutronix.de/</a></p><p>Idea:Defer loading of FPU state until return to userspace. This gives the kernel the potential to skip loading FPU state for tasks that stay in kernel mode.</p><ul><li>save the FPU register into xsave area for the previous task when task switch occurs</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.15-rc6/source/arch/x86/kernel/process_64.c#L568</span></span><br><span class="line">__switch_to</span><br><span class="line">switch_fpu_prepare</span><br><span class="line">save_fpregs_to_fpstate</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!test_thread_flag(TIF_NEED_FPU_LOAD))</span><br><span class="line">switch_fpu_prepare(prev_fpu, cpu);</span><br></pre></td></tr></table></figure><p>为什么要加<code>!test_thread_flag(TIF_NEED_FPU_LOAD)</code>这一判断呢？<br>因为只有当前cpu fpu的寄存器状态属于previous task时，才能调用switch_fpu_prepare。</p><ul><li>set <code>TIF_NEED_FPU_LOAD</code> for the next task when task switch occurs</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.15-rc6/source/arch/x86/kernel/process_64.c#L623</span></span><br><span class="line">__switch_to</span><br><span class="line">switch_fpu_finish(next_fpu);</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.15-rc6/source/arch/x86/include/asm/fpu/internal.h#L534</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Delay loading of the complete FPU state until the return to userland.</span></span><br><span class="line"><span class="comment"> * PKRU is handled separately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">switch_fpu_finish</span><span class="params">(struct fpu *new_fpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cpu_feature_enabled(X86_FEATURE_FPU))</span><br><span class="line">set_thread_flag(TIF_NEED_FPU_LOAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch-fpu-prepare"><a href="#switch-fpu-prepare" class="headerlink" title="switch_fpu_prepare"></a>switch_fpu_prepare</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.15-rc6/source/arch/x86/include/asm/fpu/internal.h#L508</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * FPU state switching for scheduling.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is a two-stage process:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - switch_fpu_prepare() saves the old state.</span></span><br><span class="line"><span class="comment"> *    This is done within the context of the old process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - switch_fpu_finish() sets TIF_NEED_FPU_LOAD; the floating point state</span></span><br><span class="line"><span class="comment"> *    will get loaded on return to userspace, or when the kernel needs it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If TIF_NEED_FPU_LOAD is cleared then the CPU's FPU registers</span></span><br><span class="line"><span class="comment"> * are saved in the current thread's FPU register state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If TIF_NEED_FPU_LOAD is set then CPU's FPU registers may not</span></span><br><span class="line"><span class="comment"> * hold current()'s FPU registers. It is required to load the</span></span><br><span class="line"><span class="comment"> * registers before returning to userland or using the content</span></span><br><span class="line"><span class="comment"> * otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The FPU context is only stored/restored for a user task and</span></span><br><span class="line"><span class="comment"> * PF_KTHREAD is used to distinguish between kernel and user threads.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">switch_fpu_prepare</span><span class="params">(struct fpu *old_fpu, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (static_cpu_has(X86_FEATURE_FPU) &amp;&amp; !(current-&gt;flags &amp; PF_KTHREAD)) &#123;</span><br><span class="line">save_fpregs_to_fpstate(old_fpu);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The save operation preserved register state, so the</span></span><br><span class="line"><span class="comment"> * fpu_fpregs_owner_ctx is still @old_fpu. Store the</span></span><br><span class="line"><span class="comment"> * current CPU number in @old_fpu, so the next return</span></span><br><span class="line"><span class="comment"> * to user space can avoid the FPU register restore</span></span><br><span class="line"><span class="comment"> * when is returns on the same CPU and still owns the</span></span><br><span class="line"><span class="comment"> * context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">old_fpu-&gt;last_cpu = cpu;</span><br><span class="line"></span><br><span class="line">trace_x86_fpu_regs_deactivated(old_fpu);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exit-to-user-mode"><a href="#exit-to-user-mode" class="headerlink" title="exit to user mode"></a>exit to user mode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exit_to_user_mode_prepare</span><br><span class="line">    arch_exit_to_user_mode_prepare</span><br><span class="line">        switch_fpu_return</span><br><span class="line">        fpregs_restore_userregs</span><br><span class="line">        __restore_fpregs_from_fpstate</span><br><span class="line">        fpregs_activate</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syscall_exit_to_user_mode</span><br><span class="line">    __syscall_exit_to_user_mode_work</span><br><span class="line">        exit_to_user_mode_prepare</span><br><span class="line">            arch_exit_to_user_mode_prepare</span><br><span class="line">__exit_to_user_mode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">irqentry_exit_to_user_mode</span><br><span class="line">__exit_to_user_mode</span><br></pre></td></tr></table></figure><h3 id="fpregs-restore-userregs"><a href="#fpregs-restore-userregs" class="headerlink" title="fpregs_restore_userregs"></a>fpregs_restore_userregs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.15-rc6/source/arch/x86/include/asm/fpu/internal.h#L456</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fpregs_restore_userregs</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">fpu</span> = &amp;<span class="title">current</span>-&gt;<span class="title">thread</span>.<span class="title">fpu</span>;</span></span><br><span class="line"><span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(current-&gt;flags &amp; PF_KTHREAD))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fpregs_state_valid(fpu, cpu)) &#123;</span><br><span class="line">u64 mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This restores _all_ xstate which has not been</span></span><br><span class="line"><span class="comment"> * established yet.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If PKRU is enabled, then the PKRU value is already</span></span><br><span class="line"><span class="comment"> * correct because it was either set in switch_to() or in</span></span><br><span class="line"><span class="comment"> * flush_thread(). So it is excluded because it might be</span></span><br><span class="line"><span class="comment"> * not up to date in current-&gt;thread.fpu.xsave state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mask = xfeatures_mask_restore_user() |</span><br><span class="line">xfeatures_mask_supervisor();</span><br><span class="line">__restore_fpregs_from_fpstate(&amp;fpu-&gt;state, mask);</span><br><span class="line"></span><br><span class="line">fpregs_activate(fpu);</span><br><span class="line">fpu-&gt;last_cpu = cpu;</span><br><span class="line">&#125;</span><br><span class="line">clear_thread_flag(TIF_NEED_FPU_LOAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpregs_state_valid</span><span class="params">(struct fpu *fpu, <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fpu == this_cpu_read(fpu_fpregs_owner_ctx) &amp;&amp; cpu == fpu-&gt;last_cpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Highest level per task FPU state data structure that</span></span><br><span class="line"><span class="comment"> * contains the FPU register state plus various FPU</span></span><br><span class="line"><span class="comment"> * state fields:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @last_cpu:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Records the last CPU on which this context was loaded into</span></span><br><span class="line"><span class="comment"> * FPU registers. (In the lazy-restore case we might be</span></span><br><span class="line"><span class="comment"> * able to reuse FPU registers across multiple context switches</span></span><br><span class="line"><span class="comment"> * this way, if no intermediate task used the FPU.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A value of -1 is used to indicate that the FPU state in context</span></span><br><span class="line"><span class="comment"> * memory is newer than the FPU state in registers, and that the</span></span><br><span class="line"><span class="comment"> * FPU state should be reloaded next time the task is run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>last_cpu;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @avx512_timestamp:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Records the timestamp of AVX512 use during last context switch.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>avx512_timestamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @state:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In-memory copy of all FPU registers that we save/restore</span></span><br><span class="line"><span class="comment"> * over context switches. If the task is using the FPU then</span></span><br><span class="line"><span class="comment"> * the registers in the FPU are more recent than this state</span></span><br><span class="line"><span class="comment"> * copy. If the task context-switches away then they get</span></span><br><span class="line"><span class="comment"> * saved here and represent the FPU state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">union</span> fpregs_statestate;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * WARNING: 'state' is dynamically-sized.  Do not put</span></span><br><span class="line"><span class="comment"> * anything after it here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fpregs_activate</span><br><span class="line">this_cpu_write(fpu_fpregs_owner_ctx, fpu)</span><br><span class="line"></span><br><span class="line">fpregs_deactivate</span><br><span class="line">this_cpu_write(fpu_fpregs_owner_ctx, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="kernel-fpu-begin-kernel-fpu-end"><a href="#kernel-fpu-begin-kernel-fpu-end" class="headerlink" title="kernel_fpu_begin/kernel_fpu_end"></a>kernel_fpu_begin/kernel_fpu_end</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">kernel_fpu_begin</span><br><span class="line">kernel_fpu_begin_mask(KFPU_MXCSR)</span><br><span class="line">__cpu_invalidate_fpregs_state</span><br><span class="line">__this_cpu_write(fpu_fpregs_owner_ctx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_KTHREAD0x00200000<span class="comment">/* I am a kernel thread */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kernel_fpu_begin_mask</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> kfpu_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">preempt_disable();</span><br><span class="line"></span><br><span class="line">WARN_ON_FPU(!irq_fpu_usable());</span><br><span class="line">WARN_ON_FPU(this_cpu_read(in_kernel_fpu));</span><br><span class="line"></span><br><span class="line">this_cpu_write(in_kernel_fpu, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(current-&gt;flags &amp; PF_KTHREAD) &amp;&amp;</span><br><span class="line">    !test_thread_flag(TIF_NEED_FPU_LOAD)) &#123;</span><br><span class="line">set_thread_flag(TIF_NEED_FPU_LOAD);</span><br><span class="line">save_fpregs_to_fpstate(&amp;current-&gt;thread.fpu);</span><br><span class="line">&#125;</span><br><span class="line">__cpu_invalidate_fpregs_state();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Put sane initial values into the control registers. */</span></span><br><span class="line"><span class="keyword">if</span> (likely(kfpu_mask &amp; KFPU_MXCSR) &amp;&amp; boot_cpu_has(X86_FEATURE_XMM))</span><br><span class="line">ldmxcsr(MXCSR_DEFAULT);</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kernel_fpu_end</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WARN_ON_FPU(!this_cpu_read(in_kernel_fpu));</span><br><span class="line"></span><br><span class="line">this_cpu_write(in_kernel_fpu, <span class="literal">false</span>);</span><br><span class="line">preempt_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将结合kernel &lt;a href=&quot;https://elixir.bootlin.com/linux/v5.15-rc6/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v5.15-rc6&lt;/a&gt;，记录下FPU相关的笔记。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>The usage of cpu hot(un)plug in QEMU</title>
    <link href="http://liujunming.github.io/2022/01/07/The-usage-of-cpu-hot-un-plug-in-QEMU/"/>
    <id>http://liujunming.github.io/2022/01/07/The-usage-of-cpu-hot-un-plug-in-QEMU/</id>
    <published>2022-01-07T06:48:33.000Z</published>
    <updated>2022-01-07T15:08:48.460Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍在QEMU KVM 环境下，cpu hot(un)plug的使用。<a id="more"></a></p><h3 id="1-Kernel-Configuration"><a href="#1-Kernel-Configuration" class="headerlink" title="1. Kernel Configuration"></a>1. Kernel Configuration</h3><p>To use the cpu hotplug feature,  need to select the following items:</p><ul><li>CONFIG_SMP</li><li>CONFIG_HOTPLUG_CPU</li><li>CONFIG_ACPI_HOTPLUG_CPU</li></ul><h3 id="2-QEMU-launch-script-setting"><a href="#2-QEMU-launch-script-setting" class="headerlink" title="2. QEMU launch script setting"></a>2. QEMU launch script setting</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu [...] -smp 1,maxcpus=4 -qmp unix:/tmp/qmp-sock,server=on,wait=off</span><br></pre></td></tr></table></figure><p>note that the “maxcpus” is mandatory to allow vCPU hotplug.</p><h3 id="3-Run-‘qmp-shell’"><a href="#3-Run-‘qmp-shell’" class="headerlink" title="3. Run ‘qmp-shell’"></a>3. Run ‘qmp-shell’</h3><p>Run ‘qmp-shell’ (located in the source tree, under: “scripts/qmp/“) to connect to the just-launched QEMU:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./qmp-shell -p -v /tmp/qmp-sock</span><br><span class="line">Welcome to the QMP low-level shell!</span><br><span class="line">Connected to QEMU 5.1.0</span><br><span class="line"></span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure></p><h3 id="4-Find-out-which-CPU-types-could-be-plugged-and-into-which-sockets"><a href="#4-Find-out-which-CPU-types-could-be-plugged-and-into-which-sockets" class="headerlink" title="4. Find out which CPU types could be plugged, and into which sockets:"></a>4. Find out which CPU types could be plugged, and into which sockets:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">(QEMU) query-hotpluggable-cpus</span><br><span class="line">&#123;</span><br><span class="line">    &quot;execute&quot;: &quot;query-hotpluggable-cpus&quot;,</span><br><span class="line">    &quot;arguments&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;return&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 3</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;vcpus-count&quot;: 1,</span><br><span class="line">            &quot;type&quot;: &quot;host-x86_64-cpu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 2</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;vcpus-count&quot;: 1,</span><br><span class="line">            &quot;type&quot;: &quot;host-x86_64-cpu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 1</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;vcpus-count&quot;: 1,</span><br><span class="line">            &quot;type&quot;: &quot;host-x86_64-cpu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;vcpus-count&quot;: 1,</span><br><span class="line">            &quot;qom-path&quot;: &quot;/machine/unattached/device[0]&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;host-x86_64-cpu&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure><p>The <code>query-hotpluggable-cpus</code> command returns an object for CPUs that are present (containing a “qom-path” member) or which may be hot-plugged (no “qom-path” member). From the output, we can see that <code>host-x86_64-cpu</code> is present in socket 0, while hot-plugging a CPU into socket 1 requires passing the listed properties to QMP <code>device_add</code>.</p><h3 id="5-Hotplug"><a href="#5-Hotplug" class="headerlink" title="5. Hotplug"></a>5. Hotplug</h3><p>Before  running <code>device_add</code>, run the following command lines.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /sys/devices/system/cpu</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">cpu0</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(QEMU) query-cpus-fast</span><br><span class="line">&#123;</span><br><span class="line">    &quot;execute&quot;: &quot;query-cpus-fast&quot;,</span><br><span class="line">    &quot;arguments&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;return&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;arch&quot;: &quot;x86&quot;,</span><br><span class="line">            &quot;thread-id&quot;: 20077,</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;qom-path&quot;: &quot;/machine/unattached/device[0]&quot;,</span><br><span class="line">            &quot;cpu-index&quot;: 0,</span><br><span class="line">            &quot;target&quot;: &quot;x86_64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure><p>CPU hot-add:<br><strong><em>{ ‘command’: ‘device_add’, ‘data’: {‘driver’: ‘str’, ‘id’: ‘str’, … }}</em></strong></p><ul><li>mandatory properties for every CPU<ul><li>driver: cpu model type name</li><li>id: unique device name</li></ul></li><li>target/configuration dependent properties<ul><li>socket-id: socket number in range [0..max sockets)</li><li>core-id: core number in range [0..max cores)</li><li>thread-id: thread-id in range [..max threads)</li><li>node-id: NUMA node ID the CPU belongs to</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(QEMU) device_add driver=host-x86_64-cpu socket-id=1 core-id=0 thread-id=0 id=cpu2</span><br><span class="line">&#123;</span><br><span class="line">    &quot;execute&quot;: &quot;device_add&quot;,</span><br><span class="line">    &quot;arguments&quot;: &#123;</span><br><span class="line">        &quot;driver&quot;: &quot;host-x86_64-cpu&quot;,</span><br><span class="line">        &quot;socket-id&quot;: 1,</span><br><span class="line">        &quot;core-id&quot;: 0,</span><br><span class="line">        &quot;thread-id&quot;: 0,</span><br><span class="line">        &quot;id&quot;: &quot;cpu2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;return&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure><p>After  running <code>device_add</code>, run the following command lines.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /sys/devices/system/cpu</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">cpu0</span><br><span class="line">cpu1</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(QEMU) query-cpus-fast</span><br><span class="line">&#123;</span><br><span class="line">    &quot;execute&quot;: &quot;query-cpus-fast&quot;,</span><br><span class="line">    &quot;arguments&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;return&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;arch&quot;: &quot;x86&quot;,</span><br><span class="line">            &quot;thread-id&quot;: 20077,</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;qom-path&quot;: &quot;/machine/unattached/device[0]&quot;,</span><br><span class="line">            &quot;cpu-index&quot;: 0,</span><br><span class="line">            &quot;target&quot;: &quot;x86_64&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;arch&quot;: &quot;x86&quot;,</span><br><span class="line">            &quot;thread-id&quot;: 20117,</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 1</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;qom-path&quot;: &quot;/machine/peripheral/cpu2&quot;,</span><br><span class="line">            &quot;cpu-index&quot;: 1,</span><br><span class="line">            &quot;target&quot;: &quot;x86_64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure><p><strong>Optionally online newly added CPU inside guest</strong><br>Linux kernel doesn’t online hot-added CPUs automatically. Once CPU is hot-added it should be onlined using an appropriate udev script or manually by issuing a following command:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/devices/system/cpu/cpu1/online</span><br></pre></td></tr></table></figure></p><h3 id="6-Hotunplug"><a href="#6-Hotunplug" class="headerlink" title="6. Hotunplug"></a>6. Hotunplug</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(QEMU) device_del id=cpu2</span><br><span class="line">&#123;</span><br><span class="line">    &quot;execute&quot;: &quot;device_del&quot;,</span><br><span class="line">    &quot;arguments&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;cpu2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;return&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure><p>After  running <code>device_del</code>, run the following command lines.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /sys/devices/system/cpu</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">cpu0</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(QEMU) query-cpus-fast</span><br><span class="line">&#123;</span><br><span class="line">    &quot;execute&quot;: &quot;query-cpus-fast&quot;,</span><br><span class="line">    &quot;arguments&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;return&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;arch&quot;: &quot;x86&quot;,</span><br><span class="line">            &quot;thread-id&quot;: 20077,</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;qom-path&quot;: &quot;/machine/unattached/device[0]&quot;,</span><br><span class="line">            &quot;cpu-index&quot;: 0,</span><br><span class="line">            &quot;target&quot;: &quot;x86_64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://qemu.readthedocs.io/en/latest/system/cpu-hotplug.html" target="_blank" rel="noopener">Virtual CPU hotplug</a></li><li><a href="https://wiki.qemu.org/Features/CPUHotplug" target="_blank" rel="noopener">Features/CPUHotplug</a></li><li><a href="http://events17.linuxfoundation.org/sites/events/files/slides/CPU%20Hot-plug%20support%20in%20QEMU.pdf" target="_blank" rel="noopener">QEMU CPU Hotplug</a></li><li><a href="https://github.com/esminc/qemu/blob/master/Source/device-qemu/android/android-goldfish-2.6.29/Documentation/cpu-hotplug.txt" target="_blank" rel="noopener">cpu-hotplug.txt</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍在QEMU KVM 环境下，cpu hot(un)plug的使用。
    
    </summary>
    
      <category term="QEMU" scheme="http://liujunming.github.io/categories/QEMU/"/>
    
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="hotplug" scheme="http://liujunming.github.io/tags/hotplug/"/>
    
  </entry>
  
  <entry>
    <title>The usage of memory hot(un)plug in QEMU</title>
    <link href="http://liujunming.github.io/2022/01/07/The-usage-of-memory-hotplug-under-QEMU-KVM/"/>
    <id>http://liujunming.github.io/2022/01/07/The-usage-of-memory-hotplug-under-QEMU-KVM/</id>
    <published>2022-01-06T16:27:39.000Z</published>
    <updated>2022-01-07T15:08:48.461Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍在QEMU KVM 环境下，memory hot(un)plug的使用。<a id="more"></a></p><h3 id="1-Kernel-Configuration"><a href="#1-Kernel-Configuration" class="headerlink" title="1. Kernel Configuration"></a>1. Kernel Configuration</h3><p>To use the memory hotplug feature, <code>CONFIG_ACPI_HOTPLUG_MEMORY</code> should be selected.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /boot/config-5.4.0-92-generic | grep CONFIG_ACPI_HOTPLUG_MEMORY</span><br><span class="line">CONFIG_ACPI_HOTPLUG_MEMORY=y</span><br></pre></td></tr></table></figure></p><h3 id="2-QEMU-launch-script-setting"><a href="#2-QEMU-launch-script-setting" class="headerlink" title="2. QEMU launch script setting"></a>2. QEMU launch script setting</h3><p>In order to be able to hotplug memory, QEMU has to be told how many hotpluggable memory slots to create and what is the maximum amount of memory the guest can grow. This is done at startup time by means of the <code>-m</code> command-line option, which has the following format:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-m [size=]megs[,slots=n,maxmem=size]</span><br></pre></td></tr></table></figure></p><p>Where,</p><ul><li>“megs” is the startup RAM. It is the RAM the guest will boot with</li><li>“slots” is the number of hotpluggable memory slots</li><li>“maxmem” is the maximum RAM size the guest can have</li></ul><p>For example, the following command-line:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu [...] -m 1G,slots=3,maxmem=4G</span><br></pre></td></tr></table></figure></p><p>Creates a guest with 1GB of memory and three hotpluggable memory slots. The hotpluggable memory slots are empty when the guest is booted, so all memory the guest will see after boot is 1GB. The maximum memory the guest can reach is 4GB. This means that three additional gigabytes can be hotplugged by using any combination of the available memory slots.</p><h3 id="3-Hotplug"><a href="#3-Hotplug" class="headerlink" title="3. Hotplug"></a>3. Hotplug</h3><p>Before  running <code>device_add</code>, run the following command lines.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/meminfo | head -2</span><br><span class="line">MemTotal:         727172 kB</span><br><span class="line">MemFree:           59700 kB</span><br><span class="line">$ ls /sys/devices/system/memory/ | grep memory</span><br><span class="line">memory0</span><br><span class="line">memory1</span><br><span class="line">memory2</span><br><span class="line">memory3</span><br><span class="line">memory4</span><br><span class="line">memory5</span><br><span class="line">memory6</span><br><span class="line">memory7</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(qemu) object_add memory-backend-ram,id=mem1,size=1G</span><br><span class="line">(qemu) device_add pc-dimm,id=dimm1,memdev=mem1</span><br></pre></td></tr></table></figure><p>After  running <code>device_add</code>, run the following command lines.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/meminfo | head -2</span><br><span class="line">MemTotal:        1785560 kB</span><br><span class="line">MemFree:         1115004 kB</span><br><span class="line">$ ls /sys/devices/system/memory/ | grep memory</span><br><span class="line">memory0</span><br><span class="line">memory1</span><br><span class="line">memory2</span><br><span class="line">memory3</span><br><span class="line">memory32</span><br><span class="line">memory33</span><br><span class="line">memory34</span><br><span class="line">memory35</span><br><span class="line">memory36</span><br><span class="line">memory37</span><br><span class="line">memory38</span><br><span class="line">memory39</span><br><span class="line">memory4</span><br><span class="line">memory5</span><br><span class="line">memory6</span><br><span class="line">memory7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ cat /sys/devices/system/memory/memory33/state</span><br><span class="line">online</span><br></pre></td></tr></table></figure></p><h3 id="4-Hotunplug"><a href="#4-Hotunplug" class="headerlink" title="4. Hotunplug"></a>4. Hotunplug</h3><p>You may need to add <code>movable_node</code> in guest kernel command line firstly!</p><p>In order to be able to hot unplug pc-dimm device, QEMU has to be told the ids of pc-dimm device and memory backend object. The ids were assigned when you hot plugged memory.</p><p>Two monitor commands are used to hot unplug memory:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- &quot;device_del&quot;: deletes a front-end pc-dimm device</span><br><span class="line">- &quot;object_del&quot;: deletes a memory backend object</span><br></pre></td></tr></table></figure></p><p>For example, assuming that the pc-dimm device with id “dimm1” exists, and its memory backend is “mem1”, the following commands tries to remove it.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(qemu) device_del dimm1</span><br><span class="line">(qemu) object_del mem1</span><br></pre></td></tr></table></figure></p><p>After  running <code>device_del</code>, run the following command lines.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/meminfo | head -2</span><br><span class="line">MemTotal:         736984 kB</span><br><span class="line">MemFree:           87368 kB</span><br><span class="line">$ ls /sys/devices/system/memory/ | grep memory</span><br><span class="line">memory0</span><br><span class="line">memory1</span><br><span class="line">memory2</span><br><span class="line">memory3</span><br><span class="line">memory4</span><br><span class="line">memory5</span><br><span class="line">memory6</span><br><span class="line">memory7</span><br></pre></td></tr></table></figure></p><hr><p>参考资料:</p><ol><li><a href="https://github.com/qemu/qemu/blob/master/docs/memory-hotplug.txt" target="_blank" rel="noopener">QEMU memory hotplug</a></li><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/memory-hotplug.html" target="_blank" rel="noopener">kernel doc Memory Hot(Un)Plug</a></li><li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1674497" target="_blank" rel="noopener">Memory Hot-unplug fails to remove DIMM</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍在QEMU KVM 环境下，memory hot(un)plug的使用。
    
    </summary>
    
      <category term="QEMU" scheme="http://liujunming.github.io/categories/QEMU/"/>
    
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="hotplug" scheme="http://liujunming.github.io/tags/hotplug/"/>
    
  </entry>
  
  <entry>
    <title>How to fetch mailing list patches</title>
    <link href="http://liujunming.github.io/2022/01/06/How-to-fetch-mailing-list-patches/"/>
    <id>http://liujunming.github.io/2022/01/06/How-to-fetch-mailing-list-patches/</id>
    <published>2022-01-06T06:17:43.000Z</published>
    <updated>2022-01-06T11:45:09.862Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍利用b4来获取mailing list中的patch。<a id="more"></a></p><h3 id="1-Motivation"><a href="#1-Motivation" class="headerlink" title="1. Motivation"></a>1. Motivation</h3><p>如何将mailing list中看到的patch <a href="https://lore.kernel.org/all/20210915095037.1149-1-shameerali.kolothum.thodi@huawei.com/" target="_blank" rel="noopener">https://lore.kernel.org/all/20210915095037.1149-1-shameerali.kolothum.thodi@huawei.com/</a> 下载下来呢？</p><p>b4正式登场！</p><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install b4</span><br></pre></td></tr></table></figure><h3 id="3-Usage"><a href="#3-Usage" class="headerlink" title="3. Usage"></a>3. Usage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ b4 am https://lore.kernel.org/all/20210915095037.1149-1-shameerali.kolothum.thodi@huawei.com</span><br><span class="line"></span><br><span class="line">Grabbing thread from lore.kernel.org/all/20210915095037.1149-1-shameerali.kolothum.thodi%40huawei.com/t.mbox.gz</span><br><span class="line">Analyzing 31 messages in the thread</span><br><span class="line">Checking attestation on all messages, may take a moment...</span><br><span class="line">---</span><br><span class="line">  [PATCH v3 1/6] crypto: hisilicon/qm: Move the QM header to include/linux</span><br><span class="line">  [PATCH v3 2/6] crypto: hisilicon/qm: Move few definitions to common header</span><br><span class="line">  [PATCH v3 3/6] hisi_acc_qm: Move PCI device IDs to common header</span><br><span class="line">  [PATCH v3 4/6] hisi-acc-vfio-pci: add new vfio_pci driver for HiSilicon ACC devices</span><br><span class="line">  [PATCH v3 5/6] hisi_acc_vfio_pci: Restrict access to VF dev BAR2 migration region</span><br><span class="line">  [PATCH v3 6/6] hisi_acc_vfio_pci: Add support for VFIO live migration</span><br><span class="line">---</span><br><span class="line">Total patches: 6</span><br><span class="line">---</span><br><span class="line">Cover: ./v3_20210915_shameerali_kolothum_thodi_vfio_hisilicon_add_acc_live_migration_driver.cover</span><br><span class="line"> Link: https://lore.kernel.org/r/20210915095037.1149-1-shameerali.kolothum.thodi@huawei.com</span><br><span class="line"> Base: not specified</span><br><span class="line">       git am ./v3_20210915_shameerali_kolothum_thodi_vfio_hisilicon_add_acc_live_migration_driver.mbx</span><br></pre></td></tr></table></figure><ul><li>grab the whole thread</li><li>find the latest revision of the series (v3)</li><li>save all patches into a <strong>mbox</strong> file</li><li>save the cover letter into a <strong>cover</strong> file</li><li>show example <code>git am</code> commands</li></ul><hr><p>参考资料:</p><ol><li><a href="https://people.kernel.org/monsieuricon/introducing-b4-and-patch-attestation" target="_blank" rel="noopener">Introducing b4 and patch attestation</a></li><li><a href="https://blog.csdn.net/Rong_Toa/article/details/109693210" target="_blank" rel="noopener">如何跟踪发现Linux内核补丁</a></li><li><a href="https://memcpy.io/applying-mailing-list-patches-with-git-b4.html" target="_blank" rel="noopener">Applying mailing list patches with ‘git b4’</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍利用b4来获取mailing list中的patch。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Dive into Intel int n instruction</title>
    <link href="http://liujunming.github.io/2022/01/06/Dive-into-Intel-int-n-instruction/"/>
    <id>http://liujunming.github.io/2022/01/06/Dive-into-Intel-int-n-instruction/</id>
    <published>2022-01-06T02:09:57.000Z</published>
    <updated>2022-01-07T15:08:48.459Z</updated>
    
    <content type="html"><![CDATA[<p>本文将深入解析Intel <code>int n</code> instruction。<a id="more"></a></p><h3 id="1-Theory"><a href="#1-Theory" class="headerlink" title="1. Theory"></a>1. Theory</h3><p>The <code>int n</code> instruction uses a vector as an argument, which allows a program to call any interrupt handler.<br><img src="/images/2022/01/08.png" alt><br><img src="/images/2022/01/09.png" alt></p><p><a href="/2022/01/06/Dive-into-Intel-iret-instruction/">Dive into Intel iret instruction</a></p><h3 id="2-Source-code-in-KVM-Unit-Tests"><a href="#2-Source-code-in-KVM-Unit-Tests" class="headerlink" title="2. Source code in KVM-Unit-Tests"></a>2. Source code in KVM-Unit-Tests</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USERMODE_STACK_SIZE0x2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RET_TO_KERNEL_IRQ0x20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> run_in_user(usermode_func func, <span class="keyword">unsigned</span> <span class="keyword">int</span> fault_vector,</span><br><span class="line"><span class="keyword">uint64_t</span> arg1, <span class="keyword">uint64_t</span> arg2, <span class="keyword">uint64_t</span> arg3,</span><br><span class="line"><span class="keyword">uint64_t</span> arg4, <span class="keyword">bool</span> *raised_vector)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> ret_to_kernel;</span><br><span class="line"><span class="keyword">uint64_t</span> rax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> user_stack[USERMODE_STACK_SIZE];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">set_idt_entry(RET_TO_KERNEL_IRQ, &amp;ret_to_kernel, <span class="number">3</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Prepare kernel SP for exception handlers */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %%rsp, %[rsp0]\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Load user_ds to DS and ES */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %[user_ds], %%ax\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %%ax, %%ds\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %%ax, %%es\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* IRET into user mode */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pushq %[user_ds]\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pushq %[user_stack_top]\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pushfq\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pushq %[user_cs]\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pushq $user_mode\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"iretq\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"user_mode:\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Back up registers before invoking func */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%rbx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%rcx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%rdx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%r8\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%r9\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%r10\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%r11\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%rdi\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%rsi\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Call user mode function */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %[arg1], %%rdi\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %[arg2], %%rsi\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %[arg3], %%rdx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %[arg4], %%rcx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"call *%[func]\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Restore registers */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%rsi\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%rdi\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%r11\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%r10\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%r9\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%r8\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%rdx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%rcx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%rbx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Return to kernel via system call */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"int %[kernel_entry_vector]\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Kernel Mode */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"ret_to_kernel:\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %[rsp0], %%rsp\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line">"+a"(rax),</span><br><span class="line">[rsp0]<span class="string">"=m"</span>(tss[<span class="number">0</span>].rsp0)</span><br><span class="line">:</span><br><span class="line">[arg1]<span class="string">"m"</span>(arg1),</span><br><span class="line">[arg2]<span class="string">"m"</span>(arg2),</span><br><span class="line">[arg3]<span class="string">"m"</span>(arg3),</span><br><span class="line">[arg4]<span class="string">"m"</span>(arg4),</span><br><span class="line">[func]<span class="string">"m"</span>(func),</span><br><span class="line">[user_ds]<span class="string">"i"</span>(USER_DS),</span><br><span class="line">[user_cs]<span class="string">"i"</span>(USER_CS),</span><br><span class="line">[user_stack_top]<span class="string">"r"</span>(user_stack +</span><br><span class="line"><span class="keyword">sizeof</span>(user_stack)),</span><br><span class="line">[kernel_entry_vector]<span class="string">"i"</span>(RET_TO_KERNEL_IRQ)</span><br><span class="line">:</span><br><span class="line"><span class="string">"rsi"</span>, <span class="string">"rdi"</span>, <span class="string">"rcx"</span>, <span class="string">"rdx"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-set-idt-entry"><a href="#2-1-set-idt-entry" class="headerlink" title="2.1 set_idt_entry"></a>2.1 set_idt_entry</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set_idt_entry(RET_TO_KERNEL_IRQ, &amp;ret_to_kernel, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_idt_entry</span><span class="params">(<span class="keyword">int</span> vec, <span class="keyword">void</span> *addr, <span class="keyword">int</span> dpl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">idt_entry_t</span> *e = &amp;boot_idt[vec];</span><br><span class="line">    <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span> *e);</span><br><span class="line">    e-&gt;offset0 = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr;</span><br><span class="line">    e-&gt;selector = read_cs();</span><br><span class="line">    e-&gt;ist = <span class="number">0</span>;</span><br><span class="line">    e-&gt;type = <span class="number">14</span>;</span><br><span class="line">    e-&gt;dpl = dpl;</span><br><span class="line">    e-&gt;p = <span class="number">1</span>;</span><br><span class="line">    e-&gt;offset1 = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    e-&gt;offset2 = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr &gt;&gt; <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2022/01/10.png" alt></p><h4 id="2-2-int-n"><a href="#2-2-int-n" class="headerlink" title="2.2 int n"></a>2.2 int n</h4><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return to kernel via system call */</span></span><br><span class="line"><span class="string">"int %[kernel_entry_vector]\n\t"</span></span><br><span class="line"><span class="comment">/* Kernel Mode */</span></span><br><span class="line"><span class="string">"ret_to_kernel:\n\t"</span></span><br><span class="line"><span class="string">"mov %[rsp0], %%rsp\n\t"</span></span><br><span class="line">:</span><br><span class="line"><span class="string">"+a"</span>(rax),</span><br><span class="line">[rsp0]<span class="string">"=m"</span>(tss[<span class="number">0</span>].rsp0)</span><br></pre></td></tr></table></figure><p>Why handler is <code>mov %[rsp0], %%rsp</code>?<br><img src="/images/2022/01/11.png" alt><br>processor会操作内核栈，rsp会发生变化，而handler则将rsp恢复到正确的状态。</p><h4 id="2-3-tss-0-rsp0"><a href="#2-3-tss-0-rsp0" class="headerlink" title="2.3 tss[0].rsp0"></a>2.3 tss[0].rsp0</h4><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"mov %%rsp, %[rsp0]\n\t"</span></span><br><span class="line">:: </span><br><span class="line">[rsp0]<span class="string">"=m"</span>(tss[<span class="number">0</span>].rsp0)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  __<span class="title">attribute__</span>((<span class="title">packed</span>)) &#123;</span></span><br><span class="line">u32 res1;</span><br><span class="line">u64 rsp0;</span><br><span class="line">u64 rsp1;</span><br><span class="line">u64 rsp2;</span><br><span class="line">u64 res2;</span><br><span class="line">u64 ist1;</span><br><span class="line">u64 ist2;</span><br><span class="line">u64 ist3;</span><br><span class="line">u64 ist4;</span><br><span class="line">u64 ist5;</span><br><span class="line">u64 ist6;</span><br><span class="line">u64 ist7;</span><br><span class="line">u64 res3;</span><br><span class="line">u16 res4;</span><br><span class="line">u16 iomap_base;</span><br><span class="line">&#125; <span class="keyword">tss64_t</span>;</span><br></pre></td></tr></table></figure><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>掌握住<code>int n</code> instruction的Operation即可！<br>详情当然是参考Intel SDM Vol2 INSTRUCTION SET REFERENCE!</p><p>要点：</p><ul><li>用户栈切换到内核栈</li><li>设置好IDT entry<ul><li>handler(rip)</li><li>dpl(is 3)</li><li>selector(kernel code segment)</li><li>…</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将深入解析Intel &lt;code&gt;int n&lt;/code&gt; instruction。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Dive into Intel iret instruction</title>
    <link href="http://liujunming.github.io/2022/01/06/Dive-into-Intel-iret-instruction/"/>
    <id>http://liujunming.github.io/2022/01/06/Dive-into-Intel-iret-instruction/</id>
    <published>2022-01-06T02:08:41.000Z</published>
    <updated>2022-01-06T11:45:09.862Z</updated>
    
    <content type="html"><![CDATA[<p>本文将深入解析Intel <code>iret</code> instruction。<a id="more"></a></p><h3 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h3><p>建议读者阅读下<a href="/2020/01/16/浅谈栈/">浅谈栈</a> 与<a href="/2020/01/18/浅谈tss/">浅谈tss</a>。</p><h3 id="2-Materials"><a href="#2-Materials" class="headerlink" title="2. Materials"></a>2. Materials</h3><p>最权威的资料，值得读者细品。</p><ul><li>Intel SDM Vol1 CHAPTER 6 PROCEDURE CALLS, INTERRUPTS, AND EXCEPTIONS</li><li>Intel SDM Vol2 INSTRUCTION SET REFERENCE</li></ul><h3 id="3-Theory"><a href="#3-Theory" class="headerlink" title="3. Theory"></a>3. Theory</h3><p><img src="/images/2022/01/04.png" alt></p><p><img src="/images/2022/01/05.png" alt></p><p><img src="/images/2022/01/06.png" alt></p><h3 id="4-Example-in-kvm-unit-test"><a href="#4-Example-in-kvm-unit-test" class="headerlink" title="4. Example in kvm unit test"></a>4. Example in kvm unit test</h3><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">asm volatile (</span><br><span class="line"><span class="comment">/* Prepare kernel SP for exception handlers */</span></span><br><span class="line"><span class="string">"mov %%rsp, %[rsp0]\n\t"</span></span><br><span class="line"><span class="comment">/* Load user_ds to DS and ES */</span></span><br><span class="line"><span class="string">"mov %[user_ds], %%ax\n\t"</span></span><br><span class="line"><span class="string">"mov %%ax, %%ds\n\t"</span></span><br><span class="line"><span class="string">"mov %%ax, %%es\n\t"</span></span><br><span class="line"><span class="comment">/* IRET into user mode */</span></span><br><span class="line"><span class="string">"pushq %[user_ds]\n\t"</span></span><br><span class="line"><span class="string">"pushq %[user_stack_top]\n\t"</span></span><br><span class="line"><span class="string">"pushfq\n\t"</span></span><br><span class="line"><span class="string">"pushq %[user_cs]\n\t"</span></span><br><span class="line"><span class="string">"pushq $user_mode\n\t"</span></span><br><span class="line"><span class="string">"iretq\n"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"user_mode:\n\t"</span></span><br><span class="line"><span class="comment">/* Back up registers before invoking func */</span></span><br><span class="line"><span class="string">"push %%rbx\n\t"</span></span><br><span class="line"><span class="string">"push %%rcx\n\t"</span></span><br><span class="line"><span class="string">"push %%rdx\n\t"</span></span><br><span class="line"><span class="string">"push %%r8\n\t"</span></span><br><span class="line"><span class="string">"push %%r9\n\t"</span></span><br><span class="line"><span class="string">"push %%r10\n\t"</span></span><br><span class="line"><span class="string">"push %%r11\n\t"</span></span><br><span class="line"><span class="string">"push %%rdi\n\t"</span></span><br><span class="line"><span class="string">"push %%rsi\n\t"</span></span><br><span class="line"><span class="comment">/* Call user mode function */</span></span><br><span class="line"><span class="string">"mov %[arg1], %%rdi\n\t"</span></span><br><span class="line"><span class="string">"mov %[arg2], %%rsi\n\t"</span></span><br><span class="line"><span class="string">"mov %[arg3], %%rdx\n\t"</span></span><br><span class="line"><span class="string">"mov %[arg4], %%rcx\n\t"</span></span><br><span class="line"><span class="string">"call *%[func]\n\t"</span></span><br><span class="line"><span class="comment">/* Restore registers */</span></span><br><span class="line"><span class="string">"pop %%rsi\n\t"</span></span><br><span class="line"><span class="string">"pop %%rdi\n\t"</span></span><br><span class="line"><span class="string">"pop %%r11\n\t"</span></span><br><span class="line"><span class="string">"pop %%r10\n\t"</span></span><br><span class="line"><span class="string">"pop %%r9\n\t"</span></span><br><span class="line"><span class="string">"pop %%r8\n\t"</span></span><br><span class="line"><span class="string">"pop %%rdx\n\t"</span></span><br><span class="line"><span class="string">"pop %%rcx\n\t"</span></span><br><span class="line"><span class="string">"pop %%rbx\n\t"</span></span><br><span class="line"><span class="comment">/* Return to kernel via system call */</span></span><br><span class="line"><span class="string">"int %[kernel_entry_vector]\n\t"</span></span><br><span class="line"><span class="comment">/* Kernel Mode */</span></span><br><span class="line"><span class="string">"ret_to_kernel:\n\t"</span></span><br><span class="line"><span class="string">"mov %[rsp0], %%rsp\n\t"</span></span><br><span class="line">:</span><br><span class="line"><span class="string">"+a"</span>(rax),</span><br><span class="line">[rsp0]<span class="string">"=m"</span>(tss[<span class="number">0</span>].rsp0)</span><br><span class="line">:</span><br><span class="line">[arg1]<span class="string">"m"</span>(arg1),</span><br><span class="line">[arg2]<span class="string">"m"</span>(arg2),</span><br><span class="line">[arg3]<span class="string">"m"</span>(arg3),</span><br><span class="line">[arg4]<span class="string">"m"</span>(arg4),</span><br><span class="line">[func]<span class="string">"m"</span>(func),</span><br><span class="line">[user_ds]<span class="string">"i"</span>(USER_DS),</span><br><span class="line">[user_cs]<span class="string">"i"</span>(USER_CS),</span><br><span class="line">[user_stack_top]<span class="string">"r"</span>(user_stack +</span><br><span class="line">sizeof(user_stack)),</span><br><span class="line">[kernel_entry_vector]<span class="string">"i"</span>(RET_TO_KERNEL_IRQ)</span><br><span class="line">:</span><br><span class="line"><span class="string">"rsi"</span>, <span class="string">"rdi"</span>, <span class="string">"rcx"</span>, <span class="string">"rdx"</span>);</span><br></pre></td></tr></table></figure><p>为了能进入user mode，在内核态，进行了如下操作：<br><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Load user_ds to DS and ES */</span></span><br><span class="line"><span class="string">"mov %[user_ds], %%ax\n\t"</span></span><br><span class="line"><span class="string">"mov %%ax, %%ds\n\t"</span></span><br><span class="line"><span class="string">"mov %%ax, %%es\n\t"</span></span><br><span class="line"><span class="comment">/* IRET into user mode */</span></span><br><span class="line"><span class="string">"pushq %[user_ds]\n\t"</span></span><br><span class="line"><span class="string">"pushq %[user_stack_top]\n\t"</span></span><br><span class="line"><span class="string">"pushfq\n\t"</span></span><br><span class="line"><span class="string">"pushq %[user_cs]\n\t"</span></span><br><span class="line"><span class="string">"pushq $user_mode\n\t"</span></span><br><span class="line"><span class="string">"iretq\n"</span></span><br></pre></td></tr></table></figure></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>掌握住<code>iret</code> instruction的Operation即可！<br>详情当然是参考Intel SDM Vol2 INSTRUCTION SET REFERENCE!<br><img src="/images/2022/01/07.png" alt></p><p>建议详细阅读下<a href="https://stackoverflow.com/a/6892934/15530503" target="_blank" rel="noopener">Switching to User-mode using iret</a>！</p><hr><p>参考资料:</p><ol><li><a href="https://stackoverflow.com/questions/6892421/switching-to-user-mode-using-iret" target="_blank" rel="noopener">Switching to User-mode using iret</a></li><li><a href="https://stackoverflow.com/questions/13243958/cpu-switches-from-kernel-mode-to-user-mode-on-x86-when-and-how" target="_blank" rel="noopener">CPU Switches from Kernel mode to User Mode on X86 : When and How?</a></li><li><a href="http://www.jamesmolloy.co.uk/tutorial_html/10.-User%20Mode.html" target="_blank" rel="noopener">jamesmolloy.co.uk User mode</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将深入解析Intel &lt;code&gt;iret&lt;/code&gt; instruction。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>The usage of Intel GS segment</title>
    <link href="http://liujunming.github.io/2022/01/05/The-usage-of-Intel-GS-segment/"/>
    <id>http://liujunming.github.io/2022/01/05/The-usage-of-Intel-GS-segment/</id>
    <published>2022-01-05T07:48:22.000Z</published>
    <updated>2022-01-05T10:08:18.255Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读<a href="https://gitlab.com/kvm-unit-tests/kvm-unit-tests" target="_blank" rel="noopener">KVM-Unit-Tests</a>过程中，看到了<code>asm (&quot;mov %0, %%gs:0&quot; : : &quot;r&quot;(apic_id()) : &quot;memory&quot;);</code>，不是很明白，因此，特此写一篇文章记录下Intel GS segment的相关用法。<a id="more"></a></p><h3 id="1-Description-in-SDM"><a href="#1-Description-in-SDM" class="headerlink" title="1. Description in SDM"></a>1. Description in SDM</h3><p><img src="/images/2022/01/01.png" alt></p><h3 id="2-Usage"><a href="#2-Usage" class="headerlink" title="2. Usage"></a>2. Usage</h3><ul><li>The GS segment can be used for thread local storage.</li><li>The GS segment can be used for per-CPU data.</li></ul><h3 id="3-Source-code-in-KVM-Unit-Tests"><a href="#3-Source-code-in-KVM-Unit-Tests" class="headerlink" title="3. Source code in KVM-Unit-Tests"></a>3. Source code in KVM-Unit-Tests</h3><p>commit id: ca785dae0dd343b1de4b3f5d6c1223d41fbc39e7</p><p><img src="/images/2022/01/03.png" alt><br><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MSR_GS_BASE = <span class="number">0xc0000101</span></span><br><span class="line"></span><br><span class="line">.macro setup_percpu_area</span><br><span class="line">lea <span class="number">-4096</span>(%esp), %eax</span><br><span class="line">mov $<span class="number">0</span>, %edx</span><br><span class="line">mov $MSR_GS_BASE, %ecx</span><br><span class="line">wrmsr</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure></p><p><code>MSR_GS_BASE</code> MSR的描述如下：<br><img src="/images/2022/01/02.png" alt></p><p>stack的layout可以以<code>stacktop</code>为关键字，在<a href="https://gitlab.com/kvm-unit-tests/kvm-unit-tests/-/blob/master/x86/cstart64.S" target="_blank" rel="noopener">cstart64.S</a>中搜索。</p><p>Here’re the example to use GS segment to access per-CPU data:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smp_id</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> (<span class="string">"mov %%gs:0, %0"</span> : <span class="string">"=r"</span>(id));</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_smp_id</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span> (<span class="string">"mov %0, %%gs:0"</span> : : <span class="string">"r"</span>(apic_id()) : <span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>参考资料：</p><ol><li><a href="https://stackoverflow.com/questions/10810203/what-is-the-fs-gs-register-intended-for" target="_blank" rel="noopener">What is the “FS”/“GS” register intended for?</a></li><li><a href="https://stackoverflow.com/questions/9249315/what-is-gs-in-assembly" target="_blank" rel="noopener">What is %gs in Assembly</a></li><li><a href="https://stackoverflow.com/questions/12234817/what-does-this-instruction-do-mov-gs0x14-eax" target="_blank" rel="noopener">what does this instruction do?:- mov %gs:0x14,%eax</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在阅读&lt;a href=&quot;https://gitlab.com/kvm-unit-tests/kvm-unit-tests&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;KVM-Unit-Tests&lt;/a&gt;过程中，看到了&lt;code&gt;asm (&amp;quot;mov %0, %%gs:0&amp;quot; : : &amp;quot;r&amp;quot;(apic_id()) : &amp;quot;memory&amp;quot;);&lt;/code&gt;，不是很明白，因此，特此写一篇文章记录下Intel GS segment的相关用法。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>MSR management in QEMU/KVM</title>
    <link href="http://liujunming.github.io/2021/12/26/MSR-management-in-QEMU-KVM/"/>
    <id>http://liujunming.github.io/2021/12/26/MSR-management-in-QEMU-KVM/</id>
    <published>2021-12-26T05:37:17.000Z</published>
    <updated>2021-12-27T12:16:38.559Z</updated>
    
    <content type="html"><![CDATA[<p>本文将以<a href="https://gitlab.com/qemu-project/qemu/-/tree/v5.2.0" target="_blank" rel="noopener">QEMU V5.2.0</a>,<a href="https://elixir.bootlin.com/linux/v5.14/source" target="_blank" rel="noopener">kernel  v5.14</a>的源码与SDM的描述，介绍MSR management，具体细节不会一一介绍，但是会点出关键性的内容，读者可以以此为线索，深挖细节。<a id="more"></a></p><h2 id="1-理论基础"><a href="#1-理论基础" class="headerlink" title="1. 理论基础"></a>1. 理论基础</h2><h3 id="1-1-RDMSR-and-WRMSR-instruction"><a href="#1-1-RDMSR-and-WRMSR-instruction" class="headerlink" title="1.1 RDMSR and WRMSR instruction"></a>1.1 RDMSR and WRMSR instruction</h3><ul><li>RDMSR—Read from Model Specific Register<br>EDX:EAX ← MSR[ECX];</li><li>WRMSR—Write to Model Specific Register<br>MSR[ECX] ← EDX:EAX;</li></ul><p>WRMSR与RDMSR类似，受篇幅限制，接下来主要以RDMSR为主。</p><h3 id="1-2-VM-Exit"><a href="#1-2-VM-Exit" class="headerlink" title="1.2 VM Exit"></a>1.2 VM Exit</h3><p>The RDMSR instruction causes a VM exit if any of the following are true:</p><ul><li>The “use MSR bitmaps” VM-execution control is 0.</li><li>The value of ECX is not in the ranges 00000000H – 00001FFFH and C0000000H – C0001FFFH.</li><li>The value of ECX is in the range 00000000H – 00001FFFH and bit n in read bitmap for low MSRs is 1, where n is the value of ECX.</li><li>The value of ECX is in the range C0000000H – C0001FFFH and bit n in read bitmap for high MSRs is 1, where n is the value of ECX &amp; 00001FFFH.</li></ul><h3 id="1-3-MSR-bitmap"><a href="#1-3-MSR-bitmap" class="headerlink" title="1.3 MSR bitmap"></a>1.3 MSR bitmap</h3><p>On processors that support the 1-setting of the “use MSR bitmaps” VM-execution control, the VM-execution control fields include the 64-bit physical address of four contiguous <strong>MSR bitmaps</strong>, which are each 1-KByte in size. This field does not exist on processors that do not support the 1-setting of that control. The four bitmaps are:</p><ul><li><strong>Read bitmap for low MSRs</strong> (located at the MSR-bitmap address). This contains one bit for each MSR address in the range 00000000H to 00001FFFH. The bit determines whether an execution of RDMSR applied to that MSR causes a VM exit.</li><li><strong>Read bitmap for high MSRs</strong> (located at the MSR-bitmap address plus 1024). This contains one bit for each MSR address in the range C0000000H toC0001FFFH. The bit determines whether an execution of RDMSR applied to that MSR causes a VM exit.</li><li><strong>Write bitmap for low MSRs </strong>(located at the MSR-bitmap address plus 2048). This contains one bit for each MSR address in the range 00000000H to 00001FFFH. The bit determines whether an execution of WRMSR applied to that MSR causes a VM exit.</li><li><strong>Write bitmap for high MSRs</strong> (located at the MSR-bitmap address plus 3072). This contains one bit for each MSR address in the range C0000000H toC0001FFFH. The bit determines whether an execution of WRMSR applied to that MSR causes a VM exit.</li></ul><p>A logical processor uses these bitmaps if and only if the “use MSR bitmaps” control is 1. If the bitmaps are used, an execution of RDMSR or WRMSR causes a VM exit if the value of RCX is in neither of the ranges covered by the bitmaps or <u>if the appropriate bit in the MSR bitmaps (corresponding to the instruction and the RCX value) is 1</u>.</p><h3 id="1-4-VM-Exit-Controls-for-MSRs"><a href="#1-4-VM-Exit-Controls-for-MSRs" class="headerlink" title="1.4 VM-Exit Controls for MSRs"></a>1.4 VM-Exit Controls for MSRs</h3><p><img src="/images/2021/12/27.png" alt></p><h3 id="1-5-VM-Entry-Controls-for-MSRs"><a href="#1-5-VM-Entry-Controls-for-MSRs" class="headerlink" title="1.5 VM-Entry Controls for MSRs"></a>1.5 VM-Entry Controls for MSRs</h3><p><img src="/images/2021/12/28.png" alt></p><h2 id="2-Basic-VMX-related-source-code"><a href="#2-Basic-VMX-related-source-code" class="headerlink" title="2. Basic VMX-related source code"></a>2. Basic VMX-related source code</h2><h3 id="2-1-MSR-bitmap"><a href="#2-1-MSR-bitmap" class="headerlink" title="2.1 MSR bitmap"></a>2.1 MSR bitmap</h3><h4 id="2-1-1-空间分配与初始化"><a href="#2-1-1-空间分配与初始化" class="headerlink" title="2.1.1 空间分配与初始化"></a>2.1.1 空间分配与初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kvm_vm_ioct(KVM_CREATE_VCPU)</span><br><span class="line">    kvm_vm_ioctl_create_vcpu</span><br><span class="line">        kvm_arch_vcpu_create</span><br><span class="line">            vmx_create_vcpu[static_call(kvm_x86_vcpu_create)(vcpu)]</span><br><span class="line">                alloc_loaded_vmcs</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个page(4K)的空间给msr bitmap,并将该空间的内容初始化为全1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_loaded_vmcs</span><span class="params">(struct loaded_vmcs *loaded_vmcs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cpu_has_vmx_msr_bitmap()) &#123;</span><br><span class="line">loaded_vmcs-&gt;msr_bitmap = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)</span><br><span class="line">__get_free_page(GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (!loaded_vmcs-&gt;msr_bitmap)</span><br><span class="line"><span class="keyword">goto</span> out_vmcs;</span><br><span class="line"><span class="built_in">memset</span>(loaded_vmcs-&gt;msr_bitmap, <span class="number">0xff</span>, PAGE_SIZE);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-VMCS-field"><a href="#2-1-2-VMCS-field" class="headerlink" title="2.1.2 VMCS field"></a>2.1.2 VMCS field</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmx_create_vcpu</span><br><span class="line">alloc_loaded_vmcs</span><br><span class="line">init_vmcs</span><br><span class="line">vmcs_write64(MSR_BITMAP, __pa(vmx-&gt;vmcs01.msr_bitmap))</span><br></pre></td></tr></table></figure><h3 id="2-2-passthrough-MSR"><a href="#2-2-passthrough-MSR" class="headerlink" title="2.2 passthrough MSR"></a>2.2 passthrough MSR</h3><p><code>vmx_disable_intercept_for_msr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmx_disable_intercept_for_msr</span><span class="params">(struct kvm_vcpu *vcpu, u32 msr, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vcpu_vmx</span> *<span class="title">vmx</span> = <span class="title">to_vmx</span>(<span class="title">vcpu</span>);</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *msr_bitmap = vmx-&gt;vmcs01.msr_bitmap;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mark the desired intercept state in shadow bitmap, this is needed</span></span><br><span class="line"><span class="comment"> * for resync when the MSR filters change.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (is_valid_passthrough_msr(msr)) &#123;</span><br><span class="line"><span class="keyword">int</span> idx = possible_passthrough_msr_slot(msr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (idx != -ENOENT) &#123;</span><br><span class="line"><span class="keyword">if</span> (type &amp; MSR_TYPE_R)</span><br><span class="line">clear_bit(idx, vmx-&gt;shadow_msr_intercept.read);</span><br><span class="line"><span class="keyword">if</span> (type &amp; MSR_TYPE_W)</span><br><span class="line">clear_bit(idx, vmx-&gt;shadow_msr_intercept.write);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-MSR-area"><a href="#2-3-MSR-area" class="headerlink" title="2.3 MSR area"></a>2.3 MSR area</h3><p>建议学习下<a href="/2021/03/20/虚拟化学习心得-three-context/">虚拟化学习心得:three context</a> 中MSR area中的motivation。</p><p>以下内容为关键字，读者可去KVM中搜索源码学习。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VM_ENTRY_MSR_LOAD_COUNT</span><br><span class="line">VM_ENTRY_MSR_LOAD_ADDR</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VM_EXIT_MSR_STORE_COUNT</span><br><span class="line">VM_EXIT_MSR_LOAD_COUNT</span><br><span class="line">VM_EXIT_MSR_STORE_ADDR</span><br><span class="line">VM_EXIT_MSR_LOAD_ADDR</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vcpu_vmx</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msr_autoload</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vmx_msrs</span> <span class="title">guest</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vmx_msrs</span> <span class="title">host</span>;</span></span><br><span class="line">&#125; msr_autoload;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msr_autostore</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vmx_msrs</span> <span class="title">guest</span>;</span></span><br><span class="line">&#125; msr_autostore;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-How-KVM-handle-MSR-read"><a href="#3-How-KVM-handle-MSR-read" class="headerlink" title="3. How KVM handle MSR read"></a>3. How KVM handle MSR read</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msr_data</span> &#123;</span></span><br><span class="line"><span class="keyword">bool</span> host_initiated;</span><br><span class="line">u32 index;</span><br><span class="line">u64 data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>host_initiated</strong>:</p><ul><li>true: QEMU fired the call to operate on an MSR reg</li><li>false: guest fired the call to operate on an MSR reg</li></ul><h3 id="3-1-VM-Exit-when-guest-executing-RDMSR-instruction"><a href="#3-1-VM-Exit-when-guest-executing-RDMSR-instruction" class="headerlink" title="3.1 VM Exit when guest executing RDMSR instruction"></a>3.1 VM Exit when guest executing RDMSR instruction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kvm_emulate_rdmsr</span><br><span class="line">kvm_get_msr</span><br><span class="line">kvm_get_msr_ignored_check</span><br><span class="line">__kvm_get_msr</span><br><span class="line">vmx_get_msr[kvm_x86_get_msr]</span><br><span class="line">kvm_get_msr_common</span><br></pre></td></tr></table></figure><p><code>vmx_get_msr</code>处理一部分特殊MSR的读请求,<code>kvm_get_msr_common</code>处理普通MSR的读请求。</p><h3 id="3-2-QEMU-get-MSRs"><a href="#3-2-QEMU-get-MSRs" class="headerlink" title="3.2 QEMU get MSRs"></a>3.2 QEMU get MSRs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kvm_arch_dev_ioctl</span><br><span class="line">msr_io</span><br><span class="line">__msr_io(...,do_get_msr)</span><br><span class="line"></span><br><span class="line">kvm_arch_vcpu_ioctl</span><br><span class="line">msr_io</span><br><span class="line">__msr_io(...,do_get_msr)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do_get_msr</span><br><span class="line">    kvm_get_msr_ignored_check</span><br><span class="line">        __kvm_get_msr</span><br><span class="line">            vmx_get_msr</span><br></pre></td></tr></table></figure><h2 id="4-IOCTL"><a href="#4-IOCTL" class="headerlink" title="4. IOCTL"></a>4. IOCTL</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * List of msr numbers which we expose to userspace through KVM_GET_MSRS</span></span><br><span class="line"><span class="comment"> * and KVM_SET_MSRS, and KVM_GET_MSR_INDEX_LIST.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The three MSR lists(msrs_to_save, emulated_msrs, msr_based_features)</span></span><br><span class="line"><span class="comment"> * extract the supported MSRs from the related const lists.</span></span><br><span class="line"><span class="comment"> * msrs_to_save is selected from the msrs_to_save_all to reflect the</span></span><br><span class="line"><span class="comment"> * capabilities of the host cpu. This capabilities test skips MSRs that are</span></span><br><span class="line"><span class="comment"> * kvm-specific. Those are put in emulated_msrs_all; filtering of emulated_msrs</span></span><br><span class="line"><span class="comment"> * may depend on host virtualization features rather than host cpu features.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="4-1-KVM-GET-MSR-INDEX-LIST"><a href="#4-1-KVM-GET-MSR-INDEX-LIST" class="headerlink" title="4.1 KVM_GET_MSR_INDEX_LIST"></a>4.1 KVM_GET_MSR_INDEX_LIST</h3><p><code>KVM_GET_MSR_INDEX_LIST</code> returns the guest MSRs that are supported.  The list varies by kvm version and host processor, but does not change otherwise.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QEMU</span></span><br><span class="line">kvm_get_supported_msrs</span><br><span class="line">kvm_ioctl(KVM_GET_MSR_INDEX_LIST)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KVM</span></span><br><span class="line">kvm_arch_dev_ioctl(KVM_GET_MSR_INDEX_LIST)</span><br><span class="line">msrs_to_save</span><br><span class="line">emulated_msrs</span><br></pre></td></tr></table></figure><h3 id="4-2-KVM-GET-MSR-FEATURE-INDEX-LIST"><a href="#4-2-KVM-GET-MSR-FEATURE-INDEX-LIST" class="headerlink" title="4.2 KVM_GET_MSR_FEATURE_INDEX_LIST"></a>4.2 KVM_GET_MSR_FEATURE_INDEX_LIST</h3><p><code>KVM_GET_MSR_FEATURE_INDEX_LIST</code> returns the list of MSRs that can be passed to the <code>KVM_GET_MSRS</code> system ioctl.  This lets userspace probe host capabilities and processor features that are exposed via MSRs (e.g., VMX capabilities).<br>This list also varies by kvm version and host processor, but does not change otherwise.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QEMU</span></span><br><span class="line">kvm_get_supported_feature_msrs</span><br><span class="line">kvm_ioctl(KVM_GET_MSR_FEATURE_INDEX_LIST)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KVM</span></span><br><span class="line">kvm_arch_dev_ioctl(KVM_GET_MSR_INDEX_LIST)</span><br><span class="line">msr_based_features</span><br></pre></td></tr></table></figure><h3 id="4-3-KVM-GET-MSRS"><a href="#4-3-KVM-GET-MSRS" class="headerlink" title="4.3 KVM_GET_MSRS"></a>4.3 KVM_GET_MSRS</h3><p>When used as a system ioctl:<br>Reads the values of MSR-based features that are available for the VM.<br>The list of msr-based features can be obtained using <code>KVM_GET_MSR_FEATURE_INDEX_LIST</code> in a system ioctl.</p><p>When used as a vcpu ioctl:<br>Reads model-specific registers from the vcpu.  Supported msr indices can be obtained using <code>KVM_GET_MSR_INDEX_LIST</code> in a system ioctl.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_msrs</span> &#123;</span></span><br><span class="line">__u32 nmsrs; <span class="comment">/* number of msrs in entries */</span></span><br><span class="line">__u32 pad;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_msr_entry</span> <span class="title">entries</span>[0];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_msr_entry</span> &#123;</span></span><br><span class="line">__u32 index;</span><br><span class="line">__u32 reserved;</span><br><span class="line">__u64 data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Application code should set the <code>nmsrs</code> member (which indicates the size of the entries array) and the <code>index</code> member of each array entry. kvm will fill in the <code>data</code> member.</p><h3 id="4-4-KVM-SET-MSRS"><a href="#4-4-KVM-SET-MSRS" class="headerlink" title="4.4 KVM_SET_MSRS"></a>4.4 KVM_SET_MSRS</h3><p>Writes model-specific registers to the vcpu. </p><p>Application code should set the <code>nmsrs</code> member (which indicates the size of the entries array), and the <code>index</code> and <code>data</code> members of each array entry.</p><hr><p>参考资料:</p><ol><li><a href="https://www.cnblogs.com/haiyonghao/p/14440954.html" target="_blank" rel="noopener">READMSR和CPUID指令在Guest中的代码执行路径学习</a></li><li><a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt" target="_blank" rel="noopener">kvm/api.txt</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将以&lt;a href=&quot;https://gitlab.com/qemu-project/qemu/-/tree/v5.2.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QEMU V5.2.0&lt;/a&gt;,&lt;a href=&quot;https://elixir.bootlin.com/linux/v5.14/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kernel  v5.14&lt;/a&gt;的源码与SDM的描述，介绍MSR management，具体细节不会一一介绍，但是会点出关键性的内容，读者可以以此为线索，深挖细节。
    
    </summary>
    
      <category term="QEMU&amp;&amp;KVM" scheme="http://liujunming.github.io/categories/QEMU-KVM/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>Notes about magic SysRq key</title>
    <link href="http://liujunming.github.io/2021/12/25/Notes-about-magic-SysRq-key/"/>
    <id>http://liujunming.github.io/2021/12/25/Notes-about-magic-SysRq-key/</id>
    <published>2021-12-25T02:29:06.000Z</published>
    <updated>2021-12-25T03:08:54.637Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about magic SysRq key.<a id="more"></a></p><p><img src="/images/2021/12/26.png" alt></p><h3 id="1-What-is-magic-SysRq-key"><a href="#1-What-is-magic-SysRq-key" class="headerlink" title="1. What is magic SysRq key?"></a>1. What is magic SysRq key?</h3><p>It is a ‘magical’ key combo you can hit which the kernel will respond to regardless of whatever else it is doing, unless it is completely locked up.</p><p>Magic SysRq组合键是一串能直接与Linux 内核沟通的组合键，允许用户就算在系统进入死循环濒临崩溃时，直接调用系统底层将资料写入文件系统或重启，避免尚未写入文件系统与硬盘的数据在关机后消失。</p><p>此组合键提供一系列在系统崩溃时常用到的功能，比如上述的写入数据，或关闭 X Server 、Kill 进程、卸载 文件系统，也通常是死机时的最后手段。</p><h3 id="2-How-do-I-enable-the-magic-SysRq-key"><a href="#2-How-do-I-enable-the-magic-SysRq-key" class="headerlink" title="2. How do I enable the magic SysRq key?"></a>2. How do I enable the magic SysRq key?</h3><p>You need to say “yes” to ‘Magic SysRq key (<code>CONFIG_MAGIC_SYSRQ</code>)’ when configuring the kernel. When running a kernel with SysRq compiled in, <code>/proc/sys/kernel/sysrq</code> controls the functions allowed to be invoked via the SysRq key. The default value in this file is set by the <code>CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE</code> config symbol, which itself defaults to 1. Here is the list of possible values in <code>/proc/sys/kernel/sysrq</code>:</p><ul><li><p>0 - disable sysrq completely</p></li><li><p>1 - enable all functions of sysrq</p></li><li><p>>1 - bitmask of allowed sysrq functions (see below for detailed function description):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  2 =   0x2 - enable control of console logging level</span><br><span class="line">  4 =   0x4 - enable control of keyboard (SAK, unraw)</span><br><span class="line">  8 =   0x8 - enable debugging dumps of processes etc.</span><br><span class="line"> 16 =  0x10 - enable sync command</span><br><span class="line"> 32 =  0x20 - enable remount read-only</span><br><span class="line"> 64 =  0x40 - enable signalling of processes (term, kill, oom-kill)</span><br><span class="line">128 =  0x80 - allow reboot/poweroff</span><br><span class="line">256 = 0x100 - allow nicing of all RT tasks</span><br></pre></td></tr></table></figure></li></ul><p>Note that the value of <code>/proc/sys/kernel/sysrq</code> influences only the invocation via a keyboard. Invocation of any operation via <code>/proc/sysrq-trigger</code> is always allowed (by a user with admin privileges).</p><h3 id="3-How-do-I-use-the-magic-SysRq-key"><a href="#3-How-do-I-use-the-magic-SysRq-key" class="headerlink" title="3. How do I use the magic SysRq key?"></a>3. How do I use the magic SysRq key?</h3><ul><li><p>On x86<br>You press the key combo <code>ALT-SysRq-&lt;command key&gt;</code>.</p></li><li><p>On all<br>Write a character to <code>/proc/sysrq-trigger</code>. e.g.:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo t &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-What-are-the-‘command’-keys"><a href="#4-What-are-the-‘command’-keys" class="headerlink" title="4. What are the ‘command’ keys?"></a>4. What are the ‘command’ keys?</h3><p><a href="https://www.kernel.org/doc/html/latest/admin-guide/sysrq.html#what-are-the-command-keys" target="_blank" rel="noopener">kernel.org doc</a></p><h3 id="5-Usage-example"><a href="#5-Usage-example" class="headerlink" title="5. Usage example"></a>5. Usage example</h3><h4 id="5-1-perform-a-system-crash-and-a-crashdump-will-be-taken-if-configured"><a href="#5-1-perform-a-system-crash-and-a-crashdump-will-be-taken-if-configured" class="headerlink" title="5.1 perform a system crash and a crashdump will be taken if configured."></a>5.1 perform a system crash and a crashdump will be taken if configured.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/kernel/sysrq</span><br><span class="line">echo c &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/sysrq.html" target="_blank" rel="noopener">Linux Magic System Request Key Hacks</a></li><li><a href="https://zh.wikipedia.org/zh-cn/Magic_SysRq%E7%B5%84%E5%90%88%E9%8D%B5" target="_blank" rel="noopener">wikipedia Magic SysRq组合键</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about magic SysRq key.
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Intel CPU operating modes</title>
    <link href="http://liujunming.github.io/2021/12/24/Intel-CPU-operating-modes/"/>
    <id>http://liujunming.github.io/2021/12/24/Intel-CPU-operating-modes/</id>
    <published>2021-12-24T11:24:52.000Z</published>
    <updated>2021-12-24T13:08:07.571Z</updated>
    
    <content type="html"><![CDATA[<p>本文以Intel SDM为主，以<a href="https://github.com/projectacrn/acrn-hypervisor/tree/release_2.7" target="_blank" rel="noopener">ACRN</a>源码为辅来介绍Intel CPU operating modes。<a id="more"></a></p><h2 id="1-IA-32-architecture"><a href="#1-IA-32-architecture" class="headerlink" title="1. IA-32 architecture"></a>1. IA-32 architecture</h2><h3 id="1-1-Protected-mode"><a href="#1-1-Protected-mode" class="headerlink" title="1.1 Protected mode"></a>1.1 Protected mode</h3><p>This mode is the native state of the processor. Among the capabilities of protected mode is the ability to directly execute “real-address mode” 8086 software in a protected, multi-tasking environment. This feature is called <strong>virtual-8086 mode</strong>, although it is not actually a processor mode. Virtual-8086 mode is actually a protected mode attribute that can be enabled for any task.</p><h3 id="1-2-Real-address-mode"><a href="#1-2-Real-address-mode" class="headerlink" title="1.2 Real-address mode"></a>1.2 Real-address mode</h3><p>This mode implements the programming environment of the Intel 8086 processor with extensions (such as the ability to switch to protected or system management mode). The processor is placed in real-address mode following power-up or a reset.</p><h3 id="1-3-System-management-mode-SMM"><a href="#1-3-System-management-mode-SMM" class="headerlink" title="1.3 System management mode (SMM)"></a>1.3 System management mode (SMM)</h3><p> This mode provides an operating system or executive with a transparent mechanism for implementing platform-specific functions such as power management and system security. The processor enters SMM when the external SMM interrupt pin (SMI#) is activated or an SMI is received from the advanced programmable interrupt controller (APIC).</p><p>In SMM, the processor switches to a separate address space while saving the basic context of the currently running program or task. SMM-specific code may then be executed transparently. Upon returning from SMM, the processor is placed back into its state prior to the system management interrupt. </p><h2 id="2-Intel®-64-Architecture"><a href="#2-Intel®-64-Architecture" class="headerlink" title="2. Intel® 64 Architecture"></a>2. Intel® 64 Architecture</h2><p>Intel 64 architecture adds IA-32e mode. IA-32e mode has two sub-modes.</p><h3 id="2-1-Compatibility-mode-sub-mode-of-IA-32e-mode"><a href="#2-1-Compatibility-mode-sub-mode-of-IA-32e-mode" class="headerlink" title="2.1 Compatibility mode(sub-mode of IA-32e mode)"></a>2.1 Compatibility mode(sub-mode of IA-32e mode)</h3><p>Compatibility mode permits most legacy 16-bit and 32-bit applications to run without re-compilation under a 64-bit operating system. </p><h3 id="2-2-64-bit-mode-sub-mode-of-IA-32e-mode"><a href="#2-2-64-bit-mode-sub-mode-of-IA-32e-mode" class="headerlink" title="2.2 64-bit mode(sub-mode of IA-32e mode)"></a>2.2 64-bit mode(sub-mode of IA-32e mode)</h3><p>This mode enables a 64-bit operating system to run applications written to access 64-bit linear address space.</p><h2 id="3-状态机"><a href="#3-状态机" class="headerlink" title="3. 状态机"></a>3. 状态机</h2><p><img src="/images/2021/12/23.png" alt><br><img src="/images/2021/12/24.png" alt></p><h2 id="4-Code"><a href="#4-Code" class="headerlink" title="4. Code"></a>4. Code</h2><p><a href="https://github.com/projectacrn/acrn-hypervisor/blob/release_2.7/hypervisor/arch/x86/guest/vcpu.c#L301-#L317" target="_blank" rel="noopener">set_vcpu_mode</a></p><h3 id="4-1-How-to-determine-if-protect-mode"><a href="#4-1-How-to-determine-if-protect-mode" class="headerlink" title="4.1 How to determine if protect mode?"></a>4.1 How to determine if protect mode?</h3><p><img src="/images/2021/12/25.png" alt></p><h3 id="4-2-How-to-determine-if-IA-32e-mode"><a href="#4-2-How-to-determine-if-IA-32e-mode" class="headerlink" title="4.2 How to determine if IA-32e mode?"></a>4.2 How to determine if IA-32e mode?</h3><p>注意：IA-32e mode还有一个叫法:long mode。</p><p><img src="/images/2021/12/21.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_IA32_EFER_LME_BIT(1UL &lt;&lt; 8U)<span class="comment">/* IA32e mode enable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_IA32_EFER_LMA_BIT(1UL &lt;&lt; 10U)<span class="comment">/* IA32e mode active */</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> ((ia32_efer &amp; MSR_IA32_EFER_LMA_BIT) != <span class="number">0U</span>L)</span><br></pre></td></tr></table></figure><h3 id="4-3-How-to-determine-if-64-bit-mode"><a href="#4-3-How-to-determine-if-64-bit-mode" class="headerlink" title="4.3 How to determine if 64-bit mode?"></a>4.3 How to determine if 64-bit mode?</h3><p><img src="/images/2021/12/22.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ia32_efer &amp; MSR_IA32_EFER_LMA_BIT) != <span class="number">0U</span>L) &#123;</span><br><span class="line"><span class="keyword">if</span> ((cs_attr &amp; <span class="number">0x2000</span>U) != <span class="number">0U</span>) &#123;</span><br><span class="line"><span class="comment">/* CS.L = 1 */</span></span><br><span class="line">vcpu-&gt;arch.cpu_mode = CPU_MODE_64BIT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-How-to-determine-if-compatibility-mode"><a href="#4-4-How-to-determine-if-compatibility-mode" class="headerlink" title="4.4 How to determine if compatibility mode?"></a>4.4 How to determine if compatibility mode?</h3><p>IA32e mode active and CS.L = 0</p><hr><p>参考资料:</p><ol><li><a href="https://zhuanlan.zhihu.com/p/69334474" target="_blank" rel="noopener">x86-64处理器的几种运行模式</a></li><li><a href="https://zhuanlan.zhihu.com/p/298033676" target="_blank" rel="noopener">X86 CPU的工作模式</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文以Intel SDM为主，以&lt;a href=&quot;https://github.com/projectacrn/acrn-hypervisor/tree/release_2.7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ACRN&lt;/a&gt;源码为辅来介绍Intel CPU operating modes。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>The usage of kdump</title>
    <link href="http://liujunming.github.io/2021/12/23/The-usage-of-kdump/"/>
    <id>http://liujunming.github.io/2021/12/23/The-usage-of-kdump/</id>
    <published>2021-12-22T16:09:36.000Z</published>
    <updated>2021-12-24T05:15:14.135Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about Linux kernel kdump.<a id="more"></a></p><h3 id="1-motivation"><a href="#1-motivation" class="headerlink" title="1. motivation"></a>1. motivation</h3><p>有时候<a href="/2021/12/11/Notes-about-Linux-kernel-Oops/">Oops</a>发生的同时系统也会宕机，此时这些出错信息是来不及存入文件中的，关掉电源后就无法再看到了。我们只能通过其他的方式来记录：手抄或者拍照。</p><p>还有更坏的情况，如果Oops信息过多的话，一页屏幕显示不全，我们怎么来查看完整的内容呢？第一种方法，在grub里用vga参数指定更高的分辨率以使屏幕可以显示更多的内容。很明显，这个方法其实解决不了太多的问题；第二种方法，使用两台机器，把调试机的Oops信息通过串口打印到宿主机的屏幕上。但现在大部分的笔记本电脑是没有串口的，这个解决方法也有很大的局限性；第三种方法，使用内核转储工具kdump把发生Oops时的内存和CPU寄存器的内容dump到一个文件里，之后我们再用工具来分析问题。</p><h3 id="2-Overview"><a href="#2-Overview" class="headerlink" title="2. Overview"></a>2. Overview</h3><p>Kdump uses kexec to quickly boot to a dump-capture kernel whenever a dump of the system kernel’s memory needs to be taken (for example, when the system panics). The system kernel’s memory image is preserved across the reboot and is accessible to the dump-capture kernel.</p><p>You can use common commands, such as cp, scp or makedumpfile to copy the memory image to a dump file on the local disk, or across the network to a remote system.</p><p>When the system kernel boots, it reserves a small section of memory for the dump-capture kernel. This ensures that ongoing Direct Memory Access (DMA) from the system kernel does not corrupt the dump-capture kernel. The kexec -p command loads the dump-capture kernel into this reserved memory.</p><p>With the dump-capture kernel, you can access the memory image through /proc/vmcore. This exports the dump as an ELF-format file that you can write out using file copy commands such as cp or scp. You can also use makedumpfile utility to analyze and write out filtered contents with options, e.g with ‘-d 31’ it will only write out kernel data. Further, you can use analysis tools such as the GDB and the Crash tool to debug the dump file. </p><p><img src="/images/2021/12/20.png" alt></p><h3 id="3-System-kernel-config-options"><a href="#3-System-kernel-config-options" class="headerlink" title="3. System kernel config options"></a>3. System kernel config options</h3><p>There are two possible methods of using Kdump.</p><ol><li>Build a separate custom dump-capture kernel for capturing the kernel core dump.</li><li>Or use the system kernel binary itself as dump-capture kernel and there is no need to build a separate dump-capture kernel. This is possible only with the architectures which support a relocatable kernel. As of today, i386, x86_64, ppc64, ia64, arm and arm64 architectures support relocatable kernel.</li></ol><p>本文选择的是第二种方法。</p><p>system kernel config options配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KEXEC=y</span><br><span class="line">CONFIG_KEXEC_FILE=y</span><br><span class="line">CONFIG_KEXEC_CORE=y</span><br><span class="line">CONFIG_CRASH_CORE=y</span><br><span class="line">CONFIG_SYSFS=y</span><br><span class="line">CONFIG_DEBUG_INFO=y</span><br></pre></td></tr></table></figure><h3 id="4-Setup-and-Installation"><a href="#4-Setup-and-Installation" class="headerlink" title="4. Setup and Installation"></a>4. Setup and Installation</h3><h4 id="4-1-Ubuntu"><a href="#4-1-Ubuntu" class="headerlink" title="4.1 Ubuntu"></a>4.1 Ubuntu</h4><p>参考: <a href="https://ubuntu.com/server/docs/kernel-crash-dump" target="_blank" rel="noopener">ubuntu Kernel Crash Dump</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install linux-crashdump -y</span><br></pre></td></tr></table></figure><p><img src="/images/2021/12/19.png" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/crash-utility/crash/archive/refs/tags/7.3.1.tar.gz</span><br><span class="line">tar xzvf 7.3.1.tar.gz</span><br><span class="line">cd crash-7.3.1</span><br><span class="line"></span><br><span class="line">sudo apt install bison libz-dev libncurses5-dev libncursesw5-dev texinfo -y</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h3 id="5-强制内核崩溃"><a href="#5-强制内核崩溃" class="headerlink" title="5. 强制内核崩溃"></a>5. 强制内核崩溃</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/kernel/sysrq</span><br><span class="line">echo c &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure><p>重启后可以在/var/crash/目录下看到vmcore日志文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /var/crash/</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">202112241159  kdump_lock  kexec_cmd</span><br><span class="line"><span class="meta">$</span> cd 202112241159</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">vmcore.202112241159</span><br><span class="line"><span class="meta">$</span> file vmcore.202112241159</span><br><span class="line">vmcore.202112241159: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style</span><br></pre></td></tr></table></figure><h3 id="6-Kdump-analysis-using-crash"><a href="#6-Kdump-analysis-using-crash" class="headerlink" title="6. Kdump analysis using crash"></a>6. Kdump analysis using crash</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crash vmcore.202112241159 /usr/lib/debug/lib/modules/5.15.0-rc6-virt-ui+/vmlinux</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; bt</span><br><span class="line">PID: 1579   TASK: ffff8d6087084f80  CPU: 0   COMMAND: &quot;bash&quot;</span><br><span class="line"> #0 [ffffae2c80fc7cc0] machine_kexec at ffffffffa9061348</span><br><span class="line"> #1 [ffffae2c80fc7d20] __crash_kexec at ffffffffa91bc670</span><br><span class="line"> #2 [ffffae2c80fc7de8] panic at ffffffffa9f301f0</span><br><span class="line"> #3 [ffffae2c80fc7e68] sysrq_handle_crash at ffffffffa98327a6</span><br><span class="line"> #4 [ffffae2c80fc7e70] __handle_sysrq.cold at ffffffffa9f62e96</span><br><span class="line"> #5 [ffffae2c80fc7ea0] write_sysrq_trigger at ffffffffa98331d4</span><br><span class="line"> #6 [ffffae2c80fc7eb0] proc_reg_write at ffffffffa93e83c3</span><br><span class="line"> #7 [ffffae2c80fc7ec8] vfs_write at ffffffffa934dc2d</span><br><span class="line"> #8 [ffffae2c80fc7f00] ksys_write at ffffffffa934df45</span><br><span class="line"> #9 [ffffae2c80fc7f38] do_syscall_64 at ffffffffa9fa9553</span><br><span class="line">#10 [ffffae2c80fc7f50] entry_SYSCALL_64_after_hwframe at ffffffffaa00007c</span><br><span class="line">    RIP: 00007f5ab67f5224  RSP: 00007ffe5b9e7038  RFLAGS: 00000246</span><br><span class="line">    RAX: ffffffffffffffda  RBX: 0000000000000002  RCX: 00007f5ab67f5224</span><br><span class="line">    RDX: 0000000000000002  RSI: 0000561b7a365e00  RDI: 0000000000000001</span><br><span class="line">    RBP: 0000561b7a365e00   R8: 000000000000000a   R9: 0000000000000001</span><br><span class="line">    R10: 000000000000000a  R11: 0000000000000246  R12: 00007f5ab6ad1760</span><br><span class="line">    R13: 0000000000000002  R14: 00007f5ab6acd2a0  R15: 00007f5ab6acc760</span><br><span class="line">    ORIG_RAX: 0000000000000001  CS: 0033  SS: 002b</span><br></pre></td></tr></table></figure><h3 id="7-MISC"><a href="#7-MISC" class="headerlink" title="7. MISC"></a>7. MISC</h3><ul><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/kdump/kdump.html#crashkernel-syntax" target="_blank" rel="noopener">crashkernel syntax</a></li><li>Configure Dump Location</li><li>Configure Core Collector</li></ul><p>Configure Dump Location和Configure Core Collector可以参考<a href="https://www.thegeekstuff.com/2014/05/kdump/" target="_blank" rel="noopener">How to use kdump for Linux Kernel Crash Analysis</a>。</p><hr><p>参考资料:</p><ol><li><a href="https://events.static.linuxfound.org/sites/events/files/slides/kdump_usage_and_internals.pdf" target="_blank" rel="noopener">kdump: usage and internals</a></li><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/kdump/kdump.html" target="_blank" rel="noopener"> The kexec-based Crash Dumping Solution</a></li><li><a href="https://programming.vip/docs/example-using-crash-to-analyze-kdump-dump-kernel-crash-kernel.html" target="_blank" rel="noopener">Example using crash to analyze Kdump dump kernel crash kernel</a></li><li><a href="https://www.thegeekstuff.com/2014/05/kdump/" target="_blank" rel="noopener">How to use kdump for Linux Kernel Crash Analysis</a></li><li><a href="https://www.jianshu.com/p/3c92647140f7" target="_blank" rel="noopener">如何在Ubuntu18.04下安装和配置kdump</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about Linux kernel kdump.
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Notes about the usage of git log</title>
    <link href="http://liujunming.github.io/2021/12/18/Notes-about-the-usage-of-git-log/"/>
    <id>http://liujunming.github.io/2021/12/18/Notes-about-the-usage-of-git-log/</id>
    <published>2021-12-17T16:04:12.000Z</published>
    <updated>2021-12-18T03:52:22.392Z</updated>
    
    <content type="html"><![CDATA[<p>在看源码过程中，发现可以好好利用git log来查看和搜索提交历史，本文特此mark下notes。<a id="more"></a>大部分内容转载自<a href="https://blog.csdn.net/daguanjia11/article/details/73823617" target="_blank" rel="noopener">git log的常见用法</a>。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://git-scm.com/docs/git-log" target="_blank" rel="noopener">https://git-scm.com/docs/git-log</a></p><p><code>man git-log</code></p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a><code>git log</code></h3><p>使用git log命令，什么参数都没有的话，会以下面的格式输出所有的日志。如果日志特别多的话，在git bash中，按向下键来查看更多，按q键退出查看日志。<br><img src="/images/2021/12/7.png" alt></p><h3 id="git-log-oneline"><a href="#git-log-oneline" class="headerlink" title="git log --oneline"></a><code>git log --oneline</code></h3><p><code>--oneline</code>参数可以将每条日志的输出为一行，如果日志比较多的话，用这个参数能够使结果看起来比较醒目。<br><img src="/images/2021/12/8.png" alt></p><h3 id="git-log-length"><a href="#git-log-length" class="headerlink" title="git log -[length]"></a><code>git log -[length]</code></h3><p><code>-[length]</code>参数用于指定显示多少条日志</p><p><img src="/images/2021/12/9.png" alt><br>这里面使用<code>-2</code>来指定显示前两条日志</p><h3 id="git-log-skip-skip"><a href="#git-log-skip-skip" class="headerlink" title="git log --skip=[skip]"></a><code>git log --skip=[skip]</code></h3><p><code>--skip=[skip]</code>参数用来指定跳过前几条日志。下面的命令用来查看第二和第三条日志<br><img src="/images/2021/12/10.png" alt></p><h3 id="git-log-pretty-raw"><a href="#git-log-pretty-raw" class="headerlink" title="git log --pretty=raw"></a><code>git log --pretty=raw</code></h3><p><code>--pretty=raw</code>会显示出关于每次提交的更多信息。</p><p><img src="/images/2021/12/11.png" alt><br>输出的信息中包括提交ID，文件树ID，父提交ID，作者和提交者，这些信息都非常有用。</p><h3 id="git-log-p"><a href="#git-log-p" class="headerlink" title="git log -p"></a><code>git log -p</code></h3><p><code>-p</code>参数输出的信息会更多，用来显示提交的改动记录，相当于多次使用<code>git show [commit_id]</code>的结果。<br><img src="/images/2021/12/12.png" alt></p><h3 id="git-log-graph"><a href="#git-log-graph" class="headerlink" title="git log --graph"></a><code>git log --graph</code></h3><p><code>--graph</code>参数会绘制提交的线索，如果有合并的话，也会更清晰地显示出来<br><img src="/images/2021/12/14.png" alt></p><p>这样可以查看哪几个commit是一块提交的。</p><h3 id="git-log-decorate"><a href="#git-log-decorate" class="headerlink" title="git log --decorate"></a><code>git log --decorate</code></h3><p><code>--decorate</code>参数用来显示一些相关的信息，如HEAD、分支名、tag名等。<br><img src="/images/2021/12/15.png" alt></p><h3 id="git-log-name-status"><a href="#git-log-name-status" class="headerlink" title="git log --name-status"></a><code>git log --name-status</code></h3><p><code>--name-status</code>参数会带出每次提交对应的文件改动。<br><img src="/images/2021/12/16.png" alt></p><h2 id="搜索git日志"><a href="#搜索git日志" class="headerlink" title="搜索git日志"></a>搜索git日志</h2><h3 id="通过作者搜索"><a href="#通过作者搜索" class="headerlink" title="通过作者搜索"></a>通过作者搜索</h3><p>有时候会从提交记录中查看一下自己（或某个人）的某次提交，git log命令可以很快地检索出这些信息</p><p><code>git log --author yourname</code></p><p>可以筛选出<code>yourname</code>用户提交的所有日志。这里的<code>yourname</code>可以包含通配符，从<code>Author: zdk &lt;zdk@menhoo.com&gt;</code>的信息中匹配信息。</p><p> <img src="/images/2021/12/17.png" alt></p><h3 id="通过关键字搜索"><a href="#通过关键字搜索" class="headerlink" title="通过关键字搜索"></a>通过关键字搜索</h3><p><code>git log --grep keywords</code><br>可以从提交的关键字中抓取匹配的commit项。</p><h3 id="通过文件名搜索"><a href="#通过文件名搜索" class="headerlink" title="通过文件名搜索"></a>通过文件名搜索</h3><p>有时候，我们想查某个文件(file or folder)的所有修改记录，可以根据文件名来过滤一下只跟这个文件有关的提交。<br><code>git log -- A</code></p><h3 id="查看两个tag之间的commit"><a href="#查看两个tag之间的commit" class="headerlink" title="查看两个tag之间的commit"></a>查看两个tag之间的commit</h3><p><code>git log --oneline v3.11..v3.12</code><br> <img src="/images/2021/12/18.png" alt></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="查看KVM目录下的commit"><a href="#查看KVM目录下的commit" class="headerlink" title="查看KVM目录下的commit"></a>查看KVM目录下的commit</h3><p><code>git log --oneline -- arch/x86/kvm/</code></p><h3 id="查看vmx-c的commit"><a href="#查看vmx-c的commit" class="headerlink" title="查看vmx.c的commit"></a>查看vmx.c的commit</h3><p><code>git log --oneline -- arch/x86/kvm/vmx/vmx.c</code><br>或者<br><code>git log -p -- arch/x86/kvm/vmx/vmx.c</code><br>然后关键字搜索，找到你想要的commit。</p><hr><p>参考资料：</p><ol><li><a href="https://stackoverflow.com/questions/16343659/how-to-show-git-log-history-i-e-all-the-related-commits-for-a-sub-directory" target="_blank" rel="noopener">How to show Git log history (i.e., all the related commits) for a sub directory of a Git repository</a></li><li><a href="https://blog.csdn.net/daguanjia11/article/details/73823617" target="_blank" rel="noopener">git log的常见用法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看源码过程中，发现可以好好利用git log来查看和搜索提交历史，本文特此mark下notes。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>The usage of OVMF in QEMU</title>
    <link href="http://liujunming.github.io/2021/12/17/The-usage-of-OVMF/"/>
    <id>http://liujunming.github.io/2021/12/17/The-usage-of-OVMF/</id>
    <published>2021-12-17T14:49:38.000Z</published>
    <updated>2021-12-18T03:52:22.392Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about the usage of OVMF in QEMU.<a id="more"></a></p><h3 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bios /path/to/OVMF.fd \</span><br></pre></td></tr></table></figure><h3 id="Case2-split-firmware"><a href="#Case2-split-firmware" class="headerlink" title="Case2: split firmware"></a>Case2: split firmware</h3><blockquote><p>The variable store and the firmware executable are also available in the build output as separate files: “OVMF_VARS.fd” and “OVMF_CODE.fd”. This enables central management and updates of the firmware executable, while each virtual machine can retain its own variable store.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-drive if=pflash,format=raw,unit=0,readonly=on,file=/path/to/OVMF_CODE.fd \</span><br><span class="line">-drive if=pflash,format=raw,unit=1,file=/path/to/OVMF_VARS.fd \</span><br></pre></td></tr></table></figure><h3 id="Case3-secure-boot"><a href="#Case3-secure-boot" class="headerlink" title="Case3: secure boot"></a>Case3: secure boot</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-drive if=pflash,format=raw,unit=0,readonly=on,file=/path/to/OVMF_SECURE_CODE.fd \</span><br><span class="line">-drive if=pflash,format=raw,unit=1,file=/path/to/OVMF_VARS.fd \</span><br><span class="line">-global driver=cfi.pflash01,property=secure,value=on \</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.linux-kvm.org/downloads/lersek/ovmf-whitepaper-c770f8c.txt" target="_blank" rel="noopener">Open Virtual Machine Firmware (OVMF) Status Report</a></li><li><a href="https://lore.kernel.org/qemu-devel/87y378n5iy.fsf@dusky.pond.sub.org/" target="_blank" rel="noopener">Configuring pflash devices for OVMF firmware</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about the usage of OVMF in QEMU.
    
    </summary>
    
      <category term="Firmware" scheme="http://liujunming.github.io/categories/Firmware/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Firmware" scheme="http://liujunming.github.io/tags/Firmware/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Linux kernel Oops</title>
    <link href="http://liujunming.github.io/2021/12/11/Notes-about-Linux-kernel-Oops/"/>
    <id>http://liujunming.github.io/2021/12/11/Notes-about-Linux-kernel-Oops/</id>
    <published>2021-12-11T14:23:17.000Z</published>
    <updated>2021-12-11T15:19:31.714Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about Linux kernel Oops.<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>什么是Oops？从语言学的角度说，Oops应该是一个拟声词。当出了点小事故，或者做了比较尴尬的事之后，你可以说”Oops”，翻译成中国话就叫做“哎呦”。“哎呦，对不起，对不起，我真不是故意打碎您的杯子的”。看，Oops就是这个意思。</p><p>在Linux内核开发中的Oops是什么呢？其实，它和上面的解释也没什么本质的差别，只不过说话的主角变成了Linux。当某些比较致命的问题出现时，我们的Linux内核也会抱歉的对我们说：“哎呦（Oops），对不起，我把事情搞砸了”。Linux内核在发生kernel panic时会打印出Oops信息，把目前的寄存器状态、堆栈内容、以及完整的Call trace都show给我们看，这样就可以帮助我们定位错误。</p><p>Kernel bug reports often come with a stack dump like the one below:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">------------[ cut here ]------------</span><br><span class="line">WARNING: CPU: 1 PID: 28102 at kernel/module.c:1108 module_put+0x57/0x70</span><br><span class="line">Modules linked in: dvb_usb_gp8psk(-) dvb_usb dvb_core nvidia_drm(PO) nvidia_modeset(PO) snd_hda_codec_hdmi snd_hda_intel snd_hda_codec snd_hwdep snd_hda_core snd_pcm snd_timer snd soundcore nvidia(PO) [last unloaded: rc_core]</span><br><span class="line">CPU: 1 PID: 28102 Comm: rmmod Tainted: P        WC O 4.8.4-build.1 #1</span><br><span class="line">Hardware name: MSI MS-7309/MS-7309, BIOS V1.12 02/23/2009</span><br><span class="line"> 00000000 c12ba080 00000000 00000000 c103ed6a c1616014 00000001 00006dc6</span><br><span class="line"> c1615862 00000454 c109e8a7 c109e8a7 00000009 ffffffff 00000000 f13f6a10</span><br><span class="line"> f5f5a600 c103ee33 00000009 00000000 00000000 c109e8a7 f80ca4d0 c109f617</span><br><span class="line">Call Trace:</span><br><span class="line"> [&lt;c12ba080&gt;] ? dump_stack+0x44/0x64</span><br><span class="line"> [&lt;c103ed6a&gt;] ? __warn+0xfa/0x120</span><br><span class="line"> [&lt;c109e8a7&gt;] ? module_put+0x57/0x70</span><br><span class="line"> [&lt;c109e8a7&gt;] ? module_put+0x57/0x70</span><br><span class="line"> [&lt;c103ee33&gt;] ? warn_slowpath_null+0x23/0x30</span><br><span class="line"> [&lt;c109e8a7&gt;] ? module_put+0x57/0x70</span><br><span class="line"> [&lt;f80ca4d0&gt;] ? gp8psk_fe_set_frontend+0x460/0x460 [dvb_usb_gp8psk]</span><br><span class="line"> [&lt;c109f617&gt;] ? symbol_put_addr+0x27/0x50</span><br><span class="line"> [&lt;f80bc9ca&gt;] ? dvb_usb_adapter_frontend_exit+0x3a/0x70 [dvb_usb]</span><br><span class="line"> [&lt;f80bb3bf&gt;] ? dvb_usb_exit+0x2f/0xd0 [dvb_usb]</span><br><span class="line"> [&lt;c13d03bc&gt;] ? usb_disable_endpoint+0x7c/0xb0</span><br><span class="line"> [&lt;f80bb48a&gt;] ? dvb_usb_device_exit+0x2a/0x50 [dvb_usb]</span><br><span class="line"> [&lt;c13d2882&gt;] ? usb_unbind_interface+0x62/0x250</span><br><span class="line"> [&lt;c136b514&gt;] ? __pm_runtime_idle+0x44/0x70</span><br><span class="line"> [&lt;c13620d8&gt;] ? __device_release_driver+0x78/0x120</span><br><span class="line"> [&lt;c1362907&gt;] ? driver_detach+0x87/0x90</span><br><span class="line"> [&lt;c1361c48&gt;] ? bus_remove_driver+0x38/0x90</span><br><span class="line"> [&lt;c13d1c18&gt;] ? usb_deregister+0x58/0xb0</span><br><span class="line"> [&lt;c109fbb0&gt;] ? SyS_delete_module+0x130/0x1f0</span><br><span class="line"> [&lt;c1055654&gt;] ? task_work_run+0x64/0x80</span><br><span class="line"> [&lt;c1000fa5&gt;] ? exit_to_usermode_loop+0x85/0x90</span><br><span class="line"> [&lt;c10013f0&gt;] ? do_fast_syscall_32+0x80/0x130</span><br><span class="line"> [&lt;c1549f43&gt;] ? sysenter_past_esp+0x40/0x6a</span><br><span class="line">---[ end trace 6ebc60ef3981792f ]---</span><br></pre></td></tr></table></figure></p><p>Such stack traces provide enough information to identify the line inside the Kernel’s source code where the bug happened. Depending on the severity of the issue, it may also contain the word <strong>Oops</strong>, as on this one:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BUG: unable to handle kernel NULL pointer dereference at   (null)</span><br><span class="line">IP: [&lt;c06969d4&gt;] iret_exc+0x7d0/0xa59</span><br><span class="line">*pdpt = 000000002258a001 *pde = 0000000000000000</span><br><span class="line">Oops: 0002 [#1] PREEMPT SMP</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Despite being an <strong>Oops</strong> or some other sort of stack trace, the offended line is usually required to identify and handle the bug. Along this chapter, we’ll refer to “Oops” for all kinds of stack traces that need to be analyzed.</p><h3 id="2-decode-stacktrace"><a href="#2-decode-stacktrace" class="headerlink" title="2. decode_stacktrace"></a>2. decode_stacktrace</h3><p>If the kernel is compiled with <code>CONFIG_DEBUG_INFO</code>, you can enhance the quality of the stack trace by using file:<a href="https://lwn.net/Articles/592724/" target="_blank" rel="noopener">scripts/decode_stacktrace.sh</a>.</p><h4 id="2-1-Input"><a href="#2-1-Input" class="headerlink" title="2.1 Input"></a>2.1 Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[    6.906437]  [&lt;ffffffff811f0e90&gt;] ? backtrace_test_irq_callback+0x20/0x20</span><br><span class="line">[    6.907121]  [&lt;ffffffff84388ce8&gt;] dump_stack+0x52/0x7f</span><br><span class="line">[    6.907640]  [&lt;ffffffff811f0ec8&gt;] backtrace_regression_test+0x38/0x110</span><br><span class="line">[    6.908281]  [&lt;ffffffff813596a0&gt;] ? proc_create_data+0xa0/0xd0</span><br><span class="line">[    6.908870]  [&lt;ffffffff870a8040&gt;] ? proc_modules_init+0x22/0x22</span><br><span class="line">[    6.909480]  [&lt;ffffffff810020c2&gt;] do_one_initcall+0xc2/0x1e0</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h4 id="2-2-Output"><a href="#2-2-Output" class="headerlink" title="2.2 Output"></a>2.2 Output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[  635.148361]  dump_stack (lib/dump_stack.c:52)</span><br><span class="line">[  635.149127]  warn_slowpath_common (kernel/panic.c:418)</span><br><span class="line">[  635.150214]  warn_slowpath_null (kernel/panic.c:453)</span><br><span class="line">[  635.151031]  _oalloc_pages_slowpath+0x6a/0x7d0</span><br><span class="line">[  635.152171]  ? zone_watermark_ok (mm/page_alloc.c:1728)</span><br><span class="line">[  635.152988]  ? get_page_from_freelist (mm/page_alloc.c:1939)</span><br><span class="line">[  635.154766]  __alloc_pages_nodemask (mm/page_alloc.c:2766)</span><br></pre></td></tr></table></figure><h4 id="2-3-Usage"><a href="#2-3-Usage" class="headerlink" title="2.3 Usage"></a>2.3 Usage</h4><p><code>./decode_stacktrace.sh [vmlinux] [base path]</code></p><p>Where vmlinux is the vmlinux to extract line numbers from and base path is the path that points to the root of the build tree, for example:</p><p><code>./decode_stacktrace.sh vmlinux /home/sasha/linux/ &lt; input.log &gt; output.log</code></p><h3 id="3-Finding-the-bug-location-by-gdb"><a href="#3-Finding-the-bug-location-by-gdb" class="headerlink" title="3. Finding the bug location by gdb"></a>3. Finding the bug location by gdb</h3><p>Reporting a bug works best if you point the location of the bug at the Kernel source file. Usually, using gdb is easier, but the Kernel should be pre-compiled with debug info.</p><p>The gdb is the best way to figure out the exact file and line number of the OOPS from the <code>vmlinux</code> file.</p><p>The usage of gdb works best on a kernel compiled with <code>CONFIG_DEBUG_INFO</code>. This can be set by running:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./scripts/config -d COMPILE_TEST -e DEBUG_KERNEL -e DEBUG_INFO</span><br></pre></td></tr></table></figure><p>On a kernel compiled with <code>CONFIG_DEBUG_INFO</code>, you can simply copy the EIP value from the OOPS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EIP:    0060:[&lt;c021e50e&gt;]    Not tainted VLI</span><br></pre></td></tr></table></figure><p>And use GDB to translate that to human-readable form:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gdb vmlinux</span><br><span class="line">(gdb) l *0xc021e50e</span><br></pre></td></tr></table></figure><h3 id="4-More-info"><a href="#4-More-info" class="headerlink" title="4. More info"></a>4. More info</h3><h4 id="4-1-Oops-0002-1"><a href="#4-1-Oops-0002-1" class="headerlink" title="4.1 Oops: 0002 [#1]"></a>4.1 Oops: 0002 [#1]</h4><p>0002表示Oops的error code, #1表示这个错误发生一次。</p><h4 id="4-2-Tainted信息"><a href="#4-2-Tainted信息" class="headerlink" title="4.2 Tainted信息"></a>4.2 Tainted信息</h4><ul><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/bug-hunting.html#modules-linked-in" target="_blank" rel="noopener">Modules linked in</a></li><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/tainted-kernels.html" target="_blank" rel="noopener">Tainted kernels</a></li></ul><hr><p>参考资料:</p><ol><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/bug-hunting.html" target="_blank" rel="noopener">Bug hunting</a></li><li><a href="https://www.cnblogs.com/wwang/archive/2010/11/14/1876735.html" target="_blank" rel="noopener">Linux内核的Oops</a></li><li><a href="https://lwn.net/Articles/592724/" target="_blank" rel="noopener">decode_stacktrace: make stack dump output useful again</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about Linux kernel Oops.
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to cpu affinity</title>
    <link href="http://liujunming.github.io/2021/12/05/Introduction-to-cpu-affinity/"/>
    <id>http://liujunming.github.io/2021/12/05/Introduction-to-cpu-affinity/</id>
    <published>2021-12-05T13:27:43.000Z</published>
    <updated>2021-12-05T15:31:19.010Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about cpu affinity.<a id="more"></a></p><h3 id="1-Motivation"><a href="#1-Motivation" class="headerlink" title="1. Motivation"></a>1. Motivation</h3><p>CPU的亲和性， 就是进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他处理器，即绑定CPU or 绑核。</p><p>在多核运行的机器上，每个CPU本身自己会有缓存，缓存着进程使用的信息，而进程可能会被OS调度到其他CPU上，如此，CPU cache命中率就低了。当绑定CPU后，程序就会一直在指定的cpu跑，不会由操作系统调度到其他CPU上，性能有一定的提高。</p><p>另外一种使用绑核考虑就是将重要的业务进程隔离开，对于部分实时进程调度优先级高，可以将其绑定到一个指定核上，既可以保证实时进程的调度，也可以避免其他CPU上进程对该实时进程的干扰。</p><p><a href="https://en.wikipedia.org/wiki/Processor_affinity" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Processor_affinity</a></p><h3 id="2-Material"><a href="#2-Material" class="headerlink" title="2. Material"></a>2. Material</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man taskset</span><br></pre></td></tr></table></figure><p>C language: <code>sched_setaffinity</code> and <code>sched_getaffinity</code> function.</p><h3 id="3-Example"><a href="#3-Example" class="headerlink" title="3. Example"></a>3. Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        prctl(PR_SET_NAME,<span class="string">"myProcess\0"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc a.c</span><br><span class="line">$ taskset 0x10 ./a.out</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pgrep myProcess</span><br><span class="line">8402</span><br><span class="line">$ sudo trace-cmd record -e sched:sched_switch -P 8402</span><br><span class="line">$ sudo trace-cmd report</span><br></pre></td></tr></table></figure><p><img src="/images/2021/12/5.png" alt></p><p>From the result, we can see: process 8402 is running on processor #4, it’s corresponding to mask <code>0x10</code>.</p><hr><p>参考资料:</p><ol><li><a href="https://oenhan.com/cpu-affinity" target="_blank" rel="noopener">CPU亲和性的使用与机制</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about cpu affinity.
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>The usage of QEMU&amp;&amp;KVM live migration</title>
    <link href="http://liujunming.github.io/2021/12/04/The-usage-of-QEMU-KVM-live-migration/"/>
    <id>http://liujunming.github.io/2021/12/04/The-usage-of-QEMU-KVM-live-migration/</id>
    <published>2021-12-04T07:45:45.000Z</published>
    <updated>2021-12-05T11:12:42.291Z</updated>
    
    <content type="html"><![CDATA[<p>Steps of live migration under QEMU&amp;&amp;KVM.<a id="more"></a></p><p>A is the source host, B is the destination host.</p><h3 id="1-launch-source-VM-on-A"><a href="#1-launch-source-VM-on-A" class="headerlink" title="1. launch source VM on A"></a>1. launch source VM on A</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;qemu-command-line&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash -x</span><br><span class="line">    qemu-system-x86_64 \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -m 4096 \</span><br><span class="line">    -smp 2 \</span><br><span class="line">    -cpu host \</span><br><span class="line">    -drive format=raw,file=laag.img \</span><br><span class="line">    -serial mon:stdio \</span><br><span class="line">    -vnc :3</span><br></pre></td></tr></table></figure><h3 id="2-launch-destination-VM-on-B"><a href="#2-launch-destination-VM-on-B" class="headerlink" title="2. launch destination VM on B"></a>2. launch destination VM on B</h3><p>Start the VM on B with the exact same parameters as the VM on A, in migration-listen mode:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;qemu-command-line&gt; -incoming tcp:0:4444</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash -x</span><br><span class="line">    qemu-system-x86_64 \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -m 4096 \</span><br><span class="line">    -smp 2 \</span><br><span class="line">    -cpu host \</span><br><span class="line">    -drive format=raw,file=laag.img \</span><br><span class="line">    -serial mon:stdio \</span><br><span class="line">    -vnc :4 \</span><br><span class="line">    -incoming tcp:0:4444</span><br></pre></td></tr></table></figure><h3 id="3-start-the-migration-on-A-only"><a href="#3-start-the-migration-on-A-only" class="headerlink" title="3. start the migration (on A only)"></a>3. start the migration (on A only)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(qemu)migrate -d tcp:&lt;host B IP&gt;:4444</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(qemu)migrate -d tcp:localhost:4444</span><br></pre></td></tr></table></figure><h3 id="4-check-the-status-on-A-only"><a href="#4-check-the-status-on-A-only" class="headerlink" title="4.  check the status (on A only)"></a>4.  check the status (on A only)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(qemu) info migrate</span><br></pre></td></tr></table></figure><p>When completed, get can the info: <code>Migration status: completed</code>.  The source VM will stop at the end.</p><h3 id="5-misc"><a href="#5-misc" class="headerlink" title="5. misc"></a>5. misc</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(qemu) help migrate</span><br><span class="line">migrate [-d] [-b] [-i] [-r] uri -- migrate to URI (using -d to not wait for completion)</span><br><span class="line">                         -b for migration without shared storage with full copy of disk</span><br><span class="line">                         -i for migration without shared storage with incremental copy of disk (base image shared between src and destination)</span><br><span class="line">                         -r to resume a paused migration</span><br></pre></td></tr></table></figure><p>The ‘-d’ will let you query the status of the migration. With no ‘-d’ the monitor prompt returns when the migration completes.</p><hr><p>参考资料:</p><ol><li><a href="https://www.linux-kvm.org/page/Migration" target="_blank" rel="noopener">page/Migration</a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/03/01/qemu-live-migration" target="_blank" rel="noopener">qemu热迁移简介</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Steps of live migration under QEMU&amp;amp;&amp;amp;KVM.
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="live migration" scheme="http://liujunming.github.io/tags/live-migration/"/>
    
  </entry>
  
  <entry>
    <title>How to verify the virtio kick behavior</title>
    <link href="http://liujunming.github.io/2021/12/03/How-to-verify-the-virtio-kick-behavior/"/>
    <id>http://liujunming.github.io/2021/12/03/How-to-verify-the-virtio-kick-behavior/</id>
    <published>2021-12-03T05:27:34.000Z</published>
    <updated>2021-12-05T11:12:42.288Z</updated>
    
    <content type="html"><![CDATA[<p>How to use QEMU monitor and trace-cmd to verify the virtio kick behavior?<a id="more"></a></p><h3 id="1-definition-of-virtio-kick"><a href="#1-definition-of-virtio-kick" class="headerlink" title="1. definition of virtio kick"></a>1. definition of virtio kick</h3><p>kick: used by the guest to notify the host that SGs have been added.</p><p><a href="http://retis.sssup.it/luca/KernelProgramming/Slides/kp_virtio.pdf" target="_blank" rel="noopener">http://retis.sssup.it/luca/KernelProgramming/Slides/kp_virtio.pdf</a></p><h3 id="2-create-a-virtio-device"><a href="#2-create-a-virtio-device" class="headerlink" title="2. create a virtio device"></a>2. create a virtio device</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-drive format=raw,file=laag.img,if=virtio</span><br></pre></td></tr></table></figure><h3 id="3-get-the-notify-mmio-addr-in-guest"><a href="#3-get-the-notify-mmio-addr-in-guest" class="headerlink" title="3. get the notify mmio addr in guest"></a>3. get the notify mmio addr in guest</h3><p>In QEMU monitor, type <code>info mtree</code></p><p><img src="/images/2021/12/2.png" alt></p><p>type <code>info pci</code></p><p><img src="/images/2021/12/3.png" alt></p><h3 id="4-track-the-kvm-mmio-event"><a href="#4-track-the-kvm-mmio-event" class="headerlink" title="4. track the kvm_mmio event"></a>4. track the kvm_mmio event</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e kvm_mmio</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><p><img src="/images/2021/12/4.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;How to use QEMU monitor and trace-cmd to verify the virtio kick behavior?
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
      <category term="virtio" scheme="http://liujunming.github.io/tags/virtio/"/>
    
  </entry>
  
  <entry>
    <title>Notes about QEMU monitor</title>
    <link href="http://liujunming.github.io/2021/12/03/Notes-about-QEMU-monitor/"/>
    <id>http://liujunming.github.io/2021/12/03/Notes-about-QEMU-monitor/</id>
    <published>2021-12-03T00:10:12.000Z</published>
    <updated>2022-01-07T15:08:48.460Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about QEMU monitor.<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>The QEMU monitor is used to give complex commands to the QEMU emulator. You can use it to:</p><ul><li>Remove or insert removable media images (such as CD-ROM or floppies).</li><li>Freeze/unfreeze the Virtual Machine (VM) and save or restore its state from a disk file.</li><li>Inspect the VM state without an external debugger</li><li>…</li></ul><h4 id="1-1-commands"><a href="#1-1-commands" class="headerlink" title="1.1 commands"></a>1.1 commands</h4><p><a href="https://qemu.readthedocs.io/en/latest/system/monitor.html#commands" target="_blank" rel="noopener">QEMU Monitor Commands</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(qemu) help</span><br></pre></td></tr></table></figure><h3 id="2-Usage"><a href="#2-Usage" class="headerlink" title="2. Usage"></a>2. Usage</h3><p>QEMU启动时，需要使用<code>-monitor</code>选项指定做为<code>console</code>设备，<a href="https://gitlab.com/qemu-project/qemu/-/blob/master/qemu-options.hx" target="_blank" rel="noopener">官方文档</a>说明如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-monitor dev</span><br><span class="line">    Redirect the monitor to host device dev (same devices as the serialport).</span><br><span class="line">    The default device is vc in graphical mode and stdio in non graphical mode.</span><br><span class="line">    Use -monitor none to disable the default monitor.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-serial mon:stdio</span><br><span class="line">    creates a multiplexed stdio backend connected to the serial port and the QEMU monitor</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(qemu) info kvm</span><br><span class="line">kvm support: enabled</span><br></pre></td></tr></table></figure><p>上述这种方式更偏向用户直接输入命令进行交互，称为HMP(Human Machine Protocol)，程序使用这种方式不是太方便。QEMU还提供了另外一种基于JSON的QMP(QEMU Machine Protocol)来满足自动化处理的需求。Libvirt就是使用QMP来控制QEMU实例。</p><h3 id="3-QMP"><a href="#3-QMP" class="headerlink" title="3. QMP"></a>3. QMP</h3><p>QMP规范可以参考:</p><ul><li><a href="https://github.com/qemu/qemu/blob/master/docs/interop/qmp-intro.txt" target="_blank" rel="noopener">qmp-intro.txt</a></li><li><a href="https://github.com/qemu/qemu/blob/master/docs/interop/qmp-spec.txt" target="_blank" rel="noopener">qmp-spec.txt</a></li><li><a href="https://qemu.readthedocs.io/en/latest/interop/qemu-qmp-ref.html" target="_blank" rel="noopener">QEMU QMP Reference Manual</a></li></ul><p>QMP协议的工作流程如下:</p><ul><li>连接建立后服务器发送欢迎信息，进入能力协商(<code>capabilities negotiation</code>)模式</li><li>客户端发送<code>{“execute”:”qmp_capablities”}</code></li><li>成功则服务器返回<code>{“return”:{}}</code>，否则<code>return</code>中会含有<code>error</code>。</li><li>客户端发送命令</li><li>服务器以异步消息返回结果</li></ul><h4 id="3-1-Basic-usage"><a href="#3-1-Basic-usage" class="headerlink" title="3.1 Basic usage"></a>3.1 Basic usage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ qemu [...] -qmp tcp:localhost:4444,server=on,wait=off</span><br></pre></td></tr></table></figure><p>or<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ qemu [...] -chardev stdio,id=mon0 -mon chardev=mon0,mode=readline \</span><br><span class="line">             -chardev socket,id=mon1,host=localhost,port=4444,server=on,wait=off \</span><br><span class="line">             -mon chardev=mon1,mode=control,pretty=on</span><br></pre></td></tr></table></figure></p><p>To manually test QMP one can connect with telnet and issue commands by hand:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ telnet localhost 4444</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">&#123;</span><br><span class="line">    &quot;QMP&quot;: &#123;</span><br><span class="line">        &quot;version&quot;: &#123;</span><br><span class="line">            &quot;qemu&quot;: &#123;</span><br><span class="line">                &quot;micro&quot;: 0,</span><br><span class="line">                &quot;minor&quot;: 0,</span><br><span class="line">                &quot;major&quot;: 3</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;package&quot;: &quot;v3.0.0&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;capabilities&quot;: [</span><br><span class="line">            &quot;oob&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-2-qmp-shell"><a href="#3-2-qmp-shell" class="headerlink" title="3.2 qmp-shell"></a>3.2 qmp-shell</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ qemu [...] -qmp unix:/tmp/qmp-sock,server=on,wait=off</span><br></pre></td></tr></table></figure><p>Run ‘qmp-shell’ (located in the source tree, under: “scripts/qmp/“) to connect to the just-launched QEMU:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./qmp-shell -p -v /tmp/qmp-sock</span><br><span class="line">[...]</span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure></p><p><a href="https://qemu.readthedocs.io/en/latest/system/cpu-hotplug.html" target="_blank" rel="noopener">Virtual CPU hotplug</a></p><hr><p>参考资料:</p><ol><li><a href="https://qemu.readthedocs.io/en/latest/system/monitor.html" target="_blank" rel="noopener">QEMU Monitor</a></li><li><a href="http://just4coding.com/2017/11/19/qemu-monitor/" target="_blank" rel="noopener">QEMU monitor机制实例分析</a></li><li><a href="https://wiki.qemu.org/Documentation/QMP" target="_blank" rel="noopener">Documentation/QMP</a></li><li><a href="https://github.com/qemu/qemu/blob/master/docs/interop/qmp-intro.txt" target="_blank" rel="noopener">qmp-intro.txt</a></li><li><a href="https://github.com/qemu/qemu/blob/master/docs/interop/qmp-spec.txt" target="_blank" rel="noopener">qmp-spec.txt</a></li><li><a href="https://qemu.readthedocs.io/en/latest/interop/qemu-qmp-ref.html" target="_blank" rel="noopener">QEMU QMP Reference Manual</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about QEMU monitor.
    
    </summary>
    
      <category term="QEMU" scheme="http://liujunming.github.io/categories/QEMU/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Notes about KVM trace</title>
    <link href="http://liujunming.github.io/2021/12/02/Notes-about-KVM-trace/"/>
    <id>http://liujunming.github.io/2021/12/02/Notes-about-KVM-trace/</id>
    <published>2021-12-02T10:37:46.000Z</published>
    <updated>2021-12-11T15:19:31.714Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about KVM trace.<a id="more"></a></p><h3 id="kvm-trace-point"><a href="#kvm-trace-point" class="headerlink" title="kvm trace point"></a>kvm trace point</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /sys/kernel/debug/tracing/available_events | grep kvm:</span><br><span class="line">sudo cat /sys/kernel/debug/tracing/available_filter_functions | grep -i kvm</span><br></pre></td></tr></table></figure><p>了解kvm 的trace event也是了解kvm的一个渠道。</p><h3 id="Track-kvm-event"><a href="#Track-kvm-event" class="headerlink" title="Track kvm event"></a>Track kvm event</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e kvm</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="Track-kvm-cpuid"><a href="#Track-kvm-cpuid" class="headerlink" title="Track kvm_cpuid"></a>Track kvm_cpuid</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e kvm_cpuid</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="Track-kvm-inj-virq"><a href="#Track-kvm-inj-virq" class="headerlink" title="Track kvm_inj_virq"></a>Track kvm_inj_virq</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e kvm_inj_virq</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="Track-kvm-inj-exception"><a href="#Track-kvm-inj-exception" class="headerlink" title="Track kvm_inj_exception"></a>Track kvm_inj_exception</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e kvm_inj_exception</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="Track-kvm-exit"><a href="#Track-kvm-exit" class="headerlink" title="Track kvm_exit"></a>Track kvm_exit</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e kvm_exit</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.linux-kvm.org/page/Tracing" target="_blank" rel="noopener">linux-kvm.org Tracing</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about KVM trace.
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Notes about trace-cmd</title>
    <link href="http://liujunming.github.io/2021/12/02/Notes-about-trace-cmd/"/>
    <id>http://liujunming.github.io/2021/12/02/Notes-about-trace-cmd/</id>
    <published>2021-12-02T07:19:02.000Z</published>
    <updated>2021-12-05T11:12:42.291Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about trace-cmd.<a id="more"></a></p><h3 id="1-Motivation"><a href="#1-Motivation" class="headerlink" title="1. Motivation"></a>1. Motivation</h3><p>ftrace isn’t a <strong>program</strong> exactly – you don’t just run <code>ftrace my_cool_function</code>. </p><p>If you read <a href="https://lwn.net/Articles/365835/" target="_blank" rel="noopener">Debugging the kernel using Ftrace</a> it starts out by telling you to <code>cd /sys/kernel/debug/tracing</code> and then do various filesystem manipulations.</p><p>For me this is way too annoying – a simple example of using ftrace this way is something like <a href="/2021/12/01/Notes-about-ftrace/#2-1-function">this</a></p><p>This filesystem interface to the tracing system (“put values in these magic files and things will happen”) seems theoretically possible to use but really not my preference.</p><p>Luckily, team ftrace also thought this interface wasn’t that user friendly and so there is an easier-to-use interface called <strong>trace-cmd</strong>!!! trace-cmd is a normal program with command line arguments. We’ll use that! I found an intro to trace-cmd on LWN at <a href="https://lwn.net/Articles/410200/" target="_blank" rel="noopener">trace-cmd: A front-end for Ftrace</a>.</p><h3 id="2-Installation-and-manual"><a href="#2-Installation-and-manual" class="headerlink" title="2. Installation and manual"></a>2. Installation and manual</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install trace-cmd -y</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trace-cmd record --help</span><br><span class="line">man trace-cmd-record</span><br><span class="line">man trace-cmd-report</span><br></pre></td></tr></table></figure><p><img src="/images/2021/12/1.png" alt></p><h3 id="3-Trace-functions"><a href="#3-Trace-functions" class="headerlink" title="3. Trace functions"></a>3. Trace functions</h3><p>How to know what functions you can trace?</p><p>If you run <code>sudo trace-cmd list -f</code> you’ll get a list of all the functions you can trace. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -p function -l __do_fault</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="4-Trace-a-process"><a href="#4-Trace-a-process" class="headerlink" title="4. Trace a process"></a>4. Trace a process</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -p function -P 25314 # record for PID 25314</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="5-Trace-function-graph"><a href="#5-Trace-function-graph" class="headerlink" title="5. Trace function graph"></a>5. Trace function graph</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -p function_graph -P 25314</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="6-Trace-events"><a href="#6-Trace-events" class="headerlink" title="6. Trace events"></a>6. Trace events</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo trace-cmd record -e sched:sched_switch</span><br><span class="line">sudo trace-cmd report</span><br></pre></td></tr></table></figure><h3 id="7-MISC"><a href="#7-MISC" class="headerlink" title="7. MISC"></a>7. MISC</h3><ul><li><code>trace-cmd report -F filter</code> </li></ul><hr><p>参考资料:</p><ol><li><a href="https://jvns.ca/blog/2017/03/19/getting-started-with-ftrace/" target="_blank" rel="noopener">ftrace: trace your kernel functions!</a></li><li><a href="https://lwn.net/Articles/410200/" target="_blank" rel="noopener">trace-cmd: A front-end for Ftrace</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about trace-cmd.
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
</feed>
