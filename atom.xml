<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2022-10-05T13:59:49.981Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux watch命令</title>
    <link href="http://liujunming.github.io/2022/10/05/Linux-watch-command/"/>
    <id>http://liujunming.github.io/2022/10/05/Linux-watch-command/</id>
    <published>2022-10-05T13:10:29.000Z</published>
    <updated>2022-10-05T13:59:49.981Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark watch命令相关notes。<a id="more"></a> </p><p>watch命令以周期性的方式执行给定的指令，指令输出以全屏方式显示。watch是一个非常实用的命令，基本所有的Linux发行版都带有这个小工具，如同名字一样，watch可以帮你监测一个命令的运行结果，省得你一遍遍的手动运行。</p><p>下面将介绍下watch命令的一个用例。</p><p>在虚拟化环境下，如何确认TLB shootdown是引起性能下降的因素之一？<br>在 Guest 中执行：<br><code>watch -d -n 1 &quot;cat /proc/interrupts | grep TLB&quot;</code></p><p>如果看到数据上涨比较厉害，那么基本就可以看到问题了。</p><hr><p>参考资料:</p><ol><li><a href="https://man7.org/linux/man-pages/man1/watch.1.html" target="_blank" rel="noopener">man</a></li><li><a href="https://wangchujiang.com/linux-command/c/watch.html" target="_blank" rel="noopener">watch</a></li><li><a href="https://blog.csdn.net/ByteDanceTech/article/details/104765810" target="_blank" rel="noopener">深入理解 Linux 内核–jemalloc 引起的 TLB shootdown 及优化</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark watch命令相关notes。
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 中 2＞&amp;1 详解</title>
    <link href="http://liujunming.github.io/2022/10/05/Linux-%E4%B8%AD-2%EF%BC%9E-1-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://liujunming.github.io/2022/10/05/Linux-中-2＞-1-详解/</id>
    <published>2022-10-05T08:20:30.000Z</published>
    <updated>2022-10-05T08:37:46.919Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自: <a href="https://blog.csdn.net/icanlove/article/details/38018169" target="_blank" rel="noopener">Linux 中 2＞&amp;1 详解</a><a id="more"></a> </p><h3 id="1和2在Linux中的含义"><a href="#1和2在Linux中的含义" class="headerlink" title="1和2在Linux中的含义"></a>1和2在Linux中的含义</h3><p>在Linux系统中0 1 2是一个文件描述符：<br>标准的输入，输出和错误输出分别表示为STDIN,STDOUT,STDERR，也可以用0，1，2来表示。<br>整理成表格如下：<br><img src="/images/2022/10/06.jpg" alt></p><p>其中0表示键盘输入 1表示屏幕输出 2表示错误输出。</p><h3 id="2-gt-amp-1的含义"><a href="#2-gt-amp-1的含义" class="headerlink" title="2&gt;&amp;1的含义"></a>2&gt;&amp;1的含义</h3><p>2&gt;&amp;1的含义：将标准错误输出重定向到标准输出。<br>注意：符号&gt;&amp;是一个整体，不可分开，分开后就不是上述含义了。</p><p><code>strace -f -p 1510 2&gt;&amp;1 | grep madvise</code></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/images/2022/10/07.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自: &lt;a href=&quot;https://blog.csdn.net/icanlove/article/details/38018169&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux 中 2＞&amp;amp;1 详解&lt;/a&gt;
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Notes about strace</title>
    <link href="http://liujunming.github.io/2022/10/05/Notes-about-strace/"/>
    <id>http://liujunming.github.io/2022/10/05/Notes-about-strace/</id>
    <published>2022-10-05T02:20:51.000Z</published>
    <updated>2022-10-05T08:13:42.572Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录strace相关笔记。<a id="more"></a> </p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>strace is a diagnostic, debugging and instructional userspace utility for Linux. It is used to monitor and tamper with interactions between processes and the Linux kernel, which include system calls, signal deliveries, and changes of process state.</p><p>System administrators, diagnosticians and trouble-shooters will find it invaluable for solving problems with programs for which the source is not readily available since they do not need to be recompiled in order to trace them.</p><p>The operation of strace is made possible by the kernel feature known as <code>ptrace</code>.</p><p><img src="/images/2022/10/05.jpg" alt></p><blockquote><p>strace解决的问题都是关于寻找程序依赖的文件、找出程序卡住或慢的原因、或者找出程序失败的原因。</p></blockquote><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p><a href="https://man7.org/linux/man-pages/man1/strace.1.html" target="_blank" rel="noopener">man strace</a><br><a href="https://nanxiao.github.io/strace-little-book/" target="_blank" rel="noopener">Strace little book</a></p><p><img src="/images/2022/10/04.jpg" alt></p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><ul><li><p>Print stack trace of every system call<br><code>-k</code> option is used to print stack trace of every system call.<br><a href="https://nanxiao.github.io/strace-little-book/posts/print-stack-trace-of-every-system-call.html" target="_blank" rel="noopener">Print stack trace of every system call</a></p></li><li><p><code>-f</code>跟踪目标进程，以及目标进程创建的所有子进程</p></li><li><p><code>-t</code> 在输出中的每一行前加上时间信息(<code>-tt</code> 表示微秒级)</p></li><li><p><code>-T</code> 显示每个系统调用所耗的时间</p></li><li><p><code>-o</code> filename: Write the trace output to the file filename rather than to stderr.</p></li><li><p><code>-c</code> Count time, calls, and errors for each system call and report a summary on program exit, suppressing the regular output. </p></li></ul><h3 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h3><ul><li><a href="https://blog.csdn.net/joeyon1985/article/details/72986412" target="_blank" rel="noopener">手把手教你用Strace诊断问题</a></li><li><a href="https://zhuanlan.zhihu.com/p/180053751" target="_blank" rel="noopener">Linux神器strace的使用方法及实践</a></li><li><a href="https://zhuanlan.zhihu.com/p/362348075" target="_blank" rel="noopener">strace 可以解决什么问题?</a><ul><li>配置文件在哪里？</li><li>这个程序还依赖什么文件？</li><li>为什么这个程序会挂掉？</li><li>这个程序卡住了吗？</li><li>为什么这个程序很慢？</li><li>隐藏的权限错误</li><li>正在使用什么命令行参数？</li><li>为什么这个网络连接失败？</li><li>为什么这个程序以一种方式运行时成功，以另一种方式运行时失败？</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><a href="https://blog.packagecloud.io/how-does-strace-work/" target="_blank" rel="noopener">How does strace work?</a></li></ul><hr><p>参考资料:</p><ol><li><a href="https://www.cnblogs.com/chenxinshuo/p/11986858.html" target="_blank" rel="noopener">Debug 利器：pstack &amp; strace</a></li><li><a href="https://blog.csdn.net/joeyon1985/article/details/72986412" target="_blank" rel="noopener">Linux strace、pstack 命令 使用详解</a></li><li><a href="https://blog.csdn.net/ByteDanceTech/article/details/104765810" target="_blank" rel="noopener">深入理解 Linux 内核–jemalloc 引起的 TLB shootdown 及优化</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录strace相关笔记。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第32期</title>
    <link href="http://liujunming.github.io/2022/10/04/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC32%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2022/10/04/每周分享第32期/</id>
    <published>2022-10-04T08:25:23.000Z</published>
    <updated>2022-10-04T09:35:39.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="七千字详解阿里云新一代云计算体系架构-CIPU"><a href="#七千字详解阿里云新一代云计算体系架构-CIPU" class="headerlink" title="七千字详解阿里云新一代云计算体系架构 CIPU"></a>七千字详解阿里云新一代云计算体系架构 CIPU</h3><p><a href="https://mp.weixin.qq.com/s/OX4Iyu_rOekNiP9hUMzGew" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OX4Iyu_rOekNiP9hUMzGew</a><a id="more"></a> </p><h3 id="Linux-如何测量函数的执行时间"><a href="#Linux-如何测量函数的执行时间" class="headerlink" title="Linux - 如何测量函数的执行时间"></a>Linux - 如何测量函数的执行时间</h3><p><a href="https://zhuanlan.zhihu.com/p/476264071" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/476264071</a></p><ul><li>bpftrace</li><li>bcc-tools</li><li>systemtap</li></ul><h3 id="In-which-conditions-the-ioctl-KVM-RUN-returns"><a href="#In-which-conditions-the-ioctl-KVM-RUN-returns" class="headerlink" title="In which conditions the ioctl KVM_RUN returns?"></a>In which conditions the ioctl KVM_RUN returns?</h3><p><a href="https://stackoverflow.com/questions/65194712/in-which-conditions-the-ioctl-kvm-run-returns" target="_blank" rel="noopener">https://stackoverflow.com/questions/65194712/in-which-conditions-the-ioctl-kvm-run-returns</a><br><img src="/images/2022/10/03.jpg" alt></p><h3 id="陈海波：面向-2030-的操作系统架构与演进思考"><a href="#陈海波：面向-2030-的操作系统架构与演进思考" class="headerlink" title="陈海波：面向 2030 的操作系统架构与演进思考"></a>陈海波：面向 2030 的操作系统架构与演进思考</h3><p><a href="https://mp.weixin.qq.com/s/3k8ro-QahNHsQQXa183VOw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3k8ro-QahNHsQQXa183VOw</a></p><h3 id="英伟达高管交流纪要"><a href="#英伟达高管交流纪要" class="headerlink" title="英伟达高管交流纪要"></a>英伟达高管交流纪要</h3><p><a href="https://xueqiu.com/6846564531/223664454?sharetime=2" target="_blank" rel="noopener">https://xueqiu.com/6846564531/223664454?sharetime=2</a></p><h3 id="他是世界上最杰出的程序员，一个月写了个操作系统，退休后去做飞行员！"><a href="#他是世界上最杰出的程序员，一个月写了个操作系统，退休后去做飞行员！" class="headerlink" title="他是世界上最杰出的程序员，一个月写了个操作系统，退休后去做飞行员！"></a>他是世界上最杰出的程序员，一个月写了个操作系统，退休后去做飞行员！</h3><p><a href="https://mp.weixin.qq.com/s/fUKv2Nfznf5-uExSh3XTfw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fUKv2Nfznf5-uExSh3XTfw</a></p><h3 id="80岁还在写代码！Hello-World发明人、UNIX命名者项目登上GitHub热榜"><a href="#80岁还在写代码！Hello-World发明人、UNIX命名者项目登上GitHub热榜" class="headerlink" title="80岁还在写代码！Hello World发明人、UNIX命名者项目登上GitHub热榜"></a>80岁还在写代码！Hello World发明人、UNIX命名者项目登上GitHub热榜</h3><p><a href="https://mp.weixin.qq.com/s/9HA8a7dQ_xhT0cx4rB5FXg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/9HA8a7dQ_xhT0cx4rB5FXg</a></p><h3 id="github-copilot"><a href="#github-copilot" class="headerlink" title="github copilot"></a>github copilot</h3><p>GitHub Copilot（以下简称Copilot）是近期发布的代码智能生成插件，目前支持VSCode、JetBrains等IDE平台，不同于其他代码补全工具只提供最多一行的补全结果，Copilot能通过代码上下文以及语言描述，生成整个代码片段，无疑是开发者的编码利器。<br><a href="https://www.pc-daily.com/jichu/105890.html" target="_blank" rel="noopener">https://www.pc-daily.com/jichu/105890.html</a></p><h3 id="阿里云张伟丰：基于小芯片的计算架构正在演进成为一个大趋势"><a href="#阿里云张伟丰：基于小芯片的计算架构正在演进成为一个大趋势" class="headerlink" title="阿里云张伟丰：基于小芯片的计算架构正在演进成为一个大趋势"></a>阿里云张伟丰：基于小芯片的计算架构正在演进成为一个大趋势</h3><p><a href="https://mp.weixin.qq.com/s/PwZ4c4ezZXxMIpamuBnM0A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PwZ4c4ezZXxMIpamuBnM0A</a></p><h3 id="deepl"><a href="#deepl" class="headerlink" title="deepl"></a>deepl</h3><p><a href="https://www.deepl.com/translator" target="_blank" rel="noopener">https://www.deepl.com/translator</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;七千字详解阿里云新一代云计算体系架构-CIPU&quot;&gt;&lt;a href=&quot;#七千字详解阿里云新一代云计算体系架构-CIPU&quot; class=&quot;headerlink&quot; title=&quot;七千字详解阿里云新一代云计算体系架构 CIPU&quot;&gt;&lt;/a&gt;七千字详解阿里云新一代云计算体系架构 CIPU&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/OX4Iyu_rOekNiP9hUMzGew&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/OX4Iyu_rOekNiP9hUMzGew&lt;/a&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>perf-tools funcgraph</title>
    <link href="http://liujunming.github.io/2022/10/04/perf-tools-funcgraph/"/>
    <id>http://liujunming.github.io/2022/10/04/perf-tools-funcgraph/</id>
    <published>2022-10-04T05:18:31.000Z</published>
    <updated>2022-10-04T08:17:08.727Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何利用perf-tools的funcgraph traces a graph of kernel function calls, showing children and times。既有助于学习内核源码，也有助于debug。<a id="more"></a> </p><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><p><a href="https://github.com/brendangregg/perf-tools#prerequisites" target="_blank" rel="noopener">https://github.com/brendangregg/perf-tools#prerequisites</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://github.com/brendangregg/perf-tools#install" target="_blank" rel="noopener">https://github.com/brendangregg/perf-tools#install</a></p><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>官方文档:<a href="https://github.com/brendangregg/perf-tools/blob/master/examples/funcgraph_example.txt" target="_blank" rel="noopener">funcgraph_example.txt</a></p><p>文档值得好好研究!</p><p><img src="/images/2022/10/02.jpg" alt></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><a href="https://github.com/brendangregg/perf-tools/blob/master/kernel/funcgraph" target="_blank" rel="noopener">script</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ ./funcgraph </span><br><span class="line">USAGE: funcgraph [-aCDhHPtT] [-m maxdepth] [-p PID] [-L TID] [-d secs] funcstring</span><br><span class="line">                 -a              # all info (same as -HPt)</span><br><span class="line">                 -C              # measure on-CPU time only</span><br><span class="line">                 -d seconds      # trace duration, and use buffers</span><br><span class="line">                 -D              # do not show function duration</span><br><span class="line">                 -h              # this usage message</span><br><span class="line">                 -H              # include column headers</span><br><span class="line">                 -m maxdepth     # max stack depth to show</span><br><span class="line">                 -p PID          # trace when this pid is on-CPU</span><br><span class="line">                 -L TID          # trace when this thread is on-CPU</span><br><span class="line">                 -P              # show process names &amp; PIDs</span><br><span class="line">                 -t              # show timestamps</span><br><span class="line">                 -T              # comment function tails</span><br><span class="line">  eg,</span><br><span class="line">       funcgraph do_nanosleep    # trace do_nanosleep() and children</span><br><span class="line">       funcgraph -m 3 do_sys_open # trace do_sys_open() to 3 levels only</span><br><span class="line">       funcgraph -a do_sys_open    # include timestamps and process name</span><br><span class="line">       funcgraph -p 198 do_sys_open # trace vfs_read() for PID 198 only</span><br><span class="line">       funcgraph -d 1 do_sys_open &gt;out # trace 1 sec, then write to file</span><br><span class="line"></span><br><span class="line">See the man page and example file for more info.</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.ebpf.top/post/no_space_left_on_devices/" target="_blank" rel="noopener">eBPF+Ftrace 合璧剑指：no space left on device?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍如何利用perf-tools的funcgraph traces a graph of kernel function calls, showing children and times。既有助于学习内核源码，也有助于debug。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel task work机制</title>
    <link href="http://liujunming.github.io/2022/10/03/Linux-kernel-task-work%E6%9C%BA%E5%88%B6/"/>
    <id>http://liujunming.github.io/2022/10/03/Linux-kernel-task-work机制/</id>
    <published>2022-10-03T08:11:00.000Z</published>
    <updated>2022-10-03T11:42:28.174Z</updated>
    
    <content type="html"><![CDATA[<p>task work机制可以在内核中向指定的进程添加一些任务函数，这些任务函数会在进程返回用户态时执行，使用的是该进程的上下文。<a id="more"></a> </p><p>本文部分转载自:<a href="https://www.cnblogs.com/lailailai/p/4510982.html" target="_blank" rel="noopener">Linux:task work 机制</a>，内核代码的版本是v4.18。</p><h2 id="1-definition"><a href="#1-definition" class="headerlink" title="1. definition"></a>1. definition</h2><p>进程对象<a href="https://elixir.bootlin.com/linux/v4.18/source/include/linux/sched.h#L874" target="_blank" rel="noopener">task_struct</a>中有个字段用来存储这些待进行的任务列表头即task_works，这个结构体包含一个next指针和需要执行的函数指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct callback_head - callback structure for use with RCU and task_work</span></span><br><span class="line"><span class="comment"> * @next: next update requests in a list</span></span><br><span class="line"><span class="comment"> * @func: actual update function to call after the grace period.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> (*func)(struct callback_head *head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="2-task-work-add"><a href="#2-task-work-add" class="headerlink" title="2. task_work_add"></a>2. task_work_add</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> <span class="title">work_exited</span>;</span> <span class="comment">/* all we need is -&gt;next == NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * task_work_add - ask the @task to execute @work-&gt;func()</span></span><br><span class="line"><span class="comment"> * @task: the task which should run the callback</span></span><br><span class="line"><span class="comment"> * @work: the callback to run</span></span><br><span class="line"><span class="comment"> * @notify: send the notification if true</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Queue @work for task_work_run() below and notify the @task if @notify.</span></span><br><span class="line"><span class="comment"> * Fails if the @task is exiting/exited and thus it can't process this @work.</span></span><br><span class="line"><span class="comment"> * Otherwise @work-&gt;func() will be called when the @task returns from kernel</span></span><br><span class="line"><span class="comment"> * mode or exits.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is like the signal handler which runs in kernel mode, but it doesn't</span></span><br><span class="line"><span class="comment"> * try to wake up the @task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: there is no ordering guarantee on works queued here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURNS:</span></span><br><span class="line"><span class="comment"> * 0 if succeeds or -ESRCH.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">task_work_add(struct task_struct *task, struct callback_head *work, <span class="keyword">bool</span> notify)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">head = READ_ONCE(task-&gt;task_works);</span><br><span class="line"><span class="keyword">if</span> (unlikely(head == &amp;work_exited))</span><br><span class="line"><span class="keyword">return</span> -ESRCH;</span><br><span class="line">work-&gt;next = head;</span><br><span class="line">&#125; <span class="keyword">while</span> (cmpxchg(&amp;task-&gt;task_works, head, work) != head);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (notify)</span><br><span class="line">set_notify_resume(task);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要工作：</p><ol><li>通过CAS以无锁的形式添加了一个链表元素。（新元素排在原有链表头部）</li><li><code>set_notify_resume</code>函数向指定的进程设置了一个<code>_TIF_NOTIFY_RESUME</code>标记。</li></ol><h2 id="3-task-work-run执行时机"><a href="#3-task-work-run执行时机" class="headerlink" title="3. task_work_run执行时机"></a>3. task_work_run执行时机</h2><h3 id="3-1-with-TIF-NOTIFY-RESUME-flag"><a href="#3-1-with-TIF-NOTIFY-RESUME-flag" class="headerlink" title="3.1 with _TIF_NOTIFY_RESUME flag"></a>3.1 with <code>_TIF_NOTIFY_RESUME</code> flag</h3><h4 id="3-1-1-exit-to-usermode-loop"><a href="#3-1-1-exit-to-usermode-loop" class="headerlink" title="3.1.1 exit_to_usermode_loop"></a>3.1.1 <code>exit_to_usermode_loop</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit_to_usermode_loop</span><span class="params">(struct pt_regs *regs, u32 cached_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (cached_flags &amp; _TIF_NOTIFY_RESUME) &#123;</span><br><span class="line">                clear_thread_flag(TIF_NOTIFY_RESUME);</span><br><span class="line">                tracehook_notify_resume(regs);</span><br><span class="line">                rseq_handle_notify_resume(<span class="literal">NULL</span>, regs);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h4 id="3-1-2-tracehook-notify-resume"><a href="#3-1-2-tracehook-notify-resume" class="headerlink" title="3.1.2 tracehook_notify_resume"></a>3.1.2 <code>tracehook_notify_resume</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tracehook_notify_resume - report when about to return to user mode</span></span><br><span class="line"><span class="comment"> * @regs:user-mode registers of @current task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is called when %TIF_NOTIFY_RESUME has been set.  Now we are</span></span><br><span class="line"><span class="comment"> * about to return to user mode, and the user state in @regs can be</span></span><br><span class="line"><span class="comment"> * inspected or adjusted.  The caller in arch code has cleared</span></span><br><span class="line"><span class="comment"> * %TIF_NOTIFY_RESUME before the call.  If the flag gets set again</span></span><br><span class="line"><span class="comment"> * asynchronously, this will be called again before we return to</span></span><br><span class="line"><span class="comment"> * user mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Called without locks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tracehook_notify_resume</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The caller just cleared TIF_NOTIFY_RESUME. This barrier</span></span><br><span class="line"><span class="comment"> * pairs with task_work_add()-&gt;set_notify_resume() after</span></span><br><span class="line"><span class="comment"> * hlist_add_head(task-&gt;task_works);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">smp_mb__after_atomic();</span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;task_works))</span><br><span class="line">task_work_run();</span><br><span class="line"></span><br><span class="line">mem_cgroup_handle_over_high();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进程对象的task_works不为null的情况下才有任务需要执行。</p><h3 id="3-2-without-TIF-NOTIFY-RESUME-flag"><a href="#3-2-without-TIF-NOTIFY-RESUME-flag" class="headerlink" title="3.2 without _TIF_NOTIFY_RESUME flag"></a>3.2 without <code>_TIF_NOTIFY_RESUME</code> flag</h3><ul><li><code>get_signal</code>执行<code>task_work_run</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行task work机制中的work</span></span><br><span class="line"><span class="comment">// 这是和信号无关的机制，属于搭便车在ret_to_user时刻去执行的机制</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_signal</span><span class="params">(struct ksignal *ksig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (unlikely(current-&gt;task_works))</span><br><span class="line">task_work_run();</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-task-work-run"><a href="#4-task-work-run" class="headerlink" title="4. task_work_run"></a>4. task_work_run</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * task_work_run - execute the works added by task_work_add()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Flush the pending works. Should be used by the core kernel code.</span></span><br><span class="line"><span class="comment"> * Called before the task returns to the user-mode or stops, or when</span></span><br><span class="line"><span class="comment"> * it exits. In the latter case task_work_add() can no longer add the</span></span><br><span class="line"><span class="comment"> * new work after task_work_run() returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_work_run</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> = <span class="title">current</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">work</span>, *<span class="title">head</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * work-&gt;func() can do task_work_add(), do not set</span></span><br><span class="line"><span class="comment"> * work_exited unless the list is empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">raw_spin_lock_irq(&amp;task-&gt;pi_lock);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">work = READ_ONCE(task-&gt;task_works);</span><br><span class="line">head = !work &amp;&amp; (task-&gt;flags &amp; PF_EXITING) ?</span><br><span class="line">&amp;work_exited : <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (cmpxchg(&amp;task-&gt;task_works, work, head) != work);</span><br><span class="line">raw_spin_unlock_irq(&amp;task-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!work)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">next = work-&gt;next;</span><br><span class="line">work-&gt;func(work);</span><br><span class="line">work = next;</span><br><span class="line">cond_resched();</span><br><span class="line">&#125; <span class="keyword">while</span> (work);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过CAS，以无锁的方式取得<code>task_works</code>链表</li><li>因为原链表是按元素添加到链表的时间逆序排列的（见<code>task_work_add</code>），先把链表反转一遍</li><li>反转链表后，遍历链表，执行各个元素的任务函数即<code>work-&gt;func(work)</code></li></ol><hr><p>参考资料:</p><ol><li><a href="https://www.cnblogs.com/lailailai/p/4510982.html" target="_blank" rel="noopener">Linux:task work 机制</a></li><li><a href="https://kernel.meizu.com/linux-signal.html" target="_blank" rel="noopener">Linux Signal</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;task work机制可以在内核中向指定的进程添加一些任务函数，这些任务函数会在进程返回用户态时执行，使用的是该进程的上下文。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel preempt_notifier</title>
    <link href="http://liujunming.github.io/2022/10/03/Linux-kernel-preempt-notifier/"/>
    <id>http://liujunming.github.io/2022/10/03/Linux-kernel-preempt-notifier/</id>
    <published>2022-10-03T05:05:34.000Z</published>
    <updated>2022-10-03T07:56:11.534Z</updated>
    
    <content type="html"><![CDATA[<p>preempt_notifier本质上是一种<a href="/2019/08/06/Linux-kernel-notifier-chain/">Linux kernel notifier chain</a>，监听的事件是线程被调度出去(例如时间片用完了或者被强占)、线程被重新调度。<a id="more"></a> </p><h2 id="1-线程sched-out"><a href="#1-线程sched-out" class="headerlink" title="1. 线程sched out"></a>1. 线程sched out</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">schedule</span><br><span class="line">        __schedule</span><br><span class="line">                context_switch</span><br><span class="line">                        prepare_task_switch</span><br><span class="line">                                fire_sched_out_preempt_notifiers</span><br><span class="line">                                        __fire_sched_out_preempt_notifiers:</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__fire_sched_out_preempt_notifiers(struct task_struct *curr,</span><br><span class="line">                   struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">preempt_notifier</span> *<span class="title">notifier</span>;</span></span><br><span class="line">    <span class="comment">/*调用curr注册的notifier，通知当前线程被sched out */</span></span><br><span class="line">    hlist_for_each_entry(notifier, &amp;curr-&gt;preempt_notifiers, link)</span><br><span class="line">        notifier-&gt;ops-&gt;sched_out(notifier, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-线程sched-in"><a href="#2-线程sched-in" class="headerlink" title="2. 线程sched in"></a>2. 线程sched in</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">schedule</span><br><span class="line">        __schedule</span><br><span class="line">                context_switch</span><br><span class="line">                        finish_task_switch</span><br><span class="line">                                fire_sched_in_preempt_notifiers</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __fire_sched_in_preempt_notifiers(struct task_struct *curr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">preempt_notifier</span> *<span class="title">notifier</span>;</span></span><br><span class="line">    <span class="comment">/*通知线程sched in  */</span></span><br><span class="line">    hlist_for_each_entry(notifier, &amp;curr-&gt;preempt_notifiers, link)</span><br><span class="line">        notifier-&gt;ops-&gt;sched_in(notifier, raw_smp_processor_id());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-notifier注册"><a href="#3-notifier注册" class="headerlink" title="3. notifier注册"></a>3. notifier注册</h2><p>Linux内核提供API为当前线程注册调度notifier<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_register</span><span class="params">(struct preempt_notifier *notifier)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_unregister</span><span class="params">(struct preempt_notifier *notifier)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_inc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_dec</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * preempt_notifier_register - tell me when current is being preempted &amp; rescheduled</span></span><br><span class="line"><span class="comment"> * @notifier: notifier struct to register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_register</span><span class="params">(struct preempt_notifier *notifier)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!static_key_false(&amp;preempt_notifier_key))</span><br><span class="line">WARN(<span class="number">1</span>, <span class="string">"registering preempt_notifier while notifiers disabled\n"</span>);</span><br><span class="line"></span><br><span class="line">hlist_add_head(&amp;notifier-&gt;link, &amp;current-&gt;preempt_notifiers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-KVM-Example"><a href="#4-KVM-Example" class="headerlink" title="4. KVM Example"></a>4. KVM Example</h2><p>原始<a href="https://lore.kernel.org/kvm/1184169333786-git-send-email-avi@qumranet.com/" target="_blank" rel="noopener">patch</a></p><p><img src="/images/2022/10/01.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __read_mostly <span class="class"><span class="keyword">struct</span> <span class="title">preempt_ops</span> <span class="title">kvm_preempt_ops</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kvm_vm_ioctl_create_vcpu</span><span class="params">(struct kvm *kvm, u32 id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        preempt_notifier_init(&amp;vcpu-&gt;preempt_notifier, &amp;kvm_preempt_ops);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_init</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">unsigned</span> vcpu_size, <span class="keyword">unsigned</span> vcpu_align,</span></span></span><br><span class="line"><span class="function"><span class="params">  struct <span class="keyword">module</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        kvm_preempt_ops.sched_in = kvm_sched_in;</span><br><span class="line">        kvm_preempt_ops.sched_out = kvm_sched_out;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_sched_in</span><span class="params">(struct preempt_notifier *pn, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> = <span class="title">preempt_notifier_to_vcpu</span>(<span class="title">pn</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vcpu-&gt;preempted)</span><br><span class="line">vcpu-&gt;preempted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">kvm_arch_sched_in(vcpu, cpu);</span><br><span class="line"></span><br><span class="line">kvm_arch_vcpu_load(vcpu, cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_sched_out</span><span class="params">(struct preempt_notifier *pn,</span></span></span><br><span class="line"><span class="function"><span class="params">  struct task_struct *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> = <span class="title">preempt_notifier_to_vcpu</span>(<span class="title">pn</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current-&gt;state == TASK_RUNNING)</span><br><span class="line">vcpu-&gt;preempted = <span class="literal">true</span>;</span><br><span class="line">kvm_arch_vcpu_put(vcpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vcpu_load</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        preempt_notifier_register(&amp;vcpu-&gt;preempt_notifier);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.codenong.com/cs105341245/" target="_blank" rel="noopener">Linux内核线程实时获取调度状态的方法</a></li><li><a href="http://www.luo666.com/?p=196" target="_blank" rel="noopener">Linux 内核 schedule时的preemption notify机制</a></li><li><a href="https://elixir.bootlin.com/linux/v4.8/source/include/linux/preempt.h#L255" target="_blank" rel="noopener">Linux kernel preempt_ops</a></li><li><a href="https://lore.kernel.org/kvm/11841693333159-git-send-email-avi@qumranet.com/" target="_blank" rel="noopener">SCHED: Generic hooks for trapping task preemption</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;preempt_notifier本质上是一种&lt;a href=&quot;/2019/08/06/Linux-kernel-notifier-chain/&quot;&gt;Linux kernel notifier chain&lt;/a&gt;，监听的事件是线程被调度出去(例如时间片用完了或者被强占)、线程被重新调度。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Notes about VFIO-User</title>
    <link href="http://liujunming.github.io/2022/09/25/Notes-about-VFIO-User/"/>
    <id>http://liujunming.github.io/2022/09/25/Notes-about-VFIO-User/</id>
    <published>2022-09-25T08:42:41.000Z</published>
    <updated>2022-10-03T07:56:11.535Z</updated>
    
    <content type="html"><![CDATA[<p>本文将mark下VFIO-User相关笔记。<a id="more"></a> 建议先观看视频<a href="https://www.bilibili.com/video/BV1t44y177T3/" target="_blank" rel="noopener">刘长鹏-SPDK高性能NVMe虚拟化方案</a>。<br><img src="/images/2022/09/16.jpg" alt></p><p><a href="/pdf/SPDK VFIO-USER虚拟化方案实现介绍.pdf">SPDK VFIO-USER虚拟化方案实现介绍</a></p><p><a href="https://static.sched.com/hosted_files/kvmforum2021/6a/Johnson_Raman_Ufimtseva_Vfio-user.pdf" target="_blank" rel="noopener">VFIO-User:Remote Device Emulation using VFIO</a></p><hr><p>参考资料:</p><ol><li><a href="https://mp.weixin.qq.com/s/vMxm98bQrHhhuBIHyy0aeA" target="_blank" rel="noopener">SPDK VFIO-USER虚拟化方案实现介绍</a></li><li><a href="https://www.youtube.com/watch?v=NBT8rImx3VE" target="_blank" rel="noopener">VFIO User - Using VFIO as the IPC Protocol in Multi-process QEMU - John Johnson &amp; Jagannathan Raman</a></li><li><a href="https://www.bilibili.com/video/BV1t44y177T3/" target="_blank" rel="noopener">刘长鹏-SPDK高性能NVMe虚拟化方案</a></li><li><a href="https://github.com/nutanix/libvfio-user" target="_blank" rel="noopener">libvfio-user</a></li><li><a href="https://spdk.io/news/2021/05/04/vfio-user/" target="_blank" rel="noopener">VFIO-USER: A new virtualization protocol</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将mark下VFIO-User相关笔记。
    
    </summary>
    
      <category term="VFIO" scheme="http://liujunming.github.io/categories/VFIO/"/>
    
    
      <category term="VFIO" scheme="http://liujunming.github.io/tags/VFIO/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Intel&#39;s Linear Address Masking</title>
    <link href="http://liujunming.github.io/2022/09/12/Notes-about-Intel-s-Linear-Address-Masking/"/>
    <id>http://liujunming.github.io/2022/09/12/Notes-about-Intel-s-Linear-Address-Masking/</id>
    <published>2022-09-12T13:35:56.000Z</published>
    <updated>2022-09-12T14:37:40.988Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about Intel’s Linear Address Masking(LAM).<a id="more"></a> </p><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><p>A 64-bit pointer can address a lot of memory — far more than just about any application could ever need. As a result, there are bits within that pointer that are not really needed to address memory, and which might be put to other needs. Storing a few bits of metadata within a pointer is a common enough use case.</p><h3 id="2-Motivation"><a href="#2-Motivation" class="headerlink" title="2. Motivation"></a>2. Motivation</h3><p>In Intel CPU, 假设使用64 bit pointer(虚拟地址)的57位到62位存放metadata，当想要<a href="https://stackoverflow.com/questions/4955198/what-does-dereferencing-a-pointer-mean" target="_blank" rel="noopener">dereferencing a pointer</a>时：</p><ul><li>Without LAM，软件需要显示地unmask掉pointer的57位到62位，说白了，每次dereferencing时，软件都需要做一个<code>与</code>操作</li><li>With LAM，软件无需unmask掉pointer的57位到62位，硬件直接完成unmask的功能，这样，每次dereferencing时，软件无需<code>与</code>操作了</li></ul><p>通俗地说，LAM的作用是将软件unmask pointer meatadata的功能offload到硬件上了。</p><h3 id="3-Details"><a href="#3-Details" class="headerlink" title="3. Details"></a>3. Details</h3><p>Intel’s LAM feature offers two modes:</p><ul><li><code>LAM_U57</code> allows six bits of metadata in bits 62 to 57.</li><li><code>LAM_U48</code> allows 15 bits of metadata in bits 62 to 48.</li></ul><h4 id="3-1-Why-not-use-bit-64-as-metadata"><a href="#3-1-Why-not-use-bit-64-as-metadata" class="headerlink" title="3.1 Why not use bit 64 as metadata"></a>3.1 Why not use bit 64 as metadata</h4><p>可以带着这个问题去<a href="https://lwn.net/Articles/902094/" target="_blank" rel="noopener">Support for Intel’s Linear Address Masking</a>中寻找答案。</p><h4 id="3-2-LAM-U48与five-level-page-tables的配合使用"><a href="#3-2-LAM-U48与five-level-page-tables的配合使用" class="headerlink" title="3.2 LAM_U48与five-level page tables的配合使用"></a>3.2 <code>LAM_U48</code>与five-level page tables的配合使用</h4><p>说白了，五级页表会使用到<code>LAM_U48</code>中的bit 48到56，因而可能会产生冲突。如何解决这个冲突呢？可以带着这个问题去<a href="https://lwn.net/Articles/902094/" target="_blank" rel="noopener">Support for Intel’s Linear Address Masking</a>中寻找答案。</p><hr><p>参考资料:</p><ol><li><a href="https://lwn.net/Articles/902094/" target="_blank" rel="noopener">Support for Intel’s Linear Address Masking</a></li><li><a href="https://mp.weixin.qq.com/s/xnEGKub5iGacr76tsNhSHg" target="_blank" rel="noopener">LWN：支持Intel线性地址屏蔽功能！</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about Intel’s Linear Address Masking(LAM).
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Injection Exitless LAPIC Timer</title>
    <link href="http://liujunming.github.io/2022/09/11/LAPIC-Implement-Exitless-Timer/"/>
    <id>http://liujunming.github.io/2022/09/11/LAPIC-Implement-Exitless-Timer/</id>
    <published>2022-09-11T03:56:04.000Z</published>
    <updated>2022-09-12T11:14:31.684Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2022/09/13.jpg" alt></p><p><img src="/images/2022/09/14.jpg" alt></p><p><img src="/images/2022/09/15.jpg" alt><br><a id="more"></a><br>建议先阅读<a href="/2022/09/06/Linux中的tick模式/">Linux中的tick模式</a>和<a href="/2022/09/07/isolated-CPU-vs-housekeeping-CPU/">isolated CPU vs housekeeping CPU</a>。</p><p>Dedicated instances are currently disturbed by unnecessary jitter due  to the emulated lapic timers fire on the same pCPUs which vCPUs resident. There is no hardware virtual timer on Intel for guest like ARM. Both  programming timer in guest and the emulated timer fires incur vmexits. This patchset tries to avoid vmexit which is incurred by the emulated  timer fires in dedicated instance scenario. </p><p>When nohz_full is enabled in dedicated instances scenario, the unpinned  timer will be moved to the nearest busy housekeepers after commit 9642d18eee2cd (nohz: Affine unpinned timers to housekeepers) and commit  444969223c8 (“sched/nohz: Fix affine unpinned timers mess”). However, KVM always makes lapic timer pinned to the pCPU which vCPU residents, the reason is explained by commit 61abdbe0 (kvm: x86: make lapic hrtimer pinned). Actually, these emulated timers can be offload to the housekeeping cpus since APICv is really common in recent years. The guest timer interrupt is injected by posted-interrupt which is delivered by housekeeping cpu once the emulated timer fires. </p><p>The host admin should fine tuned, e.g. dedicated instances scenario w/ nohz_full cover the pCPUs which vCPUs resident, several pCPUs surplus for busy housekeeping, disable mwait/hlt/pause vmexits to keep in non-root mode, ~3% redis performance benefit can be observed on Skylake server.</p><hr><p>参考资料:</p><ol><li><a href="https://lore.kernel.org/all/1562376411-3533-1-git-send-email-wanpengli@tencent.com/" target="_blank" rel="noopener">KVM: LAPIC: Implement Exitless Timer</a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/10/01/kvm-performance-2" target="_blank" rel="noopener">Exitless timer</a></li><li><a href="https://static.sched.com/hosted_files/kvmforum2019/e3/Boosting%20Dedicated%20Instances%20by%20KVM%20Tax%20Cut.pdf" target="_blank" rel="noopener">Boosting Dedicated Instance via KVM Tax Cut</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2022/09/13.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2022/09/14.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2022/09/15.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>isolated CPU vs housekeeping CPU</title>
    <link href="http://liujunming.github.io/2022/09/07/isolated-CPU-vs-housekeeping-CPU/"/>
    <id>http://liujunming.github.io/2022/09/07/isolated-CPU-vs-housekeeping-CPU/</id>
    <published>2022-09-07T03:47:39.000Z</published>
    <updated>2022-09-12T11:14:31.684Z</updated>
    
    <content type="html"><![CDATA[<p>An isolated CPU incurs reduced jitter and reduced interruptions by  the  kernel. <a id="more"></a> This  is achived   by   clearing  the  CPU  from  user-space  processes,  movable  kernel  threads, interruption handlers, kernel timers, etc. The only fixed source of interruptions  is  the 1Hz  tick  maintained  by the kernel to keep CPU usage statistics. Otherwise, the incurred jitter and interruptions, if any, depend on the kernel services used by the thread running on  the  isolated  CPU.  Threads  that run a busy loop without doing system calls, such as user-space drivers that access the hardware directly, are only expected to be  interrupted once a second by the 1Hz tick.</p><p>A  housekeeping CPU is the opposite of an isolated CPU. Housekeeping CPUs run all daemons, shell processes, kernel threads, interruption handlers and work  that  can  be  dispatched from isolated CPUs such as disk I/O, RCU work, timers, etc.</p><hr><p>参考资料;</p><ol><li><a href="https://manpages.ubuntu.com/manpages/focal/en/man7/tuned-profiles-cpu-partitioning.7.html" target="_blank" rel="noopener">tuned-profiles-cpu-partitioning</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;An isolated CPU incurs reduced jitter and reduced interruptions by  the  kernel.
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的tick模式</title>
    <link href="http://liujunming.github.io/2022/09/06/Linux%E4%B8%AD%E7%9A%84tick%E6%A8%A1%E5%BC%8F/"/>
    <id>http://liujunming.github.io/2022/09/06/Linux中的tick模式/</id>
    <published>2022-09-06T02:14:19.000Z</published>
    <updated>2022-09-12T11:14:31.684Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<br>Linux中的tick模式 - 兰新宇的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/133211285" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/133211285</a><a id="more"></a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>tick就是周期性的时钟中断，作为OS的心跳，它可以驱动scheduler运转，并且统计相关的运行信息（比如”utime”和”stime”的计算）。<br><img src="/images/2022/09/08.jpg" alt></p><p>根据硬件频率的不同，tick发生的间隔有所不同，比如x86支持100 Hz, 250 Hz和1000 Hz，则对应的间隔分别是10ms, 4ms和1ms。具体选用的数值可通过<code>grep CONFIG_HZ /boot/config-$(uname -r)</code>命令查看。<br><img src="/images/2022/09/09.jpg" alt></p><p>从系统开始启动后经过的ticks被记作”jiffies”，每发生一次时钟中断，jiffies的数值就加上1。<br><img src="/images/2022/09/10.jpg" alt></p><h3 id="dyntick-idle-模式"><a href="#dyntick-idle-模式" class="headerlink" title="dyntick-idle 模式"></a>dyntick-idle 模式</h3><p>当CPU进入idle低功耗模式时，其实是不希望被tick打断的。为此，自2007年的2.6.21版本，可通过<code>CONFIG_NO_HZ_IDLE</code>配置选项（曾用名<code>CONFIG_NO_HZ</code>），于idle模式时关闭tick（不需要HZ）。<br><img src="/images/2022/09/11.jpg" alt></p><p>这种方式有很多种叫法，主流的是”dyntick-idle”，其他还有”nohz”啦，”tickless”啦等等。其带来的收益是功耗的减少，付出的代价则是进入和退出dyntick-idle模式的指令开销，以及需重新填充clock相关的寄存器信息等。<br><img src="/images/2022/09/12.jpg" alt></p><p>除非workload中idle的次数少、时间短，或者不在乎功耗，又对延迟敏感，否则对于大多数场景来说，dyntick-idle的使用都是利大于弊的，因此是目前内核默认采用的tick模式。</p><h3 id="adaptive-ticks-模式"><a href="#adaptive-ticks-模式" class="headerlink" title="adaptive-ticks 模式"></a>adaptive-ticks 模式</h3><p>更进一步，如果一个CPU上只有一个runnable的任务，同样也是不需要tick的。这种需求在2013年的3.10版本被支持，称为”adaptive-ticks”模式，对应的配置选项为<code>CONFIG_NO_HZ_FULL</code>，”full”可理解为1个task在一段时间内完全地占有一个CPU。</p><p>对于需要开启这项功能的CPU，应在内核启动参数中设置，比如<code>nohz_full=1,6-8</code>，就表明CPU 1, 6, 7, 8是adaptive-ticks的，系统运行后不可再动态更改（想更改只能reboot）。</p><p>但要注意的是，即便系统的每个CPU上都只有一个runnable的任务，也不能把全部CPU都设为nohz full模式。这是因为对于处在adaptive-ticks状态的CPU，还是存在任务运行，还是需要使用jiffies或者walltime，因此系统应该至少保留一个CPU来承担timekeeping的工作，被选择作为timekeeper的是负责boot的那个CPU。</p><p>一旦CPU上有新的任务加入进来，那么就又需要tick了，只有一个任务运行的限制似乎显得有些理想化。不过，在一些高性能计算和realtime的场景中，将一个CPU单独拿给一个线程用是完全可能的（就连现在的手机不也动辄都是4核8核么）。</p><p>此外，一个CPU上虽然有多个runnable的任务，但包含的是一个高优先级的SCHED_FIFO任务和多个低优先级的SCHED_OTHER任务，除非这个SCHED_FIFO的任务block，否则它会一直运行，这种情况其实也可以不使用tick。还有就是任务获得的timeslice比较长，也可以考虑在这段时间内暂时关闭tick。</p><p>“dyntick-idle”模式需额外付出的effort对”adaptive-ticks”模式也是存在的，而后者还有一些其他方面的问题。当CPU上唯一runnable的线程从用户态进入内核态执行后，并不会发生task切换，依然满足adaptive-ticks的条件，这就对线程”utime”和”stime”的统计造成了困难。目前，”nohz full”的配置默认是关闭的。</p><hr><p>参考资料:</p><ol><li><a href="https://blog.linuxplumbersconf.org/2013/ocw/system/presentations/1143/original/dynticks-lpc.pdf" target="_blank" rel="noopener">Status of Linux dynticks</a></li><li><a href="https://lwn.net/Articles/549580/" target="_blank" rel="noopener">(Nearly) full tickless operation in 3.10</a></li><li><a href="https://www.kernel.org/doc/Documentation/timers/NO_HZ.txt" target="_blank" rel="noopener">Documentation/timers/NO_HZ.txt</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;br&gt;Linux中的tick模式 - 兰新宇的文章 - 知乎&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/133211285&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/133211285&lt;/a&gt;
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>The relationship between LAPIC timer and TSC</title>
    <link href="http://liujunming.github.io/2022/09/05/The-relationship-between-LAPIC-timer-and-TSC/"/>
    <id>http://liujunming.github.io/2022/09/05/The-relationship-between-LAPIC-timer-and-TSC/</id>
    <published>2022-09-05T11:59:35.000Z</published>
    <updated>2022-09-05T13:20:15.236Z</updated>
    
    <content type="html"><![CDATA[<p>LAPIC timer支持三种mode，TSC是其中的一种mode。<br><a id="more"></a><br><img src="/images/2022/09/05.jpg" alt></p><p><img src="/images/2022/09/06.jpg" alt></p><p><img src="/images/2022/09/07.jpg" alt></p><hr><p>参考资料:</p><ol><li><a href="https://lzz5235.github.io/2016/01/09/apic-timer.html" target="_blank" rel="noopener">浅谈APIC timer</a></li><li><a href="https://wiki.osdev.org/APIC_timer" target="_blank" rel="noopener">APIC timer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LAPIC timer支持三种mode，TSC是其中的一种mode。&lt;br&gt;
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>Notes about ktime accessors</title>
    <link href="http://liujunming.github.io/2022/09/04/Notes-about-ktime-accessors/"/>
    <id>http://liujunming.github.io/2022/09/04/Notes-about-ktime-accessors/</id>
    <published>2022-09-04T02:54:46.000Z</published>
    <updated>2022-09-04T03:00:56.010Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://elixir.bootlin.com/linux/v5.19/source/include/linux/timekeeping.h" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.19/source/include/linux/timekeeping.h</a></p><p><a href="https://www.kernel.org/doc/html/latest/core-api/timekeeping.html" target="_blank" rel="noopener">https://www.kernel.org/doc/html/latest/core-api/timekeeping.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://elixir.bootlin.com/linux/v5.19/source/include/linux/timekeeping.h&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://elixir.bootlin
      
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>How Linux userspace programs get time information</title>
    <link href="http://liujunming.github.io/2022/09/03/How-Linux-userspace-program-get-time-information/"/>
    <id>http://liujunming.github.io/2022/09/03/How-Linux-userspace-program-get-time-information/</id>
    <published>2022-09-03T03:43:30.000Z</published>
    <updated>2022-09-04T10:24:14.706Z</updated>
    
    <content type="html"><![CDATA[<p>本文将汇总Linux用户态程序获取时间的接口，本文内容主要转载自<a href="https://www.cnblogs.com/krythur/archive/2013/02/25/2932647.html?spm=a2c6h.12873639.article-detail.5.50a91861j79vJU" target="_blank" rel="noopener">clock()、time()、clock_gettime()和gettimeofday()函数的用法和区别</a>。<a id="more"></a></p><h3 id="1-clock"><a href="#1-clock" class="headerlink" title="1. clock()"></a>1. clock()</h3><p><a href="https://man7.org/linux/man-pages/man3/clock.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/clock.3.html</a></p><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p><code>clock</code>函数的返回值类型是<code>clock_t</code>,它除以<code>CLOCKS_PER_SEC</code>来得出时间,一般用两次<code>clock</code>函数来计算进程自身运行的时间.</p><p><code>clock</code>有三个问题:</p><ol><li>如果超过一个小时,将要导致溢出.</li><li>函数<code>clock</code>没有考虑CPU被子进程使用的情况.</li><li>也不能区分用户空间和内核空间.</li></ol><p>所以<code>clock</code>函数在linux系统上变得没有意义.</p><h4 id="1-2-测试"><a href="#1-2-测试" class="headerlink" title="1.2 测试"></a>1.2 测试</h4><p>编写程序,测试采用<code>clock</code>函数的输出与<code>time</code>程序的区别.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> i=<span class="number">1000L</span>;</span><br><span class="line">   <span class="keyword">clock_t</span> start, finish;</span><br><span class="line">   <span class="keyword">double</span>  duration;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Time to do %ld empty loops is "</span>, i );</span><br><span class="line">   start = clock();</span><br><span class="line">   <span class="keyword">while</span> (--i)&#123;</span><br><span class="line">    system(<span class="string">"cd"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   finish = clock();</span><br><span class="line">   duration = (<span class="keyword">double</span>)(finish - start) / CLOCKS_PER_SEC;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"%f seconds\n"</span>, duration );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test1.c -o test1</span><br><span class="line">$ time ./test1</span><br><span class="line">Time to do 1000 empty loops is 0.180000 seconds</span><br><span class="line"></span><br><span class="line">real    0m3.492s</span><br><span class="line">user    0m0.512s</span><br><span class="line">sys     0m2.972s</span><br></pre></td></tr></table></figure><h4 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h4><ol><li>程序调用<code>system(&quot;cd&quot;)</code>，这里主要是子进程的消耗,test1程序不能体现这一点.</li><li>0.180000 seconds秒的消耗是两次<code>clock()</code>函数调用除以<code>CLOCKS_PER_SEC</code>.</li><li><code>clock()</code>函数返回值是一个相对时间，而不是绝对时间.</li><li><code>CLOCKS_PER_SEC</code>是系统定义的宏，由GNU标准库定义为1000000.</li></ol><h3 id="2-times"><a href="#2-times" class="headerlink" title="2. times()"></a>2. times()</h3><p><a href="https://man7.org/linux/man-pages/man2/times.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/times.2.html</a></p><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>原型如下：<br><code>clock_t times(struct tms *buf);</code></p><p>tms结构体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span>&#123;</span></span><br><span class="line"> <span class="keyword">clock_t</span> tms_utime;</span><br><span class="line"> <span class="keyword">clock_t</span> tms_stime;</span><br><span class="line"> <span class="keyword">clock_t</span> tms_cutime;</span><br><span class="line"> <span class="keyword">clock_t</span> tms_cstime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>tms_utime</code>记录的是进程执行用户代码的时间.<br><code>tms_stime</code>记录的是进程执行内核代码的时间.<br><code>tms_cutime</code>记录的是子进程执行用户代码的时间.<br><code>tms_cstime</code>记录的是子进程执行内核代码的时间.</p><h4 id="2-2-测试"><a href="#2-2-测试" class="headerlink" title="2.2 测试"></a>2.2 测试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_cmd</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pr_times</span><span class="params">(<span class="keyword">clock_t</span>, struct tms *, struct tms *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; argv[i]!=<span class="literal">NULL</span>; i++)&#123;</span><br><span class="line">                do_cmd(argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_cmd</span><span class="params">(<span class="keyword">char</span> *cmd)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">tmsstart</span>, <span class="title">tmsend</span>;</span></span><br><span class="line">        <span class="keyword">clock_t</span> start, end;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">if</span>((start=times(&amp;tmsstart))== <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"times error"</span>);</span><br><span class="line">        <span class="keyword">if</span>((status=system(cmd))&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"system error"</span>);</span><br><span class="line">        <span class="keyword">if</span>((end=times(&amp;tmsend))== <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"times error"</span>);</span><br><span class="line">        pr_times(end-start, &amp;tmsstart, &amp;tmsend);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pr_times</span><span class="params">(<span class="keyword">clock_t</span> real, struct tms *tmsstart, struct tms *tmsend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">long</span> clktck=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == clktck)</span><br><span class="line">                <span class="keyword">if</span>((clktck=sysconf(_SC_CLK_TCK))&lt;<span class="number">0</span>)</span><br><span class="line">                           <span class="built_in">puts</span>(<span class="string">"sysconf err"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"real:%7.2f\n"</span>, real/(<span class="keyword">double</span>)clktck);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"user-cpu:%7.2f\n"</span>, (tmsend-&gt;tms_utime - tmsstart-&gt;tms_utime)/(<span class="keyword">double</span>)clktck);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"system-cpu:%7.2f\n"</span>, (tmsend-&gt;tms_stime - tmsstart-&gt;tms_stime)/(<span class="keyword">double</span>)clktck);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child-user-cpu:%7.2f\n"</span>, (tmsend-&gt;tms_cutime - tmsstart-&gt;tms_cutime)/(<span class="keyword">double</span>)clktck);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child-system-cpu:%7.2f\n"</span>, (tmsend-&gt;tms_cstime - tmsstart-&gt;tms_cstime)/(<span class="keyword">double</span>)clktck);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test2.c -o test2</span><br><span class="line">$ time ./test2 &quot;dd if=/dev/zero f=/dev/null bs=1M count=10000&quot;</span><br><span class="line">10000+0 records in</span><br><span class="line">10000+0 records out</span><br><span class="line">10485760000 bytes (10 GB) copied, 4.93028 s, 2.1 GB/s</span><br><span class="line">real:   4.94</span><br><span class="line">user-cpu:   0.00</span><br><span class="line">system-cpu:   0.00</span><br><span class="line">child-user-cpu:   0.01</span><br><span class="line">child-system-cpu:   4.82</span><br><span class="line"></span><br><span class="line">real    0m4.943s</span><br><span class="line">user    0m0.016s</span><br><span class="line">sys     0m4.828s</span><br></pre></td></tr></table></figure><h4 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h4><ol><li>通过这个测试,系统的<code>time</code>程序与test2程序输出基本一致了.</li><li><code>(double)clktck</code>是通过<code>clktck=sysconf(_SC_CLK_TCK)</code>来取的,也就是要得到user-cpu所占用的时间,就要用<code>(tmsend-&gt;tms_utime - tmsstart-&gt;tms_utime)/(double)clktck)</code></li><li><code>clock_t times(struct tms *buf)</code>返回值是过去一段时间内时钟嘀嗒的次数.</li><li><code>times()</code>函数返回值也是一个相对时间.</li></ol><h3 id="3-gettimeofday"><a href="#3-gettimeofday" class="headerlink" title="3. gettimeofday()"></a>3. gettimeofday()</h3><p><a href="https://man7.org/linux/man-pages/man2/gettimeofday.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/gettimeofday.2.html</a></p><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p><code>gettimeofday()</code>可以获得当前系统的时间,是一个绝对值</p><p>原型如下：<br><code>int gettimeofday (struct timeval * tv , struct timezone * tz)</code></p><p><code>timeval</code>结型体的原型如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">               <span class="keyword">time_t</span>      tv_sec;    </span><br><span class="line">               <span class="keyword">suseconds_t</span> tv_usec;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>所以它可以精确到微秒</p><h4 id="3-2-测试"><a href="#3-2-测试" class="headerlink" title="3.2 测试"></a>3.2 测试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main()&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">10000000</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tvs</span>,<span class="title">tve</span>;</span></span><br><span class="line">        gettimeofday(&amp;tvs,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span> (--i);</span><br><span class="line">        gettimeofday(&amp;tve,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">double</span> span = tve.tv_sec-tvs.tv_sec + (tve.tv_usec-tvs.tv_usec)/<span class="number">1000000.0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"time: %.12f\n"</span>,span);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test5.c</span><br><span class="line">$ ./a.out</span><br><span class="line">time: 0.041239000000</span><br></pre></td></tr></table></figure><h3 id="4-clock-gettime"><a href="#4-clock-gettime" class="headerlink" title="4. clock_gettime()"></a>4. clock_gettime()</h3><p><a href="https://www.man7.org/linux/man-pages/man3/clock_gettime.3.html" target="_blank" rel="noopener">https://www.man7.org/linux/man-pages/man3/clock_gettime.3.html</a></p><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>原型如下：<br><code>int clock_gettime(clockid_t clk_id, struct timespec *tp);</code></p><p>有以下特点:</p><ol><li><p>有一个时间结构体:<code>timespec</code>,<code>timespec</code>计算时间的精度是ns.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>&#123;</span></span><br><span class="line">        <span class="keyword">time_t</span> tv_sec;</span><br><span class="line">        <span class="keyword">long</span> tv_nsec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>clockid_t</code>确定哪个时钟类型.<br><code>CLOCK_REALTIME</code><br><img src="/images/2022/09/02.jpg" alt><br><code>CLOCK_MONOTONIC</code><br><img src="/images/2022/09/03.jpg" alt><br><code>CLOCK_PROCESS_CPUTIME_ID</code>和<code>CLOCK_THREAD_CPUTIME_ID</code>.<br><img src="/images/2022/09/04.jpg" alt></p></li></ol><h4 id="4-2-测试"><a href="#4-2-测试" class="headerlink" title="4.2 测试:"></a>4.2 测试:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MILLION 1000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">int</span> loop = <span class="number">1000</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tpstart</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tpend</span>;</span></span><br><span class="line">        <span class="keyword">long</span> timedif;</span><br><span class="line"></span><br><span class="line">        clock_gettime(CLOCK_MONOTONIC, &amp;tpstart);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (--loop)&#123;</span><br><span class="line">                system(<span class="string">"cd"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        clock_gettime(CLOCK_MONOTONIC, &amp;tpend);</span><br><span class="line">        timedif = MILLION*(tpend.tv_sec-tpstart.tv_sec)+(tpend.tv_nsec-tpstart.tv_nsec)/<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"it took %ld microseconds\n"</span>, timedif);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test3.c -lrt -o test3</span><br><span class="line"></span><br><span class="line">$ time ./test3</span><br><span class="line">it took 3463843 microseconds</span><br><span class="line"></span><br><span class="line">real    0m3.467s</span><br><span class="line">user    0m0.512s</span><br><span class="line">sys     0m2.936s</span><br></pre></td></tr></table></figure><h3 id="5-比较"><a href="#5-比较" class="headerlink" title="5. 比较"></a>5. 比较</h3><h4 id="5-1-精度"><a href="#5-1-精度" class="headerlink" title="5.1 精度"></a>5.1 精度</h4><ul><li><code>clock()</code>的精度是10毫秒(ms)</li><li><code>times()</code>的精度是10毫秒(ms)</li><li><code>gettimofday()</code>的精度是微秒(μs)</li><li><code>clock_gettime()</code>的精度是纳秒(ns)</li></ul><h4 id="5-2-测试"><a href="#5-2-测试" class="headerlink" title="5.2 测试"></a>5.2 测试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WAIT for(i=0;i&lt;298765432;i++);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MILLION    1000000</span></span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">main ( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> ttt;</span><br><span class="line">    <span class="keyword">clock_t</span> s,e;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">aaa</span>;</span></span><br><span class="line"></span><br><span class="line">    s=clock();</span><br><span class="line">    WAIT;</span><br><span class="line">    e=clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"clock time : %.12f\n"</span>,(e-s)/(<span class="keyword">double</span>)CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> tps = sysconf(_SC_CLK_TCK);</span><br><span class="line">    s=times(&amp;aaa);</span><br><span class="line">    WAIT;</span><br><span class="line">    e=times(&amp;aaa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"times time : %.12f\n"</span>,(e-s)/(<span class="keyword">double</span>)tps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tvs</span>,<span class="title">tve</span>;</span></span><br><span class="line">    gettimeofday(&amp;tvs,<span class="literal">NULL</span>);</span><br><span class="line">    WAIT;</span><br><span class="line">    gettimeofday(&amp;tve,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">double</span> span = tve.tv_sec-tvs.tv_sec + (tve.tv_usec-tvs.tv_usec)/<span class="number">1000000.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"gettimeofday time: %.12f\n"</span>,span);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tpstart</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tpend</span>;</span></span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;tpstart);</span><br><span class="line">    WAIT;</span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;tpend);</span><br><span class="line">    <span class="keyword">double</span> timedif = (tpend.tv_sec-tpstart.tv_sec)+(tpend.tv_nsec-tpstart.tv_nsec)/<span class="number">1000000000.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"clock_gettime time: %.12f\n"</span>, timedif);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -lrt test4.c -o test4</span><br><span class="line">$ ./test4</span><br><span class="line">clock time : 1.190000000000</span><br><span class="line">times time : 1.180000000000</span><br><span class="line">gettimeofday time: 1.186477000000</span><br><span class="line">clock_gettime time: 1.179271718000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将汇总Linux用户态程序获取时间的接口，本文内容主要转载自&lt;a href=&quot;https://www.cnblogs.com/krythur/archive/2013/02/25/2932647.html?spm=a2c6h.12873639.article-detail.5.50a91861j79vJU&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clock()、time()、clock_gettime()和gettimeofday()函数的用法和区别&lt;/a&gt;。
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Notes about IVT(Interrupt Vector Table)</title>
    <link href="http://liujunming.github.io/2022/09/02/Notes-about-IVT-Interrupt-Vector-Table/"/>
    <id>http://liujunming.github.io/2022/09/02/Notes-about-IVT-Interrupt-Vector-Table/</id>
    <published>2022-09-02T03:44:18.000Z</published>
    <updated>2022-09-03T04:15:28.015Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录IVT(Interrupt Vector Table)相关笔记。<a id="more"></a></p><h3 id="1-What"><a href="#1-What" class="headerlink" title="1. What"></a>1. What</h3><p>On the x86 architecture, the Interrupt Vector Table (IVT) is a table that specifies the addresses of all the 256 interrupt handlers used in real mode.</p><h3 id="2-IVT-vs-IDT"><a href="#2-IVT-vs-IDT" class="headerlink" title="2. IVT vs IDT"></a>2. IVT vs IDT</h3><p>In the real addressing mode the structure just contains addresses of ISRs. This format of it is known as IVT. In the protected mode the structure is more complex and is called IDT. The CPU manual from Intel or AMD will tell you all the details about interrupt handling.</p><p>Modern OSes operate almost fully in protected mode and hence use the IDT. The IVT is only necessary when the OS boots, because that happens in real mode.</p><h3 id="3-Usage"><a href="#3-Usage" class="headerlink" title="3. Usage"></a>3. Usage</h3><p>To access a BIOS function, you generally set the AH CPU register (or AX, or EAX) to a particular value, and then do an INT opcode. The value in AH (or AX, or EAX), combined with the particular interrupt number selected requests a specific BIOS function.</p><p>It is simplest to create a listing of BIOS functions by specifying the interrupt number, and the value of AH (or AX, or EAX) that selects the function. It is also easiest to refer to particular BIOS functions this way in discussions. For example, INT 0x13, AH=0 is a BIOS function that resets hard disks or floppy disks.</p><p>To an extent, the BIOS functions are organized by interrupt number:</p><ul><li>INT 0x10 = Video display functions (including VESA/VBE)</li><li>INT 0x13 = mass storage (disk, floppy) access</li><li>INT 0x15 = memory size functions</li><li>INT 0x16 = keyboard functions</li></ul><h4 id="3-1-Common-functions"><a href="#3-1-Common-functions" class="headerlink" title="3.1 Common functions"></a>3.1 Common functions</h4><p><img src="/images/2022/09/01.jpg" alt></p><h4 id="3-2-e820"><a href="#3-2-e820" class="headerlink" title="3.2 e820"></a>3.2 e820</h4><p><strong>BIOS Function: INT 0x15, EAX = 0xE820</strong></p><p><a href="/2019/12/15/从硬件获得内存布局-e820/">从硬件获得内存布局–e820</a></p><hr><p>参考资料:</p><ol><li><a href="https://wiki.osdev.org/IVT" target="_blank" rel="noopener">osdev IVT</a></li><li><a href="https://wiki.osdev.org/BIOS" target="_blank" rel="noopener">osdev BIOS</a></li><li><a href="https://stackoverflow.com/questions/11540095/what-is-the-difference-between-ivt-and-idt" target="_blank" rel="noopener">what is the difference between IVT and IDT?</a></li><li><a href="https://wiki.osdev.org/Detecting_Memory_(x86)" target="_blank" rel="noopener">https://wiki.osdev.org/Detecting_Memory_(x86)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录IVT(Interrupt Vector Table)相关笔记。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>RTC virtualization in QEMU</title>
    <link href="http://liujunming.github.io/2022/08/27/RTC-virtualization-in-QEMU/"/>
    <id>http://liujunming.github.io/2022/08/27/RTC-virtualization-in-QEMU/</id>
    <published>2022-08-27T12:05:29.000Z</published>
    <updated>2022-09-03T07:58:45.844Z</updated>
    
    <content type="html"><![CDATA[<p>本文将结合<a href="https://github.com/qemu/qemu/commits/stable-5.0" target="_blank" rel="noopener">QEMU</a>代码，解析RTC虚拟化。<a id="more"></a>一些细节作者也没有捋清楚，待日后更新吧。</p><h2 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h2><ul><li>读者需对<a href="/2020/05/02/深入理解RTC/">RTC</a>有一定的了解<ul><li>往PIO 0x70写入0x00后，从PIO 0x71寄存器中读到的就是当前的秒数</li><li>往PIO 0x70写入0x02后，从PIO 0x71寄存器中读到的就是当前的分钟数</li><li>往PIO 0x70写入0x04后，从PIO 0x71寄存器中读到的就是当前的小时数<br><img src="/images/2022/07/12.jpg" alt></li></ul></li><li><a href="/2021/10/19/PIO-virtualization-in-QEMU-KVM/">PIO virtualization in QEMU/KVM</a></li></ul><h2 id="2-How-to-use-RTC-in-QEMU"><a href="#2-How-to-use-RTC-in-QEMU" class="headerlink" title="2. How to use RTC in QEMU"></a>2. How to use RTC in QEMU</h2><h3 id="2-1-QEMU-document"><a href="#2-1-QEMU-document" class="headerlink" title="2.1 QEMU document"></a>2.1 QEMU document</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">``-rtc [base=utc|localtime|datetime][,clock=host|rt|vm][,driftfix=none|slew]``</span><br><span class="line">    Specify ``base`` as ``utc`` or ``localtime`` to let the RTC start at</span><br><span class="line">    the current UTC or local time, respectively. ``localtime`` is</span><br><span class="line">    required for correct date in MS-DOS or Windows. To start at a</span><br><span class="line">    specific point in time, provide datetime in the format</span><br><span class="line">    ``2006-06-17T16:01:21`` or ``2006-06-17``. The default base is UTC.</span><br><span class="line"></span><br><span class="line">    By default the RTC is driven by the host system time. This allows</span><br><span class="line">    using of the RTC as accurate reference clock inside the guest,</span><br><span class="line">    specifically if the host time is smoothly following an accurate</span><br><span class="line">    external reference clock, e.g. via NTP. If you want to isolate the</span><br><span class="line">    guest time from the host, you can set ``clock`` to ``rt`` instead,</span><br><span class="line">    which provides a host monotonic clock if host support it. To even</span><br><span class="line">    prevent the RTC from progressing during suspension, you can set</span><br><span class="line">    ``clock`` to ``vm`` (virtual clock). &apos;\ ``clock=vm``\ &apos; is</span><br><span class="line">    recommended especially in icount mode in order to preserve</span><br><span class="line">    determinism; however, note that in icount mode the speed of the</span><br><span class="line">    virtual clock is variable and can in general differ from the host</span><br><span class="line">    clock.</span><br><span class="line"></span><br><span class="line">    Enable ``driftfix`` (i386 targets only) if you experience time drift</span><br><span class="line">    problems, specifically with Windows&apos; ACPI HAL. This option will try</span><br><span class="line">    to figure out how many timer interrupts were not processed by the</span><br><span class="line">    Windows guest and will re-inject them.</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time" target="_blank" rel="noopener">UTC</a> is the primary time standard by which the world regulates clocks and time.</p></li><li><p><strong>system time</strong> vs <strong>monotonic clock</strong><br><a href="https://en.wikipedia.org/wiki/Network_Time_Protocol" target="_blank" rel="noopener">NTP</a><br>system time:<br><img src="/images/2022/09/02.jpg" alt><br>monotonic clock:<br><img src="/images/2022/09/03.jpg" alt></p></li></ul><ul><li><p>与<code>clock=rt</code>相比，<code>clock=vm</code>增加了一个新的特性:当guest suspend的时候，RTC暂停计时</p></li><li><p>icount: instruction counter</p></li><li><p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/windows-kernel-mode-hal-library" target="_blank" rel="noopener">HAL(Hardware Abstraction Layers)</a></p></li></ul><h3 id="2-2-QEMUClockType"><a href="#2-2-QEMUClockType" class="headerlink" title="2.2 QEMUClockType"></a>2.2 QEMUClockType</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * QEMUClockType:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following clock types are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @QEMU_CLOCK_REALTIME: Real time clock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The real time clock should be used only for stuff which does not</span></span><br><span class="line"><span class="comment"> * change the virtual machine state, as it runs even if the virtual</span></span><br><span class="line"><span class="comment"> * machine is stopped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @QEMU_CLOCK_VIRTUAL: virtual clock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The virtual clock only runs during the emulation. It stops</span></span><br><span class="line"><span class="comment"> * when the virtual machine is stopped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @QEMU_CLOCK_HOST: host clock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The host clock should be used for device models that emulate accurate</span></span><br><span class="line"><span class="comment"> * real time sources. It will continue to run when the virtual machine</span></span><br><span class="line"><span class="comment"> * is suspended, and it will reflect system time changes the host may</span></span><br><span class="line"><span class="comment"> * undergo (e.g. due to NTP).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @QEMU_CLOCK_VIRTUAL_RT: realtime clock used for icount warp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Outside icount mode, this clock is the same as @QEMU_CLOCK_VIRTUAL.</span></span><br><span class="line"><span class="comment"> * In icount mode, this clock counts nanoseconds while the virtual</span></span><br><span class="line"><span class="comment"> * machine is running.  It is used to increase @QEMU_CLOCK_VIRTUAL</span></span><br><span class="line"><span class="comment"> * while the CPUs are sleeping and thus not executing instructions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    QEMU_CLOCK_REALTIME = <span class="number">0</span>,</span><br><span class="line">    QEMU_CLOCK_VIRTUAL = <span class="number">1</span>,</span><br><span class="line">    QEMU_CLOCK_HOST = <span class="number">2</span>,</span><br><span class="line">    QEMU_CLOCK_VIRTUAL_RT = <span class="number">3</span>,</span><br><span class="line">    QEMU_CLOCK_MAX</span><br><span class="line">&#125; QEMUClockType;</span><br></pre></td></tr></table></figure><h3 id="2-3-QEMU参数解析"><a href="#2-3-QEMU参数解析" class="headerlink" title="2.3 QEMU参数解析"></a>2.3 QEMU参数解析</h3><p>至于QEMU是如何解析<code>base</code>、<code>clock</code>和<code>driftfix</code>这些参数的呢？请参考<code>configure_rtc</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">configure_rtc</span><span class="params">(QemuOpts *opts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set defaults */</span></span><br><span class="line">    rtc_clock = QEMU_CLOCK_HOST;</span><br><span class="line">    rtc_ref_start_datetime = qemu_clock_get_ms(QEMU_CLOCK_HOST) / <span class="number">1000</span>;</span><br><span class="line">    rtc_realtime_clock_offset = qemu_clock_get_ms(QEMU_CLOCK_REALTIME) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    value = qemu_opt_get(opts, <span class="string">"base"</span>);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(value, <span class="string">"utc"</span>)) &#123;</span><br><span class="line">            rtc_base_type = RTC_BASE_UTC;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(value, <span class="string">"localtime"</span>)) &#123;</span><br><span class="line">            Error *blocker = <span class="literal">NULL</span>;</span><br><span class="line">            rtc_base_type = RTC_BASE_LOCALTIME;</span><br><span class="line">            error_setg(&amp;blocker, QERR_REPLAY_NOT_SUPPORTED,</span><br><span class="line">                      <span class="string">"-rtc base=localtime"</span>);</span><br><span class="line">            replay_add_blocker(blocker);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rtc_base_type = RTC_BASE_DATETIME;</span><br><span class="line">            configure_rtc_base_datetime(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-Full-picture"><a href="#3-Full-picture" class="headerlink" title="3. Full picture"></a>3. Full picture</h2><p>往PIO 0x70写入0x00后，从PIO 0x71寄存器中读到的就是当前的秒数。本节以该操作为例，介绍下整个流程。</p><h3 id="3-1-Guest写PIO-0x70"><a href="#3-1-Guest写PIO-0x70" class="headerlink" title="3.1 Guest写PIO 0x70"></a>3.1 Guest写PIO 0x70</h3><ol><li>Guest在Non-root mode下执行了OUT指令</li><li>PIO VM Exit</li><li>KVM发现自己处理不了这个PIO，就将这个IO请求forward给QEMU</li><li>QEMU处理这个IO请求</li></ol><p>至于QEMU如何处理这个IO请求，请参考<a href="/2022/08/27/RTC-virtualization-in-QEMU/#4-3-cmos-ioport-write">cmos_ioport_write</a>。</p><h3 id="3-2-Guest读PIO-0x71"><a href="#3-2-Guest读PIO-0x71" class="headerlink" title="3.2 Guest读PIO 0x71"></a>3.2 Guest读PIO 0x71</h3><ol><li>Guest在Non-root mode下执行了IN指令</li><li>PIO VM Exit</li><li>KVM发现自己处理不了这个PIO，就将这个IO请求forward给QEMU</li><li>QEMU处理这个IO请求</li></ol><p>至于QEMU如何处理这个IO请求，请参考<a href="/2022/08/27/RTC-virtualization-in-QEMU/#4-4-cmos-ioport-read">cmos_ioport_read</a>。</p><h2 id="4-模拟mc146818时钟芯片"><a href="#4-模拟mc146818时钟芯片" class="headerlink" title="4. 模拟mc146818时钟芯片"></a>4. 模拟mc146818时钟芯片</h2><h3 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RTCState</span> &#123;</span></span><br><span class="line">    ISADevice parent_obj;</span><br><span class="line"></span><br><span class="line">    MemoryRegion io;</span><br><span class="line">    MemoryRegion coalesced_io;</span><br><span class="line">    <span class="keyword">uint8_t</span> cmos_data[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> cmos_index;</span><br><span class="line">    <span class="keyword">int32_t</span> base_year;</span><br><span class="line">    <span class="keyword">uint64_t</span> base_rtc;</span><br><span class="line">    <span class="keyword">uint64_t</span> last_update;</span><br><span class="line">    <span class="keyword">int64_t</span> offset;</span><br><span class="line">    qemu_irq irq;</span><br><span class="line">    <span class="keyword">int</span> it_shift;</span><br><span class="line">    <span class="comment">/* periodic timer */</span></span><br><span class="line">    QEMUTimer *periodic_timer;</span><br><span class="line">    <span class="keyword">int64_t</span> next_periodic_time;</span><br><span class="line">    <span class="comment">/* update-ended timer */</span></span><br><span class="line">    QEMUTimer *update_timer;</span><br><span class="line">    <span class="keyword">uint64_t</span> next_alarm_time;</span><br><span class="line">    <span class="keyword">uint16_t</span> irq_reinject_on_ack_count;</span><br><span class="line">    <span class="keyword">uint32_t</span> irq_coalesced;</span><br><span class="line">    <span class="keyword">uint32_t</span> period;</span><br><span class="line">    QEMUTimer *coalesced_timer;</span><br><span class="line">    Notifier clock_reset_notifier;</span><br><span class="line">    LostTickPolicy lost_tick_policy;</span><br><span class="line">    Notifier suspend_notifier;</span><br><span class="line">    QLIST_ENTRY(RTCState) link;</span><br><span class="line">&#125; RTCState;</span><br></pre></td></tr></table></figure><ul><li><code>cmos_data</code>存放128字节的数据</li><li><code>base_rtc</code> is the RTC value when the RTC was last updated</li><li><code>last_update</code> is the guest time when the RTC was last updated</li></ul><h3 id="4-2-初始化"><a href="#4-2-初始化" class="headerlink" title="4.2 初始化"></a>4.2 初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps cmos_ops = &#123;</span><br><span class="line">    .read = cmos_ioport_read,</span><br><span class="line">    .write = cmos_ioport_write,</span><br><span class="line">    .impl = &#123;</span><br><span class="line">        .min_access_size = <span class="number">1</span>,</span><br><span class="line">        .max_access_size = <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_realizefn</span><span class="params">(DeviceState *dev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">0x70</span>;</span><br><span class="line"></span><br><span class="line">        s-&gt;cmos_data[RTC_REG_A] = <span class="number">0x26</span>;</span><br><span class="line">        s-&gt;cmos_data[RTC_REG_B] = <span class="number">0x02</span>;</span><br><span class="line">        s-&gt;cmos_data[RTC_REG_C] = <span class="number">0x00</span>;</span><br><span class="line">        s-&gt;cmos_data[RTC_REG_D] = <span class="number">0x80</span>;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        memory_region_init_io(&amp;s-&gt;io, OBJECT(s), &amp;cmos_ops, s, <span class="string">"rtc"</span>, <span class="number">2</span>);</span><br><span class="line">        isa_register_ioport(isadev, &amp;s-&gt;io, base);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h3 id="4-3-cmos-ioport-write"><a href="#4-3-cmos-ioport-write" class="headerlink" title="4.3 cmos_ioport_write"></a>4.3 cmos_ioport_write</h3><p>Guest往PIO 0x70写入0x00后，QEMU中的处理:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmos_ioport_write</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">uint64_t</span> data, <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTCState *s = opaque;</span><br><span class="line">    <span class="keyword">uint32_t</span> old_period;</span><br><span class="line">    <span class="keyword">bool</span> update_periodic_timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((addr &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        s-&gt;cmos_index = data &amp; <span class="number">0x7f</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><p>此时，<code>addr &amp; 1</code>为0(0x70)，因此会执行<code>s-&gt;cmos_index = data &amp; 0x7f</code>，设置<code>cmos_index</code>为0。</p><h3 id="4-4-cmos-ioport-read"><a href="#4-4-cmos-ioport-read" class="headerlink" title="4.4 cmos_ioport_read"></a>4.4 cmos_ioport_read</h3><p>Guest从PIO 0x71寄存器中读到的就是当前的秒数，QEMU中的处理:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint64_t <span class="title">cmos_ioport_read</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTCState *s = opaque;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((addr &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xff</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(s-&gt;cmos_index) &#123;</span><br><span class="line">        <span class="keyword">case</span> RTC_IBM_PS2_CENTURY_BYTE:</span><br><span class="line">            s-&gt;cmos_index = RTC_CENTURY;</span><br><span class="line">            <span class="comment">/* fall through */</span></span><br><span class="line">        <span class="keyword">case</span> RTC_CENTURY:</span><br><span class="line">        <span class="keyword">case</span> RTC_SECONDS:</span><br><span class="line">        <span class="keyword">case</span> RTC_MINUTES:</span><br><span class="line">        <span class="keyword">case</span> RTC_HOURS:</span><br><span class="line">        <span class="keyword">case</span> RTC_DAY_OF_WEEK:</span><br><span class="line">        <span class="keyword">case</span> RTC_DAY_OF_MONTH:</span><br><span class="line">        <span class="keyword">case</span> RTC_MONTH:</span><br><span class="line">        <span class="keyword">case</span> RTC_YEAR:</span><br><span class="line">            <span class="comment">/* if not in set mode, calibrate cmos before</span></span><br><span class="line"><span class="comment">             * reading*/</span></span><br><span class="line">            <span class="keyword">if</span> (rtc_running(s)) &#123;</span><br><span class="line">                rtc_update_time(s);</span><br><span class="line">            &#125;</span><br><span class="line">            ret = s-&gt;cmos_data[s-&gt;cmos_index];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure></p><p>此时，<code>addr &amp; 1</code>为1(0x71)，因此会执行<code>rtc_update_time</code>，然后返回<code>s-&gt;cmos_data[s-&gt;cmos_index]</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_update_time</span><span class="params">(RTCState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">ret</span>;</span></span><br><span class="line">    <span class="keyword">time_t</span> guest_sec;</span><br><span class="line">    <span class="keyword">int64_t</span> guest_nsec;</span><br><span class="line"></span><br><span class="line">    guest_nsec = get_guest_rtc_ns(s);</span><br><span class="line">    guest_sec = guest_nsec / NANOSECONDS_PER_SECOND;</span><br><span class="line">    gmtime_r(&amp;guest_sec, &amp;ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is SET flag of Register B disabled? */</span></span><br><span class="line">    <span class="keyword">if</span> ((s-&gt;cmos_data[RTC_REG_B] &amp; REG_B_SET) == <span class="number">0</span>) &#123;</span><br><span class="line">        rtc_set_cmos(s, &amp;ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rtc_set_cmos</code>会设置<code>cmos_data</code>中的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint64_t <span class="title">get_guest_rtc_ns</span><span class="params">(RTCState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> guest_clock = qemu_clock_get_ns(rtc_clock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s-&gt;base_rtc * NANOSECONDS_PER_SECOND +</span><br><span class="line">        guest_clock - s-&gt;last_update + s-&gt;offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://lore.kernel.org/qemu-devel/1342781633-7288-5-git-send-email-pbonzini@redhat.com/" target="_blank" rel="noopener">https://lore.kernel.org/qemu-devel/1342781633-7288-5-git-send-email-pbonzini@redhat.com/</a></p><p>Calculate guest RTC based on the time of the last update.The formula is:<br><code>(base_rtc + guest_time_now - guest_time_last_update + offset)</code></p><ul><li>base_rtc is the RTC value when the RTC was last updated</li><li>guest_time_now is the guest time when the access happens</li><li>guest_time_last_update is the guest time when the RTC was last updated</li><li>offset is used when divider reset happens or the set bit is toggled(可以暂时忽略，若想深入研究，需仔细阅读RTC的spec)</li></ul><h3 id="4-5-Update-guest-RTC"><a href="#4-5-Update-guest-RTC" class="headerlink" title="4.5 Update guest RTC"></a>4.5 Update guest RTC</h3><p>什么时候会更新guest的RTC呢？<br>一旦更新guest的RTC，就会更新<code>base_rtc</code>和<code>last_update</code>。</p><h4 id="4-5-1-base-rtc和last-update的初始化"><a href="#4-5-1-base-rtc和last-update的初始化" class="headerlink" title="4.5.1 base_rtc和last_update的初始化"></a>4.5.1 <code>base_rtc</code>和<code>last_update</code>的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_set_date_from_host</span><span class="params">(ISADevice *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTCState *s = MC146818_RTC(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span>;</span></span><br><span class="line"></span><br><span class="line">    qemu_get_timedate(&amp;tm, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    s-&gt;base_rtc = mktimegm(&amp;tm);</span><br><span class="line">    s-&gt;last_update = qemu_clock_get_ns(rtc_clock);</span><br><span class="line">    s-&gt;offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the CMOS date */</span></span><br><span class="line">    rtc_set_cmos(s, &amp;tm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_realizefn</span><span class="params">(DeviceState *dev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        rtc_set_date_from_host(isadev);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-2-base-rtc和last-update的更新"><a href="#4-5-2-base-rtc和last-update的更新" class="headerlink" title="4.5.2 base_rtc和last_update的更新"></a>4.5.2 <code>base_rtc</code>和<code>last_update</code>的更新</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_set_time</span><span class="params">(RTCState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span>;</span></span><br><span class="line"></span><br><span class="line">    rtc_get_time(s, &amp;tm);</span><br><span class="line">    s-&gt;base_rtc = mktimegm(&amp;tm);</span><br><span class="line">    s-&gt;last_update = qemu_clock_get_ns(rtc_clock);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rtc_set_time</code>会更新<code>base_rtc</code>和<code>last_update</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmos_ioport_write</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">uint64_t</span> data, <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTCState *s = opaque;</span><br><span class="line">    <span class="keyword">uint32_t</span> old_period;</span><br><span class="line">    <span class="keyword">bool</span> update_periodic_timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((addr &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        s-&gt;cmos_index = data &amp; <span class="number">0x7f</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CMOS_DPRINTF(<span class="string">"cmos: write index=0x%02x val=0x%02"</span> PRIx64 <span class="string">"\n"</span>,</span><br><span class="line">                     s-&gt;cmos_index, data);</span><br><span class="line">        <span class="keyword">switch</span>(s-&gt;cmos_index) &#123;</span><br><span class="line">        <span class="keyword">case</span> RTC_SECONDS_ALARM:</span><br><span class="line">        <span class="keyword">case</span> RTC_MINUTES_ALARM:</span><br><span class="line">        <span class="keyword">case</span> RTC_HOURS_ALARM:</span><br><span class="line">            s-&gt;cmos_data[s-&gt;cmos_index] = data;</span><br><span class="line">            check_update_timer(s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RTC_IBM_PS2_CENTURY_BYTE:</span><br><span class="line">            s-&gt;cmos_index = RTC_CENTURY;</span><br><span class="line">            <span class="comment">/* fall through */</span></span><br><span class="line">        <span class="keyword">case</span> RTC_CENTURY:</span><br><span class="line">        <span class="keyword">case</span> RTC_SECONDS:</span><br><span class="line">        <span class="keyword">case</span> RTC_MINUTES:</span><br><span class="line">        <span class="keyword">case</span> RTC_HOURS:</span><br><span class="line">        <span class="keyword">case</span> RTC_DAY_OF_WEEK:</span><br><span class="line">        <span class="keyword">case</span> RTC_DAY_OF_MONTH:</span><br><span class="line">        <span class="keyword">case</span> RTC_MONTH:</span><br><span class="line">        <span class="keyword">case</span> RTC_YEAR:</span><br><span class="line">            s-&gt;cmos_data[s-&gt;cmos_index] = data;</span><br><span class="line">            <span class="comment">/* if in set mode, do not update the time */</span></span><br><span class="line">            <span class="keyword">if</span> (rtc_running(s)) &#123;</span><br><span class="line">                rtc_set_time(s);</span><br><span class="line">                check_update_timer(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RTC_REG_A:</span><br><span class="line">            update_periodic_timer = (s-&gt;cmos_data[RTC_REG_A] ^ data) &amp; <span class="number">0x0f</span>;</span><br><span class="line">            old_period = rtc_periodic_clock_ticks(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((data &amp; <span class="number">0x60</span>) == <span class="number">0x60</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rtc_running(s)) &#123;</span><br><span class="line">                    rtc_update_time(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* What happens to UIP when divider reset is enabled is</span></span><br><span class="line"><span class="comment">                 * unclear from the datasheet.  Shouldn't matter much</span></span><br><span class="line"><span class="comment">                 * though.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                s-&gt;cmos_data[RTC_REG_A] &amp;= ~REG_A_UIP;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((s-&gt;cmos_data[RTC_REG_A] &amp; <span class="number">0x60</span>) == <span class="number">0x60</span>) &amp;&amp;</span><br><span class="line">                    (data &amp; <span class="number">0x70</span>)  &lt;= <span class="number">0x20</span>) &#123;</span><br><span class="line">                <span class="comment">/* when the divider reset is removed, the first update cycle</span></span><br><span class="line"><span class="comment">                 * begins one-half second later*/</span></span><br><span class="line">                <span class="keyword">if</span> (!(s-&gt;cmos_data[RTC_REG_B] &amp; REG_B_SET)) &#123;</span><br><span class="line">                    s-&gt;offset = <span class="number">500000000</span>;</span><br><span class="line">                    rtc_set_time(s);</span><br><span class="line">                &#125;</span><br><span class="line">                s-&gt;cmos_data[RTC_REG_A] &amp;= ~REG_A_UIP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* UIP bit is read only */</span></span><br><span class="line">            s-&gt;cmos_data[RTC_REG_A] = (data &amp; ~REG_A_UIP) |</span><br><span class="line">                (s-&gt;cmos_data[RTC_REG_A] &amp; REG_A_UIP);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (update_periodic_timer) &#123;</span><br><span class="line">                periodic_timer_update(s, qemu_clock_get_ns(rtc_clock),</span><br><span class="line">                                      old_period, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            check_update_timer(s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RTC_REG_B:</span><br><span class="line">            update_periodic_timer = (s-&gt;cmos_data[RTC_REG_B] ^ data)</span><br><span class="line">                                       &amp; REG_B_PIE;</span><br><span class="line">            old_period = rtc_periodic_clock_ticks(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data &amp; REG_B_SET) &#123;</span><br><span class="line">                <span class="comment">/* update cmos to when the rtc was stopping */</span></span><br><span class="line">                <span class="keyword">if</span> (rtc_running(s)) &#123;</span><br><span class="line">                    rtc_update_time(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* set mode: reset UIP mode */</span></span><br><span class="line">                s-&gt;cmos_data[RTC_REG_A] &amp;= ~REG_A_UIP;</span><br><span class="line">                data &amp;= ~REG_B_UIE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* if disabling set mode, update the time */</span></span><br><span class="line">                <span class="keyword">if</span> ((s-&gt;cmos_data[RTC_REG_B] &amp; REG_B_SET) &amp;&amp;</span><br><span class="line">                    (s-&gt;cmos_data[RTC_REG_A] &amp; <span class="number">0x70</span>) &lt;= <span class="number">0x20</span>) &#123;</span><br><span class="line">                    s-&gt;offset = get_guest_rtc_ns(s) % NANOSECONDS_PER_SECOND;</span><br><span class="line">                    rtc_set_time(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>从第34、57和90行可知，当guest往PIO 0x71设置值的时候，就可能会调用<code>rtc_set_time</code>。<br>比如在guest中，当前为2022年，如果guest想设置为2021年，此时就会触发<code>base_rtc</code>和<code>last_update</code>的更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtc_post_load</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">int</span> version_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTCState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (version_id &lt;= <span class="number">2</span> || rtc_clock == QEMU_CLOCK_REALTIME) &#123;</span><br><span class="line">        rtc_set_time(s);</span><br><span class="line">        s-&gt;offset = <span class="number">0</span>;</span><br><span class="line">        check_update_timer(s);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当live migration时，在目的端，也可能会调用<code>rtc_set_time</code>。</p><h3 id="4-6-MISC"><a href="#4-6-MISC" class="headerlink" title="4.6 MISC"></a>4.6 MISC</h3><ul><li><code>rtc_policy_slew_deliver_irq</code>是<code>driftfix=slew</code>参数对应的操作，细节未研究，待日后更新。</li><li>rtc作为定时器的用法，本文也没有阐述，待日后更新。<br><img src="/images/2022/07/13.jpg" alt></li></ul><hr><p>参考资料:</p><ol><li><a href="https://blog.csdn.net/u014022631/article/details/122429251" target="_blank" rel="noopener">qemu时钟虚拟化</a></li><li><a href="https://martin.uy/blog/bios-execution-in-qemu-first-io-interaction/" target="_blank" rel="noopener">BIOS execution in QEMU: first I/O interaction</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将结合&lt;a href=&quot;https://github.com/qemu/qemu/commits/stable-5.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QEMU&lt;/a&gt;代码，解析RTC虚拟化。
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>Notes about KVM steal time</title>
    <link href="http://liujunming.github.io/2022/08/20/Notes-about-KVM-steal-time/"/>
    <id>http://liujunming.github.io/2022/08/20/Notes-about-KVM-steal-time/</id>
    <published>2022-08-20T14:31:40.000Z</published>
    <updated>2022-09-03T04:15:28.016Z</updated>
    
    <content type="html"><![CDATA[<p>本文将参考<a href="https://cloud.tencent.com/developer/article/1087403" target="_blank" rel="noopener">steal time技术分析</a>，并结合<a href="https://elixir.bootlin.com/linux/v4.19/source" target="_blank" rel="noopener">v4.19 kernel</a>来解析steal time。<a id="more"></a></p><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><p>当前Host的墙上时间是HWT1，此时Guest中的墙上时间GWT1，如果是同一个时区的话，此时HWT1和GWT1是相等的。</p><p>如果此时Host中发生了调度，Guest所在的qemu进程不执行了，那么HWT1将继续增长，GWT1是否应该增长呢？</p><ul><li><p>如果GWT1不增长，那么等到Guest继续执行的时候，就会继续在原来的GWT1基础上增长，那么HWT2到HWT1之间的时间就发生了丢失；现象就是Guest中的时间变慢了。</p></li><li><p>如果GWT1同时增长，那么就会在Guest进程切回来继续执行的时候，Guest中的时间会瞬间增大了HWT2减掉HWT1的差值。现象就是Guest的墙上时间是对的。可是新的问题又来了：在Guest的qemu进程被Host切换之前，Guest中刚刚切换走redis，开始执行Nginx；等到Guest继续执行的时候，因为Guest中的时钟跳变增大了很多，Guest会认为Nginx执行了大量的CPU时间。如果Linux Guest中采用的是cfs调度算法，那么Nginx下次被调度会隔比较长的时间。可是实际上呢，Nginx根本没有得到执行！</p></li></ul><h3 id="2-Motivation"><a href="#2-Motivation" class="headerlink" title="2. Motivation"></a>2. Motivation</h3><p>为了解决上述Guest中的调度问题，就引入了steal time。<br>Steal time的原理就是：告诉Guest，哪些时间被Host给steal了，调度的时候，忽略这部分时间，就可以正确调度了。<br>所以，基本就是两个部分：</p><ol><li>在Host中通知Guest具体的steal time是多少</li><li>在Guest中处理这些时间，修正因时间跳变引起的调度错误</li></ol><h3 id="3-Identify-steal-time-in-Guest"><a href="#3-Identify-steal-time-in-Guest" class="headerlink" title="3. Identify steal time in Guest"></a>3. Identify steal time in Guest</h3><p><img src="/images/2022/07/11.jpg" alt><br>可以在<code>/proc/stat</code>中的第八项看到steal time(<code>top</code>就是从<code>/proc/stat</code>获取的数据)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v4.19/source/fs/proc/stat.c</span></span><br><span class="line">steal = kcpustat_cpu(i).cpustat[CPUTIME_STEAL];</span><br></pre></td></tr></table></figure></p><h3 id="4-Guest-register-steal-time"><a href="#4-Guest-register-steal-time" class="headerlink" title="4. Guest register steal time"></a>4. Guest register steal time</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_register_steal_time</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_steal_time</span> *<span class="title">st</span> = &amp;<span class="title">per_cpu</span>(<span class="title">steal_time</span>, <span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!has_steal_clock)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">wrmsrl(MSR_KVM_STEAL_TIME, (slow_virt_to_phys(st) | KVM_MSR_ENABLED));</span><br><span class="line">pr_info(<span class="string">"kvm-stealtime: cpu %d, msr %llx\n"</span>,</span><br><span class="line">cpu, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) slow_virt_to_phys(st));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>guest通过写MSR MSR_KVM_STEAL_TIME，把per_cpu变量steal_time的物理地址（Guest Physical Address）告诉Host。</p><p>MSR_KVM_STEAL_TIME MSR的描述:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">MSR_KVM_STEAL_TIME: <span class="number">0x4b564d03</span></span><br><span class="line"></span><br><span class="line">data: <span class="number">64</span>-byte alignment physical address of a memory area which must be</span><br><span class="line">in guest RAM, plus an enable bit in bit <span class="number">0.</span> This memory is expected to</span><br><span class="line">hold a copy of the following structure:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_steal_time</span> &#123;</span></span><br><span class="line">__u64 steal;</span><br><span class="line">__u32 version;</span><br><span class="line">__u32 flags;</span><br><span class="line">__u8  preempted;</span><br><span class="line">__u8  u8_pad[<span class="number">3</span>];</span><br><span class="line">__u32 pad[<span class="number">11</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">whose data will be filled in by the hypervisor periodically. Only one</span><br><span class="line">write, <span class="keyword">or</span> registration, is needed <span class="keyword">for</span> each VCPU. The interval between</span><br><span class="line">updates of <span class="keyword">this</span> structure is arbitrary <span class="keyword">and</span> implementation-dependent.</span><br><span class="line">The hypervisor may update <span class="keyword">this</span> structure at any time it sees fit until</span><br><span class="line">anything with bit0 == <span class="number">0</span> is written to it. Guest is required to make sure</span><br><span class="line"><span class="keyword">this</span> structure is initialized to zero.</span><br><span class="line"></span><br><span class="line">Fields have the following meanings:</span><br><span class="line"></span><br><span class="line">version: a sequence counter. In other words, guest has to check</span><br><span class="line"><span class="keyword">this</span> field before <span class="keyword">and</span> after grabbing time information <span class="keyword">and</span> make</span><br><span class="line">sure they are both equal <span class="keyword">and</span> even. An odd version indicates an</span><br><span class="line">in-progress update.</span><br><span class="line"></span><br><span class="line">flags: At <span class="keyword">this</span> point, always zero. May be used to indicate</span><br><span class="line">changes in <span class="keyword">this</span> structure in the future.</span><br><span class="line"></span><br><span class="line">steal: the amount of time in which <span class="keyword">this</span> vCPU did <span class="keyword">not</span> run, in</span><br><span class="line">nanoseconds. Time during which the vcpu is idle, will <span class="keyword">not</span> be</span><br><span class="line">reported as steal time.</span><br><span class="line"></span><br><span class="line">preempted: indicate the vCPU who owns <span class="keyword">this</span> struct is running <span class="keyword">or</span></span><br><span class="line"><span class="keyword">not</span>. Non-zero values mean the vCPU has been preempted. Zero</span><br><span class="line">means the vCPU is <span class="keyword">not</span> preempted. NOTE, it is always zero <span class="keyword">if</span> the</span><br><span class="line">the hypervisor doesn't support <span class="keyword">this</span> field.</span><br></pre></td></tr></table></figure></p><p><code>version</code>的作用类似于<a href="/2020/05/02/深入理解RTC/">rtc</a>的”Update in progress” flag，防止读到中间状态。<br>guest grab time information时，应该包含如下逻辑:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">version1 = before grabbing time information</span><br><span class="line">do something to grab time information</span><br><span class="line">version2 = after grabbing time information</span><br><span class="line">&#125; while(!(version1 == version2 &amp;&amp; version1为偶数));</span><br></pre></td></tr></table></figure></p><h3 id="5-Host-calculate-steal-time"><a href="#5-Host-calculate-steal-time" class="headerlink" title="5. Host calculate steal time"></a>5. Host calculate steal time</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v4.19/source/include/linux/sched.h#L290</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span> &#123;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* Time spent waiting on a runqueue: */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>run_delay;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意看<code>run_delay</code>，如注释，就是task等待的时间，也就是没有执行的时间（例子中Guest的qemu被切换走的时间）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v4.19/source/arch/x86/kvm/x86.c#L2292</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">record_steal_time</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">vcpu-&gt;arch.st.steal.version += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">kvm_write_guest_cached(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.st.stime,</span><br><span class="line">&amp;vcpu-&gt;arch.st.steal, <span class="keyword">sizeof</span>(struct kvm_steal_time));</span><br><span class="line"></span><br><span class="line">smp_wmb();</span><br><span class="line"></span><br><span class="line">vcpu-&gt;arch.st.steal.steal += current-&gt;sched_info.run_delay -</span><br><span class="line">vcpu-&gt;arch.st.last_steal;</span><br><span class="line">vcpu-&gt;arch.st.last_steal = current-&gt;sched_info.run_delay;</span><br><span class="line"></span><br><span class="line">kvm_write_guest_cached(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.st.stime,</span><br><span class="line">&amp;vcpu-&gt;arch.st.steal, <span class="keyword">sizeof</span>(struct kvm_steal_time));</span><br><span class="line"></span><br><span class="line">smp_wmb();</span><br><span class="line"></span><br><span class="line">vcpu-&gt;arch.st.steal.version += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">kvm_write_guest_cached(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.st.stime,</span><br><span class="line">&amp;vcpu-&gt;arch.st.steal, <span class="keyword">sizeof</span>(struct kvm_steal_time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Host中，用<code>run_delay</code>计算出Guest的steal time，并通过<code>kvm_write_guest_cached</code>告诉Guest（前文中Guest向Host注册的地址，Host直接修改）。<br>这样，在Guest恢复执行的时候，就可以知道steal time的具体大小了。</p><h3 id="6-Guest-scheduler处理steal-time"><a href="#6-Guest-scheduler处理steal-time" class="headerlink" title="6. Guest scheduler处理steal time"></a>6. Guest scheduler处理steal time</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v4.19/source/kernel/sched/core.c#L132</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RQ-clock updating methods:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_rq_clock_task</span><span class="params">(struct rq *rq, s64 delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PARAVIRT_TIME_ACCOUNTING</span></span><br><span class="line"><span class="keyword">if</span> (static_key_false((&amp;paravirt_steal_rq_enabled))) &#123;</span><br><span class="line">steal = paravirt_steal_clock(cpu_of(rq));</span><br><span class="line">steal -= rq-&gt;prev_steal_time_rq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(steal &gt; delta))</span><br><span class="line">steal = delta;</span><br><span class="line"></span><br><span class="line">rq-&gt;prev_steal_time_rq += steal;</span><br><span class="line">delta -= steal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">rq-&gt;clock_task += delta;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clock_task</code>记录的是队列中任务执行的时间，其由函数<code>update_rq_clock_task()</code>负责更新。steal time是guest可以意识到的时间，这个时间不被计算到具体的调度队列的运行时间，因而虚拟化下guest中的task调度正常，不会出现时间跳变引起的调度错误。</p><hr><p>参考资料:</p><ol><li><a href="https://cloud.tencent.com/developer/article/1087403" target="_blank" rel="noopener">steal time技术分析</a></li><li><a href="https://lore.kernel.org/kvm/1309793548-16714-1-git-send-email-glommer@redhat.com/" target="_blank" rel="noopener">Steal time for KVM</a></li><li><a href="https://oenhan.com/kvm-steal-time" target="_blank" rel="noopener">KVM下STEAL_TIME源代码分析</a></li><li><a href="https://blog.csdn.net/wu7244582/article/details/111366245" target="_blank" rel="noopener">kvm steal 溯源</a></li><li><a href="https://www.site24x7.com/learn/linux/cpu-steal-time.html" target="_blank" rel="noopener">What is CPU steal time?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将参考&lt;a href=&quot;https://cloud.tencent.com/developer/article/1087403&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;steal time技术分析&lt;/a&gt;，并结合&lt;a href=&quot;https://elixir.bootlin.com/linux/v4.19/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v4.19 kernel&lt;/a&gt;来解析steal time。
    
    </summary>
    
      <category term="KVM" scheme="http://liujunming.github.io/categories/KVM/"/>
    
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>Notes about KVM async page fault</title>
    <link href="http://liujunming.github.io/2022/08/18/Notes-about-KVM-async-page-fault/"/>
    <id>http://liujunming.github.io/2022/08/18/Notes-about-KVM-async-page-fault/</id>
    <published>2022-08-18T12:59:06.000Z</published>
    <updated>2022-08-18T13:43:09.348Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about KVM apf(async page fault)。<a id="more"></a>转载自:<a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2019/03/24/kvm-async-page-fault" target="_blank" rel="noopener">KVM async page fault</a>。</p><p>The qemu/kvm VM’s physical memory is the virtual memory of qemu process. When the virtual memory of qemu has been commit and is setup with physical memory the host can swap out this physical memory. When the guest vcpu access memory swapped out by host, its execution is suspended until memory is swapped back. Asynchronous page fault is a way to try and use guest vcpu more efficiently by allowing it to execute other tasks while page is brought back into memory. Following give a summary of these processes.</p><ol><li><p>page fault when the EPT page table is not setup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. VMEXIT</span><br><span class="line">2. kvm_mmu_page_fault()</span><br><span class="line">3. gfn_to_pfn()</span><br><span class="line">4. get_user_pages_unlocked()</span><br><span class="line">     no previously mapped page and no swap entry found</span><br><span class="line">     empty page is allocated</span><br><span class="line">5. page is added into shadow/nested page table</span><br></pre></td></tr></table></figure></li><li><p>page fault when the physical memory is swapped out(without apf)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. VMEXIT</span><br><span class="line">2. kvm_mmu_page_fault()</span><br><span class="line">3. gfn_to_pfn()</span><br><span class="line">4. get_user_pages_unlocked()</span><br><span class="line">    swap entry is found</span><br><span class="line">    page swap-in process is initiated</span><br><span class="line">    vcpu thread goes to sleep until page is swapped in</span><br></pre></td></tr></table></figure></li><li><p>page fault when the phycial memory is swapped out(with apf)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. VMEXIT</span><br><span class="line">2. kvm_mmu_page_fault()</span><br><span class="line">3. gfn_to_pfn()</span><br><span class="line">4. get_user_pages_nowait()</span><br><span class="line">5. gup(get_user_pages) is done by dedicated thread, inject &apos;page not present&apos; exception to guest</span><br><span class="line">6. guest puts process A(which caused this page fault) to sleep and schedule another process</span><br><span class="line">7. page is swapped in, inject &apos;page ready&apos; exception to guest</span><br><span class="line">8. guest can schedule process A back to run on vcpu</span><br></pre></td></tr></table></figure></li></ol><p>Following shows the process of kvm async page fault process.<br><img src="/images/2022/07/10.jpeg" alt><br>From description we know that kvm apf need the guest do something, such as recognize the apf ‘page not present’ and ‘page ready’ exception, and also the pv guest should hook the exception to process these two new exception. apf contains following steps.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. the guest should be initialized to process the new exception</span><br><span class="line">2. kvm page fault handler should recognize the swapped out case and initialize a work to swap in the page, inject a &apos;page not present&apos; to guest</span><br><span class="line">3. the guest receive this exception and schedule another process to run </span><br><span class="line">4. when the page caused page fault in step 2 has been swapped in, the kvm inject a &apos;page ready&apos; exception to guest</span><br><span class="line">5. the guest can do schedule to run process that was blocked by page fault in step 2</span><br></pre></td></tr></table></figure></p><hr><p>参考资料:</p><ol><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2019/03/24/kvm-async-page-fault" target="_blank" rel="noopener">KVM async page fault</a></li><li><a href="https://www.linux-kvm.org/images/a/ac/2010-forum-Async-page-faults.pdf" target="_blank" rel="noopener">2010-forum-Async-page-faults</a></li><li><a href="https://lore.kernel.org/lkml/20091108164706.GB3286@elte.hu/T/" target="_blank" rel="noopener">Add shared memory hypercall to PV Linux guest</a></li><li><a href="https://xingguotian.github.io/2019/08/23/qemu-kvm%20%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" target="_blank" rel="noopener">Qemu-kvm memory 虚拟化</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about KVM apf(async page fault)。
    
    </summary>
    
      <category term="KVM" scheme="http://liujunming.github.io/categories/KVM/"/>
    
    
      <category term="内存管理" scheme="http://liujunming.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>Linux/x86中断处理：中断号</title>
    <link href="http://liujunming.github.io/2022/08/15/Linux-x86%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%AD%E6%96%AD%E5%8F%B7/"/>
    <id>http://liujunming.github.io/2022/08/15/Linux-x86中断处理：中断号/</id>
    <published>2022-08-15T08:32:27.000Z</published>
    <updated>2022-08-15T13:45:39.587Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自:<a href="https://github.com/eternalNight/blog-pages/blob/master/_posts/linux-intr-irq.md" target="_blank" rel="noopener">Linux/x86中断处理：中断号</a>。<a id="more"></a></p><h2 id="1-架构相关部分（x86）"><a href="#1-架构相关部分（x86）" class="headerlink" title="1. 架构相关部分（x86）"></a>1. 架构相关部分（x86）</h2><p>特别要注意的是，架构无关部分所用的中断号纯粹是个逻辑值，和硬件上所用的中断号没有必然联系！换句话说，只要和架构相关的代码串通好了，我们就完全可以说时钟的中断号是0xbeef，串口的中断号是0xdead，硬盘的中断号是0xbaddad，尽管硬件使用的中断号可能都没超过256。区别起见，以下把架构无关部分用的中断号叫做“逻辑中断号”，硬件使用的中断号（具体到x86上就是用哪个IDT表项）叫做“物理中断号”。对于x86架构来说，物理中断号的范围就是0-255，0号是除0错，14号是缺页等等。</p><h3 id="1-1-物理中断号到逻辑中断号的映射"><a href="#1-1-物理中断号到逻辑中断号的映射" class="headerlink" title="1.1 物理中断号到逻辑中断号的映射"></a>1.1 物理中断号到逻辑中断号的映射</h3><p>建立物理中断号到逻辑中断号的映射，是架构相关的中断处理例程需要完成的主要任务之一。对于x86_64来说，汇编部分的IDT表项入口是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(irq_entries_start)</span><br><span class="line">        INTR_FRAME</span><br><span class="line">    vector=FIRST_EXTERNAL_VECTOR</span><br><span class="line">    .rept (FIRST_SYSTEM_VECTOR - FIRST_EXTERNAL_VECTOR)</span><br><span class="line">        pushq_cfi $(~vector+0x80)    /* Note: always in signed byte range */</span><br><span class="line">    vector=vector+1</span><br><span class="line">        jmp     common_interrupt</span><br><span class="line">        CFI_ADJUST_CFA_OFFSET -8</span><br><span class="line">        .align  8</span><br><span class="line">    .endr</span><br><span class="line">        CFI_ENDPROC</span><br><span class="line">END(irq_entries_start)</span><br></pre></td></tr></table></figure></p><p>C部分的IDT建立是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for_each_clear_bit_from(i, used_vectors, first_system_vector) &#123;</span><br><span class="line">        <span class="comment">/* IA32_SYSCALL_VECTOR could be used in trap_init already. */</span></span><br><span class="line">        set_intr_gate(i, irq_entries_start +</span><br><span class="line">                        <span class="number">8</span> * (i - FIRST_EXTERNAL_VECTOR));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FIRST_EXTERNAL_VECTOR是0x20（和Intel手册上的内容一致）。进入中断后的一系列操作包括汇编里的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">common_interrupt:</span><br><span class="line">        XCPT_FRAME</span><br><span class="line">        ASM_CLAC</span><br><span class="line">        addq $-0x80,(%rsp)              /* Adjust vector to [-256,-1] range */</span><br><span class="line">        interrupt do_IRQ</span><br></pre></td></tr></table></figure></p><p>和C里的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __<span class="function">irq_entry <span class="title">do_IRQ</span><span class="params">(struct pt_regs *regs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="built_in">vector</span> = ~regs-&gt;orig_ax;</span><br><span class="line">        <span class="keyword">unsigned</span> irq;</span><br><span class="line">...</span><br><span class="line">irq = __this_cpu_read(vector_irq[<span class="built_in">vector</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handle_irq(irq, regs))</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中regs-&gt;orig_ax就是irq_entries_start里那些IDT入口push到栈上的值。那么，do_IRQ里的vector（记作v’）和IDT入口里的vector（记作v）的关系就应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v&apos; = ~((~v + 0x80) + (-0x80)) = v</span><br></pre></td></tr></table></figure></p><p>不就是一样的嘛……</p><p>拿到vector之后，接下去还有一个per_cpu的vector_irq，把vector映射成irq，这个才是麻烦的部分，因为对于x86平台上大部分中断，无论是物理中断号还是发给哪个CPU都是可配置的，所以静态没办法决定物理中断号、CPU号和逻辑中断号间的关系，只好弄一个per_cpu的vector_irq，遇到一个存一个。</p><h2 id="2-架构无关部分"><a href="#2-架构无关部分" class="headerlink" title="2. 架构无关部分"></a>2. 架构无关部分</h2><p>在架构无关部分，中断处理的大致流程很直观：handle_irq（架构无关部分的中断处理入口）拿到一个中断号，找先前在这个中断号上注册过的中断处理例程，每个例程调一遍，完事。所谓“在这个中断号上注册”，指的就是以这个中断号为参数，调用request_irq。</p><p>数据结构也很直接：一个中断号对应一个irq_desc，irq_desc里面记录了所有先前注册了这个中断号的中断处理例程（irqaction）。irq_desc里的handle_irq是一级的处理入口，由它一边处理一些通用的细节问题（比如边沿/电平触发的分别处理），一边一个一个地调action链表里注册过的例程。irq_chip是对应中断控制器的结构，里面存放的是一系列函数指针，实现像开关中断这样的由中断控制器提供的中断管理服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                       irq_desc</span><br><span class="line">      irq == ?? ==&gt; +------------+</span><br><span class="line">                    | handle_irq |</span><br><span class="line">   irq_chip      +--|    chip    |        irqaction</span><br><span class="line">+------------+&lt;--+  |   action   | ---&gt; +-----------+  +-&gt;+-----------+  +-&gt; ...</span><br><span class="line">|  irq_mask  |      |    name    |      |  handler  |  |  |  handler  |  |</span><br><span class="line">| irq_unmask |      .            .      | thread_fn |  |  | thread_fn |  |</span><br><span class="line">.            .      .            .      |   next    |--+  |   next    |--+</span><br><span class="line">.            .                          .           .     .           .</span><br></pre></td></tr></table></figure></p><p>对于从中断号（上图中的irq）到irq_desc的映射，Linux里默认是用了一个NR_IRQS个单元的irq_desc数组做的，也就是说中断号仅限于0到NR_IRQS-1之间。如果配置选项CONFIG_SPARSE_IRQ开启，那么中断号到irq_desc的映射就会用一个radix tree来维护，那样的话中断号多大都无所谓了。</p><p>irq_desc有几个设置函数，用来设置handle_irq、name、chip（严格来说是irq_desc里的irq_data的chip）等，包括：</p><ul><li>irq_set_chip：设置chip</li><li>__irq_set_handler：设置handle_irq和name</li><li>irq_set_chip_and_handler_name：handle_irq、name、chip全包</li></ul><h2 id="3-procfs-amp-sysfs里的中断相关文件"><a href="#3-procfs-amp-sysfs里的中断相关文件" class="headerlink" title="3. procfs &amp; sysfs里的中断相关文件"></a>3. procfs &amp; sysfs里的中断相关文件</h2><h3 id="3-1-proc-interrupts"><a href="#3-1-proc-interrupts" class="headerlink" title="3.1 /proc/interrupts"></a>3.1 /proc/interrupts</h3><p>这大概是最著名的一个了。文件的创建位置是proc_interrupts_init，内容由show_interrupts函数提供，主要流程是遍历一遍所有有效的逻辑中断号，对于带了action（也就是被注册过的）的中断，打印的域包括：</p><ul><li>逻辑中断号；</li><li>每个CPU上中断次数的统计；</li><li>对应chip的名称，诸如IO-APIC、PCI-MSI之类；</li><li>中断的名称，即irq_desc里的name，通常是空的；</li><li>每个action的名称，也就是request_irq时给的name，多个action的话用逗号分隔。</li></ul><p>遍历了所有逻辑中断号之后，还会调用arch_show_interrupts获得体系结构相关部分的中断信息，在x86上所有第一列不是数字的部分就是x86的arch_show_interrupts捣腾出来的内容，主要的信息包括中断类型和每个CPU上的中断计数。</p><h4 id="3-1-1-proc-interrupts有中断看不到？！"><a href="#3-1-1-proc-interrupts有中断看不到？！" class="headerlink" title="3.1.1 /proc/interrupts有中断看不到？！"></a>3.1.1 /proc/interrupts有中断看不到？！</h4><p>这个可以有，因为首先处理中断的总是内核的架构相关部分，如果它默默地自己处理了某些中断，既不用handle_irq（架构无关部分的中断处理入口），也不request_irq，还不在arch_show_interrupts里给你看，那/proc/interrupts里自然就找不到这些中断的痕迹。</p><p>x86就有架构相关部分默默处理掉的中断，比如LAPIC时钟。虽说LAPIC时钟中断默认是0x20，但在__setup_APIC_LVTT里就把它改成0xEF了，而0xEF的IDT表项又在apic_intr_init中专门设成了apic_timer_interrupt，而不是irq_entries_start那张表里的通用入口。所以要是在/proc/interrupts里看到这么一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">         CPU0       CPU1       CPU2       CPU3</span><br><span class="line">0:        134          0          0          0   IO-APIC-edge      timer</span><br></pre></td></tr></table></figure></p><p>这货才不是运行时的时钟（不排除系统启动的时候暂时用过它）！真正的时钟应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOC:  919608278  869138540  868188298  901247206   Local timer interrupts</span><br></pre></td></tr></table></figure></p><h3 id="3-2-proc-irq"><a href="#3-2-proc-irq" class="headerlink" title="3.2 /proc/irq/*"></a>3.2 /proc/irq/*</h3><p>这个目录主要是用来控制中断亲和性的，目录下面每个被注册过的逻辑中断号有一个目录，用得比较多的是下面两个文件：</p><ul><li>smp_affinity：bitmap形式的亲和性设置；</li><li>smp_affinity_list：CPU id列表形式的亲和性设置；</li></ul><p>其它几个文件只读，其内容的含义待考。</p><h3 id="3-3-sys-…-irq-和-sys-…-msi-irqs"><a href="#3-3-sys-…-irq-和-sys-…-msi-irqs" class="headerlink" title="3.3 /sys/…/irq 和 /sys/…/msi_irqs"></a>3.3 /sys/…/irq 和 /sys/…/msi_irqs</h3><p>基本每个device的目录下面都有，irq是每个设备所使用的逻辑中断号，不过奇怪的是有些逻辑中断号没有在/proc/interrupts里出现，原因不明。msi_irqs目录下面是一些以逻辑中断号命名的文件，每个都是这个设备所申请的msi或msix中断，没有申请过msi和msix中断的设备没有这个目录。</p><h2 id="4-总结：怎么知道设备的中断号？"><a href="#4-总结：怎么知道设备的中断号？" class="headerlink" title="4. 总结：怎么知道设备的中断号？"></a>4. 总结：怎么知道设备的中断号？</h2><p>绕了这么一大圈下来，可以明显感觉到x86平台为了让一套中断系统适应各种各样奇奇怪怪的环境，在“可配置”这一点上下了多大功夫。这也让搞内核开发的有点头疼：找个中断号怎么就那么麻烦？！</p><p>根据x86中断系统的结构，在Linux里找一个设备的中断号大概分这么几步：</p><ol><li>确定逻辑中断号：先看/proc/interrupts，有名字跟设备直接对应的最好，看不出的话就去sysfs这个符号链接的迷宫，从总线、功能、驱动模块……等等角度，找那个device对应的目录，看文件irq和目录msi_irqs的内容；</li><li>确定物理中断号：插printk，在适当的位置（比如arch_show_interrupts）把vector_irq这个数组打出来，找哪个物理中断号对应了上面确定的逻辑中断号；</li><li>确定物理中断号的配置情况：先从/proc/interrupts搞清楚管理这个中断的chip，然后：</li></ol><ul><li>如果是IOAPIC，找调用ioapic_write_entry和__ioapic_write_entry（更新I/O Redirection Table的函数）的地方；</li><li>如果是MSI，找驱动初始化时申请msi的地方；</li><li>如果是其它东西，那一般是一个级联的中断控制器，先翻翻这个中断控制器的驱动，看看有没有设置中断号之类的API再做商榷；</li><li>对于中断号用字母缩写的中断，在apic.h里找对应的寄存器，然后找apic_write这个寄存器的地方。</li></ul><hr><p>参考资料:</p><ol><li><a href="https://github.com/eternalNight/blog-pages/blob/master/_posts/linux-intr-irq.md" target="_blank" rel="noopener">Linux/x86中断处理：中断号</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA5NTM3MjIxMw==&amp;mid=2247490602&amp;idx=2&amp;sn=4d973784bb61cb1b422b122f6b5239c4&amp;chksm=90410af0a73683e64af7c2593a3bd3c4be04729204548fc8b530c0bbdad01211e0bfb8c8de73&amp;mpshare=1&amp;scene=1&amp;srcid=0322dXqrZHc4i5osgoZomhKG&amp;sharer_sharetime=1616389873996&amp;sharer_shareid=a9a36119fdda2f083962ae6839e2e602&amp;key=fafdc124f4ee647bb0faa403b80208ef8ac0b1661dc3c5bb4ce4a39ce07c8824fcfab78d3a4e7dcb7aee0bcd1713edcf83928a51e956654938343cbb08310d4ae50c7e217888e430e52004715065e53d2226cfa0aecb6a428ae73be4b31649adc006c2c55f79b93a2ab0f85174ed62f92cb81cc30c46fb3d2d4c1d83720fbc3a&amp;ascene=1&amp;uin=MTcwOTQ4NzA0MQ%3D%3D&amp;devicetype=Windows+7&amp;version=6206014b&amp;lang=zh_CN&amp;exportkey=AU79XKScyoT9GEt1KS9SgHU%3D&amp;pass_ticket=DvZ2hOy2IlirucyQl09vTYciz0pynAY1RZ7s06iR710rBFtKcFVvIrOPi9vbGDkO&amp;wx_header=0&amp;winzoom=1#" target="_blank" rel="noopener">Linux中断子系统-通用框架处理</a></li><li><a href="http://www.wowotech.net/irq_subsystem/irq-domain.html" target="_blank" rel="noopener">IRQ Domain介绍</a></li><li><a href="http://www.wowotech.net/irq_subsystem/interrupt_descriptor.html" target="_blank" rel="noopener">IRQ number和中断描述符</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自:&lt;a href=&quot;https://github.com/eternalNight/blog-pages/blob/master/_posts/linux-intr-irq.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux/x86中断处理：中断号&lt;/a&gt;。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
</feed>
