<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2019-08-21T12:17:21.267Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux kernel中tasklet的使用</title>
    <link href="http://liujunming.github.io/2019/08/21/linux-kernel%E4%B8%ADtasklet%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://liujunming.github.io/2019/08/21/linux-kernel中tasklet的使用/</id>
    <published>2019-08-21T11:36:28.000Z</published>
    <updated>2019-08-21T12:17:21.267Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="http://tuxthink.blogspot.com/2011/09/tasklets-1-introduction.html" target="_blank" rel="noopener">Tasklets</a></p><a id="more"></a><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>Tasklets are used in kernel to schedule a function some time in future. The major use of the tasklet is to schedule <a href="http://liujunming.top/2018/12/04/Understanding-the-Linux-Kernel-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Interrupts-and-Exceptions/" target="_blank" rel="noopener">the bottom half of an interrupt service routine</a>. </p><p>Bottom half is the part of the interrupt service routine which is not time critical and can be executed after a little delay from the time interrupt is generated. This helps is releasing the interrupt line quickly and processing more interrupts. </p><p>Let us look at how we can create a tasklet and schedule it in a kernel module. </p><p>The structure, <code>tasklet_struct</code>, declared in interrupt.h looks as follows </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> state;</span><br><span class="line">    <span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The members of the structure that has to be initialized in the module are : </p><ol><li><p><code>func</code> : Pointer to the function that needs to scheduled for execution at a later time </p></li><li><p><code>data</code> : Data to be passed to the function <code>func</code> </p></li></ol><p>The other members are initialized by the kernel as follows:</p><ul><li><code>count</code> : holds a nonzero value if the tasklet is disabled and 0 if it is enabled. </li><li><code>states</code> : <code>TASKLET_STATE_SCHED</code> , which denotes it is scheduled to run. <code>TASKLET_STATE_RUN</code> , which denotes it is running. </li></ul><p>There are two ways of creating a tasklet:<br><strong>1. Creating Statically: (using Macros) </strong></p><ol><li><code>DECLARE_TASKLET(name, func, data)</code>: Creates a tasklet in the enabled state </li><li><code>DECLARE_TASKLET_DISABLED(name, func, data)</code>: Creates a tasklet in the disabled state </li></ol><p>If the tasklets is created using the second macro, it needs to be enabled explicitly. </p><p>For details, just reference this <a href="http://tuxthink.blogspot.com/2011/09/tasklets-3-using-macros.html" target="_blank" rel="noopener">Using Macros</a>.<br><strong>2. Creating in runtime</strong></p><ul><li><code>tasklet_init(name,func,data)</code></li></ul><p>Where “name” is the name of the taskelet, “func” in the function which has to be executed as a part of the tasklet and “data” is the data that has to passed to func. </p><ul><li><p>A tasklet is a softirq and hence runs in an interrupt context. Thus while executing the function you are not allowed to go to sleep and have to use proper locking for any data that is shared with other tasklets. </p></li><li><p>Scheduling a tasklet: </p></li></ul><p>Once the tasklet has been created, it needs to be scheduled which is done by the function <code>tasklet_schedule(&amp;tasklet)</code> </p><ul><li>Enable and Disable : </li></ul><p>The tasklets can be disabled, if they are not running already, using <code>tasklet_disable(&amp;taskelt)</code></p><p>and enabled using <code>tasklet_enble(&amp;tasklet)</code></p><p>When does the tasklet actually get scheduled can not be controlled and is decided by the scheduler depending on the load on the processor. If the processor is free, it might get scheduled immediately. </p><p>For details, just reference this <a href="http://tuxthink.blogspot.com/2011/09/tasklet-2-using-tasklerinit.html" target="_blank" rel="noopener">using tasklet_init</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;http://tuxthink.blogspot.com/2011/09/tasklets-1-introduction.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tasklets&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>acrn-kernel那些事</title>
    <link href="http://liujunming.github.io/2019/08/20/acrn-kernel%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://liujunming.github.io/2019/08/20/acrn-kernel那些事/</id>
    <published>2019-08-20T14:05:59.000Z</published>
    <updated>2019-08-20T14:14:44.703Z</updated>
    
    <content type="html"><![CDATA[<p>学习kernel时，结合文档与patch，效果俱佳。本文将对<a href="https://github.com/projectacrn/acrn-kernel" target="_blank" rel="noopener">acrn-kernel</a>中acrn/vhm的patch进行解析，相信会从中学到许多。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习kernel时，结合文档与patch，效果俱佳。本文将对&lt;a href=&quot;https://github.com/projectacrn/acrn-kernel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;acrn-kernel&lt;/a&gt;中acrn/vhm的patch进行解析，相信会从中学到许多。&lt;/p&gt;
    
    </summary>
    
      <category term="acrn" scheme="http://liujunming.github.io/categories/acrn/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="acrn" scheme="http://liujunming.github.io/tags/acrn/"/>
    
  </entry>
  
  <entry>
    <title>中断基本概念的建立</title>
    <link href="http://liujunming.github.io/2019/08/17/%E4%B8%AD%E6%96%AD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <id>http://liujunming.github.io/2019/08/17/中断基本概念的建立/</id>
    <published>2019-08-17T08:14:01.000Z</published>
    <updated>2019-08-17T09:37:47.587Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍PCI、APIC、MSI基本概念。<a id="more"></a></p><p>中断从设备发送到CPU需要“可编程中断控制器”的转发(MSI除外)。中断控制器发展至今，经历了PIC和APIC两个阶段。</p><h2 id="1-PIC"><a href="#1-PIC" class="headerlink" title="1. PIC"></a>1. PIC</h2><p>也就是8259A芯片。PIC的相关介绍参见<a href="https://book.douban.com/subject/3619896/" target="_blank" rel="noopener">系统虚拟化</a>2.4.1章节。</p><p>明白PIC中重要的寄存器以及PIC向CPU递交中断的流程即可。若想深究，可以参见<a href="https://pdos.csail.mit.edu/6.828/2005/readings/hardware/8259A.pdf" target="_blank" rel="noopener">8259A Programmable Interrupt Controller</a></p><h2 id="2-APIC"><a href="#2-APIC" class="headerlink" title="2. APIC"></a>2. APIC</h2><p>PIC可以在UP(单处理器)平台上工作，但无法用于MP(多处理器)平台。为此，APIC应运而生。</p><p><img src="/images/2019/8/9.png" alt><br>APIC的相关介绍参见<a href="https://book.douban.com/subject/3619896/" target="_blank" rel="noopener">系统虚拟化</a>2.4.1章节。</p><p>APIC的发展历程：<br>APIC-&gt;xAPIC-&gt;x2APIC</p><p>LAPIC处理的中断类型有如下三种：</p><ul><li>Local interrupt - configured by local vector table(LVT)</li><li>External interrupt - from IOAPIC/MSI</li><li>inter-processor interrupt(IPI) - configured by interrupt command register(ICR)</li></ul><p>详细内容请参见SDM(ADVANCED PROGRAMMABLE INTERRUPT CONTROLLER)部分。</p><h2 id="3-MSI"><a href="#3-MSI" class="headerlink" title="3. MSI"></a>3. MSI</h2><h3 id="3-1-What-are-MSIs"><a href="#3-1-What-are-MSIs" class="headerlink" title="3.1 What are MSIs?"></a>3.1 What are MSIs?</h3><p>A Message Signaled Interrupt is a write from the device to a special address which causes an interrupt to be received by the CPU.</p><p>The MSI capability was first specified in PCI 2.2 and was later enhanced in PCI 3.0 to allow each interrupt to be masked individually.  The MSI-X capability was also introduced with PCI 3.0.  It supports more interrupts per device than MSI and allows interrupts to be independently configured.</p><h3 id="3-2-Why-use-MSIs"><a href="#3-2-Why-use-MSIs" class="headerlink" title="3.2 Why use MSIs?"></a>3.2 Why use MSIs?</h3><p>There are three reasons why using MSIs can give an advantage over traditional pin-based interrupts.</p><ol><li><p>Pin-based PCI interrupts are often shared amongst several devices. To support this, the kernel must call each interrupt handler associated with an interrupt, which leads to reduced performance for the system as a whole.  MSIs are never shared, so this problem cannot arise. <a href="http://liujunming.top/2018/12/04/Understanding-the-Linux-Kernel-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Interrupts-and-Exceptions/" target="_blank" rel="noopener">for detail</a></p></li><li><p>When a device writes data to memory, then raises a pin-based interrupt, it is possible that the interrupt may arrive before all the data has arrived in memory (this becomes more likely with devices behind PCI-PCI bridges).  In order to ensure that all the data has arrived in memory, the interrupt handler must read a register on the device which raised the interrupt.  PCI transaction ordering rules require that all the data arrive in memory before the value may be returned from the register. Using MSIs avoids this problem as the interrupt-generating write cannot pass the data writes, so by the time the interrupt is raised, the driver knows that all the data has arrived in memory.</p></li><li><p>PCI devices can only support a single pin-based interrupt per function. Often drivers have to query the device to find out what event has occurred, slowing down interrupt handling for the common case.  With MSIs, a device can support more interrupts, allowing each interrupt to be specialised to a different purpose.  </p></li></ol><h3 id="3-3-misc"><a href="#3-3-misc" class="headerlink" title="3.3 misc"></a>3.3 misc</h3><p>intel系统中，MSI允许PCI设备直接发送中断到LAPIC，不需要通过IOAPIC。</p><p>MSI allows the device to write a small amount of interrupt-describing data to a special memory-mapped I/O address, and the chipset then delivers the corresponding interrupt to a processor.</p><p>A common misconception with MSI is that it allows the device to send data to a processor as part of the interrupt. The data that is sent as part of the memory write transaction is used by the chipset to determine which interrupt to trigger on which processor; that data is not available for the device to communicate additional information to the interrupt handler.</p><p>On Intel systems, the LAPIC must be enabled for the PCI (and PCI Express) MSI/MSI-X to work, even on uniprocessor (single core) systems. In these systems, MSIs are handled by writing the interrupt vector directly into the LAPIC of the processor/core that needs to service the interrupt.</p><p>详细内容请参见SDM(MESSAGE SIGNALLED INTERRUPTS)部分。</p><hr><p>参考资料：</p><ol><li><a href="https://elixir.bootlin.com/linux/v5.3-rc4/source/Documentation/PCI/msi-howto.rst" target="_blank" rel="noopener">msi kernel document</a></li><li><a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts" target="_blank" rel="noopener">msi wikipedia</a></li><li><a href="https://www.binss.me/blog/what-is-apic/" target="_blank" rel="noopener">APIC的那些事儿</a></li><li><a href="https://github.com/GiantVM/doc/tree/master/interrupt_and_io" target="_blank" rel="noopener">interrupt_and_io</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍PCI、APIC、MSI基本概念。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>中断那些事</title>
    <link href="http://liujunming.github.io/2019/08/17/%E4%B8%AD%E6%96%AD%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://liujunming.github.io/2019/08/17/中断那些事/</id>
    <published>2019-08-17T07:59:43.000Z</published>
    <updated>2019-08-17T08:15:11.511Z</updated>
    
    <content type="html"><![CDATA[<p>中断，既熟悉，又陌生。<a id="more"></a></p><p>本系列将逐步更新中断相关文章，将会包含如下内容：</p><ol><li>PIC</li><li>APIC</li><li>MSI/MSI-x</li><li>interrupt软件虚拟化</li><li>interrupt硬件虚拟化<ol><li>interrupt remapping</li><li>posted-interrupt</li></ol></li></ol><ul><li><a href="http://liujunming.top/2019/08/17/%E4%B8%AD%E6%96%AD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%9A%84%E5%BB%BA%E7%AB%8B/" target="_blank" rel="noopener">中断基本概念的建立</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中断，既熟悉，又陌生。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>gpio introduction</title>
    <link href="http://liujunming.github.io/2019/08/17/gpio-introduction/"/>
    <id>http://liujunming.github.io/2019/08/17/gpio-introduction/</id>
    <published>2019-08-17T02:14:37.000Z</published>
    <updated>2019-08-17T02:28:24.828Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍gpio的概念与使用方法。<a id="more"></a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>每个GPIO都代表一个连接到特定引脚的一个位。</p><p>“通用输入/输出口”(GPIO)是一个灵活的由软件控制的数字信号。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>gpio的确切含义由主板提供。在安装完gpio的驱动后，就可以在sysfs/class/gpio中使用了。</p><p>看完<a href="https://www.youtube.com/watch?v=i28nmEwwWHo&amp;t=7s" target="_blank" rel="noopener">Linux GPIO access using sysfs</a>后就能明白gpio的使用了。</p><hr><p>参考资料：</p><ol><li><a href="https://www.kernel.org/doc/html/latest/driver-api/gpio/intro.html" target="_blank" rel="noopener">GPIO Introduction</a></li><li><a href="https://www.youtube.com/watch?v=i28nmEwwWHo&amp;t=7s" target="_blank" rel="noopener">Linux GPIO access using sysfs</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍gpio的概念与使用方法。
    
    </summary>
    
      <category term="IO系统" scheme="http://liujunming.github.io/categories/IO%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="IO系统" scheme="http://liujunming.github.io/tags/IO%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about learning kernel &amp;&amp; virtualization</title>
    <link href="http://liujunming.github.io/2019/08/16/Some-notes-about-learning-kernel-virtualization/"/>
    <id>http://liujunming.github.io/2019/08/16/Some-notes-about-learning-kernel-virtualization/</id>
    <published>2019-08-16T12:35:14.000Z</published>
    <updated>2019-08-17T08:15:51.681Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要分享自己的一些学习经验，同时会推荐相关资料与工具。<a id="more"></a></p><p>本页面将持续更新。</p><h2 id="内核资料"><a href="#内核资料" class="headerlink" title="内核资料"></a>内核资料</h2><p>学习内核的最好方法是阅读源码，然而，一上来读源码是不现实的。要明白机理之后读源码才有意义。</p><p>当需要读某一模块源码时，可以按照如下方法去查询资料：</p><ul><li>去内核的Document目录中查询最官方的文档资料</li><li>用关键字去Google、百度中搜索</li><li>去谷歌学术中搜索是否有相关论文</li><li>去<a href="https://software.intel.com/en-us/articles/intel-sdm" target="_blank" rel="noopener">SDM</a>中查询硬件接口信息<ul><li>要能够区分什么事情是硬件做的，什么事情是操作系统做的。以内存寻址为例，操作系统的任务是建立与维护页表，而页表查询是由硬件MMU单元来完成的。</li><li>首先存在硬件，之后根据硬件的接口信息，才能写出相关软件(操作系统)。</li></ul></li><li>阅读相关patch<ul><li>去查询相关模块的git commit history，去阅读每一个patch。</li><li>结合patch中的comment信息与git diff源码信息，可以增进对源码的理解</li></ul></li></ul><h2 id="虚拟化资料"><a href="#虚拟化资料" class="headerlink" title="虚拟化资料"></a>虚拟化资料</h2><ul><li><a href="http://liujunming.top/2019/05/27/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Concurrent and Distributed Systems</a></li><li><a href="https://book.douban.com/subject/3619896/" target="_blank" rel="noopener">系统虚拟化</a><ul><li><strong>虚拟化领域的圣经</strong>，我司出品，必属精品，但有些内容有些陈旧。遗憾的是实体书已经绝版，不过网上有电子资源</li><li>虚拟化最好的入门书籍，若想了解实现细节，只有实践+源码</li></ul></li><li><a href="https://software.intel.com/en-us/articles/intel-sdm" target="_blank" rel="noopener">SDM</a><ul><li>查询硬件辅助虚拟化的相关硬件信息</li></ul></li><li>我部门的内部培训资料<ul><li>很多培训资料，由于是保密资料，所以不能分享</li><li>若想学习，欢迎来我司。简历可以发我邮箱:<a href="mailto:junming.liu@intel.com" target="_blank" rel="noopener">junming.liu@intel.com</a></li></ul></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>tig<ul><li>tig 文件，可以查看该文件的commit history</li><li>tig 目录，可以查看该目录的commit history</li><li>这样，可以查询到某一模块的相关patch，就可以开始啃源码了</li></ul></li></ul><h2 id="后续博客内容"><a href="#后续博客内容" class="headerlink" title="后续博客内容"></a>后续博客内容</h2><p>立个flag，将在后续博客中，将理论结合源码，推出如下系列文章。</p><ul><li><a href="http://liujunming.top/2019/08/17/%E4%B8%AD%E6%96%AD%E9%82%A3%E4%BA%9B%E4%BA%8B/" target="_blank" rel="noopener">中断那些事</a></li><li>ACRN hypervisor那些事</li><li>ACRN kernel那些事</li><li>BOOT那些事</li><li>CPU虚拟化那些事</li><li>内存虚拟化那些事</li><li>IO虚拟化那些事</li><li>GPU &amp; GVT那些事</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要分享自己的一些学习经验，同时会推荐相关资料与工具。
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>What is Kernel mode-setting?</title>
    <link href="http://liujunming.github.io/2019/08/15/What-is-Kernel-mode-setting/"/>
    <id>http://liujunming.github.io/2019/08/15/What-is-Kernel-mode-setting/</id>
    <published>2019-08-15T11:33:40.000Z</published>
    <updated>2019-08-15T11:47:59.519Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简要地介绍Kernel mode-setting。<br><a id="more"></a><br>在今天的工作中，遇到了<code>i915.modeset=0</code>这一选项，故mark下笔记。</p><p>Mode setting is a software operation that activates a display mode (screen resolution, color depth, and refresh rate) for a computer’s display controller.</p><p>In kernel mode-setting (KMS), the display mode is set by the kernel. In user-space mode-setting (UMS), the display mode is set by a userland process.</p><p>Kernel mode-setting is more flexible and allows displaying of an error in the case of a fatal system error in the kernel, even when using a user-space display server.</p><p>内核级显示模式设置 (KMS) ，作用是可以在内核级别而不是最终用户级别切换显示分辨率和颜色深度。</p><p><img src="/images/2019/8/8.png" alt><br><em>Regulating access to the hardware is a fundamental kernel task. The Direct Rendering Manager and KMS are part of the Linux kernel. The KMS does only the mode setting.</em></p><hr><p>参考资料：</p><ol><li><a href="https://unix.stackexchange.com/questions/110573/what-is-i915-modeset-1-for" target="_blank" rel="noopener">What is i915.modeset=1 for?</a></li><li><a href="https://www.wikiwand.com/en/Mode_setting" target="_blank" rel="noopener">Mode setting</a></li><li><a href="https://wiki.archlinux.org/index.php/Kernel_mode_setting_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">Kernel mode setting</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简要地介绍Kernel mode-setting。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>x86 CPU的MSR寄存器</title>
    <link href="http://liujunming.github.io/2019/08/12/x86-CPU%E7%9A%84MSR%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://liujunming.github.io/2019/08/12/x86-CPU的MSR寄存器/</id>
    <published>2019-08-12T14:54:34.000Z</published>
    <updated>2019-08-15T11:13:59.042Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简要地介绍MSR（Model Specific Register）。<a id="more"></a>内容来源于<a href="https://zhuanlan.zhihu.com/p/50142793" target="_blank" rel="noopener">x86 CPU的MSR寄存器</a>。</p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>MSR（Model Specific Register）是x86架构中的概念，指的是在x86架构处理器中，一系列用于控制CPU运行、功能开关、调试、跟踪程序执行、监测CPU性能等方面的寄存器。</p><h2 id="2-发展"><a href="#2-发展" class="headerlink" title="2. 发展"></a>2. 发展</h2><p>到Intel Pentium处理器的时候，Intel正式引入<code>RDMSR</code>和<code>WRMSR</code>两个指令用于读和写MSR寄存器，这个时候MSR就算被正式引入。在引入<code>RDMSR</code>和<code>WRMSR</code>指令的同时，也引入了<code>CPUID</code>指令，该指令用于指明具体的CPU芯片中，哪些功能是可用的，或者这些功能对应的MSR寄存器是否存在，软件可以通过<code>CPUID</code>指令查询某些功能是否在当前CPU上是否支持。</p><h2 id="3-MSR的访问方式"><a href="#3-MSR的访问方式" class="headerlink" title="3. MSR的访问方式"></a>3. MSR的访问方式</h2><p>每个MSR寄存器都会有一个相应的ID，即MSR Index，或者也叫作MSR寄存器地址，当执行RDMSR或者WRMSR指令的时候，只要提供MSR Index就能让CPU知道目标MSR寄存器。这些MSR寄存器的编号（MSR Index）、名字及其各个数据区域的定义可以在Intel x86架构手册”Intel 64 and IA-32 Architectures Software Developer’s Manual”的<a href="https://software.intel.com/sites/default/files/managed/22/0d/335592-sdm-vol-4.pdf" target="_blank" rel="noopener">Volume 4</a>中找到。</p><h2 id="4-相关介绍"><a href="#4-相关介绍" class="headerlink" title="4. 相关介绍"></a>4. 相关介绍</h2><p>MSR顾名思义就是Model Specific，即不同的CPU型号或不同的CPU厂商（Intel和AMD都会做x86架构的处理器），它的MSR寄存器可能是不一样的，它会根据具体的CPU型号的变化而变化，每款新的CPU都有可能引入新的MSR寄存器。</p><p>事实证明，MSR寄存器的引入用处还是很大的，有一些MSR寄存器甚至是MSR寄存器的部分区域将会被固定下来，并且未来的CPU都会支持这些MSR寄存器或者MSR寄存器的部分区域，这类MSR寄存器就叫做“Architecture MSRs”，Architecture MSR由于历史的原因（Pentium处理器是32位的），它的名字都是以”IA32_”为前缀的，即使是在目前主流的64位x86处理器中也是这样命名。</p><p>对于Intel的x86 CPU和AMD的x86 CPU而言，它们的MSR寄存器可能会有区别，但是可能因为各种原因，或者为了软件的兼容性，它们的部分MSR寄存器是一样的，如IA32_LSTAR。</p><hr><p>参考资料：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/50142793" target="_blank" rel="noopener">x86 CPU的MSR寄存器</a></li><li><a href="https://www.quora.com/How-do-x86-CPUs-use-the-model-specific-registers" target="_blank" rel="noopener">How do x86 CPUs use the model-specific registers?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简要地介绍MSR（Model Specific Register）。
    
    </summary>
    
      <category term="体系结构" scheme="http://liujunming.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>sysfs、udev 和 它们背后的 Linux 统一设备模型</title>
    <link href="http://liujunming.github.io/2019/08/11/sysfs%E3%80%81udev%20%E5%92%8C%20%E5%AE%83%E4%BB%AC%E8%83%8C%E5%90%8E%E7%9A%84%20Linux%20%E7%BB%9F%E4%B8%80%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"/>
    <id>http://liujunming.github.io/2019/08/11/sysfs、udev 和 它们背后的 Linux 统一设备模型/</id>
    <published>2019-08-11T02:38:40.000Z</published>
    <updated>2019-08-11T02:55:35.447Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自<a href="https://www.binss.me/blog/sysfs-udev-and-Linux-Unified-Device-Model/" target="_blank" rel="noopener">sysfs、udev 和 它们背后的 Linux 统一设备模型</a></p><p>详细内容请参考<a href="http://www.wowotech.net/sort/device_model" target="_blank" rel="noopener">统一设备模型</a>。</p><a id="more"></a><h2 id="1-sysfs-诞生之前"><a href="#1-sysfs-诞生之前" class="headerlink" title="1. sysfs 诞生之前"></a>1. sysfs 诞生之前</h2><p>一切皆文件，这是 Linux 的哲学之一。设备当然也不例外，它们往往被抽象成文件，存放在 /dev 目录下供用户进程进行操作。用户通过这些设备文件，可以实现对硬件进行相应的操作。而这些设备文件，需要由对应的设备文件系统来负责管理。</p><p>在 kernel 2.6 之前，完成这一使命的是 devfs。devfs 是 Linux 2.4 引入的一个虚拟的文件系统，挂载在 /dev 目录下。可以动态地为设备在 /dev 下创建或删除相应的设备文件，只生成存在设备的节点。</p><p>然而它存在以下缺点：</p><ul><li>可分配的<a href="https://nanxiao.me/linux-kernel-note-20-device-major-minor-number/" target="_blank" rel="noopener">设备号</a>数目 (major / minor) 受到限制</li><li>设备映射不确定，一个设备所对应的设备文件可能发生改变</li><li>设备名称在内核或模块中写死，违反了内核开发的原则</li><li>缺乏热插拔机制</li></ul><p>随着 kernel 的发展，从 Linux 2.6 起，devfs 被 sysfs + udev 所取代。sysfs + udev 在设计哲学和现实中的易用性都比 devfs 更优，自此 sysfs + udev 的组合走上 mainline ，直至目前，依然作为 Linux 的设备管理手段。</p><h2 id="2-sysfs"><a href="#2-sysfs" class="headerlink" title="2. sysfs"></a>2. sysfs</h2><p>sysfs 是一个基于内存的虚拟的文件系统，由 kernel 提供，挂载到 /sys 目录下(用 mount 查看得到 <code>sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)</code>)，负责以设备树的形式向 user space 提供直观的设备和驱动信息。</p><p>sysfs 以不同的视角展示当前系统接入的设备：</p><ul><li><p>/sys/block 历史遗留问题，存放块设备，提供以设备名 (如 sda) 到 / sys/devices 的符号链接</p></li><li><p>/sys/bus(对应kernel中的 <code>struct bus_type</code>) 按总线类型分类，在某个总线目录之下可以找到连接该总线的设备的符号链接，指向 / sys/devices。某个总线目录之下的 drivers 目录包含了该总线所需的所有驱动的符号链接。</p></li><li><p>/sys/class(对应kernel中的<code>struct class</code>) 按设备功能分类，如输入设备在 /sys/class/input 之下，图形设备在 /sys/class/graphics 之下，是指向 /sys/devices 目录下对应设备的符号链接。</p></li><li><p>/sys/dev(对应kernel中的<code>struct device_driver</code>)按设备驱动程序分层(字符设备/块设备)，提供以 major:minor 为名到/sys/devices 的符号链接。</p></li><li><p>/sys/devices(对应kernel中的<code>struct device</code>) 包含所有被发现的注册在各种总线上的各种物理设备。<br>所有的物理设备都按其在总线上的拓扑结构来显示，除了 platform devices 和 system devices：</p><ul><li>platform devices 一般是挂在芯片内部高速或者低速总线上的各种控制器和外设，能被 CPU 直接寻址。</li><li>system devices 不是外设，他是芯片内部的核心结构，比如 CPU，timer 等，他们一般没有相关的 driver，但是会有一些体系结构相关的代码来配置他们。</li></ul></li><li><p>/sys/firmware 提供对固件的查询和操作接口(关于固件有专用于固件加载的一套API)。</p></li><li><p>/sys/fs 描述当前加载的文件系统，提供文件系统和文件系统已挂载设备信息。</p></li><li><p>/sys/hypervisor 如果开启了 Xen，这个目录下会提供相关属性文件。</p></li><li><p>/sys/kernel 提供 kernel 所有可调整参数，但大多数可调整参数依然存放在 sysctl(/proc/sys/kernel)。</p></li><li><p>/sys/module 所有加载模块 (包括内联、编译进 kernel、外部的模块) 的信息，按模块类型分类。</p></li><li><p>/sys/power 电源选项，可用于控制整个机器的电源状态，如写入控制命令进行关机、重启等。</p></li></ul><p>sysfs 支持多视角查看，通过符号链接，同样的信息可以出现在多个目录下。</p><p>以硬盘 sda 为例，既可以在块设备目录/sys/block/下找到，又可以在所有设备目录/sys/devices/pci0000:00/0000:00:10.0/host32/target32:0:0/ 下找到。</p><p>查看 sda1 设备目录下的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ ll /sys/block/sda/</span><br><span class="line">drwxr-xr-x 11 root root    0 Feb  3 04:32 ./</span><br><span class="line">drwxr-xr-x  3 root root    0 Feb  3 04:32 ../</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 alignment_offset</span><br><span class="line">lrwxrwxrwx  1 root root    0 Feb  3 04:32 bdi -&gt; ../../../../../../../virtual/bdi/8:0/</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 capability</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 dev</span><br><span class="line">lrwxrwxrwx  1 root root    0 Feb  3 04:32 device -&gt; ../../../2:0:0:0/</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 discard_alignment</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 events</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 events_async</span><br><span class="line">-rw-r--r--  1 root root 4096 Feb  3 04:32 events_poll_msecs</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 ext_range</span><br><span class="line">drwxr-xr-x  2 root root    0 Feb  3 04:32 holders/</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 inflight</span><br><span class="line">drwxr-xr-x  2 root root    0 Feb  3 04:32 integrity/</span><br><span class="line">drwxr-xr-x  2 root root    0 Feb  3 04:32 power/</span><br><span class="line">drwxr-xr-x  3 root root    0 Feb  3 04:32 queue/</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 range</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 removable</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 ro</span><br><span class="line">drwxr-xr-x  5 root root    0 Feb  3 04:32 sda1/</span><br><span class="line">drwxr-xr-x  5 root root    0 Feb  3 04:32 sda2/</span><br><span class="line">drwxr-xr-x  5 root root    0 Feb  3 04:32 sda5/</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 size</span><br><span class="line">drwxr-xr-x  2 root root    0 Feb  3 04:32 slaves/</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 stat</span><br><span class="line">lrwxrwxrwx  1 root root    0 Feb  3 04:32 subsystem -&gt; ../../../../../../../../class/block/</span><br><span class="line">drwxr-xr-x  2 root root    0 Feb  3 04:32 trace/</span><br><span class="line">-rw-r--r--  1 root root 4096 Feb  3 04:32 uevent</span><br></pre></td></tr></table></figure></p><p>目录以文件的形式提供了设备的信息，比如 dev 记录了主设备号和次设备号，size 记录了分区大小，uevent 存放了 uevent 的标识符等：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/block/sda/size</span><br><span class="line">41943040</span><br></pre></td></tr></table></figure></p><h2 id="3-统一设备模型"><a href="#3-统一设备模型" class="headerlink" title="3. 统一设备模型"></a>3. 统一设备模型</h2><p>sysfs 的功能基于 Linux 的统一设备模型，其由以下结构构成：</p><h3 id="3-1-Kobject"><a href="#3-1-Kobject" class="headerlink" title="3.1 Kobject"></a>3.1 Kobject</h3><p>目前为止，Kobject主要提供如下功能：</p><ol><li>通过parent指针，可以将所有Kobject以层次结构的形式组合起来。</li><li>使用一个引用计数（reference count），来记录Kobject被引用的次数，并在引用次数变为0时把它释放。</li><li>和sysfs虚拟文件系统配合，将每一个Kobject及其特性，以文件的形式，开放到用户空间。</li></ol><p>在描述数据结构之前，有必要说明一下Kobject, Kset和Ktype这三个概念。</p><ul><li><p>Kobject是基本数据类型，每个Kobject都会在”/sys/“文件系统中以目录的形式出现。</p></li><li><p>Ktype代表Kobject（严格地讲，是包含了Kobject的数据结构）的属性操作集合（由于通用性，多个Kobject可能共用同一个属性操作集，因此把Ktype独立出来了）。 </p></li><li><p>Kset是一个特殊的Kobject（因此它也会在”/sys/“文件系统中以目录的形式出现），它用来集合相似的Kobject（这些Kobject可以是相同属性的，也可以不同属性的）。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *name;                      <span class="comment">// 名称，将在 sysfs 中作为目录名</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">entry</span>;</span>                  <span class="comment">// 加入 kset 链表的结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>      *<span class="title">parent</span>;</span>                <span class="comment">// 父节点指针，构成树状结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>     *<span class="title">kset</span>;</span>                      <span class="comment">// 指向所属 kset</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>    *<span class="title">ktype</span>;</span>                 <span class="comment">// 类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span>  *<span class="title">sd</span>;</span>                    <span class="comment">// 指向所属 (sysfs) 目录项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>     <span class="title">kref</span>;</span>                       <span class="comment">// 引用计数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">release</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;           <span class="comment">// 是否已经初始化</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;              <span class="comment">// 是否已在 sysfs 中显示</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;       <span class="comment">// 是否已经向 user space 发送 ADD uevent</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;    <span class="comment">// 是否已经向 user space 发送 REMOVE uevent</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;             <span class="comment">// 是否忽略上报(不上报 uevent)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*release)(struct kobject *kobj);      <span class="comment">// 析构函数，kobject 的引用计数为 0 时调用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span>          <span class="comment">// 操作函数，当用户读取 sysfs 属性时调用 show()，写入 sysfs 属性时调用 store()</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span>           <span class="comment">// 默认属性，体现为该 kobject 目录下的文件</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="title">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span>   <span class="comment">// namespace 操作函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct kobject *kobj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>                      <span class="comment">// kobject 链表头</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;                       <span class="comment">// 自旋锁，保障操作安全</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>                        <span class="comment">// 自身的 kobject</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span>   <span class="comment">// uevent 操作函数集。kobject 发送 uevent 时会调用所属 kset 的 uevent_ops</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结: </p><ul><li><p>Kobject的核心功能是：保持一个引用计数，当该计数减为0时，自动释放Kobject所占用的meomry空间。这就决定了Kobject必须是动态分配的（只有这样才能动态释放）。 </p></li><li><p>Kobject大多数的使用场景，是内嵌在大型的数据结构中，因此这些大型的数据结构，也必须是动态分配、动态释放的。那么释放的时机是什么呢？是内嵌的Kobject释放时。但是Kobject的释放是由Kobject模块自动完成的（在引用计数为0时），那么怎么一并释放包含自己的大型数据结构呢？ </p></li><li><p>这时Ktype就派上用场了。我们知道，Ktype中的release回调函数负责释放Kobject（甚至是包含Kobject的数据结构）的内存空间，那么Ktype及其内部函数，是由谁实现呢？是由上层数据结构所在的模块！因为只有它，才清楚Kobject嵌在哪个数据结构中，并通过Kobject指针以及自身的数据结构类型，找到需要释放的上层数据结构的指针，然后释放它。 </p></li><li><p>每一个内嵌Kobject的数据结构，例如device、device_driver等等，都要实现一个Ktype，并定义其中的回调函数。同理，sysfs相关的操作也一样，必须经过ktype的中转，因为sysfs看到的是Kobject，而真正的文件操作的主体，是内嵌Kobject的上层数据结构。</p></li></ul><h3 id="3-2-device-driver-bus-class"><a href="#3-2-device-driver-bus-class" class="headerlink" title="3.2 device / driver / bus / class"></a>3.2 device / driver / bus / class</h3><p>详细内容参考<a href="http://www.wowotech.net/device_model/13.html" target="_blank" rel="noopener">Linux设备模型(1)_基本概念</a>。</p><p>device / driver / bus / class 四者之间存在着这样的关系：</p><ul><li>driver 用于驱动 device ，其保存了所有能够被它所驱动的设备链表。</li><li>bus 是连接 CPU 和 device 的桥梁，其保存了所有挂载在它上面的设备链表和驱动这些设备的驱动链表。</li><li>class 用于描述一类 device ，其保存了所有该类 device 的设备链表。</li></ul><h3 id="3-3-attribute"><a href="#3-3-attribute" class="headerlink" title="3.3 attribute"></a>3.3 attribute</h3><p>用于定义设备模型中的各项属性。基本属性有两种，分别为普通属性 attribute 和二进制属性 bin_attribute</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *name;              <span class="comment">// 属性名</span></span><br><span class="line">    <span class="keyword">umode_t</span>         mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="keyword">bool</span>            ignore_lockdep:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>   *<span class="title">key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>   <span class="title">skey</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>    <span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span>          size;</span><br><span class="line">    <span class="keyword">void</span>            *<span class="keyword">private</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read)(struct file *, struct kobject *, struct bin_attribute *,</span><br><span class="line">            <span class="keyword">char</span> *, <span class="keyword">loff_t</span>, <span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write)(struct file *, struct kobject *, struct bin_attribute *,</span><br><span class="line">             <span class="keyword">char</span> *, <span class="keyword">loff_t</span>, <span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">int</span> (*mmap)(struct file *, struct kobject *, struct bin_attribute *attr,</span><br><span class="line">            struct vm_area_struct *vma);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 attribute 生成的 sysfs 文件，只能用字符串的形式读写。而 struct bin_attribute 在 attribute 的基础上，增加了 read、write 等函数，因此它所生成的 sysfs 文件可以用任何方式读写。</p><h2 id="4-udev-amp-amp-uevent"><a href="#4-udev-amp-amp-uevent" class="headerlink" title="4. udev &amp;&amp; uevent"></a>4. udev &amp;&amp; uevent</h2><p><a href="https://insujang.github.io/2018-11-27/udev-device-manager-for-the-linux-kernel-in-userspace/" target="_blank" rel="noopener">udev: Device Manager for the Linux Kernel in Userspace</a>很好地介绍了udev。</p><h3 id="4-1-What-is-udev"><a href="#4-1-What-is-udev" class="headerlink" title="4.1 What is udev?"></a>4.1 What is udev?</h3><blockquote><p>udev (userspace /dev) is a device manager for the Linux kernel. As the successor of devfsd and hotplug, udev primaily manages device nodes in the /dev directory. At the same time, udev also handls all user space events raised when hardware devices are added into the system or removed from it, including firmware loading as reuqired by certain devices.</p></blockquote><h3 id="4-2-Why-was-udev-developed"><a href="#4-2-Why-was-udev-developed" class="headerlink" title="4.2 Why was udev developed?"></a>4.2 Why was udev developed?</h3><p>/dev directory is where all device files for the system are loaded (note that everything in Linux is files, so are devices). This directory had been managed by devfs filesystem until Linux kernel version 2.5. The introduction of devfs solved some problem, however, still many problems remained. </p><p>udev was started to solve all of those problems, and its goals are:</p><ul><li>Run in userspace (doing so we save kernel memory space that was wasted by saving device naming rules)</li><li>Create a dynamic /dev (automatically creates or removes device entries in /dev when devices are inserted or removed)</li><li>Provide consistent device naming </li><li>Provide a userspace API to access info about current system devices</li></ul><h3 id="4-3-How-to-use-udev"><a href="#4-3-How-to-use-udev" class="headerlink" title="4.3 How to use udev?"></a>4.3 How to use udev?</h3><p>看完<a href="https://www.youtube.com/watch?v=eV4InZop--0" target="_blank" rel="noopener">使用udev修改设备默认名称</a>可以理解udev的使用。</p><h3 id="4-4-udev的构成"><a href="#4-4-udev的构成" class="headerlink" title="4.4 udev的构成"></a>4.4 udev的构成</h3><ol><li>libudev 函数库，提供获取设备信息的接口</li><li>udevd 处于 user namespace 的管理软件。管理 / dev 下的设备文件。</li><li>udevadm 命令行工具。可用来向 udevd 发送指令。</li></ol><h3 id="4-5-uevent的功能"><a href="#4-5-uevent的功能" class="headerlink" title="4.5 uevent的功能"></a>4.5 uevent的功能</h3><p>uevent是Kobject的一部分，用于在Kobject状态发生改变时，例如增加、移除等，通知用户空间程序。用户空间程序收到这样的事件后，会做相应的处理。</p><p>该机制通常是用来支持热拔插设备的，例如U盘插入后，USB相关的驱动软件会动态创建用于表示该U盘的device结构（相应的也包括其中的kobject），并告知用户空间程序，为该U盘动态的创建/dev/目录下的设备节点，更进一步，可以通知其它的应用程序，将该U盘设备mount到系统中，从而动态的支持该设备。</p><h3 id="4-6-uevent在kernel中的位置"><a href="#4-6-uevent在kernel中的位置" class="headerlink" title="4.6 uevent在kernel中的位置"></a>4.6 uevent在kernel中的位置</h3><p>下面图片描述了uevent模块在内核中的位置：<br><img src="/images/2019/8/7.gif" alt></p><p>由此可知，uevent的机制是比较简单的，设备模型中任何设备有事件需要上报时，会触发uevent提供的接口。uevent模块准备好上报事件的格式后，可以通过两个途径把事件上报到用户空间：一种是通过kmod模块，直接调用用户空间的可执行文件；另一种是通过netlink通信机制，将事件从内核空间传递给用户空间。</p><h3 id="4-7-mdev"><a href="#4-7-mdev" class="headerlink" title="4.7 mdev"></a>4.7 mdev</h3><ul><li>udev是基于netlink机制的，它在系统启动时运行了一个deamon程序udevd，通过监听内核发送的uevent 来执行相应的热拔插动作，包括创建/删除设备节点，加载/卸载驱动模块等等。</li><li>mdev是基于uevent_helper机制的，它在系统启动时修改了内核中的uevnet_helper 变量（通过写/proc/sys/kernel/hotplug），值为“/sbin/mdev”。</li><li>udev 使用的netlink 机制在有大量uevent 的场合效率高，适合用在PC 机上；而mdev 使用的uevent_helper 机制实现简单，适合用在嵌入式系统中。</li></ul><hr><p>参考资料：</p><ol><li><a href="https://segmentfault.com/a/1190000011010908" target="_blank" rel="noopener">Linux Udev</a></li><li><a href="https://blog.csdn.net/W1107101310/article/details/80211885" target="_blank" rel="noopener">嵌入式Linux——uevent机制：uevent原理分析</a></li><li><a href="https://insujang.github.io/2018-11-27/udev-device-manager-for-the-linux-kernel-in-userspace/" target="_blank" rel="noopener">udev: Device Manager for the Linux Kernel in Userspace</a></li><li><a href="https://www.youtube.com/watch?v=eV4InZop--0" target="_blank" rel="noopener">使用udev修改设备默认名称</a></li><li><a href="https://blog.csdn.net/hunanchenxingyu/article/details/40432275" target="_blank" rel="noopener">mdev和udev机制并不相同</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自&lt;a href=&quot;https://www.binss.me/blog/sysfs-udev-and-Linux-Unified-Device-Model/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sysfs、udev 和 它们背后的 Linux 统一设备模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详细内容请参考&lt;a href=&quot;http://www.wowotech.net/sort/device_model&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;统一设备模型&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="IO系统" scheme="http://liujunming.github.io/categories/IO%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="IO系统" scheme="http://liujunming.github.io/tags/IO%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>IOMMU的简单介绍</title>
    <link href="http://liujunming.github.io/2019/08/10/IOMMU%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://liujunming.github.io/2019/08/10/IOMMU的简单介绍/</id>
    <published>2019-08-10T01:15:13.000Z</published>
    <updated>2019-08-10T11:26:07.066Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍下IOMMU的相关知识点，相关细节，将在后续的文章中，结合代码，详细讲解。<br><a id="more"></a><br>本文内容是对相关材料的汇总，并非原创。详情参见文章末尾的参考资料。</p><h2 id="1-什么是IOMMU"><a href="#1-什么是IOMMU" class="headerlink" title="1. 什么是IOMMU"></a>1. 什么是IOMMU</h2><p>IOMMU（Input/Output Memory Management Unit）是一个内存管理单元（Memory Management Unit），它的作用是连接DMA-capable I/O总线（Direct Memory Access-capable I/O Bus）和主存（main memory）。传统的内存管理单元会把CPU访问的虚拟地址转化成实际的物理地址。而IOMMU则是把设备（device）访问的虚拟地址转化成物理地址。</p><p><img src="/images/2019/8/4.png" alt></p><h2 id="2-为什么要有IOMMU"><a href="#2-为什么要有IOMMU" class="headerlink" title="2. 为什么要有IOMMU"></a>2. 为什么要有IOMMU</h2><p>首先，我们看下没有IOMMU的世界吧。</p><h3 id="2-1-physical-DMA-without-IOMMU"><a href="#2-1-physical-DMA-without-IOMMU" class="headerlink" title="2.1 physical DMA without IOMMU"></a>2.1 physical DMA without IOMMU</h3><ul><li>一些设备需要大量的物理连续内存，但是os无法为其分配。可以有如下解决方案：<ul><li>在内核启动是为设备保留内存</li><li>将MMU内嵌到设备中，如<a href="http://liujunming.top/2019/07/16/Intel-GPU-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">GPU</a></li></ul></li><li>一些设备有DMA寻址限制，例如，只支持32位的DMA寻址。可以有如下解决方案：<ul><li><a href="http://www.chudov.com/tmp/LinuxVM/html/understand/node65.html" target="_blank" rel="noopener">Bounce buffer</a></li></ul></li><li>没有内存保护机制，设备可能会错误地访问内存地址</li><li>不能支持PCI设备的<a href="http://liujunming.top/pdf/passthrough.pdf" target="_blank" rel="noopener">pass-through</a></li></ul><p>接下来，我们看下拥有IOMMU的世界吧。</p><h3 id="2-2-with-IOMMU"><a href="#2-2-with-IOMMU" class="headerlink" title="2.2 with IOMMU"></a>2.2 with IOMMU</h3><ul><li>使用更大的DMA寻址空间<ul><li>每个设备都用自己独立的DMA内存寻址空间</li></ul></li><li>使用更大的连续DMA内存<ul><li>可以将非连续的物理内存映射到连续的DMA内存空间中</li><li>避免使用<a href="https://knowledge.ni.com/KnowledgeArticleDetails?id=kA00Z0000019NMqSAM" target="_blank" rel="noopener">scatter-gather list</a></li></ul></li><li>避免使用<a href="http://www.chudov.com/tmp/LinuxVM/html/understand/node65.html" target="_blank" rel="noopener">Bounce buffer</a></li><li>提供了访问内存保护机制<ul><li>防止设备错误地访问内存</li></ul></li><li>支持PCI设备的<a href="http://liujunming.top/pdf/passthrough.pdf" target="_blank" rel="noopener">pass-through</a></li></ul><h2 id="3-IOMMU在虚拟化中的用途"><a href="#3-IOMMU在虚拟化中的用途" class="headerlink" title="3. IOMMU在虚拟化中的用途"></a>3. IOMMU在虚拟化中的用途</h2><p>IOMMU的一个重要用途是在虚拟化技术（virtualization）：虚拟机上运行的操作系统（guest OS）通常不知道它所访问的host-physical内存地址。如果要进行DMA操作，就有可能破坏内存，因为实际的硬件（hardware）不知道guest-physical和host-physical内存地址之间的映射关系。IOMMU根据guest-physical和host-physical内存地址之间的转换表（translation table），re-mapping硬件访问的地址，就可以解决这个问题。</p><p>在AMD的<a href="http://pages.cs.wisc.edu/~basu/isca_iommu_tutorial/IOMMU_TUTORIAL_ASPLOS_2016.pdf" target="_blank" rel="noopener">VIRTUALIZING IO THROUGH THE IO MEMORY MANAGEMENT UNIT (IOMMU)</a>文档中，也有一个更全面的总结图：</p><p><img src="/images/2019/8/5.jpg" alt></p><p>引入虚拟化后，带来的问题是：设备看到的是GPA(guest physical address)，但是访问的是HPA(host physical address)。</p><h3 id="3-1-per-BDF-DMA-remapping"><a href="#3-1-per-BDF-DMA-remapping" class="headerlink" title="3.1 per-BDF DMA remapping"></a>3.1 per-BDF DMA remapping</h3><blockquote><p>DMA Remapping通过IOMMU页表方式将直通设备对内存的访问限制到特定的domain中，在提高IO性能的同时完成了直通设备的隔离，保证了直通设备DMA的安全性。</p></blockquote><p><img src="/images/2019/8/6.png" alt></p><h3 id="3-2-interrupt-remapping"><a href="#3-2-interrupt-remapping" class="headerlink" title="3.2 interrupt remapping"></a>3.2 interrupt remapping</h3><blockquote><p>Interrupt Remapping则提供IO设备的中断重映射和路由功能，来达到中断隔离和中断迁移的目的，提升了虚拟化环境下直通设备的中断处理效率。</p></blockquote><blockquote><p>为什么要搞中断重映射这么一套东西呢？直通设备的中断不能直通到虚拟机内部吗？ 我们知道直通场景下直通设备的MSI/MSI-X Msg信息都是由Guest直接分配的，那么问题来了：设备发送中断的时候写的Msg地址是GPA，肯定不能直接往host上投递，否则就乱套了。在虚拟化场景下，直通设备的中断是无法直接投递到Guest中的，那么我们该怎么办？我们可以由IOMMU截获中断，先将中断映射到host的某个中断上，然后再重定向（由VMM投递）到Guest内部。</p></blockquote><p>对于MSI/MSI-X中断机制的相关知识，会在后续的文章中陆续推出。</p><hr><p>参考资料：</p><ol><li><a href="https://lists.linuxfoundation.org/pipermail/iommu/2011-November/003185.html" target="_blank" rel="noopener">Kai Huang mail.kai.huang at gmail.com </a></li><li><a href="https://nanxiao.me/iommu-introduction/" target="_blank" rel="noopener">什么是IOMMU？</a></li><li><a href="https://invisiblethingslab.com/resources/2011/Software%20Attacks%20on%20Intel%20VT-d.pdf" target="_blank" rel="noopener">Software attacks against Intel(R) VT-d technology</a></li><li><a href="https://kernelgo.org/interrupt-remapping.html" target="_blank" rel="noopener">VT-d Interrupt Remapping</a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2019/08/04/iommu-introduction" target="_blank" rel="noopener">IOMMU introduction</a></li><li><a href="https://www.wikiwand.com/en/Input%E2%80%93output_memory_management_unit" target="_blank" rel="noopener">Input–output memory management unit</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍下IOMMU的相关知识点，相关细节，将在后续的文章中，结合代码，详细讲解。&lt;br&gt;
    
    </summary>
    
      <category term="IO系统" scheme="http://liujunming.github.io/categories/IO%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="IO系统" scheme="http://liujunming.github.io/tags/IO%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Makefile 与Linux内核编译系统kbuild</title>
    <link href="http://liujunming.github.io/2019/08/09/Makefile-%E4%B8%8ELinux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9Fkbuild/"/>
    <id>http://liujunming.github.io/2019/08/09/Makefile-与Linux内核编译系统kbuild/</id>
    <published>2019-08-09T10:41:16.000Z</published>
    <updated>2019-08-15T12:12:48.160Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://blog.csdn.net/thisway_diy/article/details/76981113" target="_blank" rel="noopener">内核的Makefile、Kconfig和.config文件</a></p><a id="more"></a><p>如果对makefile一点不懂，可以参考<a href="http://liujunming.top/2017/07/15/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">makefile入门教程</a>。</p><p>最权威资料请查阅<a href="https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt" target="_blank" rel="noopener">Linux Kernel Makefiles</a>。</p><p>Linux内核源码文件繁多，搞不清Makefile、Kconfig、.config间的关系，不了解内核编译体系，编译修改内核有问题无从下手，自己写的驱动不知道怎么编进内核，不知道怎么配置内核，这些问题都和Makefile、Kconfig、.config有关，下面简单谈谈Makefile、Kconfig和.config。</p><h2 id="1-三者的作用"><a href="#1-三者的作用" class="headerlink" title="1. 三者的作用"></a>1. 三者的作用</h2><p>简单来说就是去饭店点菜：Kconfig是菜单，Makefile是做法，.config就是你点的菜。</p><ul><li><p>Makefile：一个文本形式的文件，编译源文件的方法。</p></li><li><p>Kconfig：一个文本形式的文件，内核的配置菜单。</p></li><li><p>.config：编译内核所依据的配置。</p></li></ul><h2 id="2-三者的语法"><a href="#2-三者的语法" class="headerlink" title="2. 三者的语法"></a>2. 三者的语法</h2><h3 id="2-1-Makefile"><a href="#2-1-Makefile" class="headerlink" title="2.1 Makefile"></a>2.1 Makefile</h3><p>参考：linux-3.4.2/drivers/Makefile</p><p>作用：用来定义哪些内容作为模块编译，哪些条件编译等。子目录Makefile被顶层Makefile包含。</p><ol><li><p>直接编译<br><code>obj-y      +=xxx.o</code><br>表示由xxx.c或xxx.s编译得到xxx.o并直接编进内核。</p></li><li><p>条件编译<br><code>obj -$(CONFIG_HELLO)  +=xxx.o</code><br>根据.config文件的CONFIG_XXX来决定文件是否编进内核。</p></li><li><p>模块编译<br><code>obj-m     +=xxx.o</code><br>表示xxx作为模块编译，即执行make modules时才会被编译。</p></li></ol><h3 id="2-2-Kconfig"><a href="#2-2-Kconfig" class="headerlink" title="2.2 Kconfig"></a>2.2 Kconfig</h3><p>每个config菜单项都有类型定义: bool布尔类型、 tristate三态(内建、模块、移除)、string字符串、 hex十六进制、integer整型。 </p><p>作用：决定make menuconfig时展示的菜单项，</p><p>参考：linux-3.4.2/drivers/leds/kconfig：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config LEDS_S3C24XX</span><br><span class="line">       tristate&quot;LED Support for Samsung S3C24XX GPIO LEDs&quot;</span><br><span class="line">       dependson LEDS_CLASS</span><br><span class="line">       dependson ARCH_S3C24XX</span><br><span class="line">       help</span><br><span class="line">         This option enables support for LEDs connected to GPIO lines on Samsung S3C24XX series CPUs, such as the S3C2410 and S3C2440.</span><br></pre></td></tr></table></figure></p><p><code>LEDS_S3C24XX</code>：配置选项的名称，省略了前缀”CONFIG_”</p><p><code>Tristate</code>：表示该项是否编进内核、编成模块。显示为&lt; &gt; , 假如选择编译成内核模块，则会在.config中生成一个 CONFIG_HELLO_MODULE=m的配置，选择Y就是直接编进内核，会在.config中生成一个 CONFIG_HELLO_MODULE=y的配置项。Tristate后的字符串是make menuconfig时显示的配置项名称。</p><p><code>bool</code>：此类型只能选中或不选中，make menuconfig时显示为[ ]，即无法配置成模块。</p><p><code>dependon</code>:该选项依赖于另一个选项，只有当依赖项被选中时，当前配置项的提示信息才会出现，才能设置当前配置项。</p><p><code>select</code>:反向依赖关系，该选项选中时，同时选中select后面定义的那一项。</p><p><code>help</code>：帮助信息。</p><p><code>目录层次迭代</code>：Kconfig中有类似语句：source “drivers/usb/Kconfig” ，用来包含（或嵌套）新的Kconfig文件，使得各个目录管理各自的配置内容，不必把那些配置都写在同一个文件里，方便修改和管理。</p><h3 id="2-3-config"><a href="#2-3-config" class="headerlink" title="2.3 .config"></a>2.3 .config</h3><p>参考：linux-3.4.2/.config</p><p>通过前俩个文件的分析，.config的含义已经很清晰：内核编译参考文件，查看里面内容可以知道哪些驱动被编译进内核。</p><p>配置内核方式有3种(任选其一)：</p><p>（1）make menuconfig<br>（2）make xxx_defconfig<br>（3）直接修改.config</p><p>注意: 如果直接修改.config，不一定会生效，因为有些配置可能存在依赖关系，make时会根据依赖关系，进行规则的检查，直接修改.config有时无效，所以不推荐直接修改。</p><h2 id="3-demo"><a href="#3-demo" class="headerlink" title="3. demo"></a>3. demo</h2><p>以上可能有点抽象，下面举例说明：<br>写一个简单的入口函数输出hello world的驱动并编译进内核。</p><p>步骤：<br>（1）在drivers目录下新建hello文件夹，里面实现hello.c、Makefile、Kconfig。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">first_drv_init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   printk(<span class="string">"------------------hello world !--------------------"</span>); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">first_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   printk(<span class="string">"------------------exit hello world!--------------------"</span>); </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">module_init(first_drv_init); </span><br><span class="line">module_exit(first_drv_exit); </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Makefile</span><br><span class="line"></span><br><span class="line">obj-<span class="variable">$(CONFIG_HELLO)</span>        += hello.o</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Kconfig</span><br><span class="line"></span><br><span class="line">config HELLO  </span><br><span class="line">   tristate &quot;Hello Worldfor fengyuwuzu&quot;  </span><br><span class="line">   help  </span><br><span class="line">     Hello  forfengyuwuzu</span><br></pre></td></tr></table></figure><p>config HELLO决定名字：CONFIG_HELLO。<br>Hello World for fengyuwuzu：决定了在make menuconfig时显示的名字。</p><p>（2）修改上一级（Linux-3.4.2/drivers下）的Makefile、Kconfig。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Makefile</span><br><span class="line"></span><br><span class="line">obj-y  += hello/</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Kconfig</span><br><span class="line"></span><br><span class="line">source &quot;drivers/hello/Kconfig&quot;</span><br></pre></td></tr></table></figure><p>（3）make menuconfig</p><p><img src="/images/2019/8/3.png" alt></p><hr><p>参考资料：</p><ol><li><a href="https://edsionte.com/techblog/archives/1332" target="_blank" rel="noopener">对Makefile、Kconfig与.config文件的再次理解</a></li><li><a href="https://nanxiao.me/linux-kernel-note-59-kconfig-depends-on-select/" target="_blank" rel="noopener">Kconfig中的“depends on”和“select”</a></li><li><a href="https://jin-yang.github.io/reference/linux/kernel/KBUILD_system.pdf" target="_blank" rel="noopener">KBUILD 系统原理分析</a></li><li><a href="https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt" target="_blank" rel="noopener">Linux Kernel Makefiles</a></li><li><a href="https://stackoverflow.com/questions/29231876/how-does-kbuild-actually-work" target="_blank" rel="noopener">How does kbuild actually work?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/thisway_diy/article/details/76981113&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;内核的Makefile、Kconfig和.config文件&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel notifier chain</title>
    <link href="http://liujunming.github.io/2019/08/06/Linux-kernel-notifier-chain/"/>
    <id>http://liujunming.github.io/2019/08/06/Linux-kernel-notifier-chain/</id>
    <published>2019-08-06T15:02:30.000Z</published>
    <updated>2019-08-07T14:48:21.886Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍Linux内核基础–事件通知链。</p><a id="more"></a><p>内容主要转载自：<a href="https://blog.csdn.net/wuhzossibility/article/details/8079025" target="_blank" rel="noopener">Linux内核基础–事件通知链</a>。</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Linux内核中各个子系统相互依赖，当其中某个子系统状态发生改变时，就必须使用一定的机制告知使用其服务的其他子系统，以便其他子系统采取相应的措施。为满足这样的需求，内核实现了事件通知链机制（notification chain）。</p><p>通知链只能用在各个子系统之间，而不能在内核态和用户态之间进行事件通知。内核的核心代码均位于kernel目录下，通知链表位于kernel/notifier.c中，对应的头文件为include/linux/notifier.h。</p><p>事件通知链是一个事件处理函数的列表，每个通知链都与某个或某些事件有关。当特定的事件发生时，就调用相应的事件通知链中的回调函数，进行相应的处理。</p><p><img src="/images/2019/8/2.png" alt></p><center>图 1  内核通知链</center><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p>如图 1中所示，Linux的网络子系统一共有3个通知链：表示ipv4地址发生变化时的inetaddr_chain；表示ipv6地址发生变化的inet6addr_chain；还有表示设备注册、状态变化的netdev_chain。</p><p>在这些链中都是一个个notifier_block结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> &#123;</span></span><br><span class="line">       <span class="keyword">int</span> (*notifier_call)(struct notifier_block *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">void</span> *);</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> *<span class="title">next</span>;</span></span><br><span class="line">       <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中:</p><ol><li><p><code>notifier_call</code>：当相应事件发生时应该调用的函数，由被通知方提供，如other_subsys_1；</p></li><li><p><code>notifier_block *next</code>：用于链接成链表的指针；</p></li><li><p><code>priority</code>：回调函数的优先级，一般默认为0。</p></li></ol><p>内核代码中一般把通知链命名为xxx_chain, xxx_nofitier_chain这种形式的变量名。围绕核心数据结构<code>notifier_block</code>，内核定义了四种通知链类型：</p><ol><li><p>原子通知链（Atomic notifier chains）：通知链元素的回调函数（当事件发生时要执行的函数）在中断或原子操作上下文中运行，不允许阻塞。对应的链表头结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="keyword">spinlock_t</span>  lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>可阻塞通知链（Blocking notifier chains）：通知链元素的回调函数在进程上下文中运行，允许阻塞。对应的链表头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">blocking_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">rw_semaphore</span>  <span class="title">rwsem</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>   *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>原始通知链（Raw notifierchains）：对通知链元素的回调函数没有任何限制，所有锁和保护机制都由调用者维护。对应的链表头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">raw_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>   *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>SRCU 通知链（ SRCU notifier chains ）：可阻塞通知链的一种变体。对应的链表头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">srcu_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">srcu_struct</span>  <span class="title">srcu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>  *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-运行机理"><a href="#3-运行机理" class="headerlink" title="3. 运行机理"></a>3. 运行机理</h2><p>被通知一方（other_subsys_x）通过notifier_chain_register向特定的chain注册回调函数，并且一般而言特定的子系统会用特定的notifier_chain_register包装函数来注册。</p><h3 id="3-1-子系统向事件通知链注册的步骤"><a href="#3-1-子系统向事件通知链注册的步骤" class="headerlink" title="3.1 子系统向事件通知链注册的步骤"></a>3.1 子系统向事件通知链注册的步骤</h3><ol><li><p>申明struct notifier_block结构</p></li><li><p>编写notifier_call函数</p></li><li><p>调用特定的事件通知链的注册函数，将notifier_block注册到通知链中</p></li></ol><h3 id="3-2-通知子系统有事件发生"><a href="#3-2-通知子系统有事件发生" class="headerlink" title="3.2 通知子系统有事件发生"></a>3.2 通知子系统有事件发生</h3><p>inet_subsys是通过notifier_call_chain来通知其他的子系统（other_subsys_x）的。</p><p>notifier_call_chain会按照通知链上各成员的优先级顺序执行回调函数（notifier_call_x）。</p><h3 id="3-3-事件列表"><a href="#3-3-事件列表" class="headerlink" title="3.3 事件列表"></a>3.3 事件列表</h3><p>对于网络子系统而言，其事件常以NETDEV_XXX命名：描述了网络设备状态（dev-&gt;flags）、传送队列状态（dev-&gt;state）、设备注册状态（dev-&gt;reg_state），以及设备的硬件功能特性（dev-&gt;features）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* netdevice notifier chain */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_UP  0x0001  <span class="comment">/* 激活一个网络设备 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_DOWN  0x0002f <span class="comment">/* 停止一个网络设备，所有对该设备的引用都应释放 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_REBOOT       0x0003       <span class="comment">/* 检查到网络设备接口硬件崩溃，硬件重启 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGE       0x0004  <span class="comment">/* 网络设备的数据包队列状态发生改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_REGISTER  0x0005   <span class="comment">/*一个网络设备事例注册到系统中，但尚未激活 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_UNREGISTER       0x0006       <span class="comment">/*网络设备驱动已卸载 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGEMTU      0x0007  <span class="comment">/*MTU发生了改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGEADDR    0x0008  <span class="comment">/*硬件地址发生了改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_GOING_DOWN   0x0009  <span class="comment">/*网络设备即将注销，有dev-&gt;close报告，通知相关子系统处理 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGENAME   0x000A  <span class="comment">/*网络设备名改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_FEAT_CHANGE    0x000B  <span class="comment">/*feature网络硬件功能改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_BONDING_FAILOVER 0x000C  <span class="comment">/*    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_PRE_UP        0x000D  <span class="comment">/*    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_BONDING_OLDTYPE  0x000E              <span class="comment">/*    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_BONDING_NEWTYPE  0x000F      <span class="comment">/*    */</span></span></span><br></pre></td></tr></table></figure><h2 id="4-demo"><a href="#4-demo" class="headerlink" title="4. demo"></a>4. demo</h2><p>notifier_chain机制只能在内核个子系统间使用，因此，这里使用3个模块：test_notifier_chain_0、test_notifier_chain_1、test_notifier_chain_2。<br>test_notifier_chain_2通过module_init初始化时会发出事件TESTCHAIN_2_INIT；然后 test_notifier_chain_1作出相应的处理(打印 test_notifier_chain_2正在初始化)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test_chain_0.c ：0. 申明一个通知链；1. 向内核注册通知链；2. 定义事件； 3. 导出符号*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;   </span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTCHAIN_INIT 0x52U</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">RAW_NOTIFIER_HEAD</span><span class="params">(test_chain)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* define our own notifier_call_chain */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">call_test_notifiers</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> raw_notifier_call_chain(&amp;test_chain, val, v);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(call_test_notifiers);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* define our own notifier_chain_register func */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_test_notifier</span><span class="params">(struct notifier_block *nb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    err = raw_notifier_chain_register(&amp;test_chain, nb);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">EXPORT_SYMBOL(register_test_notifier);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_chain_0_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"I'm in test_chain_0\n"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_chain_0_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"Goodbye to test_chain_0\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL v2"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fishOnFly"</span>);</span><br><span class="line"> </span><br><span class="line">module_init(test_chain_0_init);</span><br><span class="line">module_exit(test_chain_0_exit);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test_chain_1.c ：1. 定义回调函数；2. 定义notifier_block；3. 向chain_0注册notifier_block；*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;   </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">register_test_notifier</span><span class="params">(struct notifier_block *nb)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTCHAIN_INIT 0x52U</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* realize the notifier_call func */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_init_event</span><span class="params">(struct notifier_block *nb, <span class="keyword">unsigned</span> <span class="keyword">long</span> event,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(event)&#123;</span><br><span class="line">    <span class="keyword">case</span> TESTCHAIN_INIT:</span><br><span class="line">        printk(KERN_DEBUG <span class="string">"I got the chain event: test_chain_2 is on the way of init\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> NOTIFY_DONE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* define a notifier_block */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">test_init_notifier</span> = &#123;</span></span><br><span class="line">    .notifier_call = test_init_event,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_chain_1_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"I'm in test_chain_1\n"</span>);</span><br><span class="line">    register_test_notifier(&amp;test_init_notifier);    <span class="comment">// 由chain_0提供的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_chain_1_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"Goodbye to test_clain_l\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fishOnFly"</span>);</span><br><span class="line"> </span><br><span class="line">module_init(test_chain_1_init);</span><br><span class="line">module_exit(test_chain_1_exit);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test_chain_2.c：发出通知链事件*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;   </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">call_test_notifiers</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTCHAIN_INIT 0x52U</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_chain_2_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"I'm in test_chain_2\n"</span>);</span><br><span class="line">    call_test_notifiers(TESTCHAIN_INIT, <span class="string">"no_use"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_chain_2_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"Goodbye to test_chain_2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL v2"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fishOnFly"</span>);</span><br><span class="line"> </span><br><span class="line">module_init(test_chain_2_init);</span><br><span class="line">module_exit(test_chain_2_exit);</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Comment/uncomment the following line to disable/enable debugging</span></span><br><span class="line"><span class="comment"># DEBUG = y</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Add your debugging flag (or not) to CFLAGS</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,y)</span><br><span class="line">  DEBFLAGS = -O -g -DSCULL_DEBUG <span class="comment"># "-O" is needed to expand inlines</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  DEBFLAGS = -O2</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"><span class="comment"># call from kernel build system</span></span><br><span class="line"> </span><br><span class="line">obj-m   := test_chain_0.o test_chain_1.o test_chain_2.o</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> </span><br><span class="line">KERNELDIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">PWD       := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"> </span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"> </span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br><span class="line"> </span><br><span class="line">depend .depend dep:</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -M *.c &gt; .depend</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">ifeq</span> (.depend,<span class="variable">$(<span class="built_in">wildcard</span> .depend)</span>)</span><br><span class="line"><span class="keyword">include</span> .depend</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insmod test_chain_0.ko</span><br><span class="line">insmod test_chain_1.ko</span><br><span class="line">insmod test_chain_2.ko</span><br><span class="line">rmmod test_chain_2.ko</span><br><span class="line">rmmod test_chain_1.ko</span><br><span class="line">rmmod test_chain_0.ko</span><br></pre></td></tr></table></figure><p><img src="/images/2019/8/1.png" alt></p><hr><p>参考资料：</p><ol><li><p><a href="https://blog.csdn.net/wuhzossibility/article/details/8079025" target="_blank" rel="noopener">Linux内核基础–事件通知链</a></p></li><li><p><a href="https://codingfreak.blogspot.com/2012/02/notification-chains-in-linux-kernel.html" target="_blank" rel="noopener">Notification Chains in Linux Kernel</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍Linux内核基础–事件通知链。&lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>linux ioctl()函数详解</title>
    <link href="http://liujunming.github.io/2019/07/20/linux-ioctl-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://liujunming.github.io/2019/07/20/linux-ioctl-函数详解/</id>
    <published>2019-07-20T02:19:28.000Z</published>
    <updated>2019-07-20T05:54:19.032Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要转载自<a href="https://opensourceforu.com/2011/08/io-control-in-linux/" target="_blank" rel="noopener">I/O Control in Linux</a>。</p><blockquote><p>Most drivers need the ability to perform various types of hardware control via the device driver. Most devices can perform operations beyond simple data transfers; user space must often be able to request, for example, that the device lock its door, eject its media, report error information, change a baud rate, or self destruct. These operations are usually supported via the <code>ioctl</code> method, which implements the system call by the same time.</p></blockquote><a id="more"></a><p>摘录自《Linux Device Drivers》第三版第六章。</p><h2 id="Introducing-ioctl"><a href="#Introducing-ioctl" class="headerlink" title="Introducing ioctl()"></a>Introducing <em>ioctl()</em></h2><p>Input/Output Control (<em>ioctl</em>, in short) is a common operation, or system call, available in most driver categories. It is a one-bill-fits-all kind of system call. If there is no other system call that meets a particular requirement, then <code>ioctl()</code> is the one to use.</p><p>Practical examples include volume control for an audio device, display configuration for a video device, reading device registers, and so on — basically, anything to do with device input/output, or device-specific operations, yet versatile enough for any kind of operation (for example, for debugging a driver by querying driver data structures).</p><p>The question is: how can all this be achieved by a single function prototype? The trick lies in using its two key parameters: <em>command</em> and <em>argument</em>. The <em>command</em> is a number representing an operation. The <em>argument</em> is the corresponding parameter for the operation. The <code>ioctl()</code> function implementation does a switch … <em>case</em> over the commmand to implement the corresponding functionality. The following has been its prototype in the Linux kernel for quite some time:</p><p><code>int ioctl(struct inode *i, struct file *f, unsigned int cmd, unsigned long arg);</code></p><p>However, from kernel 2.6.35, it changed to:</p><p><code>long ioctl(struct file *f, unsigned int cmd, unsigned long arg);</code></p><p>If there is a need for more arguments, all of them are put in a structure, and a pointer to the structure becomes the ‘one’ argument. Whether integer or pointer, the argument is taken as a long integer in kernel-space, and accordingly type-cast and processed.</p><p><code>ioctl()</code> is typically implemented as part of the corresponding driver, and then an appropriate function pointer is initialised with it, exactly as in other system calls like <code>open()</code>, <code>read()</code>, etc. For example, in character drivers, it is the <code>ioctl</code> or <code>unlocked_ioctl</code> (since kernel 2.6.35) function pointer field in the struct <code>file_operations</code> that is to be initialised.</p><p>Again, like other system calls, it can be equivalently invoked from user-space using the <code>ioctl()</code> system call, prototyped in <code>&lt;sys/ioctl.h&gt;</code>as:</p><p><code>int ioctl(int fd, int cmd, ...);</code></p><p>Here, <code>cmd</code> is the same as what is implemented in the driver’s <code>ioctl()</code>, and the variable argument construct (<code>...</code>) is a hack to be able to pass any type of argument (though only one) to the driver’s <code>ioctl()</code>. Other parameters will be ignored.</p><p>Note that both the command and argument type definitions need to be shared across the driver (in kernel-space) and the application (in user-space). Thus, these definitions are commonly put into header files for each space.</p><h2 id="Querying-driver-internal-variables"><a href="#Querying-driver-internal-variables" class="headerlink" title="Querying driver-internal variables"></a>Querying driver-internal variables</h2><p>To better understand the boring theory explained above, here’s the code set for the “debugging a driver” example. This driver has three static global variables: <code>status</code>, <code>dignity</code>, and <code>ego</code>, which need to be queried and possibly operated from an application. The header file <code>query_ioctl.h</code> defines the corresponding commands and argument type. A listing follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUERY_IOCTL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_IOCTL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> status, dignity, ego;</span><br><span class="line">&#125; <span class="keyword">query_arg_t</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_GET_VARIABLES _IOR(<span class="meta-string">'q'</span>, 1, query_arg_t *)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_CLR_VARIABLES _IO(<span class="meta-string">'q'</span>, 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_SET_VARIABLES _IOW(<span class="meta-string">'q'</span>, 3, query_arg_t *)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>Using these, the driver’s <code>ioctl()</code> implementation in <code>query_ioctl.c</code> would be as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"query_ioctl.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIRST_MINOR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR_CNT 1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dev_t</span> dev;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">c_dev</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">cl</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> status = <span class="number">1</span>, dignity = <span class="number">3</span>, ego = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_open</span><span class="params">(struct inode *i, struct file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_close</span><span class="params">(struct inode *i, struct file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,35))</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_ioctl</span><span class="params">(struct inode *i, struct file *f, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">my_ioctl</span><span class="params">(struct file *f, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">query_arg_t</span> q;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> QUERY_GET_VARIABLES:</span><br><span class="line">            q.status = status;</span><br><span class="line">            q.dignity = dignity;</span><br><span class="line">            q.ego = ego;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user((<span class="keyword">query_arg_t</span> *)arg, &amp;q, <span class="keyword">sizeof</span>(<span class="keyword">query_arg_t</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QUERY_CLR_VARIABLES:</span><br><span class="line">            status = <span class="number">0</span>;</span><br><span class="line">            dignity = <span class="number">0</span>;</span><br><span class="line">            ego = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QUERY_SET_VARIABLES:</span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;q, (<span class="keyword">query_arg_t</span> *)arg, <span class="keyword">sizeof</span>(<span class="keyword">query_arg_t</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">            &#125;</span><br><span class="line">            status = q.status;</span><br><span class="line">            dignity = q.dignity;</span><br><span class="line">            ego = q.ego;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">query_fops</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = my_open,</span><br><span class="line">    .release = my_close,</span><br><span class="line">#<span class="keyword">if</span> (LINUX_VERSION_CODE &lt; KERNEL_VERSION(<span class="number">2</span>,<span class="number">6</span>,<span class="number">35</span>))</span><br><span class="line">    .ioctl = my_ioctl</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    .unlocked_ioctl = my_ioctl</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">query_ioctl_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev_ret</span>;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((ret = alloc_chrdev_region(&amp;dev, FIRST_MINOR, MINOR_CNT, <span class="string">"query_ioctl"</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cdev_init(&amp;c_dev, &amp;query_fops);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((ret = cdev_add(&amp;c_dev, dev, MINOR_CNT)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(cl = class_create(THIS_MODULE, <span class="string">"char"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        cdev_del(&amp;c_dev);</span><br><span class="line">        unregister_chrdev_region(dev, MINOR_CNT);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(cl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev_ret = device_create(cl, <span class="literal">NULL</span>, dev, <span class="literal">NULL</span>, <span class="string">"query"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        class_destroy(cl);</span><br><span class="line">        cdev_del(&amp;c_dev);</span><br><span class="line">        unregister_chrdev_region(dev, MINOR_CNT);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(dev_ret);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">query_ioctl_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_destroy(cl, dev);</span><br><span class="line">    class_destroy(cl);</span><br><span class="line">    cdev_del(&amp;c_dev);</span><br><span class="line">    unregister_chrdev_region(dev, MINOR_CNT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(query_ioctl_init);</span><br><span class="line">module_exit(query_ioctl_exit);</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Anil Kumar Pugalia &lt;email_at_sarika-pugs_dot_com&gt;"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Query ioctl() Char Driver"</span>);</span><br></pre></td></tr></table></figure><p>And finally, the corresponding invocation functions from the application <code>query_app.c</code> would be as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"query_ioctl.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_vars</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">query_arg_t</span> q;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, QUERY_GET_VARIABLES, &amp;q) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"query_apps ioctl get"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Status : %d\n"</span>, q.status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Dignity: %d\n"</span>, q.dignity);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Ego    : %d\n"</span>, q.ego);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clr_vars</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, QUERY_CLR_VARIABLES) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"query_apps ioctl clr"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_vars</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">query_arg_t</span> q;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter Status: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">    getchar();</span><br><span class="line">    q.status = v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter Dignity: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">    getchar();</span><br><span class="line">    q.dignity = v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter Ego: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">    getchar();</span><br><span class="line">    q.ego = v;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, QUERY_SET_VARIABLES, &amp;q) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"query_apps ioctl set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *file_name = <span class="string">"/dev/query"</span>;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    &#123;</span><br><span class="line">        e_get,</span><br><span class="line">        e_clr,</span><br><span class="line">        e_set</span><br><span class="line">    &#125; option;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        option = e_get;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-g"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            option = e_get;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-c"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            option = e_clr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-s"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            option = e_set;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s [-g | -c | -s]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s [-g | -c | -s]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = open(file_name, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"query_apps open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (option)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> e_get:</span><br><span class="line">            get_vars(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> e_clr:</span><br><span class="line">            clr_vars(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> e_set:</span><br><span class="line">            set_vars(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    close (fd);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now try out <code>query_app.c</code> and <code>query_ioctl.c</code> with the following operations:</p><ul><li>Build the <code>query_ioctl</code> driver (<code>query_ioctl.ko</code> file) and the application (<code>query_app</code> file) by running <code>make</code>, using the following <code>Makefile</code>:</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If called directly from the command line, invoke the kernel build system.</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"> </span><br><span class="line">    KERNEL_SOURCE := /usr/src/linux</span><br><span class="line">    PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">default: module query_app</span></span><br><span class="line"> </span><br><span class="line"><span class="section">module:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_SOURCE)</span> SUBDIRS=<span class="variable">$(PWD)</span> modules</span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_SOURCE)</span> SUBDIRS=<span class="variable">$(PWD)</span> clean</span><br><span class="line">    $&#123;RM&#125; query_app</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Otherwise KERNELRELEASE is defined; we've been invoked from the</span></span><br><span class="line"><span class="comment"># kernel build system and can use its language.</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> </span><br><span class="line">    obj-m := query_ioctl.o</span><br><span class="line"> </span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><ul><li>Load the driver using insmod <code>query_ioctl.ko</code>.</li><li>With appropriate privileges and command-line arguments, run the application <code>query_app</code>:<ul><li><code>./query_app</code> — to display the driver variables</li><li><code>./query_app -c</code> — to clear the driver variables</li><li><code>./query_app -g</code> — to display the driver variables</li><li><code>./query_app -s</code> — to set the driver variables (not mentioned above)</li></ul></li><li>Unload the driver using <code>rmmod query_ioctl</code>.</li></ul><h2 id="Defining-the-ioctl-commands"><a href="#Defining-the-ioctl-commands" class="headerlink" title="Defining the ioctl() commands"></a>Defining the <em>ioctl()</em> commands</h2><p>You may wondere about <code>_IOR</code>, <code>_IO</code>, etc., which were used in defining commands in <code>query_ioctl.h</code>. These are usual numbers only, as mentioned earlier for an <code>ioctl()</code> command. Just that, now additionally, some useful command related information is also encoded as part of these numbers using various macros, as per the POSIX standard for <code>ioctl</code>. The standard talks about the 32-bit command numbers, formed of four components embedded into the [31:0] bits:</p><ol><li>The direction of command operation [bits 31:30] — read, write, both, or none — filled by the corresponding macro (<code>_IOR</code>, <code>_IOW</code>, <code>_IOWR</code>, <code>_IO</code>).</li><li>The size of the  argument [bits 29:16] — computed using <code>sizeof()</code> with the  argument’s type — the third argument to these macros.</li><li>The 8-bit magic number [bits 15:8] — to render the commands unique enough — typically an ASCII character (the first argument to these macros).</li><li>The original command number [bits 7:0] — the actual command number (1, 2, 3, …), defined as per our requirement — the second argument to these macros.</li></ol><p>Check out the header <a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/ioctl.h" target="_blank" rel="noopener">&lt;asm-generic/ioctl.h&gt;</a> for implementation details.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要转载自&lt;a href=&quot;https://opensourceforu.com/2011/08/io-control-in-linux/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;I/O Control in Linux&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Most drivers need the ability to perform various types of hardware control via the device driver. Most devices can perform operations beyond simple data transfers; user space must often be able to request, for example, that the device lock its door, eject its media, report error information, change a baud rate, or self destruct. These operations are usually supported via the &lt;code&gt;ioctl&lt;/code&gt; method, which implements the system call by the same time.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/categories/I-O%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>程序员眼中的PCI设备</title>
    <link href="http://liujunming.github.io/2019/07/19/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9C%BC%E4%B8%AD%E7%9A%84PCI%E8%AE%BE%E5%A4%87/"/>
    <id>http://liujunming.github.io/2019/07/19/程序员眼中的PCI设备/</id>
    <published>2019-07-19T10:18:52.000Z</published>
    <updated>2019-07-19T14:26:35.687Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文主要内容来自<a href="https://book.douban.com/subject/3619896/" target="_blank" rel="noopener">系统虚拟化</a>，再加上自己的一些理解，希望能将PCI设备的内容解释清楚。</p><p>何为PCI(Peripheral Component Interconnect)总线？PCI总线是CPU与外部设备沟通的桥梁。<a id="more"></a>PCI总线的优点：速度快、具有动态配置功能、独立于CPU架构等，因而迅速被各种平台接受，成为一种通用的总线架构。</p><h3 id="1-PCI总线架构"><a href="#1-PCI总线架构" class="headerlink" title="1. PCI总线架构"></a>1. PCI总线架构</h3><p>PCI总线是一种典型的树结构。把北桥中HOST-PCI桥看作根，总线中其他PCI-PCI桥、PCI-ISA桥等桥设备和直接接PCI总线的设备看作节点，整个PCI架构可以概括为下图所示。<br><img src="/images/2019/7/4.png" alt></p><h4 id="设备标识符"><a href="#设备标识符" class="headerlink" title="设备标识符"></a><strong>设备标识符</strong></h4><p><img src="/images/2019/7/5.png" alt></p><h3 id="2-PCI设备枚举过程"><a href="#2-PCI设备枚举过程" class="headerlink" title="2. PCI设备枚举过程"></a>2. PCI设备枚举过程</h3><p>PCI设备和总线一起构成了树结构，其中桥设备是子树的根节点，设备枚举的过程就是要在内存中建立一颗和实际总线情况相符合的设备树。枚举过程中最关键的步骤就是发现桥设备。<br><a href="https://www.youtube.com/watch?v=qhIHu8mFrdg" target="_blank" rel="noopener">PCI Basics and Bus Enumeration</a>很好地阐述了此动态过程，看完视频之后都理解的话，那么对PCI设备枚举过程也就理解了。</p><h3 id="3-PCI-configeration-space"><a href="#3-PCI-configeration-space" class="headerlink" title="3. PCI configeration space"></a>3. PCI configeration space</h3><p>通过BDF，我们可以唯一标志一个设备。每个设备，都有自己PCI configeration space，而PCI configeration space本质是registers。PCI设备规范规定，设备的配置空间最多为256个字节，其中前64个字节的格式和用途是统一的，如下图所示。<br><img src="/images/2019/7/6.png" alt></p><p><strong>例1：</strong>假设设备1的BDF编号是(0,3,2),当我们需要定位其Expansion ROM Base Address寄存器时，应输入(0,3,2,30h)。</p><p>x86架构把I/O端口地址空间中的0xCF8~0xCFF段预留给了PCI总线，用于访问设备的配置空间。其中，前32位的寄存器为”地址寄存器“，后32位为”值寄存器“。软件通过把设备的BDF和要访问的配置空间的字节偏移量写入”地址寄存器“中，就可以通过”值寄存器“读写该配置空间了。</p><p>BDF占据16bits，而PCI configeration space最多为256个字节，也就是64个DWORD(Double WORD,WORD占16位，DWORD即占32位)，所以Config. Addr只需占用6bits(能定位到64个DWORD)。具体位数含义可参见下图：<br><img src="/images/2019/7/7.png" alt></p><p>如例1所示，我们将(0,3,2,30h)写入pio的0xCF8h，就可以通过读0xCFCh来获取设备1的Expansion ROM Base Address寄存器值了。</p><p>讲完Accessing PCIe Config Registers后，我们需要介绍下程序员最关心的Base Address Registers和Interrupt Line了。</p><ul><li>Base Address Registers:基地址寄存器，也就是常说的PCI Bar。它报告设备寄存器或者设备RAM在I/O端口地址空间（或物理地址空间中）的地址。地址是由软件(BIOS或操作系统)动态设置的。通常枚举PCI设备的软件(BIOS或操作系统)会在获得平台所有PCI设备后，根据设备数量，依照固定的算法为每个设备的PCI Bar分配I/O端口(或物理地址)。设备的电子线路负责把这些端口(或地址)映射到自身的寄存器(设备RAM)上，这样CPU就可以通过端口号(Port I/O方式)、物理地址(MMIO方式)访问到设备了。</li></ul><ul><li>Interupt Line:设备的中断线。BIOS通常用它来保存设备所连的PIC/IOAPIC的管脚号。</li></ul><hr><p>参考资料：</p><ol><li><a href="https://book.douban.com/subject/3619896/" target="_blank" rel="noopener">系统虚拟化</a></li><li><a href="http://cpci.co.kr/eng/download/technote/config-pci.pdf" target="_blank" rel="noopener">PCI configuration mechanism </a></li><li><a href="https://www.youtube.com/watch?v=qhIHu8mFrdg" target="_blank" rel="noopener">PCI Basics and Bus Enumeration</a></li><li><a href="https://www.youtube.com/watch?v=6112AekrsqA" target="_blank" rel="noopener">Accessing PCIe Config Registers</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注：本文主要内容来自&lt;a href=&quot;https://book.douban.com/subject/3619896/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;系统虚拟化&lt;/a&gt;，再加上自己的一些理解，希望能将PCI设备的内容解释清楚。&lt;/p&gt;
&lt;p&gt;何为PCI(Peripheral Component Interconnect)总线？PCI总线是CPU与外部设备沟通的桥梁。
    
    </summary>
    
      <category term="系统" scheme="http://liujunming.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="http://liujunming.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Intel GPU 内存管理</title>
    <link href="http://liujunming.github.io/2019/07/16/Intel-GPU-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://liujunming.github.io/2019/07/16/Intel-GPU-内存管理/</id>
    <published>2019-07-16T13:18:59.000Z</published>
    <updated>2019-07-16T15:07:44.047Z</updated>
    
    <content type="html"><![CDATA[<p>本文将会介绍Intel GPU的内存管理。<a id="more"></a>由于不同GPU的参数可能不一致，本文给出的参数是demo性质的，如果想要查看GPU的具体参数，请参考<a href="https://01.org/zh/linuxgraphics/documentation/hardware-specification-prms" target="_blank" rel="noopener">HARDWARE SPECIFICATION - PRMS</a>。</p><p>PS:到目前为止，我司GPU的memory依然是system memory，而非on-die memory。</p><p>对于GPU的应用而言，GPU的virtual memory address space分为两部分，分别是global graphic memory和local graphic memory。在本文接下来的内容中，我们将global graphic memory和local graphic memory的大小设置为2GB。</p><h2 id="global-graphic-memory"><a href="#global-graphic-memory" class="headerlink" title="global graphic memory"></a>global graphic memory</h2><p>对于GPU的global graphic memory，是所有进程共享的：即所有的进程共用这2GB的虚拟地址空间。</p><p>当GPU访问global graphic memory时，利用global graphics translation table (GGTT) 来完成虚拟地址到物理地址的映射，过程如下图所示（可以将GGTT看作是GPU的页表，同时GGTT是一级页表，而寻址过程是由硬件来完成的）。</p><p><img src="/images/2019/7/1.png" alt></p><p>global graphic memory的部分内存，CPU是可以访问的，这样才能完成GPU与CPU的数据交互。对于CPU能访问的这部分内存，我们称之为<a href="https://www.wikiwand.com/en/Aperture_%28computer_memory%29" target="_blank" rel="noopener">aperture</a>。CPU的虚拟地址空间与GPU的虚拟地址空间是相互独立的，因此，CPU如果想要访问aperture，就需要将aperture mmap到CPU的虚拟地址空间。</p><p><img src="/images/2019/7/2.png" alt></p><p>如上图所示，在GPU的global graphic memory中，0~FFFFFF的内容是aperture，而CPU将aperture内存mmap到C000000~CFFFFFF地址范围内，这样CPU就可以访问aperture了。对于global graphic memory的非aperture部分，CPU是无法访问的。</p><h2 id="local-graphic-memory"><a href="#local-graphic-memory" class="headerlink" title="local graphic memory"></a>local graphic memory</h2><p>对于GPU的local graphic memory，每个进程都有2GB的虚拟地址空间。GPU通过per-process graphics translation table(PPGTT)来完成地址翻译，过程如下图所示。</p><p><img src="/images/2019/7/3.png" alt></p><p>值得注意的是：</p><ul><li>PPGTT是多级页表(具体级数跟GPU的架构相关)</li><li>CPU是无法访问local graphic memory的</li></ul><hr><p>参考资料：</p><ol><li><a href="https://01.org/zh/linuxgraphics/documentation/hardware-specification-prms" target="_blank" rel="noopener">HARDWARE SPECIFICATION - PRMS</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将会介绍Intel GPU的内存管理。
    
    </summary>
    
      <category term="GPU" scheme="http://liujunming.github.io/categories/GPU/"/>
    
    
      <category term="GPU" scheme="http://liujunming.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>计算机启动相关知识点</title>
    <link href="http://liujunming.github.io/2019/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://liujunming.github.io/2019/07/15/计算机启动相关知识点/</id>
    <published>2019-07-15T13:13:37.000Z</published>
    <updated>2019-07-15T13:23:55.504Z</updated>
    
    <content type="html"><![CDATA[<p>附件中将会介绍计算机启动的相关知识点，详细内容见参考链接。</p><p><a href="/pdf/computer_boot.pdf">计算机启动</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;附件中将会介绍计算机启动的相关知识点，详细内容见参考链接。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/pdf/computer_boot.pdf&quot;&gt;计算机启动&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="系统" scheme="http://liujunming.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="http://liujunming.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Paper Notes</title>
    <link href="http://liujunming.github.io/2019/06/23/Paper-Notes/"/>
    <id>http://liujunming.github.io/2019/06/23/Paper-Notes/</id>
    <published>2019-06-23T08:23:36.000Z</published>
    <updated>2019-07-21T02:14:47.926Z</updated>
    
    <content type="html"><![CDATA[<p>论文笔记。<br><a id="more"></a><br><a href="/pdf/paper/xen sosp.pdf">Xen and the Art of Virtualization</a><br><a href="/pdf/paper/Xen_notes.pdf">Notes</a> </p><p><a href="/pdf/paper/gVirt.pdf">A Full GPU Virtualization Solution with Mediated Pass-Through</a><br><a href="/pdf/paper/gVirt_notes.pdf">Notes</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;论文笔记。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Concurrency</title>
    <link href="http://liujunming.github.io/2019/06/08/Concurrency/"/>
    <id>http://liujunming.github.io/2019/06/08/Concurrency/</id>
    <published>2019-06-08T00:53:38.000Z</published>
    <updated>2019-06-23T08:21:38.427Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先介绍Concurrency的相关知识点。</p><a id="more"></a><p>Operating Systems: Three Easy Pieces中Concurrency的相关内容。</p><ol><li><a href="[http://liujunming.top/junming/os/26.threads-intro.pdf](http://liujunming.top/junming/os/26.threads-intro.pdf">Concurrency and Threads</a></li><li><a href="[http://liujunming.top/junming/os/27.threads-api.pdf](http://liujunming.top/junming/os/27.threads-api.pdf">Thread API</a></li><li><a href="[http://liujunming.top/junming/os/28.threads-locks.pdf](http://liujunming.top/junming/os/28.threads-locks.pdf">Locks</a></li><li><a href="[http://liujunming.top/junming/os/29.threads-locks-usage.pdf](http://liujunming.top/junming/os/29.threads-locks-usage.pdf">Locked Data Structures</a></li><li><a href="[http://liujunming.top/junming/os/30.threads-cv.pdf](http://liujunming.top/junming/os/30.threads-cv.pdf">Condition Variables</a></li><li><a href="[http://liujunming.top/junming/os/31.threads-sema.pdf](http://liujunming.top/junming/os/31.threads-sema.pdf">Semaphores</a></li><li><a href="[http://liujunming.top/junming/os/32.threads-bugs.pdf](http://liujunming.top/junming/os/32.threads-bugs.pdf">Concurrency Bugs</a></li><li><a href="[http://liujunming.top/junming/os/33.threads-events.pdf](http://liujunming.top/junming/os/33.threads-events.pdf">Event-based Concurrency</a></li></ol><p><a href="/pdf/Concurrency.pdf">Notes</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先介绍Concurrency的相关知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/categories/Concurrency/"/>
    
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化课程学习</title>
    <link href="http://liujunming.github.io/2019/05/27/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>http://liujunming.github.io/2019/05/27/虚拟化课程学习/</id>
    <published>2019-05-27T06:27:16.000Z</published>
    <updated>2019-05-30T08:21:56.761Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://lettieri.iet.unipi.it/virtualization/" target="_blank" rel="noopener">Concurrent and Distributed Systems</a>课程很好地讲述了虚拟化的相关原理，由浅入深，循序渐进。本文将记录下自己的学习笔记。<br><a id="more"></a></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p><a href="/pdf/Virtualization-Introduction.pdf">Virtualization Introduction</a></p><p><a href="/pdf/intro_virtual.pdf">Notes</a></p><h3 id="Emulation-amp-amp-Binary-Translation"><a href="#Emulation-amp-amp-Binary-Translation" class="headerlink" title="Emulation &amp;&amp; Binary Translation"></a>Emulation &amp;&amp; Binary Translation</h3><p><a href="/pdf/emulation.pdf">Emulation</a></p><p><a href="/pdf/binary-translation.pdf">Binary Translation</a></p><p><a href="/pdf/emulator &amp;&amp; binary translation.pdf">Notes</a></p><h3 id="Hardware-assisted-virtualization"><a href="#Hardware-assisted-virtualization" class="headerlink" title="Hardware assisted virtualization"></a>Hardware assisted virtualization</h3><p><a href="/pdf/hardware-assisted-intro.pdf">Introduction</a>(无需细读)</p><p><a href="/pdf/hardware-assisted-vmm.pdf">The Virtual Machine Monitor</a></p><p><a href="/pdf/hardware-assisted-intel-vmx.pdf">The Intel VMX technology</a></p><p><a href="/pdf/hardware-assisted-virtual-mmu.pdf">Virtualization of virtual memory</a></p><p><a href="/pdf/Hardware assisted virtualization.pdf">Notes</a></p><h3 id="Hardware-passthrough"><a href="#Hardware-passthrough" class="headerlink" title="Hardware passthrough"></a>Hardware passthrough</h3><p><a href="/pdf/passthrough.pdf">Hardware passthrough</a></p><p><a href="/pdf/Hardware passthrough.pdf">Notes</a></p><h3 id="Paravirtualization"><a href="#Paravirtualization" class="headerlink" title="Paravirtualization"></a>Paravirtualization</h3><p><a href="/pdf/paravirtualization.pdf">Introduction</a></p><p><a href="/pdf/20161124-io-paravirtualization-tour.pdf">Virtio networking: A case study of I/O paravirtualization</a></p><p><a href="/pdf/Para-virtualization.pdf">Notes</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://lettieri.iet.unipi.it/virtualization/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Concurrent and Distributed Systems&lt;/a&gt;课程很好地讲述了虚拟化的相关原理，由浅入深，循序渐进。本文将记录下自己的学习笔记。&lt;br&gt;
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>(转)Memory barrier</title>
    <link href="http://liujunming.github.io/2019/05/09/Memory-barrier/"/>
    <id>http://liujunming.github.io/2019/05/09/Memory-barrier/</id>
    <published>2019-05-09T11:56:29.000Z</published>
    <updated>2019-05-11T04:37:14.999Z</updated>
    
    <content type="html"><![CDATA[<p>程序在运行时，内存实际的访问顺序和程序代码编写的访问顺序不一定一致，基于这个前提，Memory barrier 就有存在的必要了。</p><p>Memory barrier 能够保证其之前的内存访问操作先于其后的完成。Memory barrier的主要应用场景如下：</p><ol><li>实现同步原语（synchronization primitives）</li><li>实现无锁数据结构（lock-free data structures）</li><li>驱动程序</li></ol><a id="more"></a><p>本文内容转载自：<a href="http://b2e699b3.wiz03.com/share/s/2OVFCP1_wkXs20LtbT1nXNrj0EqwFC1zZAjT2bCeRi3Tzco2" target="_blank" rel="noopener">Name5566:理解 Memory barrier</a>。</p><h2 id="1-Memory-barrier-简介"><a href="#1-Memory-barrier-简介" class="headerlink" title="1. Memory barrier 简介"></a>1. Memory barrier 简介</h2><p>程序在运行时，内存实际的访问顺序和程序代码编写的访问顺序不一定一致，这就是内存乱序访问。内存乱序访问出现的理由是为了提升程序运行时的性能。内存乱序访问主要发生在两个阶段：</p><ol><li>编译时，编译器优化导致内存乱序访问（指令重排）</li><li>运行时，多个CPU之间的交互引起内存乱序访问</li></ol><p>Memory barrier 能够让 CPU 或编译器在内存访问上有序。一个 Memory barrier 之前的内存访问操作必定先于其之后的完成。Memory barrier 包括两类：</p><ol><li>编译器 barrier</li><li>CPU Memory barrier</li></ol><p>通常情况下，编译器和 CPU 引起的内存乱序访问不会带来什么问题，但在一些特殊情况下，程序逻辑的正确性依赖于内存访问的顺序，此时内存乱序访问会带来逻辑上的错误，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread 1</span></span><br><span class="line"><span class="keyword">while</span> (!ok);</span><br><span class="line"><span class="keyword">do</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread 2</span></span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line">ok = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>此段代码中，ok 初始化为 0，线程 1 等待 ok 被设置为 1 后执行 do 函数。假如说，线程 2 对内存的写操作乱序执行，也就是 x 赋值后于 ok 赋值完成，那么 do 函数接受的实参就很可能不是 42。</p><h3 id="1-1-编译时内存乱序访问"><a href="#1-1-编译时内存乱序访问" class="headerlink" title="1.1 编译时内存乱序访问"></a>1.1 编译时内存乱序访问</h3><p>编译器对代码做出优化时，可能改变指令的执行顺序（例如 gcc 下 O2 或 O3 都可能会改变指令的执行顺序）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="keyword">int</span> x, y, r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = r;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器优化的结果可能导致 y = 1 在 x = r 之前执行完成。首先直接编译此源文件：<br><code>g++ -S test.cpp</code></p><p>得到相关的汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl    r(%rip), %eax</span><br><span class="line">movl    %eax, x(%rip)</span><br><span class="line">movl    $1, y(%rip)</span><br></pre></td></tr></table></figure></p><p>这里可以看到，x = r 和 y = 1 并没有乱序。现使用优化选项 O2（或 O3）编译上面的代码（g++ -O2 -S test.cpp），生成汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl    r(%rip), %eax</span><br><span class="line">movl    $1, y(%rip)</span><br><span class="line">movl    %eax, x(%rip)</span><br></pre></td></tr></table></figure></p><p>我们可以清楚的看到，经过编译器优化之后 ，movl $1, y(%rip) 先于 movl %eax, x(%rip) 执行。避免编译时内存乱序访问的办法就是使用<code>编译器 barrier</code>（又叫<code>优化 barrier</code>）。Linux 内核提供函数 <code>barrier()</code> 用于让编译器保证其之前的内存访问先于其之后的完成。内核实现 <code>barrier()</code>如下（X86-64 架构）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> barrier() __asm__ __volatile__(<span class="meta-string">""</span> ::: <span class="meta-string">"memory"</span>)</span></span><br></pre></td></tr></table></figure></p><p>现在把此编译器 barrier 加入代码中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = r;</span><br><span class="line">    __asm__ __volatile__(<span class="string">""</span> ::: <span class="string">"memory"</span>);</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就避免了编译器优化带来的内存乱序访问的问题了。本例中，我们还可以使用 <code>volatile</code> 这个关键字来避免编译时内存乱序访问（而无法避免后面要说的运行时内存乱序访问）。<code>volatile</code> 关键字能够避免相关的变量在内存访问上乱序访问，这里可以修改 x 和 y 的定义来解决问题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = r;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现加上了 <code>volatile</code> 关键字，这使得 x 相对于 y、y 相对于 x 在内存访问上有序。在 Linux 内核中，提供了一个宏 <code>ACCESS_ONCE</code> 来避免编译器对于连续的 <code>ACCESS_ONCE</code>实例进行指令重排。其实 <code>ACCESS_ONCE</code> 实现源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))</span></span><br></pre></td></tr></table></figure></p><p>此代码只是将变量 x 转换为 <code>volatile</code> 的而已。现在我们就有了第三个修改方案：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ACCESS_ONCE(x) = r;</span><br><span class="line">    ACCESS_ONCE(y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此基本上就阐述完了编译时内存乱序访问的问题。下面开始介绍运行时内存乱序访问。</p><h3 id="1-2-运行时内存乱序访问"><a href="#1-2-运行时内存乱序访问" class="headerlink" title="1.2 运行时内存乱序访问"></a>1.2 运行时内存乱序访问</h3><p>在运行时，CPU 虽然会乱序执行指令，但是在单个 CPU上，硬件能够保证程序执行时,所有的内存访问操作看起来像是按程序代码编写的顺序执行的，这时候 Memory barrier 没有必要使用（不考虑编译器优化的情况下）。这里我们了解一下 CPU 乱序执行的行为。在乱序执行时，一个处理器真正执行指令的顺序由可用的输入数据决定，而非程序员编写的顺序。<br>早期的处理器为有序处理器（In-order processors），有序处理器处理指令通常有以下几步：</p><ol><li>指令获取</li><li>如果指令的输入操作对象（input operands）可用（例如已经在寄存器中了），则将此指令分发到适当的功能单元中。如果一个或者多个操作对象不可用（通常是由于需要从内存中获取），则处理器会等待，直到它们可用</li><li>指令被适当的功能单元执行</li><li>功能单元将结果写回寄存器堆（Register file，一个 CPU 中的一组寄存器）</li></ol><p>相比之下，乱序处理器（Out-of-order processors）处理指令通常有以下几步：</p><ol><li>指令获取</li><li>指令被分发到指令队列</li><li>指令在指令队列中等待，直到输入操作对象可用（一旦输入操作对象可用，指令就可以离开队列，即便更早的指令未被执行）</li><li>指令被分配到适当的功能单元并执行</li><li>执行结果被放入队列（而不立即写入寄存器堆）</li><li>只有所有更早请求执行的指令的执行结果被写入寄存器堆后，指令执行的结果才被写入寄存器堆（执行结果重排序，让执行看起来是有序的）</li></ol><p>从上面的执行过程可以看出，相比有序执行，乱序执行能够避免等待不可用的操作对象（有序执行的第二步），从而提高了效率。处理器运行的速度比内存快很多，在有序处理器花在等待可用数据的时间里，已经可以处理大量指令了。<br>现在思考一下乱序处理器处理指令的过程，我们能得到几个结论：</p><ol><li>对于单个 CPU， 指令获取是有序的（通过队列实现）</li><li>对于单个 CPU，指令执行结果也是有序返回寄存器堆的（通过队列实现）</li></ol><p>由此可知，在单 CPU 上，当不考虑编译器优化导致乱序时，多线程执行不存在内存乱序访问的问题。我们从内核源码中也可以得到类似的结论：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smp_mb() mb()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smp_mb() barrier()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>这里可以看到，如果是 SMP， 则使用 mb，mb 被定义为 CPU Memory barrier（后面会讲到），而非 SMP 时，直接使用编译器 barrier。</p><p>多处理器架构一般采用NUMA，这种架构下的内存操作会有巨大的延时问题。为了缓解这些问题，处理器会采取一些优化措施, 而导致程序顺序被破坏。</p><ul><li><p>情景一: 设想某处理器发出一条某内存位置读的指令，恰好这个内存位置在远端内存，而且处理器本地缓存也没有命中。于是，为了等待这个值，处理器需要空转(stall)。这显然是效率的极大浪费，事实上，现代的处理器都有乱序执行引擎, 指令并不是直接被执行，而是放到等待队列里，等待操作数到位后才执行，而这期间处理器优先处理其他指令。也就是出于效率考虑，处理器会重排指令。</p></li><li><p>情景二: 设想有一个热点全局变量，那么在程序运行一段时间后，很可能很多个处理器的本地缓存都有该变量的一份拷贝。再设想现在有处理器A修改这个全局变量，这个修改会发布一条消息能过网络通知所有其他处理器更新该变量缓存。由于路径的问题，消息不会同时到达所有处理器，那么存在一种可能性，某处理器此时仍观察到旧的值，而采取一些基于该旧值的动作。</p></li></ul><p>有兴趣可以研究<a href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf" target="_blank" rel="noopener">Memory Barriers: a Hardware View for Software Hackers</a>一文，其详细的分析了以上过程。</p><h2 id="2-Memory-barrier的应用场景"><a href="#2-Memory-barrier的应用场景" class="headerlink" title="2. Memory barrier的应用场景"></a>2. Memory barrier的应用场景</h2><p>Memory barrier 常用场合包括：</p><ol><li>实现同步原语（synchronization primitives）</li><li>实现无锁数据结构（lock-free data structures）</li><li>驱动程序</li></ol><p>在应用程序开发中，开发者可能完全不知道 Memory barrier 就可以开发正确的多线程程序，这主要是因为各种同步机制中已经隐含了 Memory barrier（但和实际的 Memory barrier 有细微差别）。但是如果你希望编写诸如无锁数据结构，那么 Memory barrier 还是很有用的。</p><p>在 Linux 内核中，除了前面说到的编译器 barrier — <code>barrier()</code> 和 <code>ACCESS_ONCE()</code>，还有 CPU Memory barrier：</p><ol><li>通用 barrier，保证读写操作有序的，<code>mb()</code>和 <code>smp_mb()</code></li><li>写操作 barrier，仅保证写操作有序的，<code>wmb()</code> 和 <code>smp_wmb()</code></li><li>读操作 barrier，仅保证读操作有序的，<code>rmb()</code> 和 <code>smp_rmb()</code></li></ol><p>注意，以上的CPU Memory barrier都隐含了编译器 barrier。这里以smp 开头的 Memory barrier 会在单处理器上直接使用编译器 barrier，而在 SMP 上才使用 CPU Memory barrier。</p><p>最后需要注意的是，CPU Memory barrier 中某些类型的 Memory barrier 需要成对使用，否则会出错。例如：一个写操作 barrier 需要和读操作barrier 一起使用（当然，通用 barrier 也是可以的），反之依然。</p><h3 id="2-1-Memory-barrier-的示例"><a href="#2-1-Memory-barrier-的示例" class="headerlink" title="2.1 Memory barrier 的示例"></a>2.1 Memory barrier 的示例</h3><p>下面我们通过读内核代码来进一步学习 Memory barrier 的使用。<br>Linux 内核实现的无锁（只有一个读线程和一个写线程时）环形缓冲区 kfifo 就使用到了 Memory barrier，实现源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A simple kernel FIFO implementation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2004 Stelian Pop &lt;stelian@popies.net&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"> * it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span></span><br><span class="line"><span class="comment"> * (at your option) any later version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment"> * GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment"> * along with this program; if not, write to the Free Software</span></span><br><span class="line"><span class="comment"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kfifo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/log2.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_init - allocates a new FIFO using a preallocated buffer</span></span><br><span class="line"><span class="comment"> * @buffer: the preallocated buffer to be used.</span></span><br><span class="line"><span class="comment"> * @size: the size of the internal buffer, this have to be a power of 2.</span></span><br><span class="line"><span class="comment"> * @gfp_mask: get_free_pages mask, passed to kmalloc()</span></span><br><span class="line"><span class="comment"> * @lock: the lock to be used to protect the fifo buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do NOT pass the kfifo to kfifo_free() after use! Simply free the</span></span><br><span class="line"><span class="comment"> * &amp;struct kfifo with kfree().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct kfifo *<span class="title">kfifo_init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> *<span class="title">fifo</span>;</span></span><br><span class="line">    <span class="comment">/* size must be a power of 2 */</span></span><br><span class="line">    BUG_ON(!is_power_of_2(size));</span><br><span class="line">    fifo = kmalloc(<span class="keyword">sizeof</span>(struct kfifo), gfp_mask);</span><br><span class="line">    <span class="keyword">if</span> (!fifo)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    fifo-&gt;buffer = buffer;</span><br><span class="line">    fifo-&gt;size = size;</span><br><span class="line">    fifo-&gt;in = fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line">    fifo-&gt;lock = lock;</span><br><span class="line">    <span class="keyword">return</span> fifo;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfifo_init);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_alloc - allocates a new FIFO and its internal buffer</span></span><br><span class="line"><span class="comment"> * @size: the size of the internal buffer to be allocated.</span></span><br><span class="line"><span class="comment"> * @gfp_mask: get_free_pages mask, passed to kmalloc()</span></span><br><span class="line"><span class="comment"> * @lock: the lock to be used to protect the fifo buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The size will be rounded-up to a power of 2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct kfifo *<span class="title">kfifo_alloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> *<span class="title">ret</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * round up to the next power of 2, since our 'let the indices</span></span><br><span class="line"><span class="comment">     * wrap' technique works only in this case.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_power_of_2(size)) &#123;</span><br><span class="line">        BUG_ON(size &gt; <span class="number">0x80000000</span>);</span><br><span class="line">        size = roundup_pow_of_two(size);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer = kmalloc(size, gfp_mask);</span><br><span class="line">    <span class="keyword">if</span> (!buffer)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    ret = kfifo_init(buffer, size, gfp_mask, lock);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(ret))</span><br><span class="line">        kfree(buffer);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfifo_alloc);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_free - frees the FIFO</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be freed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfifo_free</span><span class="params">(struct kfifo *fifo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kfree(fifo-&gt;buffer);</span><br><span class="line">    kfree(fifo);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfifo_free);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __kfifo_put - puts some data into the FIFO, no locking version</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be used.</span></span><br><span class="line"><span class="comment"> * @buffer: the data to be added.</span></span><br><span class="line"><span class="comment"> * @len: the length of the data to be added.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function copies at most @len bytes from the @buffer into</span></span><br><span class="line"><span class="comment"> * the FIFO depending on the free space, and returns the number of</span></span><br><span class="line"><span class="comment"> * bytes copied.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that with only one concurrent reader and one concurrent</span></span><br><span class="line"><span class="comment"> * writer, you don't need extra locking to use these functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __kfifo_put(struct kfifo *fifo,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line">    len = min(len, fifo-&gt;size - fifo-&gt;in + fifo-&gt;out);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that we sample the fifo-&gt;out index -before- we</span></span><br><span class="line"><span class="comment">     * start putting bytes into the kfifo.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_mb();</span><br><span class="line">    <span class="comment">/* first put the data starting from fifo-&gt;in to buffer end */</span></span><br><span class="line">    l = min(len, fifo-&gt;size - (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">memcpy</span>(fifo-&gt;buffer + (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)), buffer, l);</span><br><span class="line">    <span class="comment">/* then put the rest (if any) at the beginning of the buffer */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(fifo-&gt;buffer, buffer + l, len - l);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that we add the bytes to the kfifo -before-</span></span><br><span class="line"><span class="comment">     * we update the fifo-&gt;in index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_wmb();</span><br><span class="line">    fifo-&gt;in += len;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kfifo_put);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __kfifo_get - gets some data from the FIFO, no locking version</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be used.</span></span><br><span class="line"><span class="comment"> * @buffer: where the data must be copied.</span></span><br><span class="line"><span class="comment"> * @len: the size of the destination buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function copies at most @len bytes from the FIFO into the</span></span><br><span class="line"><span class="comment"> * @buffer and returns the number of copied bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that with only one concurrent reader and one concurrent</span></span><br><span class="line"><span class="comment"> * writer, you don't need extra locking to use these functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __kfifo_get(struct kfifo *fifo,</span><br><span class="line">                         <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line">    len = min(len, fifo-&gt;in - fifo-&gt;out);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that we sample the fifo-&gt;in index -before- we</span></span><br><span class="line"><span class="comment">     * start removing bytes from the kfifo.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_rmb();</span><br><span class="line">    <span class="comment">/* first get the data from fifo-&gt;out until the end of the buffer */</span></span><br><span class="line">    l = min(len, fifo-&gt;size - (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, fifo-&gt;buffer + (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)), l);</span><br><span class="line">    <span class="comment">/* then get the rest (if any) from the beginning of the buffer */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buffer + l, fifo-&gt;buffer, len - l);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that we remove the bytes from the kfifo -before-</span></span><br><span class="line"><span class="comment">     * we update the fifo-&gt;out index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_mb();</span><br><span class="line">    fifo-&gt;out += len;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kfifo_get);</span><br></pre></td></tr></table></figure></p><p>在上述代码中，我们只需关注Memory barrier 即可。代码中，索引 in 和 out 被两个线程访问。in 和 out 指明了缓冲区中实际数据的边界，由于未使用同步机制，那么如果想保证顺序关系的话，就需要使用到 Memory barrier 了。索引in被一个线程修改，被两个线程读取。 索引out被另一个线程修改，被两个线程读取。__kfifo_put 先通过 in 和 out 来确定可以向缓冲区中写入数据量的多少，这时，out 索引应该先被读取后，才能将用户 buffer 中的数据写入缓冲区，因此这里使用到了 <code>smp_mb()</code>，对应的，__kfifo_get 也使用 <code>smp_mb()</code> 来确保在修改 out 索引之前，缓冲区中数据已经被读取到用户的buffer 中了。对于 in 索引，在 __kfifo_put 中，要保证先向缓冲区写入数据后才修改 in 索引，由于这里只需要保证写入操作有序，故选用写操作 barrier，在 __kfifo_get 中，要保证先读取了 in 索引才开始读取缓冲区中数据，由于这里只需要保证读取操作有序，故选用读操作 barrier。</p><hr><p>参考文献：</p><ol><li><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt" target="_blank" rel="noopener">LINUX KERNEL MEMORY BARRIERS</a></li><li><a href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf" target="_blank" rel="noopener">Memory Barriers: a Hardware View for Software Hackers</a></li><li><a href="https://github.com/JianyuZhan/larmbr.github.com/tree/master/_posts" target="_blank" rel="noopener">the-memory-barriers-in-linux-kernel</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序在运行时，内存实际的访问顺序和程序代码编写的访问顺序不一定一致，基于这个前提，Memory barrier 就有存在的必要了。&lt;/p&gt;
&lt;p&gt;Memory barrier 能够保证其之前的内存访问操作先于其后的完成。Memory barrier的主要应用场景如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现同步原语（synchronization primitives）&lt;/li&gt;
&lt;li&gt;实现无锁数据结构（lock-free data structures）&lt;/li&gt;
&lt;li&gt;驱动程序&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/categories/Concurrency/"/>
    
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
  </entry>
  
</feed>
