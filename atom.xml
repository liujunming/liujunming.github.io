<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2022-08-13T09:09:16.019Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notes about Post-Copy Live Migration</title>
    <link href="http://liujunming.github.io/2022/08/13/Notes-about-Post-Copy-Live-Migration/"/>
    <id>http://liujunming.github.io/2022/08/13/Notes-about-Post-Copy-Live-Migration/</id>
    <published>2022-08-13T08:46:11.000Z</published>
    <updated>2022-08-13T09:09:16.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Post-Copy-steps"><a href="#Post-Copy-steps" class="headerlink" title="Post-Copy steps"></a>Post-Copy steps</h3><ol><li>suspends the migrating VM at the source node</li><li>copies minimal processor state to the target node</li><li>resumes the virtual machine</li><li>begins fetching memory pages over the network from the source.<br>The manner in which pages are fetched gives rise to different variants<a id="more"></a></li></ol><h3 id="trade-off"><a href="#trade-off" class="headerlink" title="trade-off"></a>trade-off</h3><ul><li>For VMs with read-intensive workloads, pre-copy would be the better approach</li><li>For large-memory or write-intensive workloads, post-copy would better suited.</li></ul><p>Pre-copy是为了能够尽量地减少downtime，并且不影响服务的运作;而post-copy则是为了减少total migration time且让程序能够持续的执行。</p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ul><li><a href="https://github.com/liujunming/paper_reading_notes/issues/12" target="_blank" rel="noopener">Post-Copy Live Migration of Virtual Machines</a></li><li><a href="https://www.iteye.com/blog/cloudtech-1614643" target="_blank" rel="noopener">[论文笔记]Post-copy based live virtual machine migration</a></li><li><a href="http://cshuo.top/2016/09/10/live_migration/" target="_blank" rel="noopener">VM 热迁移详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Post-Copy-steps&quot;&gt;&lt;a href=&quot;#Post-Copy-steps&quot; class=&quot;headerlink&quot; title=&quot;Post-Copy steps&quot;&gt;&lt;/a&gt;Post-Copy steps&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;suspends the migrating VM at the source node&lt;/li&gt;
&lt;li&gt;copies minimal processor state to the target node&lt;/li&gt;
&lt;li&gt;resumes the virtual machine&lt;/li&gt;
&lt;li&gt;begins fetching memory pages over the network from the source.&lt;br&gt;The manner in which pages are fetched gives rise to different variants
    
    </summary>
    
      <category term="live migration" scheme="http://liujunming.github.io/categories/live-migration/"/>
    
    
      <category term="live migration" scheme="http://liujunming.github.io/tags/live-migration/"/>
    
  </entry>
  
  <entry>
    <title>Notes about netlink</title>
    <link href="http://liujunming.github.io/2022/08/12/Notes-about-netlink/"/>
    <id>http://liujunming.github.io/2022/08/12/Notes-about-netlink/</id>
    <published>2022-08-12T13:58:11.000Z</published>
    <updated>2022-08-12T12:44:27.129Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从What、Why和How这三个角度去介绍netlink。</p><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>netlink is used to transfer information between the kernel and user-space processes.  It consists of a standard sockets-based interface for user space processes and an internal kernel API for kernel modules.<a id="more"></a></p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>How can kernel code and user-space code communicate with each other?</p><p>The answer is the various IPC methods that exist between kernel and user space, such as system call, ioctl, proc filesystem or netlink socket. This article discusses netlink socket and reveals its advantages as a network feature-friendly IPC.</p><p>Netlink socket is a special IPC used for transferring information between kernel and user-space processes. It provides a full-duplex communication link between the two by way of standard socket APIs for user-space processes and a special kernel API for kernel modules. Netlink socket uses the address family AF_NETLINK, as compared to AF_INET used by TCP/IP socket. Each netlink socket feature defines its own protocol type.</p><p>Why do some features use netlink instead of system calls, ioctls or proc filesystems for communication between user and kernel worlds? It is a nontrivial task to add system calls, ioctls or proc files for new features; we risk polluting the kernel and damaging the stability of the system. Netlink socket is simple, though: only a constant, the protocol type, needs to be added. Then, the kernel module and application can talk using socket-style APIs immediately.</p><p>Netlink is asynchronous because, as with any other socket API, it provides a socket queue to smooth the burst of messages. The system call for sending a netlink message queues the message to the receiver’s netlink queue and then invokes the receiver’s reception handler. The receiver, within the reception handler’s context, can decide whether to process the message immediately or leave the message in the queue and process it later in a different context. Unlike netlink, system calls require synchronous processing. Therefore, if we use a system call to pass a message from user space to the kernel, the kernel scheduling granularity may be affected if the time to process that message is long.</p><p>The code implementing a system call in the kernel is linked statically to the kernel in compilation time; thus, it is not appropriate to include system call code in a loadable module, which is the case for most device drivers. With netlink socket, no compilation time dependency exists between the netlink core of Linux kernel and the netlink application living in loadable kernel modules.</p><p>Netlink socket supports multicast, which is another benefit over system calls, ioctls and proc. One process can multicast a message to a netlink group address, and any number of other processes can listen to that group address. This provides a near-perfect mechanism for event distribution from kernel to user space.</p><p>System call and ioctl are simplex IPCs in the sense that a session for these IPCs can be initiated only by user-space applications. But, what if a kernel module has an urgent message for a user-space application? There is no way of doing that directly using these IPCs. Normally, applications periodically need to poll the kernel to get the state changes, although intensive polling is expensive. Netlink solves this problem gracefully by allowing the kernel to initiate sessions too. We call it the duplex characteristic of the netlink socket.</p><p>Finally, netlink socket provides a BSD socket-style API that is well understood by the software development community. Therefore, training costs are less as compared to using the rather cryptic system call APIs and ioctls.</p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>运行<a href="https://github.com/mwarning/netlink-examples/tree/master/unicast_example" target="_blank" rel="noopener">unicast_example</a>，并结合以下链接，仔细阅读代码，会有不少收获。</p><ul><li><a href="https://man7.org/linux/man-pages/man7/address_families.7.html" target="_blank" rel="noopener">man address_families</a></li><li><a href="https://man7.org/linux/man-pages/man2/socket.2.html" target="_blank" rel="noopener">man socket</a></li><li><a href="https://man7.org/linux/man-pages/man7/netlink.7.html" target="_blank" rel="noopener">man netlink</a></li><li><a href="https://elixir.bootlin.com/linux/v4.9/source/include/uapi/linux/netlink.h" target="_blank" rel="noopener">include/uapi/linux/netlink.h</a></li><li><a href="https://elixir.bootlin.com/linux/v4.9/source/include/linux/netlink.h" target="_blank" rel="noopener">include/linux/netlink.h</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./nl_recv &quot;Hello you!&quot;</span><br><span class="line">Send to kernel: Hello you!</span><br><span class="line">Received from kernel: Hello you!</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[946021.892960] netlink_test: Received from pid 1322: Hello you!</span><br><span class="line">[946021.893074] netlink_test: Send Hello you!</span><br></pre></td></tr></table></figure><p>如果想要进一步的了解，可以运行<a href="https://github.com/mwarning/netlink-examples" target="_blank" rel="noopener">mwarning/netlink-examples</a>上的所有示例。</p><hr><p>参考资料:</p><ol><li><a href="https://www.linuxjournal.com/article/7356" target="_blank" rel="noopener">Kernel Korner - Why and How to Use Netlink Socket</a></li><li><a href="https://github.com/xgfone/snippet/blob/master/snippet/docs/linux/netlink/netlink-note.md" target="_blank" rel="noopener">Linux Netlink 详解</a></li><li><a href="https://github.com/mwarning/netlink-examples" target="_blank" rel="noopener">mwarning/netlink-examples</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将从What、Why和How这三个角度去介绍netlink。&lt;/p&gt;
&lt;h3 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What&quot;&gt;&lt;/a&gt;What&lt;/h3&gt;&lt;p&gt;netlink is used to transfer information between the kernel and user-space processes.  It consists of a standard sockets-based interface for user space processes and an internal kernel API for kernel modules.
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Notes about /proc/self/</title>
    <link href="http://liujunming.github.io/2022/08/11/Notes-about-proc-self/"/>
    <id>http://liujunming.github.io/2022/08/11/Notes-about-proc-self/</id>
    <published>2022-08-11T07:09:38.000Z</published>
    <updated>2022-08-11T13:36:02.682Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/dillanzhou/article/details/82876575" target="_blank" rel="noopener">/proc/self/目录的意义</a>和<a href="https://unix.stackexchange.com/questions/333225/which-process-is-proc-self-for" target="_blank" rel="noopener">Which process is <code>/proc/self/</code> for?</a>。<a id="more"></a></p><p>可以通过/proc/$pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/$pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。为了更方便的获取本进程的信息，linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。</p><p>When the kernel has to answer the question “What does <code>/proc/self</code> point to?”, it simply <a href="https://elixir.bootlin.com/linux/latest/source/fs/proc/self.c" target="_blank" rel="noopener">picks the currently-scheduled pid</a>, i.e. the currently running process (on the current logical CPU). The effect is that <code>/proc/self</code> always points to the asking program’s pid; if you run<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /proc/self</span><br></pre></td></tr></table></figure></p><p>you’ll see <code>ls</code>‘s pid; if you write code which uses <code>/proc/self</code> then code will see its own pid, etc.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/dillanzhou/article/details/82876575&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;/proc/self/目录的意义&lt;/a&gt;和&lt;a href=&quot;https://unix.stackexchange.com/questions/333225/which-process-is-proc-self-for&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Which process is &lt;code&gt;/proc/self/&lt;/code&gt; for?&lt;/a&gt;。
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>MSI/MSI-x及其虚拟化</title>
    <link href="http://liujunming.github.io/2022/08/07/MSI-MSI-x%E5%8F%8A%E5%85%B6%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>http://liujunming.github.io/2022/08/07/MSI-MSI-x及其虚拟化/</id>
    <published>2022-08-07T09:11:47.000Z</published>
    <updated>2022-08-13T09:25:21.265Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/pdf/深入理解MSI-X中断和中断虚拟化.pdf">深入理解 MSI/MSI-X 中断和中断虚拟化</a><br><a href="/pdf/MSI-x及其虚拟化.pdf">MSI/MSI-x及其虚拟化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;/pdf/深入理解MSI-X中断和中断虚拟化.pdf&quot;&gt;深入理解 MSI/MSI-X 中断和中断虚拟化&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/pdf/MSI-x及其虚拟化.pdf&quot;&gt;MSI/MSI-x及其虚拟化&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Notes about TUN/TAP Interface</title>
    <link href="http://liujunming.github.io/2022/07/31/Notes-about-TUN-TAP-Interface/"/>
    <id>http://liujunming.github.io/2022/07/31/Notes-about-TUN-TAP-Interface/</id>
    <published>2022-07-31T10:30:57.000Z</published>
    <updated>2022-07-31T13:38:29.709Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about TUN/TAP Interface。内容主要转载自:<a href="https://hechao.li/2018/05/21/Tun-Tap-Interface/" target="_blank" rel="noopener">TUN/TAP Interface</a>。<a id="more"></a></p><h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h3><p>From the Linux kernel <a href="https://www.kernel.org/doc/html/latest/networking/tuntap.html" target="_blank" rel="noopener">documentation</a>:</p><blockquote><p>TUN/TAP provides packet reception and transmission for user space programs. It can be seen as a simple Point-to-Point or Ethernet device, which, instead of receiving packets from physical media, receives them from user space program and instead of sending packets via physical media writes them to the user space program.</p></blockquote><p>In other words, TUN/TAP interfaces are virtual interfaces that does not have physical devices associated. A user space program can attach to a TUN/TAP interface and handle the traffic sent to the interface.</p><h3 id="Difference"><a href="#Difference" class="headerlink" title="Difference"></a>Difference</h3><p>There are two types of virtual network interfaces managed by <code>/dev/net/tun</code>:</p><ul><li>TUN interfaces transport IP packets (layer 3);</li><li>TAP interfaces transport Ethernet frames (layer 2).</li></ul><p>A TUN interface is a virtual IP Point-to-Point interface(L3) and a TAP interface is a virtual Ethernet interface(L2). That means the user program can only read/write IP packets from/to a TUN interface and Ethernet frames from/to a TAP interface.</p><h3 id="Use-Cases"><a href="#Use-Cases" class="headerlink" title="Use Cases"></a>Use Cases</h3><p>The typical use case of a TUN interface is IP tunneling. For example, <a href="https://openvpn.net/" target="_blank" rel="noopener">OpenVPN</a> receives packets from a TUN interface such as <code>tun0</code> and encrypts it before sending to the real ethernet interface <code>eth0</code>. Then the OpenVPN client on the peer receives the packet from <code>eth0</code> and decrypts it before sending it to <code>tun0</code>. In other words, OpenVPN works as a proxy between <code>tun0</code> and <code>eth0</code> and creates a encrypted UDP connection over the internet between two hosts.<br><img src="/images/2022/07/03.png" alt></p><p>The typical use case of a TAP interface is virtual networking. For example, in <a href="https://hechao.li/2017/12/13/linux-bridge-part1" target="_blank" rel="noopener">Linux Bridge Part 1</a>, we’ve seen that when we create a VM in the KVM with bridged network, it creates a TAP interface like <code>vnet0</code> and adds it to the Linux bridge. In this case, KVM is the userspace program which reads from and writes to the TAP interfaces. When VM0 sends a packet to its <code>eth0</code>, KVM sends it to TAP interface <code>vnet0</code> so that the bridge will forward it to <code>vnet1</code>. Then KVM receives it and sends it to VM1’s <code>eth0</code>.<br><img src="/images/2022/07/04.png" alt></p><h3 id="Managing-TUN-TAP-interfaces"><a href="#Managing-TUN-TAP-interfaces" class="headerlink" title="Managing TUN/TAP interfaces"></a>Managing TUN/TAP interfaces</h3><p><code>ip tuntap</code> can be used to manage TUN/TAP interfaces. For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ip tuntap help</span><br><span class="line">Usage: ip tuntap &#123; add | del | show | list | lst | help &#125; [ dev PHYS_DEV ]</span><br><span class="line">          [ mode &#123; tun | tap &#125; ] [ user USER ] [ group GROUP ]</span><br><span class="line">          [ one_queue ] [ pi ] [ vnet_hdr ] [ multi_queue ]</span><br><span class="line"></span><br><span class="line">Where: USER  := &#123; STRING | NUMBER &#125;</span><br><span class="line">       GROUP := &#123; STRING | NUMBER &#125;</span><br></pre></td></tr></table></figure></p><h3 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h3><p>精读<a href="/images/2022/07/Linux 虚拟网络设备之 TUN_TAP 设备 - 知乎.pdf">Linux 虚拟网络设备之 TUN/TAP 设备</a>，会收获颇丰。</p><p><img src="/images/2022/07/05.jpeg" alt></p><hr><p><img src="/images/2022/07/06.jpeg" alt></p><hr><p><img src="/images/2022/07/07.jpeg" alt></p><hr><p>参考资料:</p><ol><li><a href="https://hechao.li/2018/05/21/Tun-Tap-Interface/" target="_blank" rel="noopener">TUN/TAP Interface</a></li><li><a href="https://www.gabriel.urdhr.fr/2021/05/08/tuntap/" target="_blank" rel="noopener">TUN/TAP interface (on Linux)</a></li><li><a href="https://zhuanlan.zhihu.com/p/388742230" target="_blank" rel="noopener">Linux 虚拟网络设备之 TUN/TAP 设备</a></li><li><a href="https://www.kernel.org/doc/html/latest/networking/tuntap.html" target="_blank" rel="noopener">kernel document Universal TUN/TAP device driver</a></li><li><a href="https://backreference.org/2010/03/26/tuntap-interface-tutorial/" target="_blank" rel="noopener">Tun/Tap interface tutorial</a></li><li><a href="https://man7.org/linux/man-pages/man7/netdevice.7.html" target="_blank" rel="noopener">man netdevice</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about TUN/TAP Interface。内容主要转载自:&lt;a href=&quot;https://hechao.li/2018/05/21/Tun-Tap-Interface/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TUN/TAP Interface&lt;/a&gt;。
    
    </summary>
    
      <category term="计算机网络" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux network tun interface示例</title>
    <link href="http://liujunming.github.io/2022/07/31/Example-of-linux-network-tun-interface/"/>
    <id>http://liujunming.github.io/2022/07/31/Example-of-linux-network-tun-interface/</id>
    <published>2022-07-31T09:38:38.000Z</published>
    <updated>2022-07-31T13:38:29.708Z</updated>
    
    <content type="html"><![CDATA[<p>示例源于<a href="https://segmentfault.com/a/1190000009249039" target="_blank" rel="noopener">Linux虚拟网络设备之tun/tap</a>。<a id="more"></a></p><h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><p>收到tun设备的数据包之后，只打印出收到了多少字节的数据包，其它的什么都不做<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_tun.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tun_alloc</span><span class="params">(<span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fd, err;</span><br><span class="line">    <span class="keyword">char</span> *clonedev = <span class="string">"/dev/net/tun"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(clonedev, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">    ifr.ifr_flags = flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = ioctl(fd, TUNSETIFF, (<span class="keyword">void</span> *) &amp;ifr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Open tun/tap device: %s for reading...\n"</span>, ifr.ifr_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tun_fd, nread;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1500</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags: IFF_TUN   - TUN device (no Ethernet headers)</span></span><br><span class="line"><span class="comment">     *        IFF_TAP   - TAP device</span></span><br><span class="line"><span class="comment">     *        IFF_NO_PI - Do not provide packet information</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tun_fd = tun_alloc(IFF_TUN | IFF_NO_PI);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tun_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Allocating interface"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        nread = read(tun_fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (nread &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"Reading from interface"</span>);</span><br><span class="line">            close(tun_fd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Read %d bytes from tun/tap device\n"</span>, nread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://man7.org/linux/man-pages/man7/netdevice.7.html" target="_blank" rel="noopener">man netdevice</a></p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#--------------------------第一个shell窗口----------------------</span><br><span class="line">#将上面的程序保存成tun.c，然后编译</span><br><span class="line">dev@debian:~$ gcc tun.c -o tun</span><br><span class="line"></span><br><span class="line">#启动tun程序，程序会创建一个新的tun设备，</span><br><span class="line">#程序会阻塞在这里，等着数据包过来</span><br><span class="line">dev@debian:~$ sudo ./tun</span><br><span class="line">Open tun/tap device tun1 for reading...</span><br><span class="line">Read 84 bytes from tun/tap device</span><br><span class="line">Read 84 bytes from tun/tap device</span><br><span class="line">Read 84 bytes from tun/tap device</span><br><span class="line">Read 84 bytes from tun/tap device</span><br><span class="line"></span><br><span class="line">#--------------------------第二个shell窗口----------------------</span><br><span class="line">#启动抓包程序，抓经过tun1的包</span><br><span class="line"># tcpdump -i tun1</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on tun1, link-type RAW (Raw IP), capture size 262144 bytes</span><br><span class="line">19:57:13.473101 IP 192.168.3.11 &gt; 192.168.3.12: ICMP echo request, id 24028, seq 1, length 64</span><br><span class="line">19:57:14.480362 IP 192.168.3.11 &gt; 192.168.3.12: ICMP echo request, id 24028, seq 2, length 64</span><br><span class="line">19:57:15.488246 IP 192.168.3.11 &gt; 192.168.3.12: ICMP echo request, id 24028, seq 3, length 64</span><br><span class="line">19:57:16.496241 IP 192.168.3.11 &gt; 192.168.3.12: ICMP echo request, id 24028, seq 4, length 64</span><br><span class="line"></span><br><span class="line">#--------------------------第三个shell窗口----------------------</span><br><span class="line">#./tun启动之后，通过ip link命令就会发现系统多了一个tun设备，</span><br><span class="line">#在我的测试环境中，多出来的设备名称叫tun1，在你的环境中可能叫tun0</span><br><span class="line">#新的设备没有ip，我们先给tun1配上IP地址</span><br><span class="line">dev@debian:~$ sudo ip addr add 192.168.3.11/24 dev tun1</span><br><span class="line"></span><br><span class="line">#默认情况下，tun1没有起来，用下面的命令将tun1启动起来</span><br><span class="line">dev@debian:~$ sudo ip link set tun1 up</span><br><span class="line"></span><br><span class="line">#尝试ping一下192.168.3.0/24网段的IP，</span><br><span class="line">#根据默认路由，该数据包会走tun1设备，</span><br><span class="line">#由于我们的程序中收到数据包后，啥都没干，相当于把数据包丢弃了，</span><br><span class="line">#所以这里的ping根本收不到返回包，</span><br><span class="line">#但在前两个窗口中可以看到这里发出去的四个icmp echo请求包，</span><br><span class="line">#说明数据包正确的发送到了应用程序里面，只是应用程序没有处理该包</span><br><span class="line">dev@debian:~$ ping -c 4 192.168.3.12</span><br><span class="line">PING 192.168.3.12 (192.168.3.12) 56(84) bytes of data.</span><br><span class="line"></span><br><span class="line">--- 192.168.3.12 ping statistics ---</span><br><span class="line">4 packets transmitted, 0 received, 100% packet loss, time 3023ms</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;示例源于&lt;a href=&quot;https://segmentfault.com/a/1190000009249039&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux虚拟网络设备之tun/tap&lt;/a&gt;。
    
    </summary>
    
      <category term="计算机网络" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Notes about PV TLB Shootdown</title>
    <link href="http://liujunming.github.io/2022/07/30/Notes-about-PV-TLB-Shootdown/"/>
    <id>http://liujunming.github.io/2022/07/30/Notes-about-PV-TLB-Shootdown/</id>
    <published>2022-07-30T14:28:28.000Z</published>
    <updated>2022-07-31T05:37:43.940Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about PV TLB Shootdown.<a id="more"></a></p><p>A TLB is a cache of translation from memory virtual address to physical address. When a CPU changes virtual to physical mapping of an address, it needs to invalidate other CPUs’ stale mapping in their respective caches. This process is called TLB shootdown.</p><p>Modern operating systems consider TLB shootdown operations to be performance critical and so optimize them to exhibit very low latency.The implementation of these operations is therefore architected to ensure that shootdowns can be completed with very low latencies through the use of IPI based signalling.</p><p>Remote TLB flush does a busy wait which is fine in bare-metal scenario.But within the guest, the vCPUs might have been preempted or blocked. In this scenario, the initiator vCPU would end up busy-waiting for a long amount of time; it also consumes CPU unnecessarily to wake up the target of the shootdown.</p><p><strong>Idea:</strong><br>In PV TLB shootdown, the TLB flush initiator vCPU will not wait the sleeping vCPU, instead it just set a flag in the guest-vmm shared area and then kvm will check this flag and do the TLB flush when the sleeping vCPU come to run.</p><p><img src="/images/2022/07/02.jpg" alt></p><p>实现细节也很有意思，感兴趣的读者可以去仔细阅读代码+文末的参考资料，本文就不赘述了。</p><hr><p>参考资料:</p><ol><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/09/10/kvm-performance-1" target="_blank" rel="noopener">kvm performance optimization technologies, part one</a></li><li><a href="https://lwn.net/Articles/740363/" target="_blank" rel="noopener">KVM: X86: Add Paravirt TLB Shootdown</a></li><li><a href="https://events19.linuxfoundation.org/wp-content/uploads/2017/12/Update_Wanpeng-LI_Torwards-a-more-Scalable-KVM-Hypervisor.pdf" target="_blank" rel="noopener">Torwards a more Scalable KVM Hypervisor</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about PV TLB Shootdown.
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Notes about multiqueue virtio-net</title>
    <link href="http://liujunming.github.io/2022/07/29/Notes-about-multiqueue-virtio-net/"/>
    <id>http://liujunming.github.io/2022/07/29/Notes-about-multiqueue-virtio-net/</id>
    <published>2022-07-29T13:41:23.000Z</published>
    <updated>2022-07-29T14:47:17.669Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录multiqueue virtio-net相关笔记。<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>Multi-queue virtio-net provides an approach that scales the network performance as the number of vCPUs increases, by allowing them to transfer packets through more than one virtqueue pair at a time.</p><p>Today’s high-end servers have more processors, and guests running on them often have an increasing number of vCPUs. In single queue virtio-net, the scale of the protocol stack in a guest is restricted, as the network performance does not scale as the number of vCPUs increases. Guests cannot transmit or retrieve packets in parallel, as virtio-net has only one TX and RX queue.</p><p>Multi-queue support removes these bottlenecks by allowing paralleled packet processing.</p><p>Multi-queue virtio-net provides the greatest performance benefit when:</p><ul><li>Traffic packets are relatively large.</li><li>The guest is active on many connections at the same time, with traffic running between guests, guest to host, or guest to an external system.</li><li>The number of queues is equal to the number of vCPUs. This is because multi-queue support optimizes RX interrupt affinity and TX queue selection in order to make a specific queue private to a specific vCPU.</li></ul><h3 id="2-Parallel-send-receive-processing"><a href="#2-Parallel-send-receive-processing" class="headerlink" title="2. Parallel send/receive processing"></a>2. Parallel send/receive processing</h3><p>To make sure the whole stack could be worked in parallel, the parallelism of not only the front-end (guest driver) but also the back-end (vhost and tap/macvtap) must be explored. This is done by:</p><ul><li>Allowing multiple sockets to be attached to tap/macvtap</li><li>Using multiple threaded vhost to serve as the backend of a multiqueue capable virtio-net adapter</li><li>Use a multi-queue awared virtio-net driver to send and receive packets to/from each queue</li></ul><p><img src="https://www.linux-kvm.org/images/e/e3/Ver1.jpg" alt></p><h3 id="3-Configuration"><a href="#3-Configuration" class="headerlink" title="3. Configuration"></a>3. Configuration</h3><h3 id="3-1-If-using-qemu"><a href="#3-1-If-using-qemu" class="headerlink" title="3.1 If using qemu"></a>3.1 If using qemu</h3><ul><li>create tap device with multiple queues, please reference<br><code>Documentation/networking/tuntap.txt:(3.3 Multiqueue tuntap interface)</code></li><li>enable mq for tap (suppose N queue pairs) -netdev tap,vhost=on,queues=N</li><li>enable mq and specify msix vectors in qemu cmdline (2N+2 vectors, N for tx queues, N for rx queues, 1 for config, and one for possible control vq): -device virtio-net-pci,mq=on,vectors=2N+2…</li></ul><h3 id="3-2-If-using-libvirt"><a href="#3-2-If-using-libvirt" class="headerlink" title="3.2 If using libvirt"></a>3.2 If using libvirt</h3><p>To use multi-queue virtio-net, enable support in the guest by adding the following to the guest XML configuration (where the value of N is from 1 to 256, as the kernel supports up to 256 queues for a multi-queue tap device):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;interface type=&apos;network&apos;&gt;</span><br><span class="line">      &lt;source network=&apos;default&apos;/&gt;</span><br><span class="line">      &lt;model type=&apos;virtio&apos;/&gt;</span><br><span class="line">      &lt;driver name=&apos;vhost&apos; queues=&apos;N&apos;/&gt;</span><br><span class="line">&lt;/interface&gt;</span><br></pre></td></tr></table></figure></p><h3 id="3-3-In-guest"><a href="#3-3-In-guest" class="headerlink" title="3.3 In guest"></a>3.3 In guest</h3><p>When running a virtual machine with N virtio-net queues in the guest, enable the multi-queue support with the following command (where the value of M is from 1 to N):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -L eth0 combined M</span><br></pre></td></tr></table></figure></p><h3 id="4-Verification"><a href="#4-Verification" class="headerlink" title="4. Verification"></a>4. Verification</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -l eth0</span><br><span class="line">Channel parameters for eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:        0</span><br><span class="line">TX:        0</span><br><span class="line">Other:        0</span><br><span class="line">Combined:    4</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:        0</span><br><span class="line">TX:        0</span><br><span class="line">Other:        0</span><br><span class="line">Combined:    4</span><br></pre></td></tr></table></figure><p>验证多队列生效的方法是观察中断，即<code>cat /proc/interrupts</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/interrupts</span><br><span class="line">           CPU0       CPU1</span><br><span class="line">...</span><br><span class="line"> 27:       1352          0   PCI-MSI-edge      virtio0-input.0</span><br><span class="line"> 28:          1          0   PCI-MSI-edge      virtio0-output.0</span><br><span class="line"> 29:        378          0   PCI-MSI-edge      virtio0-input.1</span><br><span class="line"> 30:          1          0   PCI-MSI-edge      virtio0-output.1</span><br><span class="line"> 31:        151          0   PCI-MSI-edge      virtio0-input.2</span><br><span class="line"> 32:          1          0   PCI-MSI-edge      virtio0-output.2</span><br><span class="line"> 33:        268          0   PCI-MSI-edge      virtio0-input.3</span><br><span class="line"> 34:          0          0   PCI-MSI-edge      virtio0-output.3</span><br></pre></td></tr></table></figure><p>可以观察到中断分布在4个<code>virtio0</code>队列设备上。</p><hr><p>参考资料:</p><ol><li><a href="https://www.linux-kvm.org/page/Multiqueue" target="_blank" rel="noopener">Multiqueue virtio-net</a></li><li><a href="https://huataihuang.gitbooks.io/cloud-atlas/content/virtual/kvm/performance/kvm_performance_tunning_in_action/multi_queue-virtio-net.html" target="_blank" rel="noopener">多队列 virtio-net</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_tuning_and_optimization_guide/sect-virtualization_tuning_optimization_guide-networking-techniques" target="_blank" rel="noopener">Network Tuning Techniques</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录multiqueue virtio-net相关笔记。
    
    </summary>
    
      <category term="virtio" scheme="http://liujunming.github.io/categories/virtio/"/>
    
    
      <category term="virtio" scheme="http://liujunming.github.io/tags/virtio/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to userfaultfd mechanism</title>
    <link href="http://liujunming.github.io/2022/07/24/Introduction-to-userfaultfd-mechanism/"/>
    <id>http://liujunming.github.io/2022/07/24/Introduction-to-userfaultfd-mechanism/</id>
    <published>2022-07-24T05:13:22.000Z</published>
    <updated>2022-07-24T08:22:39.582Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容主要转载自<a href="http://brieflyx.me/2020/linux-tools/userfaultfd-internals/" target="_blank" rel="noopener">Linux Kernel Userfaultfd 内部机制探究</a>，看代码的时候结合<a href="https://man7.org/linux/man-pages/man2/userfaultfd.2.html" target="_blank" rel="noopener">man userfaultfd</a>和<a href="https://man7.org/linux/man-pages/man2/ioctl_userfaultfd.2.html" target="_blank" rel="noopener">man ioctl_userfaultfd</a>，方便查询。<br><a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>Userfaults allow the implementation of on-demand paging from userland and more generally they allow userland to take control of various memory page faults, something otherwise only the kernel code could do.</p><p>userfaultfd是kernel中提供的一种特殊的处理page fault的机制，能够让用户态程序自行处理自己的page fault。</p><p>它的调用方式是通过一个userfaultfd的syscall新建一个 fd，然后用ioctl等syscall来调用相关的API。该机制的初衷是为了方便虚拟机的post-copy live migration。</p><h3 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h3><p><img src="/images/2022/07/01.png" alt><br>左侧的 Faulting thread，mm core，userfaultfd 是属于同一个（内核）线程，右边的 uffd monitor 是属于另一（内核）线程，它们在用户态应该表现为共享地址空间的2个线程。</p><p>在开始时，faulting 线程读取了一块未分配物理页的内存，触发了page fault，此时进到内核中进行处理，内核调用了 <code>handle_userfault</code> 交给 userfaultfd 相关的代码进行处理，此时该线程将被挂起进入阻塞状态。同时一个待处理的消息 <code>uffd_msg</code> 结构通过该 fd 发送到了另一个 monitor 线程，该线程可以调用相关 API 进行处理 （ <code>UFFDIO_COPY</code> 或 <code>UFFDIO_ZEROPAGE</code>）并告知内核唤醒 faulting 线程。</p><p>从这个例子中我们能看出这里面涉及到2个线程之间的交互，我们也不能免俗地要介绍一下具体用法，阅读 <code>userfaultfd</code> man page 里给出的例子，里面大概分为5步。</p><h3 id="3-用法"><a href="#3-用法" class="headerlink" title="3. 用法"></a>3. 用法</h3><h4 id="3-1-分配一个-userfault-fd-并检查-API"><a href="#3-1-分配一个-userfault-fd-并检查-API" class="headerlink" title="3.1 分配一个 userfault fd 并检查 API"></a>3.1 分配一个 userfault fd 并检查 API</h4><p>由于 glibc 没有对应的 syscall wrapper，直接使用 syscall 函数分配。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Create and enable userfaultfd object */</span></span><br><span class="line"></span><br><span class="line">uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"userfaultfd"</span>);</span><br><span class="line"></span><br><span class="line">uffdio_api.api = UFFD_API;</span><br><span class="line">uffdio_api.features = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"ioctl-UFFDIO_API"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="3-2-注册需要进行-userfault-的内存区域"><a href="#3-2-注册需要进行-userfault-的内存区域" class="headerlink" title="3.2 注册需要进行 userfault 的内存区域"></a>3.2 注册需要进行 userfault 的内存区域</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register the memory range of the mapping we just created for</span></span><br><span class="line"><span class="comment">          handling by the userfaultfd object. In mode, we request to track</span></span><br><span class="line"><span class="comment">          missing pages (i.e., pages that have not yet been faulted in). */</span></span><br><span class="line"></span><br><span class="line">uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">uffdio_register.range.len = len;</span><br><span class="line">uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line"><span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"ioctl-UFFDIO_REGISTER"</span>);</span><br></pre></td></tr></table></figure><h4 id="3-3-创建-monitor-线程，（子线程）监听-fd-的事件"><a href="#3-3-创建-monitor-线程，（子线程）监听-fd-的事件" class="headerlink" title="3.3 创建 monitor 线程，（子线程）监听 fd 的事件"></a>3.3 创建 monitor 线程，（子线程）监听 fd 的事件</h4><p>在一个 for 循环中，不断使用 pool 来等待这个 fd ，然后读取一个 msg，这里读取的 msg 就是 <code>uffd_msg</code> 结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* See what poll() tells us about the userfaultfd */</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">   <span class="keyword">int</span> nready;</span><br><span class="line">   pollfd.fd = uffd;</span><br><span class="line">   pollfd.events = POLLIN;</span><br><span class="line">   nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">   <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">       errExit(<span class="string">"poll"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\nfault_handler_thread():\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"    poll() returns: nready = %d; "</span></span><br><span class="line">           <span class="string">"POLLIN = %d; POLLERR = %d\n"</span>, nready,</span><br><span class="line">           (pollfd.revents &amp; POLLIN) != <span class="number">0</span>,</span><br><span class="line">           (pollfd.revents &amp; POLLERR) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Read an event from the userfaultfd */</span></span><br><span class="line"></span><br><span class="line">   nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">   <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"EOF on userfaultfd!\n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">       errExit(<span class="string">"read"</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h4 id="3-4-主线程触发指定区域的-page-fault"><a href="#3-4-主线程触发指定区域的-page-fault" class="headerlink" title="3.4 主线程触发指定区域的 page fault"></a>3.4 主线程触发指定区域的 page fault</h4><p>读一下该区域的内存即可</p><h4 id="3-5（子线程）处理-fault"><a href="#3-5（子线程）处理-fault" class="headerlink" title="3.5（子线程）处理 fault"></a>3.5（子线程）处理 fault</h4><p>调用 <code>UFFDIO_COPY</code>为新映射的页提供数据，并唤醒主线程，子线程自身会进入到下一轮循环中继续 poll 等待输入。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Copy the page pointed to by 'page' into the faulting</span></span><br><span class="line"><span class="comment">  region. Vary the contents that are copied in, so that it</span></span><br><span class="line"><span class="comment">  is more obvious that each fault is handled separately. */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(page, <span class="string">'A'</span> + fault_cnt % <span class="number">20</span>, page_size);</span><br><span class="line">fault_cnt++;</span><br><span class="line"></span><br><span class="line">uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We need to handle page faults in units of pages(!).</span></span><br><span class="line"><span class="comment">  So, round faulting address down to page boundary */</span></span><br><span class="line"></span><br><span class="line">uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                  ~(page_size - <span class="number">1</span>);</span><br><span class="line">uffdio_copy.len = page_size;</span><br><span class="line">uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"ioctl-UFFDIO_COPY"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="4-Example"><a href="#4-Example" class="headerlink" title="4. Example"></a>4. Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* userfaultfd_demo.c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Licensed under the GNU General Public License version 2 or later.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> errExit(msg)    do &#123; perror(msg); exit(EXIT_FAILURE); \</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">fault_handler_thread(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span>   <span class="comment">/* Data read from userfaultfd */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;     <span class="comment">/* Number of faults so far handled */</span></span><br><span class="line">    <span class="keyword">long</span> uffd;                    <span class="comment">/* userfaultfd file descriptor */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *page = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a page that will be copied into the faulting region. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        page = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE,</span><br><span class="line">                    MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">            errExit(<span class="string">"mmap"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop, handling incoming events on the userfaultfd</span></span><br><span class="line"><span class="comment">       file descriptor. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* See what poll() tells us about the userfaultfd. */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"poll"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nfault_handler_thread():\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"    poll() returns: nready = %d; "</span></span><br><span class="line">                <span class="string">"POLLIN = %d; POLLERR = %d\n"</span>, nready,</span><br><span class="line">                (pollfd.revents &amp; POLLIN) != <span class="number">0</span>,</span><br><span class="line">                (pollfd.revents &amp; POLLERR) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read an event from the userfaultfd. */</span></span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"EOF on userfaultfd!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"read"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We expect only one kind of event; verify that assumption. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Unexpected event on userfaultfd\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Display info about the page-fault event. */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"    UFFD_EVENT_PAGEFAULT event: "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"flags = %"</span>PRIx64<span class="string">"; "</span>, msg.arg.pagefault.flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"address = %"</span>PRIx64<span class="string">"\n"</span>, msg.arg.pagefault.address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Copy the page pointed to by 'page' into the faulting</span></span><br><span class="line"><span class="comment">           region. Vary the contents that are copied in, so that it</span></span><br><span class="line"><span class="comment">           is more obvious that each fault is handled separately. */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="string">'A'</span> + fault_cnt % <span class="number">20</span>, page_size);</span><br><span class="line">        fault_cnt++;</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We need to handle page faults in units of pages(!).</span></span><br><span class="line"><span class="comment">           So, round faulting address down to page boundary. */</span></span><br><span class="line"></span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                           ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"ioctl-UFFDIO_COPY"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"        (uffdio_copy.copy returned %"</span>PRId64<span class="string">")\n"</span>,</span><br><span class="line">                uffdio_copy.copy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> uffd;          <span class="comment">/* userfaultfd file descriptor */</span></span><br><span class="line">    <span class="keyword">char</span> *addr;         <span class="comment">/* Start of region handled by userfaultfd */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len;       <span class="comment">/* Length of region handled by userfaultfd */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thr;      <span class="comment">/* ID of thread that handles page faults */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s num-pages\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line">    len = strtoull(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>) * page_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create and enable userfaultfd object. */</span></span><br><span class="line"></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"userfaultfd"</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_api.api = UFFD_API;</span><br><span class="line">    uffdio_api.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"ioctl-UFFDIO_API"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a private anonymous mapping. The memory will be</span></span><br><span class="line"><span class="comment">       demand-zero paged--that is, not yet allocated. When we</span></span><br><span class="line"><span class="comment">       actually touch the memory, it will be allocated via</span></span><br><span class="line"><span class="comment">       the userfaultfd. */</span></span><br><span class="line"></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE,</span><br><span class="line">                MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)</span><br><span class="line">        errExit(<span class="string">"mmap"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address returned by mmap() = %p\n"</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register the memory range of the mapping we just created for</span></span><br><span class="line"><span class="comment">       handling by the userfaultfd object. In mode, we request to track</span></span><br><span class="line"><span class="comment">       missing pages (i.e., pages that have not yet been faulted in). */</span></span><br><span class="line"></span><br><span class="line">    uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"ioctl-UFFDIO_REGISTER"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a thread that will process the userfaultfd events. */</span></span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;thr, <span class="literal">NULL</span>, fault_handler_thread, (<span class="keyword">void</span> *) uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">        errno = s;</span><br><span class="line">        errExit(<span class="string">"pthread_create"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Main thread now touches memory in the mapping, touching</span></span><br><span class="line"><span class="comment">       locations 1024 bytes apart. This will trigger userfaultfd</span></span><br><span class="line"><span class="comment">       events for all pages in the region. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    l = <span class="number">0xf</span>;    <span class="comment">/* Ensure that faulting address is not on a page</span></span><br><span class="line"><span class="comment">                   boundary, in order to test that we correctly</span></span><br><span class="line"><span class="comment">                   handle that case in fault_handling_thread(). */</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; len) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = addr[l];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Read address %p in main(): "</span>, addr + l);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, c);</span><br><span class="line">        l += <span class="number">1024</span>;</span><br><span class="line">        usleep(<span class="number">100000</span>);         <span class="comment">/* Slow things down a little */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ ./userfaultfd_demo 3</span><br><span class="line">Address returned by mmap() = 0x7fd30106c000</span><br><span class="line"></span><br><span class="line">fault_handler_thread():</span><br><span class="line">    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0</span><br><span class="line">    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106c00f</span><br><span class="line">        (uffdio_copy.copy returned 4096)</span><br><span class="line">Read address 0x7fd30106c00f in main(): A</span><br><span class="line">Read address 0x7fd30106c40f in main(): A</span><br><span class="line">Read address 0x7fd30106c80f in main(): A</span><br><span class="line">Read address 0x7fd30106cc0f in main(): A</span><br><span class="line"></span><br><span class="line">fault_handler_thread():</span><br><span class="line">    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0</span><br><span class="line">    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106d00f</span><br><span class="line">        (uffdio_copy.copy returned 4096)</span><br><span class="line">Read address 0x7fd30106d00f in main(): B</span><br><span class="line">Read address 0x7fd30106d40f in main(): B</span><br><span class="line">Read address 0x7fd30106d80f in main(): B</span><br><span class="line">Read address 0x7fd30106dc0f in main(): B</span><br><span class="line"></span><br><span class="line">fault_handler_thread():</span><br><span class="line">    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0</span><br><span class="line">    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106e00f</span><br><span class="line">        (uffdio_copy.copy returned 4096)</span><br><span class="line">Read address 0x7fd30106e00f in main(): C</span><br><span class="line">Read address 0x7fd30106e40f in main(): C</span><br><span class="line">Read address 0x7fd30106e80f in main(): C</span><br><span class="line">Read address 0x7fd30106ec0f in main(): C</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="http://brieflyx.me/2020/linux-tools/userfaultfd-internals/" target="_blank" rel="noopener">Linux Kernel Userfaultfd 内部机制探究</a></li><li><a href="https://man7.org/linux/man-pages/man2/userfaultfd.2.html" target="_blank" rel="noopener">man userfaultfd</a></li><li><a href="https://man7.org/linux/man-pages/man2/ioctl_userfaultfd.2.html" target="_blank" rel="noopener">man ioctl_userfaultfd</a></li><li><a href="https://www.slideshare.net/kerneltlv/userfaultfd-current-features-limitations-and-future-development" target="_blank" rel="noopener">Userfaultfd: Current Features, Limitations and Future Development</a></li><li><a href="https://www.kernel.org/doc/Documentation/vm/userfaultfd.txt" target="_blank" rel="noopener">kernel userfaultfd.txt</a></li><li><a href="http://lastweek.io/notes/userfaultfd/" target="_blank" rel="noopener">shanyizhou:Linux Userfaultfd</a></li><li><a href="https://blog.linuxplumbersconf.org/2017/ocw/system/presentations/4699/original/userfaultfd_%20post-copy%20VM%20migration%20and%20beyond.pdf" target="_blank" rel="noopener">userfaultfd_ post-copy VM migration and beyond.pdf</a></li><li><a href="https://noahdesu.github.io/2016/10/10/userfaultfd-hello-world.html" target="_blank" rel="noopener">userfaultfd hello world</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容主要转载自&lt;a href=&quot;http://brieflyx.me/2020/linux-tools/userfaultfd-internals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux Kernel Userfaultfd 内部机制探究&lt;/a&gt;，看代码的时候结合&lt;a href=&quot;https://man7.org/linux/man-pages/man2/userfaultfd.2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;man userfaultfd&lt;/a&gt;和&lt;a href=&quot;https://man7.org/linux/man-pages/man2/ioctl_userfaultfd.2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;man ioctl_userfaultfd&lt;/a&gt;，方便查询。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>eBPF资料合集</title>
    <link href="http://liujunming.github.io/2022/07/10/eBPF%E8%B5%84%E6%96%99%E5%90%88%E9%9B%86/"/>
    <id>http://liujunming.github.io/2022/07/10/eBPF资料合集/</id>
    <published>2022-07-10T04:10:12.000Z</published>
    <updated>2022-07-24T08:22:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>个人整理的eBPF资料合集。<a id="more"></a></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><a href="https://blog.csdn.net/hjkfcz/article/details/104916719" target="_blank" rel="noopener">ebpf原理分析</a></li><li><a href="https://tinylab.org/ebpf-part2/" target="_blank" rel="noopener">eBPF 程序装载、翻译与运行过程详解</a></li><li><a href="https://mp.weixin.qq.com/s/pKDn9DrvKYwDlu88Ojg5Pg" target="_blank" rel="noopener">揭秘 BPF map 前生今世</a></li><li><a href="https://mp.weixin.qq.com/s/afDcXoh0YfRlics22kucQw" target="_blank" rel="noopener">高效入门eBPF</a></li></ul><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ul><li><a href="https://mp.weixin.qq.com/s/9NtEmY0K861v9tHvmTOvWw" target="_blank" rel="noopener">eBPF Tracing 入门教程与实例</a></li><li><a href="https://mp.weixin.qq.com/s/LaoNpE5MNMrEeKzOFb_lYA" target="_blank" rel="noopener">深入浅出 eBPF｜你要了解的 7 个核心问题</a></li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li><a href="https://mp.weixin.qq.com/s/wn_hdcGPXOnzEZNj_-baJw" target="_blank" rel="noopener">宋宝华：用eBPF/bcc分析系统性能的一个简单案例</a></li><li><a href="https://mp.weixin.qq.com/s/6vw_HepdR76w_6vSmHuIVA" target="_blank" rel="noopener">基于eBPF监控和排查云原生环境中的磁盘IO性能问题</a></li><li><a href="https://mp.weixin.qq.com/s/meHBnFphRi9Kz-bf5QrONg" target="_blank" rel="noopener">高性能BPF内存分析工具解析</a></li><li><a href="https://www.ebpf.top/post/no_space_left_on_devices/" target="_blank" rel="noopener">eBPF+Ftrace 合璧剑指：no space left on device</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人整理的eBPF资料合集。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>bpftrace资料合集</title>
    <link href="http://liujunming.github.io/2022/07/10/bpftrace%E8%B5%84%E6%96%99%E5%90%88%E9%9B%86/"/>
    <id>http://liujunming.github.io/2022/07/10/bpftrace资料合集/</id>
    <published>2022-07-10T03:12:54.000Z</published>
    <updated>2022-07-24T08:22:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>个人整理的bpftrace资料合集。<a id="more"></a></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ul><li><a href="https://opensource.com/article/19/8/introduction-bpftrace" target="_blank" rel="noopener">An introduction to bpftrace for Linux</a></li><li><a href="https://www.brendangregg.com/ebpf.html#bpftrace" target="_blank" rel="noopener">Linux Extended BPF (eBPF) Tracing Tools:bpftrace</a></li><li><a href="https://github.com/iovisor/bpftrace/blob/master/man/adoc/bpftrace.adoc" target="_blank" rel="noopener">Manual</a></li><li><a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md" target="_blank" rel="noopener">Reference Guide</a></li><li><a href="https://github.com/iovisor/bpftrace/blob/master/docs/tutorial_one_liners.md" target="_blank" rel="noopener">One-Liner Tutorial</a></li><li><a href="https://github.com/iovisor/bpftrace" target="_blank" rel="noopener">github bpftrace</a></li></ul><h2 id="精读"><a href="#精读" class="headerlink" title="精读"></a>精读</h2><ul><li><a href="https://mp.weixin.qq.com/s/eZySfbqwOzG5EW7YL6enSw" target="_blank" rel="noopener">从bpftrace看如何利用eBPF实现内核追踪</a><ul><li><a href="/pdf/bpftrace_tutorial.pdf">archive</a></li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/476264071" target="_blank" rel="noopener">Linux - 如何测量函数的执行时间</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人整理的bpftrace资料合集。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Notes about eBPF</title>
    <link href="http://liujunming.github.io/2022/07/09/Notes-about-eBPF/"/>
    <id>http://liujunming.github.io/2022/07/09/Notes-about-eBPF/</id>
    <published>2022-07-09T07:53:10.000Z</published>
    <updated>2022-07-24T08:22:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>eBPF does to Linux what JavaScript does to HTML. (Sort of.) So instead of a static HTML website, JavaScript lets you define mini programs that run on events like mouse clicks, which are run in a safe virtual machine in the browser. And with eBPF, instead of a fixed kernel, you can now write mini programs that run on events like disk I/O, which are run in a safe virtual machine in the kernel. In reality, eBPF is more like the v8 virtual machine that runs JavaScript, rather than JavaScript itself. eBPF is part of the Linux kernel.</p><p>Programming in eBPF directly is incredibly hard, the same as coding in v8 bytecode. But no one codes in v8: they code in JavaScript, or often a framework on top of JavaScript (jQuery, Angular, React, etc). It’s the same with eBPF. People will use it and code in it via frameworks. For tracing, the main ones are bcc and bpftrace. These don’t live in the kernel code base, they live in a Linux Foundation project on github called iovisor.[1]<a id="more"></a></p><p>本文内容转载自：<a href="https://www.brendangregg.com/ebpf.html" target="_blank" rel="noopener">Linux Extended BPF (eBPF) Tracing Tools</a></p><h2 id="1-History"><a href="#1-History" class="headerlink" title="1. History"></a>1. History</h2><p>BPF originated as a technology for optimizing packet filters. If you run tcpdump with an expression (matching on a host or port), it gets compiled into optimal BPF bytecode which is executed by an in-kernel sandboxed virtual machine. Extended BPF extended what this BPF virtual machine could do: allowing it to run on events other than packets, and do actions other than filtering.</p><h2 id="2-Introduction"><a href="#2-Introduction" class="headerlink" title="2. Introduction"></a>2. Introduction</h2><p>eBPF can be used to for software defined networks, DDoS mitigation (early packet drop), improving network performance (eXpress Data Path), intrusion detection, and more. It is used as shown in the following workflow:<br><img src="https://www.brendangregg.com/eBPF/linux_ebpf_internals.png" alt></p><p>Our observability tool has BPF code to perform certain actions: measure latency, summarize as a histogram, grab stack traces, etc. That BPF code is compiled to BPF byte code and then sent to the kernel, where a verifier may reject it if it is deemed unsafe (which includes not allowing loops or backwards branches). If the BPF bytecode is accepted, it can then be attached to different event sources:</p><ul><li><strong>kprobes</strong>: kernel dynamic tracing.</li><li><strong>uprobes</strong>: user level dynamic tracing.</li><li><strong>tracepoints</strong>: kernel static tracing.</li><li><strong>perf_events</strong>: timed sampling and PMCs.</li></ul><p>The BPF program has two ways to pass measured data back to user space: either per-event details, or via a BPF map. BPF maps can implement arrays, associative arrays, and histograms, and are suited for passing summary statistics.</p><h2 id="3-Prerequisites"><a href="#3-Prerequisites" class="headerlink" title="3. Prerequisites"></a>3. Prerequisites</h2><p>A Linux kernel compiled with CONFIG_BPF_SYSCALL (eg, Ubuntu does this), and at least the 4.4 kernel (eg, Ubuntu Xenial) so that histogram, statistic, and per-event tracing is supported. The following diagram shows other features with the Linux version eBPF supported arrived in green:<br><img src="https://www.brendangregg.com/eBPF/linux_ebpf_support.png" alt></p><h2 id="4-Front-Ends"><a href="#4-Front-Ends" class="headerlink" title="4. Front Ends"></a>4. Front Ends</h2><p>There are multiple different front-ends for eBPF. Here’s a summary, I’d recommend trying out bcc and bpftrace (highlighted).<br><img src="/images/2022/06/06.jpg" alt><br>I’ve previously summarized these on three dimensions: ease of use, scope &amp; capability, and stage of development. Here are the BPF front-ends vs the standard built-in Linux tracers (ftrace and perf):<br><img src="https://www.brendangregg.com/eBPF/ebpf_tracing_landscape_jan2019.png" alt></p><hr><p>Reference:<br>[1] <a href="https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html" target="_blank" rel="noopener">https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;eBPF does to Linux what JavaScript does to HTML. (Sort of.) So instead of a static HTML website, JavaScript lets you define mini programs that run on events like mouse clicks, which are run in a safe virtual machine in the browser. And with eBPF, instead of a fixed kernel, you can now write mini programs that run on events like disk I/O, which are run in a safe virtual machine in the kernel. In reality, eBPF is more like the v8 virtual machine that runs JavaScript, rather than JavaScript itself. eBPF is part of the Linux kernel.&lt;/p&gt;
&lt;p&gt;Programming in eBPF directly is incredibly hard, the same as coding in v8 bytecode. But no one codes in v8: they code in JavaScript, or often a framework on top of JavaScript (jQuery, Angular, React, etc). It’s the same with eBPF. People will use it and code in it via frameworks. For tracing, the main ones are bcc and bpftrace. These don’t live in the kernel code base, they live in a Linux Foundation project on github called iovisor.[1]
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Notes about ACPI Platform Error Interface(APEI)</title>
    <link href="http://liujunming.github.io/2022/07/03/Notes-about-ACPI-Platform-Error-Interface-APEI/"/>
    <id>http://liujunming.github.io/2022/07/03/Notes-about-ACPI-Platform-Error-Interface-APEI/</id>
    <published>2022-07-03T07:28:01.000Z</published>
    <updated>2022-07-24T08:22:39.583Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录ACPI Platform Error Interface(APEI)相关笔记。<a id="more"></a></p><p><a href="/pdf/apei.pdf">A_Tour_beyond_BIOS_Implementing_APEI_with_UEFI_White_Paper</a></p><p>如果不想了解UEFI实现细节的话，阅读下图红框中标注的内容即可！<br><img src="/images/2022/06/04.jpg" alt></p><hr><p>参考资料：</p><ol><li><a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.466.5363&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">A_Tour_beyond_BIOS_Implementing_APEI_with_UEFI_White_Paper</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录ACPI Platform Error Interface(APEI)相关笔记。
    
    </summary>
    
      <category term="RAS" scheme="http://liujunming.github.io/categories/RAS/"/>
    
    
      <category term="ACPI" scheme="http://liujunming.github.io/tags/ACPI/"/>
    
      <category term="RAS" scheme="http://liujunming.github.io/tags/RAS/"/>
    
  </entry>
  
  <entry>
    <title>Notes about APEI Error INJection</title>
    <link href="http://liujunming.github.io/2022/06/28/Notes-about-APEI-Error-INJection/"/>
    <id>http://liujunming.github.io/2022/06/28/Notes-about-APEI-Error-INJection/</id>
    <published>2022-06-28T13:26:17.000Z</published>
    <updated>2022-07-24T08:22:39.583Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2022/06/05.jpg" alt><br>APEI (ACPI Platform Error Interface) EINJ provides a hardware error injection mechanism. It is very useful for debugging and testing APEI and RAS features in general.<a id="more"></a></p><p><img src="/images/2022/06/03.jpg" alt></p><p>An error injection example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># cd /sys/kernel/debug/apei/einj</span><br><span class="line"># cat available_error_type            # See which errors can be injected</span><br><span class="line">0x00000002    Processor Uncorrectable non-fatal</span><br><span class="line">0x00000008    Memory Correctable</span><br><span class="line">0x00000010    Memory Uncorrectable non-fatal</span><br><span class="line"># echo 0x12345000 &gt; param1            # Set memory address for injection</span><br><span class="line"># echo $((-1 &lt;&lt; 12)) &gt; param2         # Mask 0xfffffffffffff000 - anywhere in this page</span><br><span class="line"># echo 0x8 &gt; error_type                       # Choose correctable memory error</span><br><span class="line"># echo 1 &gt; error_inject                       # Inject now</span><br></pre></td></tr></table></figure></p><p>You should see something like this in dmesg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[22715.830801] EDAC sbridge MC3: HANDLING MCE MEMORY ERROR</span><br><span class="line">[22715.834759] EDAC sbridge MC3: CPU 0: Machine Check Event: 0 Bank 7: 8c00004000010090</span><br><span class="line">[22715.834759] EDAC sbridge MC3: TSC 0</span><br><span class="line">[22715.834759] EDAC sbridge MC3: ADDR 12345000 EDAC sbridge MC3: MISC 144780c86</span><br><span class="line">[22715.834759] EDAC sbridge MC3: PROCESSOR 0:306e7 TIME 1422553404 SOCKET 0 APIC 0</span><br><span class="line">[22716.616173] EDAC MC3: 1 CE memory read error on CPU_SrcID#0_Channel#0_DIMM#0 (channel:0 slot:0 page:0x12345 offset:0x0 grain:32 syndrome:0x0 -  area:DRAM err_code:0001:0090 socket:0 channel_mask:1 rank:0)</span><br></pre></td></tr></table></figure></p><hr><p>参考资料：</p><ol><li><a href="https://www.kernel.org/doc/html/latest/firmware-guide/acpi/apei/einj.html" target="_blank" rel="noopener">APEI Error INJection</a></li><li><a href="https://lwn.net/Articles/384825/" target="_blank" rel="noopener">ACPI, APEI support</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2022/06/05.jpg&quot; alt&gt;&lt;br&gt;APEI (ACPI Platform Error Interface) EINJ provides a hardware error injection mechanism. It is very useful for debugging and testing APEI and RAS features in general.
    
    </summary>
    
      <category term="ACPI" scheme="http://liujunming.github.io/categories/ACPI/"/>
    
    
      <category term="ACPI" scheme="http://liujunming.github.io/tags/ACPI/"/>
    
  </entry>
  
  <entry>
    <title>Notes about pstack and /proc/[pid]/stack</title>
    <link href="http://liujunming.github.io/2022/06/19/Notes-about-pstack-and-proc-stacks/"/>
    <id>http://liujunming.github.io/2022/06/19/Notes-about-pstack-and-proc-stacks/</id>
    <published>2022-06-19T02:51:34.000Z</published>
    <updated>2022-07-24T08:22:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录pstack与/proc/[pid]/stack相关笔记。<a id="more"></a></p><h3 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h3><p>pstack显示user-space stack，/proc/[pid]/stack显示kernel stack。</p><h3 id="2-pstack"><a href="#2-pstack" class="headerlink" title="2. pstack"></a>2. pstack</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ man pstack</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       gstack - print a stack trace of a running process</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       gstack pid</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       gstack  attaches  to the active process named by the pid on the command line,</span><br><span class="line">       and prints out an execution stack trace.</span><br><span class="line">       If ELF symbols exist in the binary, then symbolic addresses are printed as well.</span><br><span class="line"></span><br><span class="line">       If the process is part of a thread group,</span><br><span class="line">       then gstack will print out a stack trace for each of the threads in the group.</span><br></pre></td></tr></table></figure><h3 id="3-proc-pid-stack"><a href="#3-proc-pid-stack" class="headerlink" title="3. /proc/[pid]/stack"></a>3. /proc/[pid]/stack</h3><p>权威教程：<a href="https://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">man proc</a></p><p><img src="/images/2022/06/01.jpg" alt></p><p><img src="/images/2022/06/02.jpg" alt></p><hr><p>参考资料：</p><ol><li><a href="https://stackoverflow.com/questions/33429376/how-to-understand-proc-pid-stack" target="_blank" rel="noopener">How to understand “/proc/[pid]/stack”?</a></li><li><a href="https://unix.stackexchange.com/questions/23232/what-is-the-difference-between-proc-self-stack-and-output-from-pstack" target="_blank" rel="noopener">What is the difference between /proc/self/stack and output from pstack?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录pstack与/proc/[pid]/stack相关笔记。
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第31期</title>
    <link href="http://liujunming.github.io/2022/06/13/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC31%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2022/06/13/每周分享第31期/</id>
    <published>2022-06-13T14:47:32.000Z</published>
    <updated>2022-07-24T08:22:39.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ventoy"><a href="#Ventoy" class="headerlink" title="Ventoy"></a>Ventoy</h3><p><a href="https://4sysops.com/archives/ventoy-boot-multiple-iso-images-from-a-single-usb-stick/" target="_blank" rel="noopener">Ventoy: Boot multiple ISO images from a single USB stick</a></p><a id="more"></a><h3 id="打入BAT字节数据中心！这家创企硬刚英特尔，5nm芯片已送样"><a href="#打入BAT字节数据中心！这家创企硬刚英特尔，5nm芯片已送样" class="headerlink" title="打入BAT字节数据中心！这家创企硬刚英特尔，5nm芯片已送样"></a>打入BAT字节数据中心！这家创企硬刚英特尔，5nm芯片已送样</h3><p><a href="https://mp.weixin.qq.com/s/Y3SbMohPkICDEPMnFNqUJQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Y3SbMohPkICDEPMnFNqUJQ</a></p><p>考虑到x86处理器体系强大的生态壁垒，在云端数据中心市场，以Ampere为代表的Arm服务器芯片设计公司们，仍有较长的一段路要走。<br>无论如何，更多Arm芯片创业者的涌入，正令围绕云端数据中心计算平台的竞争变得更加有趣。</p><h3 id="苹果发布M2处理器"><a href="#苹果发布M2处理器" class="headerlink" title="苹果发布M2处理器"></a>苹果发布M2处理器</h3><p><a href="https://www.bilibili.com/video/BV11Y4y1x7VK?vd_source=bb66ccea153753895eb854bf770dff82" target="_blank" rel="noopener">https://www.bilibili.com/video/BV11Y4y1x7VK?vd_source=bb66ccea153753895eb854bf770dff82</a></p><h3 id="Asahi-Linux"><a href="#Asahi-Linux" class="headerlink" title="Asahi Linux"></a>Asahi Linux</h3><p><a href="https://asahilinux.org/about/" target="_blank" rel="noopener">https://asahilinux.org/about/</a></p><p>Asahi Linux is a project and community with the goal of porting Linux to Apple Silicon Macs, starting with the 2020 M1 Mac Mini, MacBook Air, and MacBook Pro.</p><h3 id="elephant-flow"><a href="#elephant-flow" class="headerlink" title="elephant flow"></a>elephant flow</h3><p>In computer networking, an elephant flow is an extremely large (in total bytes) continuous flow set up by a TCP (or other protocol) flow measured over a network link.<br><a href="https://en.wikipedia.org/wiki/Elephant_flow" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Elephant_flow</a></p><h3 id="Why-You-Should-Read-Books-The-Benefits-of-Reading-More-animated"><a href="#Why-You-Should-Read-Books-The-Benefits-of-Reading-More-animated" class="headerlink" title="Why You Should Read Books - The Benefits of Reading More (animated)"></a>Why You Should Read Books - The Benefits of Reading More (animated)</h3><p><a href="https://www.youtube.com/watch?v=pRTWFqhEDeo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=pRTWFqhEDeo</a></p><h3 id="阿里云张建锋：Back-to-Basic，定义下一代的云"><a href="#阿里云张建锋：Back-to-Basic，定义下一代的云" class="headerlink" title="阿里云张建锋：Back to Basic，定义下一代的云"></a>阿里云张建锋：Back to Basic，定义下一代的云</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4NjI4MzM4MQ==&amp;mid=2660225957&amp;idx=1&amp;sn=48b9c71e0c16ebb98416297d56484bf0&amp;chksm=84b076bfb3c7ffa90ca524a9fa18d2d6d9c33017af1a45ad4ab620629cfc5da8d99f48ec0b4c&amp;token=2053767401&amp;lang=zh_CN#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4NjI4MzM4MQ==&amp;mid=2660225957&amp;idx=1&amp;sn=48b9c71e0c16ebb98416297d56484bf0&amp;chksm=84b076bfb3c7ffa90ca524a9fa18d2d6d9c33017af1a45ad4ab620629cfc5da8d99f48ec0b4c&amp;token=2053767401&amp;lang=zh_CN#rd</a></p><p>阿里云发布了一款云数据中心专用处理器CIPU（Cloud infrastructure Processing Units），将替代CPU成为云时代IDC的处理核心。</p><h3 id="无影"><a href="#无影" class="headerlink" title="无影"></a>无影</h3><p><a href="https://www.aliyun.com/product/ecs/wuying" target="_blank" rel="noopener">https://www.aliyun.com/product/ecs/wuying</a><br>云电脑。</p><p>无影是阿里云打造的云端一体、安全高效的一站式云上办公空间。无影的云桌面、云应用、应用中心、安全浏览器等一系列的云办公能力，通过流化的技术，提供给终端用户，在算力、安全、成本、敏捷、开放等方面，无影具有超越传统PC的优势。</p><h3 id="ASP协议"><a href="#ASP协议" class="headerlink" title="ASP协议"></a>ASP协议</h3><p><a href="https://help.aliyun.com/apsara/enterprise/v_3_14_0_20210519/appstreaming/enterprise-product-introduction/what-is-the-asp-protocol.html?spm=a2c4g.14484438.10004.1" target="_blank" rel="noopener">https://help.aliyun.com/apsara/enterprise/v_3_14_0_20210519/appstreaming/enterprise-product-introduction/what-is-the-asp-protocol.html?spm=a2c4g.14484438.10004.1</a></p><p>无影宣布升级全新ASP云流协议，支持开发者打造8K画质体验，并将时延控制在20毫秒内。</p><p>ASP（Adaptive Streaming Protocol）是阿里云自主研发的面向应用流的一种新型端云协同协议，旨在为无影产品提供端云一体的协议支撑，为终端用户提供低时延高画质的实时交互体验。通过ASP协议用户在不同服务器和客户端配置需求中、不同的工作场景下以及不同的网络条件时均能得到最佳的用户体验。</p><p>ASP协议在TCP/UDP网络协议上运行，借助于当前高效的编解码技术，将云上的图形化交互界面进行编码，以视频流（Streaming）的方式推送到客户端，客户端执行解码并显示图形化界面。ASP协议通过虚拟传输通道技术，将客户端侧的鼠标、键盘等外设事件重定向到服务端，从而实现端和云的交互事件输入。</p><h3 id="VDI桌面虚拟化四大协议"><a href="#VDI桌面虚拟化四大协议" class="headerlink" title="VDI桌面虚拟化四大协议"></a>VDI桌面虚拟化四大协议</h3><ul><li>ICA：ICA协议属于Citrix，它的英文全称是Independent Computing Architecture</li><li>PCoIP：PCoIP是Vmware的</li><li>RDP：RDP英方全称是Remote Desktop Protocol</li><li>SPICE：是一个开源协议，英文全称是Simple Protocol for Independent Computing Environment</li></ul><h3 id="Citrix"><a href="#Citrix" class="headerlink" title="Citrix"></a>Citrix</h3><p>思杰系统公司是一家软件和云端运算的科技公司。它的跨国业绩包括提供服务器、软件及桌面虚拟化、网络连结、以及软件即服务等产品。<br><a href="https://zh.wikipedia.org/zh-cn/%E6%80%9D%E6%9D%B0%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/%E6%80%9D%E6%9D%B0%E7%B3%BB%E7%BB%9F</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Ventoy&quot;&gt;&lt;a href=&quot;#Ventoy&quot; class=&quot;headerlink&quot; title=&quot;Ventoy&quot;&gt;&lt;/a&gt;Ventoy&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://4sysops.com/archives/ventoy-boot-multiple-iso-images-from-a-single-usb-stick/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ventoy: Boot multiple ISO images from a single USB stick
&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Virtio 虚拟化技术趋势与 DPU 实践</title>
    <link href="http://liujunming.github.io/2022/05/29/Virtio-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF%E4%B8%8E-DPU-%E5%AE%9E%E8%B7%B5/"/>
    <id>http://liujunming.github.io/2022/05/29/Virtio-虚拟化技术趋势与-DPU-实践/</id>
    <published>2022-05-29T04:17:30.000Z</published>
    <updated>2022-07-24T08:22:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：龙蜥大讲堂第16期</p><ul><li><a href="https://openanolis.cn/video/566837307090997810" target="_blank" rel="noopener">video</a></li><li><a href="https://www.yuque.com/anolis-docs/courses" target="_blank" rel="noopener">slides</a><a id="more"></a></li></ul><h3 id="Virtio简介"><a href="#Virtio简介" class="headerlink" title="Virtio简介"></a>Virtio简介</h3><p>概述、演进、关键技术</p><p><img src="/images/2022/05/21.jpg" alt></p><p><img src="/images/2022/05/22.jpg" alt></p><p><img src="/images/2022/05/23.jpg" alt></p><p><img src="/images/2022/05/24.jpg" alt></p><p><img src="/images/2022/05/25.jpg" alt></p><p><img src="/images/2022/05/26.jpg" alt></p><h3 id="Virtio与DPU"><a href="#Virtio与DPU" class="headerlink" title="Virtio与DPU"></a>Virtio与DPU</h3><p>Virtio硬化</p><p><img src="/images/2022/05/27.jpg" alt><br>BM指的是BareMetal<br><img src="/images/2022/05/28.jpg" alt></p><p><img src="/images/2022/05/29.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：龙蜥大讲堂第16期&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://openanolis.cn/video/566837307090997810&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;video&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.yuque.com/anolis-docs/courses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;slides&lt;/a&gt;
    
    </summary>
    
      <category term="virtio" scheme="http://liujunming.github.io/categories/virtio/"/>
    
    
      <category term="virtio" scheme="http://liujunming.github.io/tags/virtio/"/>
    
      <category term="DPU" scheme="http://liujunming.github.io/tags/DPU/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第30期</title>
    <link href="http://liujunming.github.io/2022/05/27/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC30%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2022/05/27/每周分享第30期/</id>
    <published>2022-05-27T09:29:03.000Z</published>
    <updated>2022-07-24T08:22:39.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Express-Design-in-Power-Apps"><a href="#Express-Design-in-Power-Apps" class="headerlink" title="Express Design in Power Apps"></a>Express Design in Power Apps</h3><p>Express Design in <a href="https://powerapps.microsoft.com/en-us/blog/" target="_blank" rel="noopener">Power Apps</a>, which allows you to upload a PDF, PowerPoint or even a hand-drawn sketch that Express Design will convert into a working app within seconds.<br><a id="more"></a></p><h3 id="回顾AMD微处理器发展史的内幕"><a href="#回顾AMD微处理器发展史的内幕" class="headerlink" title="回顾AMD微处理器发展史的内幕"></a>回顾AMD微处理器发展史的内幕</h3><p><a href="https://mp.weixin.qq.com/s/uN9rz26QzPe96l-8r_ZViA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uN9rz26QzPe96l-8r_ZViA</a></p><h3 id="最接近事物本質的思考方式：第一性原理｜硅谷牛人馬斯克的思維方式"><a href="#最接近事物本質的思考方式：第一性原理｜硅谷牛人馬斯克的思維方式" class="headerlink" title="最接近事物本質的思考方式：第一性原理｜硅谷牛人馬斯克的思維方式"></a>最接近事物本質的思考方式：第一性原理｜硅谷牛人馬斯克的思維方式</h3><p><a href="https://www.youtube.com/watch?v=9kRSJdU2ht8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=9kRSJdU2ht8</a></p><h3 id="grammarly"><a href="#grammarly" class="headerlink" title="grammarly"></a>grammarly</h3><p>检查语法错误的工具，有chrome插件</p><h3 id="博通同意以610亿美元收购VMware"><a href="#博通同意以610亿美元收购VMware" class="headerlink" title="博通同意以610亿美元收购VMware"></a>博通同意以610亿美元收购VMware</h3><p><a href="https://news.cnstock.com/news,bwkx-202205-4889639.htm" target="_blank" rel="noopener">https://news.cnstock.com/news,bwkx-202205-4889639.htm</a></p><h3 id="Why-does-mmap-use-MAP-FAILED-instead-of-NULL"><a href="#Why-does-mmap-use-MAP-FAILED-instead-of-NULL" class="headerlink" title="Why does mmap() use MAP_FAILED instead of NULL?"></a>Why does mmap() use MAP_FAILED instead of NULL?</h3><p><a href="https://stackoverflow.com/questions/24562691/why-does-mmap-use-map-failed-instead-of-null" target="_blank" rel="noopener">https://stackoverflow.com/questions/24562691/why-does-mmap-use-map-failed-instead-of-null</a></p><p>There are some rare situations where <code>mmap()</code> will actually create a mapping at address 0x0. These days, it typically requires root privileges (or for the <code>mmap_min_addr</code> sysctl to be set to zero on Linux systems) but it is possible. If such a mapping is created, it becomes possible to write to this address.</p><p><code>MAP_FAILED</code>, on the other hand, is never a valid return value from <code>mmap()</code>, so it’s usable as a sentinel.</p><h3 id="怎样提高自己的不可替代性？"><a href="#怎样提高自己的不可替代性？" class="headerlink" title="怎样提高自己的不可替代性？"></a>怎样提高自己的不可替代性？</h3><p><a href="https://mp.weixin.qq.com/s/qCSFGs5W7HBHJCFgewGQgA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qCSFGs5W7HBHJCFgewGQgA</a></p><ol><li>一定要培养一技之长，并且练到极致</li><li>通过不断持续学习，让自己多几个标签</li><li>为公司创造价值</li><li>拥有解决问题的能力</li></ol><h3 id="阿里云刘洪强：通往山顶的路各不相同"><a href="#阿里云刘洪强：通往山顶的路各不相同" class="headerlink" title="阿里云刘洪强：通往山顶的路各不相同"></a>阿里云刘洪强：通往山顶的路各不相同</h3><p><a href="https://mp.weixin.qq.com/s/2YU2QX8HTsoSBteYBEdY-g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2YU2QX8HTsoSBteYBEdY-g</a></p><ul><li>个人主页：<a href="https://www.aminer.cn/profile/53f4a511dabfaedce5633b9d" target="_blank" rel="noopener">https://www.aminer.cn/profile/53f4a511dabfaedce5633b9d</a></li><li>必读论文：<a href="https://www.aminer.cn/topic/628317ec7376380a6a7405c9" target="_blank" rel="noopener">https://www.aminer.cn/topic/628317ec7376380a6a7405c9</a></li></ul><h3 id="回归课本、课本是精华中的精华"><a href="#回归课本、课本是精华中的精华" class="headerlink" title="回归课本、课本是精华中的精华"></a>回归课本、课本是精华中的精华</h3><p><a href="https://www.ixigua.com/7098913476193619237?wid_try=1" target="_blank" rel="noopener">https://www.ixigua.com/7098913476193619237?wid_try=1</a></p><h3 id="乘众人之智，则无不任也；用众人之力，则无不胜也"><a href="#乘众人之智，则无不任也；用众人之力，则无不胜也" class="headerlink" title="乘众人之智，则无不任也；用众人之力，则无不胜也"></a>乘众人之智，则无不任也；用众人之力，则无不胜也</h3><p><a href="https://www.kekeshici.com/mingyanmingju/guoxuejuian/129370.html" target="_blank" rel="noopener">https://www.kekeshici.com/mingyanmingju/guoxuejuian/129370.html</a><br>语出《淮南子·主术训》。利用众人的智慧，那么就没有做不好的事情;凭借众人的力量，那么就没有取不得的成功。说明只要注意发挥集体的智慧和力量，就能百为百成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Express-Design-in-Power-Apps&quot;&gt;&lt;a href=&quot;#Express-Design-in-Power-Apps&quot; class=&quot;headerlink&quot; title=&quot;Express Design in Power Apps&quot;&gt;&lt;/a&gt;Express Design in Power Apps&lt;/h3&gt;&lt;p&gt;Express Design in &lt;a href=&quot;https://powerapps.microsoft.com/en-us/blog/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Power Apps&lt;/a&gt;, which allows you to upload a PDF, PowerPoint or even a hand-drawn sketch that Express Design will convert into a working app within seconds.&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>A Perfect Solution for Live Migration with Pass-through Devices by Quan Xu </title>
    <link href="http://liujunming.github.io/2022/05/21/A-Perfect-Solution-for-Live-Migration-with-Pass-through-Devices-by-Quan-Xu/"/>
    <id>http://liujunming.github.io/2022/05/21/A-Perfect-Solution-for-Live-Migration-with-Pass-through-Devices-by-Quan-Xu/</id>
    <published>2022-05-21T10:05:38.000Z</published>
    <updated>2022-07-24T08:22:39.582Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=8eeLhzQvtpY" target="_blank" rel="noopener">A Perfect Solution for Live Migration with Pass-through Devices by Quan Xu</a></p><p>From KVM forum’2018.<a id="more"></a></p><p>Several efforts have been made on enabling live migration with pass-through devices, however, it is inevitable to modify device driver to save and restore device states, and mark a page as dirty after DMA memory access. These ‘ugly’ modifications are not compatible with legacy drivers or Windows virtual machine.<br>We design new virtio hardware devices (virtio-net based Nic and virtio-blk based storage). These devices can be pass-through with VFIO, then the legacy virtio-net/virtio-blk drivers are working without any modification in virtual machine, including Windows. We also extend the capability of devices to support live migration, including being aware of live migration, logging the page of DMA memory access, saving and restoring device states on run-time. And then we extend the migration and VFIO code to support live migration with pass-through these devices as QEMU ‘emulated’ devices.</p><p><img src="/images/2022/05/20.jpg" alt><br><img src="/images/2022/05/05.jpg" alt><br><img src="/images/2022/05/06.jpg" alt><br><img src="/images/2022/05/07.jpg" alt><br><img src="/images/2022/05/08.jpg" alt><br><img src="/images/2022/05/09.jpg" alt><br>For RO(Read Only) registers, they can be read by source host, but it couldn’t be restored on the destination host(Because the restore operations need the write of these registers, while RO registers couldn’t be wroten).<br><img src="/images/2022/05/10.jpg" alt><br><img src="/images/2022/05/11.jpg" alt><br><img src="/images/2022/05/12.jpg" alt><br><img src="/images/2022/05/13.jpg" alt><br><img src="/images/2022/05/14.jpg" alt><br><img src="/images/2022/05/15.jpg" alt><br><img src="/images/2022/05/16.jpg" alt><br><img src="/images/2022/05/17.jpg" alt><br><img src="/images/2022/05/18.jpg" alt><br><img src="/images/2022/05/19.jpg" alt></p><p>If the pass-thru devices support live migration, then all registers are R/W.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=8eeLhzQvtpY&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A Perfect Solution for Live Migration with Pass-through Devices by Quan Xu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From KVM forum’2018.
    
    </summary>
    
      <category term="live migration" scheme="http://liujunming.github.io/categories/live-migration/"/>
    
    
      <category term="live migration" scheme="http://liujunming.github.io/tags/live-migration/"/>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第29期</title>
    <link href="http://liujunming.github.io/2022/05/21/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC29%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2022/05/21/每周分享第29期/</id>
    <published>2022-05-21T08:17:14.000Z</published>
    <updated>2022-07-24T08:22:39.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。用通俗的话讲：就是针对一个操作，不管做多少次，产生效果或返回的结果都是一样的。</p><ol><li>前端对同一表单数据的重复提交，后台应该只会产生一个结果</li><li>我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱</li><li>发送消息，也应该只发一次，同样的短信如果多次发给用户，用户会崩溃</li><li>创建业务订单，一次业务请求只能创建一个，不能出现创建多个订单</li></ol><a id="more"></a><p><a href="https://gongfukangee.github.io/2019/03/25/Idempotence/" target="_blank" rel="noopener">如何保证业务的幂等性</a></p><h3 id="Potential-new-Zen-3-instructions"><a href="#Potential-new-Zen-3-instructions" class="headerlink" title="Potential new Zen 3 instructions"></a>Potential new Zen 3 instructions</h3><p>Anyway, the interesting bit for me were the new instructions, particularly INVLPGB and TLBSYNC.</p><p>The one that I found interesting was “Invalidate TLB Entry(s) with Broadcast” INVLPGB. It is supposed to be used together with “Synchronize TLB Invalidations” TLBSYNC.</p><p><a href="https://www.reddit.com/r/hardware/comments/gf2ooy/potential_new_zen_3_instructions/" target="_blank" rel="noopener">Potential new Zen 3 instructions</a></p><h3 id="一文读懂CDN"><a href="#一文读懂CDN" class="headerlink" title="一文读懂CDN"></a>一文读懂CDN</h3><p><a href="https://mp.weixin.qq.com/s/O2exHSnXnr765faeeFjvaA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/O2exHSnXnr765faeeFjvaA</a></p><h3 id="OTT"><a href="#OTT" class="headerlink" title="OTT"></a>OTT</h3><p>OTT (over-the-top) is a means of providing television and film content over the internet at the request and to suit the requirements of the individual consumer.</p><p>OTT 是“Over The Top”的缩写，指的是通过互联网传输流媒体的服务。“Over The Top” 原指篮球运动中的过顶传球，而 OTT 服务的传输过程“越过”了另外一种平台，因此而得名。</p><h3 id="有利于提高xenomai-实时性的一些配置建议"><a href="#有利于提高xenomai-实时性的一些配置建议" class="headerlink" title="有利于提高xenomai 实时性的一些配置建议"></a>有利于提高xenomai 实时性的一些配置建议</h3><p><a href="https://mp.weixin.qq.com/s/p7AhaRD90sND6CoxTlA8Xg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/p7AhaRD90sND6CoxTlA8Xg</a></p><h3 id="Cherry-（电子产品制造商）"><a href="#Cherry-（电子产品制造商）" class="headerlink" title="Cherry （电子产品制造商）"></a>Cherry （电子产品制造商）</h3><p>Cherry公司是全球专业的键盘制造厂商，专注于电子产品品牌，所在地为德国，以机械键盘闻名世界。</p><h3 id="overleaf"><a href="#overleaf" class="headerlink" title="overleaf"></a>overleaf</h3><p><a href="https://www.overleaf.com/" target="_blank" rel="noopener">https://www.overleaf.com/</a></p><p>The easy to use, online, collaborative LaTeX editor</p><h3 id="《蓝色星球2》"><a href="#《蓝色星球2》" class="headerlink" title="《蓝色星球2》"></a>《蓝色星球2》</h3><p>每一帧都值得截图当桌面</p><p><a href="https://movie.douban.com/subject/26979545/" target="_blank" rel="noopener">https://movie.douban.com/subject/26979545/</a><br><a href="https://mp.weixin.qq.com/s/_tPGE_3UPhjJrP8YgTsabg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_tPGE_3UPhjJrP8YgTsabg</a></p><h3 id="樱桃OTC前工程师感恩自白"><a href="#樱桃OTC前工程师感恩自白" class="headerlink" title="樱桃OTC前工程师感恩自白"></a>樱桃OTC前工程师感恩自白</h3><p><a href="https://mp.weixin.qq.com/s/Lh5xT6u19DyvTTgFjB183A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Lh5xT6u19DyvTTgFjB183A</a></p><h3 id="逐梦天河"><a href="#逐梦天河" class="headerlink" title="逐梦天河"></a>逐梦天河</h3><p><a href="https://www.bilibili.com/video/BV1W5411P73b/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1W5411P73b/</a><br>银河筑梦波澜阔，天河飞渡擎巨擘。由天津海河传媒中心推出的纪录片《逐梦天河》共分三集，通过讲述中国超算的发展历程，深刻诠释科学家精神的内涵。从北国冰城到湘江之畔，从哈军工到国防科大，中国的超级计算事业从萌芽、起步到登顶世界第一，广泛服务于国家科技创新的各个领域，背后是一代代以祖国需要为己任的计算机科技攻关队伍，在接续奋斗。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;幂等性&quot;&gt;&lt;a href=&quot;#幂等性&quot; class=&quot;headerlink&quot; title=&quot;幂等性&quot;&gt;&lt;/a&gt;幂等性&lt;/h3&gt;&lt;p&gt;在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。用通俗的话讲：就是针对一个操作，不管做多少次，产生效果或返回的结果都是一样的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前端对同一表单数据的重复提交，后台应该只会产生一个结果&lt;/li&gt;
&lt;li&gt;我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱&lt;/li&gt;
&lt;li&gt;发送消息，也应该只发一次，同样的短信如果多次发给用户，用户会崩溃&lt;/li&gt;
&lt;li&gt;创建业务订单，一次业务请求只能创建一个，不能出现创建多个订单&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
</feed>
