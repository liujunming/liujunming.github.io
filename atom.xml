<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2019-08-15T11:47:59.519Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>What is Kernel mode-setting?</title>
    <link href="http://liujunming.github.io/2019/08/15/What-is-Kernel-mode-setting/"/>
    <id>http://liujunming.github.io/2019/08/15/What-is-Kernel-mode-setting/</id>
    <published>2019-08-15T11:33:40.000Z</published>
    <updated>2019-08-15T11:47:59.519Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简要地介绍Kernel mode-setting。<br><a id="more"></a><br>在今天的工作中，遇到了<code>i915.modeset=0</code>这一选项，故mark下笔记。</p><p>Mode setting is a software operation that activates a display mode (screen resolution, color depth, and refresh rate) for a computer’s display controller.</p><p>In kernel mode-setting (KMS), the display mode is set by the kernel. In user-space mode-setting (UMS), the display mode is set by a userland process.</p><p>Kernel mode-setting is more flexible and allows displaying of an error in the case of a fatal system error in the kernel, even when using a user-space display server.</p><p>内核级显示模式设置 (KMS) ，作用是可以在内核级别而不是最终用户级别切换显示分辨率和颜色深度。</p><p><img src="/images/2019/8/8.png" alt><br><em>Regulating access to the hardware is a fundamental kernel task. The Direct Rendering Manager and KMS are part of the Linux kernel. The KMS does only the mode setting.</em></p><hr><p>参考资料：</p><ol><li><a href="https://unix.stackexchange.com/questions/110573/what-is-i915-modeset-1-for" target="_blank" rel="noopener">What is i915.modeset=1 for?</a></li><li><a href="https://www.wikiwand.com/en/Mode_setting" target="_blank" rel="noopener">Mode setting</a></li><li><a href="https://wiki.archlinux.org/index.php/Kernel_mode_setting_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">Kernel mode setting</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简要地介绍Kernel mode-setting。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>x86 CPU的MSR寄存器</title>
    <link href="http://liujunming.github.io/2019/08/12/x86-CPU%E7%9A%84MSR%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://liujunming.github.io/2019/08/12/x86-CPU的MSR寄存器/</id>
    <published>2019-08-12T14:54:34.000Z</published>
    <updated>2019-08-15T11:13:59.042Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简要地介绍MSR（Model Specific Register）。<a id="more"></a>内容来源于<a href="https://zhuanlan.zhihu.com/p/50142793" target="_blank" rel="noopener">x86 CPU的MSR寄存器</a>。</p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>MSR（Model Specific Register）是x86架构中的概念，指的是在x86架构处理器中，一系列用于控制CPU运行、功能开关、调试、跟踪程序执行、监测CPU性能等方面的寄存器。</p><h2 id="2-发展"><a href="#2-发展" class="headerlink" title="2. 发展"></a>2. 发展</h2><p>到Intel Pentium处理器的时候，Intel正式引入<code>RDMSR</code>和<code>WRMSR</code>两个指令用于读和写MSR寄存器，这个时候MSR就算被正式引入。在引入<code>RDMSR</code>和<code>WRMSR</code>指令的同时，也引入了<code>CPUID</code>指令，该指令用于指明具体的CPU芯片中，哪些功能是可用的，或者这些功能对应的MSR寄存器是否存在，软件可以通过<code>CPUID</code>指令查询某些功能是否在当前CPU上是否支持。</p><h2 id="3-MSR的访问方式"><a href="#3-MSR的访问方式" class="headerlink" title="3. MSR的访问方式"></a>3. MSR的访问方式</h2><p>每个MSR寄存器都会有一个相应的ID，即MSR Index，或者也叫作MSR寄存器地址，当执行RDMSR或者WRMSR指令的时候，只要提供MSR Index就能让CPU知道目标MSR寄存器。这些MSR寄存器的编号（MSR Index）、名字及其各个数据区域的定义可以在Intel x86架构手册”Intel 64 and IA-32 Architectures Software Developer’s Manual”的<a href="https://software.intel.com/sites/default/files/managed/22/0d/335592-sdm-vol-4.pdf" target="_blank" rel="noopener">Volume 4</a>中找到。</p><h2 id="4-相关介绍"><a href="#4-相关介绍" class="headerlink" title="4. 相关介绍"></a>4. 相关介绍</h2><p>MSR顾名思义就是Model Specific，即不同的CPU型号或不同的CPU厂商（Intel和AMD都会做x86架构的处理器），它的MSR寄存器可能是不一样的，它会根据具体的CPU型号的变化而变化，每款新的CPU都有可能引入新的MSR寄存器。</p><p>事实证明，MSR寄存器的引入用处还是很大的，有一些MSR寄存器甚至是MSR寄存器的部分区域将会被固定下来，并且未来的CPU都会支持这些MSR寄存器或者MSR寄存器的部分区域，这类MSR寄存器就叫做“Architecture MSRs”，Architecture MSR由于历史的原因（Pentium处理器是32位的），它的名字都是以”IA32_”为前缀的，即使是在目前主流的64位x86处理器中也是这样命名。</p><p>对于Intel的x86 CPU和AMD的x86 CPU而言，它们的MSR寄存器可能会有区别，但是可能因为各种原因，或者为了软件的兼容性，它们的部分MSR寄存器是一样的，如IA32_LSTAR。</p><hr><p>参考资料：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/50142793" target="_blank" rel="noopener">x86 CPU的MSR寄存器</a></li><li><a href="https://www.quora.com/How-do-x86-CPUs-use-the-model-specific-registers" target="_blank" rel="noopener">How do x86 CPUs use the model-specific registers?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简要地介绍MSR（Model Specific Register）。
    
    </summary>
    
      <category term="体系结构" scheme="http://liujunming.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>sysfs、udev 和 它们背后的 Linux 统一设备模型</title>
    <link href="http://liujunming.github.io/2019/08/11/sysfs%E3%80%81udev%20%E5%92%8C%20%E5%AE%83%E4%BB%AC%E8%83%8C%E5%90%8E%E7%9A%84%20Linux%20%E7%BB%9F%E4%B8%80%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"/>
    <id>http://liujunming.github.io/2019/08/11/sysfs、udev 和 它们背后的 Linux 统一设备模型/</id>
    <published>2019-08-11T02:38:40.000Z</published>
    <updated>2019-08-11T02:55:35.447Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自<a href="https://www.binss.me/blog/sysfs-udev-and-Linux-Unified-Device-Model/" target="_blank" rel="noopener">sysfs、udev 和 它们背后的 Linux 统一设备模型</a></p><p>详细内容请参考<a href="http://www.wowotech.net/sort/device_model" target="_blank" rel="noopener">统一设备模型</a>。</p><a id="more"></a><h2 id="1-sysfs-诞生之前"><a href="#1-sysfs-诞生之前" class="headerlink" title="1. sysfs 诞生之前"></a>1. sysfs 诞生之前</h2><p>一切皆文件，这是 Linux 的哲学之一。设备当然也不例外，它们往往被抽象成文件，存放在 /dev 目录下供用户进程进行操作。用户通过这些设备文件，可以实现对硬件进行相应的操作。而这些设备文件，需要由对应的设备文件系统来负责管理。</p><p>在 kernel 2.6 之前，完成这一使命的是 devfs。devfs 是 Linux 2.4 引入的一个虚拟的文件系统，挂载在 /dev 目录下。可以动态地为设备在 /dev 下创建或删除相应的设备文件，只生成存在设备的节点。</p><p>然而它存在以下缺点：</p><ul><li>可分配的<a href="https://nanxiao.me/linux-kernel-note-20-device-major-minor-number/" target="_blank" rel="noopener">设备号</a>数目 (major / minor) 受到限制</li><li>设备映射不确定，一个设备所对应的设备文件可能发生改变</li><li>设备名称在内核或模块中写死，违反了内核开发的原则</li><li>缺乏热插拔机制</li></ul><p>随着 kernel 的发展，从 Linux 2.6 起，devfs 被 sysfs + udev 所取代。sysfs + udev 在设计哲学和现实中的易用性都比 devfs 更优，自此 sysfs + udev 的组合走上 mainline ，直至目前，依然作为 Linux 的设备管理手段。</p><h2 id="2-sysfs"><a href="#2-sysfs" class="headerlink" title="2. sysfs"></a>2. sysfs</h2><p>sysfs 是一个基于内存的虚拟的文件系统，由 kernel 提供，挂载到 /sys 目录下(用 mount 查看得到 <code>sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)</code>)，负责以设备树的形式向 user space 提供直观的设备和驱动信息。</p><p>sysfs 以不同的视角展示当前系统接入的设备：</p><ul><li><p>/sys/block 历史遗留问题，存放块设备，提供以设备名 (如 sda) 到 / sys/devices 的符号链接</p></li><li><p>/sys/bus(对应kernel中的 <code>struct bus_type</code>) 按总线类型分类，在某个总线目录之下可以找到连接该总线的设备的符号链接，指向 / sys/devices。某个总线目录之下的 drivers 目录包含了该总线所需的所有驱动的符号链接。</p></li><li><p>/sys/class(对应kernel中的<code>struct class</code>) 按设备功能分类，如输入设备在 /sys/class/input 之下，图形设备在 /sys/class/graphics 之下，是指向 /sys/devices 目录下对应设备的符号链接。</p></li><li><p>/sys/dev(对应kernel中的<code>struct device_driver</code>)按设备驱动程序分层(字符设备/块设备)，提供以 major:minor 为名到/sys/devices 的符号链接。</p></li><li><p>/sys/devices(对应kernel中的<code>struct device</code>) 包含所有被发现的注册在各种总线上的各种物理设备。<br>所有的物理设备都按其在总线上的拓扑结构来显示，除了 platform devices 和 system devices：</p><ul><li>platform devices 一般是挂在芯片内部高速或者低速总线上的各种控制器和外设，能被 CPU 直接寻址。</li><li>system devices 不是外设，他是芯片内部的核心结构，比如 CPU，timer 等，他们一般没有相关的 driver，但是会有一些体系结构相关的代码来配置他们。</li></ul></li><li><p>/sys/firmware 提供对固件的查询和操作接口(关于固件有专用于固件加载的一套API)。</p></li><li><p>/sys/fs 描述当前加载的文件系统，提供文件系统和文件系统已挂载设备信息。</p></li><li><p>/sys/hypervisor 如果开启了 Xen，这个目录下会提供相关属性文件。</p></li><li><p>/sys/kernel 提供 kernel 所有可调整参数，但大多数可调整参数依然存放在 sysctl(/proc/sys/kernel)。</p></li><li><p>/sys/module 所有加载模块 (包括内联、编译进 kernel、外部的模块) 的信息，按模块类型分类。</p></li><li><p>/sys/power 电源选项，可用于控制整个机器的电源状态，如写入控制命令进行关机、重启等。</p></li></ul><p>sysfs 支持多视角查看，通过符号链接，同样的信息可以出现在多个目录下。</p><p>以硬盘 sda 为例，既可以在块设备目录/sys/block/下找到，又可以在所有设备目录/sys/devices/pci0000:00/0000:00:10.0/host32/target32:0:0/ 下找到。</p><p>查看 sda1 设备目录下的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ ll /sys/block/sda/</span><br><span class="line">drwxr-xr-x 11 root root    0 Feb  3 04:32 ./</span><br><span class="line">drwxr-xr-x  3 root root    0 Feb  3 04:32 ../</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 alignment_offset</span><br><span class="line">lrwxrwxrwx  1 root root    0 Feb  3 04:32 bdi -&gt; ../../../../../../../virtual/bdi/8:0/</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 capability</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 dev</span><br><span class="line">lrwxrwxrwx  1 root root    0 Feb  3 04:32 device -&gt; ../../../2:0:0:0/</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 discard_alignment</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 events</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 events_async</span><br><span class="line">-rw-r--r--  1 root root 4096 Feb  3 04:32 events_poll_msecs</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 ext_range</span><br><span class="line">drwxr-xr-x  2 root root    0 Feb  3 04:32 holders/</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 inflight</span><br><span class="line">drwxr-xr-x  2 root root    0 Feb  3 04:32 integrity/</span><br><span class="line">drwxr-xr-x  2 root root    0 Feb  3 04:32 power/</span><br><span class="line">drwxr-xr-x  3 root root    0 Feb  3 04:32 queue/</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 range</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 removable</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 ro</span><br><span class="line">drwxr-xr-x  5 root root    0 Feb  3 04:32 sda1/</span><br><span class="line">drwxr-xr-x  5 root root    0 Feb  3 04:32 sda2/</span><br><span class="line">drwxr-xr-x  5 root root    0 Feb  3 04:32 sda5/</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 size</span><br><span class="line">drwxr-xr-x  2 root root    0 Feb  3 04:32 slaves/</span><br><span class="line">-r--r--r--  1 root root 4096 Feb  3 04:32 stat</span><br><span class="line">lrwxrwxrwx  1 root root    0 Feb  3 04:32 subsystem -&gt; ../../../../../../../../class/block/</span><br><span class="line">drwxr-xr-x  2 root root    0 Feb  3 04:32 trace/</span><br><span class="line">-rw-r--r--  1 root root 4096 Feb  3 04:32 uevent</span><br></pre></td></tr></table></figure></p><p>目录以文件的形式提供了设备的信息，比如 dev 记录了主设备号和次设备号，size 记录了分区大小，uevent 存放了 uevent 的标识符等：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/block/sda/size</span><br><span class="line">41943040</span><br></pre></td></tr></table></figure></p><h2 id="3-统一设备模型"><a href="#3-统一设备模型" class="headerlink" title="3. 统一设备模型"></a>3. 统一设备模型</h2><p>sysfs 的功能基于 Linux 的统一设备模型，其由以下结构构成：</p><h3 id="3-1-Kobject"><a href="#3-1-Kobject" class="headerlink" title="3.1 Kobject"></a>3.1 Kobject</h3><p>目前为止，Kobject主要提供如下功能：</p><ol><li>通过parent指针，可以将所有Kobject以层次结构的形式组合起来。</li><li>使用一个引用计数（reference count），来记录Kobject被引用的次数，并在引用次数变为0时把它释放。</li><li>和sysfs虚拟文件系统配合，将每一个Kobject及其特性，以文件的形式，开放到用户空间。</li></ol><p>在描述数据结构之前，有必要说明一下Kobject, Kset和Ktype这三个概念。</p><ul><li><p>Kobject是基本数据类型，每个Kobject都会在”/sys/“文件系统中以目录的形式出现。</p></li><li><p>Ktype代表Kobject（严格地讲，是包含了Kobject的数据结构）的属性操作集合（由于通用性，多个Kobject可能共用同一个属性操作集，因此把Ktype独立出来了）。 </p></li><li><p>Kset是一个特殊的Kobject（因此它也会在”/sys/“文件系统中以目录的形式出现），它用来集合相似的Kobject（这些Kobject可以是相同属性的，也可以不同属性的）。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *name;                      <span class="comment">// 名称，将在 sysfs 中作为目录名</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">entry</span>;</span>                  <span class="comment">// 加入 kset 链表的结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>      *<span class="title">parent</span>;</span>                <span class="comment">// 父节点指针，构成树状结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>     *<span class="title">kset</span>;</span>                      <span class="comment">// 指向所属 kset</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>    *<span class="title">ktype</span>;</span>                 <span class="comment">// 类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span>  *<span class="title">sd</span>;</span>                    <span class="comment">// 指向所属 (sysfs) 目录项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>     <span class="title">kref</span>;</span>                       <span class="comment">// 引用计数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">release</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;           <span class="comment">// 是否已经初始化</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;              <span class="comment">// 是否已在 sysfs 中显示</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;       <span class="comment">// 是否已经向 user space 发送 ADD uevent</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;    <span class="comment">// 是否已经向 user space 发送 REMOVE uevent</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;             <span class="comment">// 是否忽略上报(不上报 uevent)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*release)(struct kobject *kobj);      <span class="comment">// 析构函数，kobject 的引用计数为 0 时调用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span>          <span class="comment">// 操作函数，当用户读取 sysfs 属性时调用 show()，写入 sysfs 属性时调用 store()</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span>           <span class="comment">// 默认属性，体现为该 kobject 目录下的文件</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="title">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span>   <span class="comment">// namespace 操作函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct kobject *kobj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>                      <span class="comment">// kobject 链表头</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;                       <span class="comment">// 自旋锁，保障操作安全</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>                        <span class="comment">// 自身的 kobject</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span>   <span class="comment">// uevent 操作函数集。kobject 发送 uevent 时会调用所属 kset 的 uevent_ops</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结: </p><ul><li><p>Kobject的核心功能是：保持一个引用计数，当该计数减为0时，自动释放Kobject所占用的meomry空间。这就决定了Kobject必须是动态分配的（只有这样才能动态释放）。 </p></li><li><p>Kobject大多数的使用场景，是内嵌在大型的数据结构中，因此这些大型的数据结构，也必须是动态分配、动态释放的。那么释放的时机是什么呢？是内嵌的Kobject释放时。但是Kobject的释放是由Kobject模块自动完成的（在引用计数为0时），那么怎么一并释放包含自己的大型数据结构呢？ </p></li><li><p>这时Ktype就派上用场了。我们知道，Ktype中的release回调函数负责释放Kobject（甚至是包含Kobject的数据结构）的内存空间，那么Ktype及其内部函数，是由谁实现呢？是由上层数据结构所在的模块！因为只有它，才清楚Kobject嵌在哪个数据结构中，并通过Kobject指针以及自身的数据结构类型，找到需要释放的上层数据结构的指针，然后释放它。 </p></li><li><p>每一个内嵌Kobject的数据结构，例如device、device_driver等等，都要实现一个Ktype，并定义其中的回调函数。同理，sysfs相关的操作也一样，必须经过ktype的中转，因为sysfs看到的是Kobject，而真正的文件操作的主体，是内嵌Kobject的上层数据结构。</p></li></ul><h3 id="3-2-device-driver-bus-class"><a href="#3-2-device-driver-bus-class" class="headerlink" title="3.2 device / driver / bus / class"></a>3.2 device / driver / bus / class</h3><p>详细内容参考<a href="http://www.wowotech.net/device_model/13.html" target="_blank" rel="noopener">Linux设备模型(1)_基本概念</a>。</p><p>device / driver / bus / class 四者之间存在着这样的关系：</p><ul><li>driver 用于驱动 device ，其保存了所有能够被它所驱动的设备链表。</li><li>bus 是连接 CPU 和 device 的桥梁，其保存了所有挂载在它上面的设备链表和驱动这些设备的驱动链表。</li><li>class 用于描述一类 device ，其保存了所有该类 device 的设备链表。</li></ul><h3 id="3-3-attribute"><a href="#3-3-attribute" class="headerlink" title="3.3 attribute"></a>3.3 attribute</h3><p>用于定义设备模型中的各项属性。基本属性有两种，分别为普通属性 attribute 和二进制属性 bin_attribute</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *name;              <span class="comment">// 属性名</span></span><br><span class="line">    <span class="keyword">umode_t</span>         mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="keyword">bool</span>            ignore_lockdep:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>   *<span class="title">key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>   <span class="title">skey</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>    <span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span>          size;</span><br><span class="line">    <span class="keyword">void</span>            *<span class="keyword">private</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read)(struct file *, struct kobject *, struct bin_attribute *,</span><br><span class="line">            <span class="keyword">char</span> *, <span class="keyword">loff_t</span>, <span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write)(struct file *, struct kobject *, struct bin_attribute *,</span><br><span class="line">             <span class="keyword">char</span> *, <span class="keyword">loff_t</span>, <span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">int</span> (*mmap)(struct file *, struct kobject *, struct bin_attribute *attr,</span><br><span class="line">            struct vm_area_struct *vma);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 attribute 生成的 sysfs 文件，只能用字符串的形式读写。而 struct bin_attribute 在 attribute 的基础上，增加了 read、write 等函数，因此它所生成的 sysfs 文件可以用任何方式读写。</p><h2 id="4-udev-amp-amp-uevent"><a href="#4-udev-amp-amp-uevent" class="headerlink" title="4. udev &amp;&amp; uevent"></a>4. udev &amp;&amp; uevent</h2><p><a href="https://insujang.github.io/2018-11-27/udev-device-manager-for-the-linux-kernel-in-userspace/" target="_blank" rel="noopener">udev: Device Manager for the Linux Kernel in Userspace</a>很好地介绍了udev。</p><h3 id="4-1-What-is-udev"><a href="#4-1-What-is-udev" class="headerlink" title="4.1 What is udev?"></a>4.1 What is udev?</h3><blockquote><p>udev (userspace /dev) is a device manager for the Linux kernel. As the successor of devfsd and hotplug, udev primaily manages device nodes in the /dev directory. At the same time, udev also handls all user space events raised when hardware devices are added into the system or removed from it, including firmware loading as reuqired by certain devices.</p></blockquote><h3 id="4-2-Why-was-udev-developed"><a href="#4-2-Why-was-udev-developed" class="headerlink" title="4.2 Why was udev developed?"></a>4.2 Why was udev developed?</h3><p>/dev directory is where all device files for the system are loaded (note that everything in Linux is files, so are devices). This directory had been managed by devfs filesystem until Linux kernel version 2.5. The introduction of devfs solved some problem, however, still many problems remained. </p><p>udev was started to solve all of those problems, and its goals are:</p><ul><li>Run in userspace (doing so we save kernel memory space that was wasted by saving device naming rules)</li><li>Create a dynamic /dev (automatically creates or removes device entries in /dev when devices are inserted or removed)</li><li>Provide consistent device naming </li><li>Provide a userspace API to access info about current system devices</li></ul><h3 id="4-3-How-to-use-udev"><a href="#4-3-How-to-use-udev" class="headerlink" title="4.3 How to use udev?"></a>4.3 How to use udev?</h3><p>看完<a href="https://www.youtube.com/watch?v=eV4InZop--0" target="_blank" rel="noopener">使用udev修改设备默认名称</a>可以理解udev的使用。</p><h3 id="4-4-udev的构成"><a href="#4-4-udev的构成" class="headerlink" title="4.4 udev的构成"></a>4.4 udev的构成</h3><ol><li>libudev 函数库，提供获取设备信息的接口</li><li>udevd 处于 user namespace 的管理软件。管理 / dev 下的设备文件。</li><li>udevadm 命令行工具。可用来向 udevd 发送指令。</li></ol><h3 id="4-5-uevent的功能"><a href="#4-5-uevent的功能" class="headerlink" title="4.5 uevent的功能"></a>4.5 uevent的功能</h3><p>uevent是Kobject的一部分，用于在Kobject状态发生改变时，例如增加、移除等，通知用户空间程序。用户空间程序收到这样的事件后，会做相应的处理。</p><p>该机制通常是用来支持热拔插设备的，例如U盘插入后，USB相关的驱动软件会动态创建用于表示该U盘的device结构（相应的也包括其中的kobject），并告知用户空间程序，为该U盘动态的创建/dev/目录下的设备节点，更进一步，可以通知其它的应用程序，将该U盘设备mount到系统中，从而动态的支持该设备。</p><h3 id="4-6-uevent在kernel中的位置"><a href="#4-6-uevent在kernel中的位置" class="headerlink" title="4.6 uevent在kernel中的位置"></a>4.6 uevent在kernel中的位置</h3><p>下面图片描述了uevent模块在内核中的位置：<br><img src="/images/2019/8/7.gif" alt></p><p>由此可知，uevent的机制是比较简单的，设备模型中任何设备有事件需要上报时，会触发uevent提供的接口。uevent模块准备好上报事件的格式后，可以通过两个途径把事件上报到用户空间：一种是通过kmod模块，直接调用用户空间的可执行文件；另一种是通过netlink通信机制，将事件从内核空间传递给用户空间。</p><h3 id="4-7-mdev"><a href="#4-7-mdev" class="headerlink" title="4.7 mdev"></a>4.7 mdev</h3><ul><li>udev是基于netlink机制的，它在系统启动时运行了一个deamon程序udevd，通过监听内核发送的uevent 来执行相应的热拔插动作，包括创建/删除设备节点，加载/卸载驱动模块等等。</li><li>mdev是基于uevent_helper机制的，它在系统启动时修改了内核中的uevnet_helper 变量（通过写/proc/sys/kernel/hotplug），值为“/sbin/mdev”。</li><li>udev 使用的netlink 机制在有大量uevent 的场合效率高，适合用在PC 机上；而mdev 使用的uevent_helper 机制实现简单，适合用在嵌入式系统中。</li></ul><hr><p>参考资料：</p><ol><li><a href="https://segmentfault.com/a/1190000011010908" target="_blank" rel="noopener">Linux Udev</a></li><li><a href="https://blog.csdn.net/W1107101310/article/details/80211885" target="_blank" rel="noopener">嵌入式Linux——uevent机制：uevent原理分析</a></li><li><a href="https://insujang.github.io/2018-11-27/udev-device-manager-for-the-linux-kernel-in-userspace/" target="_blank" rel="noopener">udev: Device Manager for the Linux Kernel in Userspace</a></li><li><a href="https://www.youtube.com/watch?v=eV4InZop--0" target="_blank" rel="noopener">使用udev修改设备默认名称</a></li><li><a href="https://blog.csdn.net/hunanchenxingyu/article/details/40432275" target="_blank" rel="noopener">mdev和udev机制并不相同</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自&lt;a href=&quot;https://www.binss.me/blog/sysfs-udev-and-Linux-Unified-Device-Model/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sysfs、udev 和 它们背后的 Linux 统一设备模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详细内容请参考&lt;a href=&quot;http://www.wowotech.net/sort/device_model&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;统一设备模型&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="IO系统" scheme="http://liujunming.github.io/categories/IO%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="IO系统" scheme="http://liujunming.github.io/tags/IO%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>IOMMU的简单介绍</title>
    <link href="http://liujunming.github.io/2019/08/10/IOMMU%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://liujunming.github.io/2019/08/10/IOMMU的简单介绍/</id>
    <published>2019-08-10T01:15:13.000Z</published>
    <updated>2019-08-10T11:26:07.066Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍下IOMMU的相关知识点，相关细节，将在后续的文章中，结合代码，详细讲解。<br><a id="more"></a><br>本文内容是对相关材料的汇总，并非原创。详情参见文章末尾的参考资料。</p><h2 id="1-什么是IOMMU"><a href="#1-什么是IOMMU" class="headerlink" title="1. 什么是IOMMU"></a>1. 什么是IOMMU</h2><p>IOMMU（Input/Output Memory Management Unit）是一个内存管理单元（Memory Management Unit），它的作用是连接DMA-capable I/O总线（Direct Memory Access-capable I/O Bus）和主存（main memory）。传统的内存管理单元会把CPU访问的虚拟地址转化成实际的物理地址。而IOMMU则是把设备（device）访问的虚拟地址转化成物理地址。</p><p><img src="/images/2019/8/4.png" alt></p><h2 id="2-为什么要有IOMMU"><a href="#2-为什么要有IOMMU" class="headerlink" title="2. 为什么要有IOMMU"></a>2. 为什么要有IOMMU</h2><p>首先，我们看下没有IOMMU的世界吧。</p><h3 id="2-1-physical-DMA-without-IOMMU"><a href="#2-1-physical-DMA-without-IOMMU" class="headerlink" title="2.1 physical DMA without IOMMU"></a>2.1 physical DMA without IOMMU</h3><ul><li>一些设备需要大量的物理连续内存，但是os无法为其分配。可以有如下解决方案：<ul><li>在内核启动是为设备保留内存</li><li>将MMU内嵌到设备中，如<a href="http://liujunming.top/2019/07/16/Intel-GPU-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">GPU</a></li></ul></li><li>一些设备有DMA寻址限制，例如，只支持32位的DMA寻址。可以有如下解决方案：<ul><li><a href="http://www.chudov.com/tmp/LinuxVM/html/understand/node65.html" target="_blank" rel="noopener">Bounce buffer</a></li></ul></li><li>没有内存保护机制，设备可能会错误地访问内存地址</li><li>不能支持PCI设备的<a href="http://liujunming.top/pdf/passthrough.pdf" target="_blank" rel="noopener">pass-through</a></li></ul><p>接下来，我们看下拥有IOMMU的世界吧。</p><h3 id="2-2-with-IOMMU"><a href="#2-2-with-IOMMU" class="headerlink" title="2.2 with IOMMU"></a>2.2 with IOMMU</h3><ul><li>使用更大的DMA寻址空间<ul><li>每个设备都用自己独立的DMA内存寻址空间</li></ul></li><li>使用更大的连续DMA内存<ul><li>可以将非连续的物理内存映射到连续的DMA内存空间中</li><li>避免使用<a href="https://knowledge.ni.com/KnowledgeArticleDetails?id=kA00Z0000019NMqSAM" target="_blank" rel="noopener">scatter-gather list</a></li></ul></li><li>避免使用<a href="http://www.chudov.com/tmp/LinuxVM/html/understand/node65.html" target="_blank" rel="noopener">Bounce buffer</a></li><li>提供了访问内存保护机制<ul><li>防止设备错误地访问内存</li></ul></li><li>支持PCI设备的<a href="http://liujunming.top/pdf/passthrough.pdf" target="_blank" rel="noopener">pass-through</a></li></ul><h2 id="3-IOMMU在虚拟化中的用途"><a href="#3-IOMMU在虚拟化中的用途" class="headerlink" title="3. IOMMU在虚拟化中的用途"></a>3. IOMMU在虚拟化中的用途</h2><p>IOMMU的一个重要用途是在虚拟化技术（virtualization）：虚拟机上运行的操作系统（guest OS）通常不知道它所访问的host-physical内存地址。如果要进行DMA操作，就有可能破坏内存，因为实际的硬件（hardware）不知道guest-physical和host-physical内存地址之间的映射关系。IOMMU根据guest-physical和host-physical内存地址之间的转换表（translation table），re-mapping硬件访问的地址，就可以解决这个问题。</p><p>在AMD的<a href="http://pages.cs.wisc.edu/~basu/isca_iommu_tutorial/IOMMU_TUTORIAL_ASPLOS_2016.pdf" target="_blank" rel="noopener">VIRTUALIZING IO THROUGH THE IO MEMORY MANAGEMENT UNIT (IOMMU)</a>文档中，也有一个更全面的总结图：</p><p><img src="/images/2019/8/5.jpg" alt></p><p>引入虚拟化后，带来的问题是：设备看到的是GPA(guest physical address)，但是访问的是HPA(host physical address)。</p><h3 id="3-1-per-BDF-DMA-remapping"><a href="#3-1-per-BDF-DMA-remapping" class="headerlink" title="3.1 per-BDF DMA remapping"></a>3.1 per-BDF DMA remapping</h3><blockquote><p>DMA Remapping通过IOMMU页表方式将直通设备对内存的访问限制到特定的domain中，在提高IO性能的同时完成了直通设备的隔离，保证了直通设备DMA的安全性。</p></blockquote><p><img src="/images/2019/8/6.png" alt></p><h3 id="3-2-interrupt-remapping"><a href="#3-2-interrupt-remapping" class="headerlink" title="3.2 interrupt remapping"></a>3.2 interrupt remapping</h3><blockquote><p>Interrupt Remapping则提供IO设备的中断重映射和路由功能，来达到中断隔离和中断迁移的目的，提升了虚拟化环境下直通设备的中断处理效率。</p></blockquote><blockquote><p>为什么要搞中断重映射这么一套东西呢？直通设备的中断不能直通到虚拟机内部吗？ 我们知道直通场景下直通设备的MSI/MSI-X Msg信息都是由Guest直接分配的，那么问题来了：设备发送中断的时候写的Msg地址是GPA，肯定不能直接往host上投递，否则就乱套了。在虚拟化场景下，直通设备的中断是无法直接投递到Guest中的，那么我们该怎么办？我们可以由IOMMU截获中断，先将中断映射到host的某个中断上，然后再重定向（由VMM投递）到Guest内部。</p></blockquote><p>对于MSI/MSI-X中断机制的相关知识，会在后续的文章中陆续推出。</p><hr><p>参考资料：</p><ol><li><a href="https://lists.linuxfoundation.org/pipermail/iommu/2011-November/003185.html" target="_blank" rel="noopener">Kai Huang mail.kai.huang at gmail.com </a></li><li><a href="https://nanxiao.me/iommu-introduction/" target="_blank" rel="noopener">什么是IOMMU？</a></li><li><a href="https://invisiblethingslab.com/resources/2011/Software%20Attacks%20on%20Intel%20VT-d.pdf" target="_blank" rel="noopener">Software attacks against Intel(R) VT-d technology</a></li><li><a href="https://kernelgo.org/interrupt-remapping.html" target="_blank" rel="noopener">VT-d Interrupt Remapping</a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2019/08/04/iommu-introduction" target="_blank" rel="noopener">IOMMU introduction</a></li><li><a href="https://www.wikiwand.com/en/Input%E2%80%93output_memory_management_unit" target="_blank" rel="noopener">Input–output memory management unit</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍下IOMMU的相关知识点，相关细节，将在后续的文章中，结合代码，详细讲解。&lt;br&gt;
    
    </summary>
    
      <category term="IO系统" scheme="http://liujunming.github.io/categories/IO%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="IO系统" scheme="http://liujunming.github.io/tags/IO%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Makefile 与Linux内核编译系统kbuild</title>
    <link href="http://liujunming.github.io/2019/08/09/Makefile-%E4%B8%8ELinux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9Fkbuild/"/>
    <id>http://liujunming.github.io/2019/08/09/Makefile-与Linux内核编译系统kbuild/</id>
    <published>2019-08-09T10:41:16.000Z</published>
    <updated>2019-08-09T12:52:16.885Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://blog.csdn.net/thisway_diy/article/details/76981113" target="_blank" rel="noopener">内核的Makefile、Kconfig和.config文件</a></p><a id="more"></a><p>如果对makefile一点不懂，可以参考<a href="http://liujunming.top/2017/07/15/makefile%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">makefile入门教程</a>。</p><p>最权威资料请查阅<a href="https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt" target="_blank" rel="noopener">Linux Kernel Makefiles</a>。</p><p>Linux内核源码文件繁多，搞不清Makefile、Kconfig、.config间的关系，不了解内核编译体系，编译修改内核有问题无从下手，自己写的驱动不知道怎么编进内核，不知道怎么配置内核，这些问题都和Makefile、Kconfig、.config有关，下面简单谈谈Makefile、Kconfig和.config。</p><h2 id="1-三者的作用"><a href="#1-三者的作用" class="headerlink" title="1. 三者的作用"></a>1. 三者的作用</h2><p>简单来说就是去饭店点菜：Kconfig是菜单，Makefile是做法，.config就是你点的菜。</p><ul><li><p>Makefile：一个文本形式的文件，编译源文件的方法。</p></li><li><p>Kconfig：一个文本形式的文件，内核的配置菜单。</p></li><li><p>.config：编译内核所依据的配置。</p></li></ul><h2 id="2-三者的语法"><a href="#2-三者的语法" class="headerlink" title="2. 三者的语法"></a>2. 三者的语法</h2><h3 id="2-1-Makefile"><a href="#2-1-Makefile" class="headerlink" title="2.1 Makefile"></a>2.1 Makefile</h3><p>参考：linux-3.4.2/drivers/Makefile</p><p>作用：用来定义哪些内容作为模块编译，哪些条件编译等。子目录Makefile被顶层Makefile包含。</p><ol><li><p>直接编译<br><code>obj-y      +=xxx.o</code><br>表示由xxx.c或xxx.s编译得到xxx.o并直接编进内核。</p></li><li><p>条件编译<br><code>obj -$(CONFIG_HELLO)  +=xxx.o</code><br>根据.config文件的CONFIG_XXX来决定文件是否编进内核。</p></li><li><p>模块编译<br><code>obj-m     +=xxx.o</code><br>表示xxx作为模块编译，即执行make modules时才会被编译。</p></li></ol><h3 id="2-2-Kconfig"><a href="#2-2-Kconfig" class="headerlink" title="2.2 Kconfig"></a>2.2 Kconfig</h3><p>每个config菜单项都有类型定义: bool布尔类型、 tristate三态(内建、模块、移除)、string字符串、 hex十六进制、integer整型。 </p><p>作用：决定make menuconfig时展示的菜单项，</p><p>参考：linux-3.4.2/drivers/leds/kconfig：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config LEDS_S3C24XX</span><br><span class="line">       tristate&quot;LED Support for Samsung S3C24XX GPIO LEDs&quot;</span><br><span class="line">       dependson LEDS_CLASS</span><br><span class="line">       dependson ARCH_S3C24XX</span><br><span class="line">       help</span><br><span class="line">         This option enables support for LEDs connected to GPIO lines on Samsung S3C24XX series CPUs, such as the S3C2410 and S3C2440.</span><br></pre></td></tr></table></figure></p><p><code>LEDS_S3C24XX</code>：配置选项的名称，省略了前缀”CONFIG_”</p><p><code>Tristate</code>：表示该项是否编进内核、编成模块。显示为&lt; &gt; , 假如选择编译成内核模块，则会在.config中生成一个 CONFIG_HELLO_MODULE=m的配置，选择Y就是直接编进内核，会在.config中生成一个 CONFIG_HELLO_MODULE=y的配置项。Tristate后的字符串是make menuconfig时显示的配置项名称。</p><p><code>bool</code>：此类型只能选中或不选中，make menuconfig时显示为[ ]，即无法配置成模块。</p><p><code>dependon</code>:该选项依赖于另一个选项，只有当依赖项被选中时，当前配置项的提示信息才会出现，才能设置当前配置项。</p><p><code>select</code>:反向依赖关系，该选项选中时，同时选中select后面定义的那一项。</p><p><code>help</code>：帮助信息。</p><p><code>目录层次迭代</code>：Kconfig中有类似语句：source “drivers/usb/Kconfig” ，用来包含（或嵌套）新的Kconfig文件，使得各个目录管理各自的配置内容，不必把那些配置都写在同一个文件里，方便修改和管理。</p><h3 id="2-3-config"><a href="#2-3-config" class="headerlink" title="2.3 .config"></a>2.3 .config</h3><p>参考：linux-3.4.2/.config</p><p>通过前俩个文件的分析，.config的含义已经很清晰：内核编译参考文件，查看里面内容可以知道哪些驱动被编译进内核。</p><p>配置内核方式有3种(任选其一)：</p><p>（1）make menuconfig<br>（2）make xxx_defconfig<br>（3）直接修改.config</p><p>注意: 如果直接修改.config，不一定会生效，因为有些配置可能存在依赖关系，make时会根据依赖关系，进行规则的检查，直接修改.config有时无效，所以不推荐直接修改。</p><h2 id="3-demo"><a href="#3-demo" class="headerlink" title="3. demo"></a>3. demo</h2><p>以上可能有点抽象，下面举例说明：<br>写一个简单的入口函数输出hello world的驱动并编译进内核。</p><p>步骤：<br>（1）在drivers目录下新建hello文件夹，里面实现hello.c、Makefile、Kconfig。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">first_drv_init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   printk(<span class="string">"------------------hello world !--------------------"</span>); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">first_drv_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   printk(<span class="string">"------------------exit hello world!--------------------"</span>); </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">module_init(first_drv_init); </span><br><span class="line">module_exit(first_drv_exit); </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Makefile</span><br><span class="line"></span><br><span class="line">obj-<span class="variable">$(CONFIG_HELLO)</span>        += hello.o</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Kconfig</span><br><span class="line"></span><br><span class="line">config HELLO  </span><br><span class="line">   tristate &quot;Hello Worldfor fengyuwuzu&quot;  </span><br><span class="line">   help  </span><br><span class="line">     Hello  forfengyuwuzu</span><br></pre></td></tr></table></figure><p>config HELLO决定名字：CONFIG_HELLO。<br>Hello World for fengyuwuzu：决定了在make menuconfig时显示的名字。</p><p>（2）修改上一级（Linux-3.4.2/drivers下）的Makefile、Kconfig。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Makefile</span><br><span class="line"></span><br><span class="line">obj-y  += hello/</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Kconfig</span><br><span class="line"></span><br><span class="line">source &quot;drivers/hello/Kconfig&quot;</span><br></pre></td></tr></table></figure><p>（3）make menuconfig</p><p><img src="/images/2019/8/3.png" alt></p><hr><p>参考资料：</p><ol><li><a href="https://edsionte.com/techblog/archives/1332" target="_blank" rel="noopener">对Makefile、Kconfig与.config文件的再次理解</a></li><li><a href="https://nanxiao.me/linux-kernel-note-59-kconfig-depends-on-select/" target="_blank" rel="noopener">Kconfig中的“depends on”和“select”</a></li><li><a href="https://jin-yang.github.io/reference/linux/kernel/KBUILD_system.pdf" target="_blank" rel="noopener">KBUILD 系统原理分析</a></li><li><a href="https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt" target="_blank" rel="noopener">Linux Kernel Makefiles</a></li><li><a href="https://stackoverflow.com/questions/29231876/how-does-kbuild-actually-work" target="_blank" rel="noopener">How does kbuild actually work?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/thisway_diy/article/details/76981113&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;内核的Makefile、Kconfig和.config文件&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel notifier chain</title>
    <link href="http://liujunming.github.io/2019/08/06/Linux-kernel-notifier-chain/"/>
    <id>http://liujunming.github.io/2019/08/06/Linux-kernel-notifier-chain/</id>
    <published>2019-08-06T15:02:30.000Z</published>
    <updated>2019-08-07T14:48:21.886Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍Linux内核基础–事件通知链。</p><a id="more"></a><p>内容主要转载自：<a href="https://blog.csdn.net/wuhzossibility/article/details/8079025" target="_blank" rel="noopener">Linux内核基础–事件通知链</a>。</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Linux内核中各个子系统相互依赖，当其中某个子系统状态发生改变时，就必须使用一定的机制告知使用其服务的其他子系统，以便其他子系统采取相应的措施。为满足这样的需求，内核实现了事件通知链机制（notification chain）。</p><p>通知链只能用在各个子系统之间，而不能在内核态和用户态之间进行事件通知。内核的核心代码均位于kernel目录下，通知链表位于kernel/notifier.c中，对应的头文件为include/linux/notifier.h。</p><p>事件通知链是一个事件处理函数的列表，每个通知链都与某个或某些事件有关。当特定的事件发生时，就调用相应的事件通知链中的回调函数，进行相应的处理。</p><p><img src="/images/2019/8/2.png" alt></p><center>图 1  内核通知链</center><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p>如图 1中所示，Linux的网络子系统一共有3个通知链：表示ipv4地址发生变化时的inetaddr_chain；表示ipv6地址发生变化的inet6addr_chain；还有表示设备注册、状态变化的netdev_chain。</p><p>在这些链中都是一个个notifier_block结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> &#123;</span></span><br><span class="line">       <span class="keyword">int</span> (*notifier_call)(struct notifier_block *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">void</span> *);</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> *<span class="title">next</span>;</span></span><br><span class="line">       <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中:</p><ol><li><p><code>notifier_call</code>：当相应事件发生时应该调用的函数，由被通知方提供，如other_subsys_1；</p></li><li><p><code>notifier_block *next</code>：用于链接成链表的指针；</p></li><li><p><code>priority</code>：回调函数的优先级，一般默认为0。</p></li></ol><p>内核代码中一般把通知链命名为xxx_chain, xxx_nofitier_chain这种形式的变量名。围绕核心数据结构<code>notifier_block</code>，内核定义了四种通知链类型：</p><ol><li><p>原子通知链（Atomic notifier chains）：通知链元素的回调函数（当事件发生时要执行的函数）在中断或原子操作上下文中运行，不允许阻塞。对应的链表头结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="keyword">spinlock_t</span>  lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>可阻塞通知链（Blocking notifier chains）：通知链元素的回调函数在进程上下文中运行，允许阻塞。对应的链表头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">blocking_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">rw_semaphore</span>  <span class="title">rwsem</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>   *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>原始通知链（Raw notifierchains）：对通知链元素的回调函数没有任何限制，所有锁和保护机制都由调用者维护。对应的链表头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">raw_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>   *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>SRCU 通知链（ SRCU notifier chains ）：可阻塞通知链的一种变体。对应的链表头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">srcu_notifier_head</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">srcu_struct</span>  <span class="title">srcu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">notifier_block</span>  *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-运行机理"><a href="#3-运行机理" class="headerlink" title="3. 运行机理"></a>3. 运行机理</h2><p>被通知一方（other_subsys_x）通过notifier_chain_register向特定的chain注册回调函数，并且一般而言特定的子系统会用特定的notifier_chain_register包装函数来注册。</p><h3 id="3-1-子系统向事件通知链注册的步骤"><a href="#3-1-子系统向事件通知链注册的步骤" class="headerlink" title="3.1 子系统向事件通知链注册的步骤"></a>3.1 子系统向事件通知链注册的步骤</h3><ol><li><p>申明struct notifier_block结构</p></li><li><p>编写notifier_call函数</p></li><li><p>调用特定的事件通知链的注册函数，将notifier_block注册到通知链中</p></li></ol><h3 id="3-2-通知子系统有事件发生"><a href="#3-2-通知子系统有事件发生" class="headerlink" title="3.2 通知子系统有事件发生"></a>3.2 通知子系统有事件发生</h3><p>inet_subsys是通过notifier_call_chain来通知其他的子系统（other_subsys_x）的。</p><p>notifier_call_chain会按照通知链上各成员的优先级顺序执行回调函数（notifier_call_x）。</p><h3 id="3-3-事件列表"><a href="#3-3-事件列表" class="headerlink" title="3.3 事件列表"></a>3.3 事件列表</h3><p>对于网络子系统而言，其事件常以NETDEV_XXX命名：描述了网络设备状态（dev-&gt;flags）、传送队列状态（dev-&gt;state）、设备注册状态（dev-&gt;reg_state），以及设备的硬件功能特性（dev-&gt;features）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* netdevice notifier chain */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_UP  0x0001  <span class="comment">/* 激活一个网络设备 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_DOWN  0x0002f <span class="comment">/* 停止一个网络设备，所有对该设备的引用都应释放 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_REBOOT       0x0003       <span class="comment">/* 检查到网络设备接口硬件崩溃，硬件重启 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGE       0x0004  <span class="comment">/* 网络设备的数据包队列状态发生改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_REGISTER  0x0005   <span class="comment">/*一个网络设备事例注册到系统中，但尚未激活 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_UNREGISTER       0x0006       <span class="comment">/*网络设备驱动已卸载 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGEMTU      0x0007  <span class="comment">/*MTU发生了改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGEADDR    0x0008  <span class="comment">/*硬件地址发生了改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_GOING_DOWN   0x0009  <span class="comment">/*网络设备即将注销，有dev-&gt;close报告，通知相关子系统处理 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_CHANGENAME   0x000A  <span class="comment">/*网络设备名改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_FEAT_CHANGE    0x000B  <span class="comment">/*feature网络硬件功能改变 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_BONDING_FAILOVER 0x000C  <span class="comment">/*    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_PRE_UP        0x000D  <span class="comment">/*    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_BONDING_OLDTYPE  0x000E              <span class="comment">/*    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETDEV_BONDING_NEWTYPE  0x000F      <span class="comment">/*    */</span></span></span><br></pre></td></tr></table></figure><h2 id="4-demo"><a href="#4-demo" class="headerlink" title="4. demo"></a>4. demo</h2><p>notifier_chain机制只能在内核个子系统间使用，因此，这里使用3个模块：test_notifier_chain_0、test_notifier_chain_1、test_notifier_chain_2。<br>test_notifier_chain_2通过module_init初始化时会发出事件TESTCHAIN_2_INIT；然后 test_notifier_chain_1作出相应的处理(打印 test_notifier_chain_2正在初始化)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test_chain_0.c ：0. 申明一个通知链；1. 向内核注册通知链；2. 定义事件； 3. 导出符号*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;   </span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTCHAIN_INIT 0x52U</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">RAW_NOTIFIER_HEAD</span><span class="params">(test_chain)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* define our own notifier_call_chain */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">call_test_notifiers</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> raw_notifier_call_chain(&amp;test_chain, val, v);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(call_test_notifiers);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* define our own notifier_chain_register func */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_test_notifier</span><span class="params">(struct notifier_block *nb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    err = raw_notifier_chain_register(&amp;test_chain, nb);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">EXPORT_SYMBOL(register_test_notifier);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_chain_0_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"I'm in test_chain_0\n"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_chain_0_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"Goodbye to test_chain_0\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL v2"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fishOnFly"</span>);</span><br><span class="line"> </span><br><span class="line">module_init(test_chain_0_init);</span><br><span class="line">module_exit(test_chain_0_exit);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test_chain_1.c ：1. 定义回调函数；2. 定义notifier_block；3. 向chain_0注册notifier_block；*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;   </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">register_test_notifier</span><span class="params">(struct notifier_block *nb)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTCHAIN_INIT 0x52U</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* realize the notifier_call func */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_init_event</span><span class="params">(struct notifier_block *nb, <span class="keyword">unsigned</span> <span class="keyword">long</span> event,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(event)&#123;</span><br><span class="line">    <span class="keyword">case</span> TESTCHAIN_INIT:</span><br><span class="line">        printk(KERN_DEBUG <span class="string">"I got the chain event: test_chain_2 is on the way of init\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> NOTIFY_DONE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* define a notifier_block */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">test_init_notifier</span> = &#123;</span></span><br><span class="line">    .notifier_call = test_init_event,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_chain_1_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"I'm in test_chain_1\n"</span>);</span><br><span class="line">    register_test_notifier(&amp;test_init_notifier);    <span class="comment">// 由chain_0提供的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_chain_1_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"Goodbye to test_clain_l\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fishOnFly"</span>);</span><br><span class="line"> </span><br><span class="line">module_init(test_chain_1_init);</span><br><span class="line">module_exit(test_chain_1_exit);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test_chain_2.c：发出通知链事件*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/notifier.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;   </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">call_test_notifiers</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *v)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTCHAIN_INIT 0x52U</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_chain_2_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"I'm in test_chain_2\n"</span>);</span><br><span class="line">    call_test_notifiers(TESTCHAIN_INIT, <span class="string">"no_use"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_chain_2_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_DEBUG <span class="string">"Goodbye to test_chain_2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL v2"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fishOnFly"</span>);</span><br><span class="line"> </span><br><span class="line">module_init(test_chain_2_init);</span><br><span class="line">module_exit(test_chain_2_exit);</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Comment/uncomment the following line to disable/enable debugging</span></span><br><span class="line"><span class="comment"># DEBUG = y</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Add your debugging flag (or not) to CFLAGS</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,y)</span><br><span class="line">  DEBFLAGS = -O -g -DSCULL_DEBUG <span class="comment"># "-O" is needed to expand inlines</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  DEBFLAGS = -O2</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"><span class="comment"># call from kernel build system</span></span><br><span class="line"> </span><br><span class="line">obj-m   := test_chain_0.o test_chain_1.o test_chain_2.o</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> </span><br><span class="line">KERNELDIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">PWD       := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"> </span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"> </span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br><span class="line"> </span><br><span class="line">depend .depend dep:</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -M *.c &gt; .depend</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">ifeq</span> (.depend,<span class="variable">$(<span class="built_in">wildcard</span> .depend)</span>)</span><br><span class="line"><span class="keyword">include</span> .depend</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insmod test_chain_0.ko</span><br><span class="line">insmod test_chain_1.ko</span><br><span class="line">insmod test_chain_2.ko</span><br><span class="line">rmmod test_chain_2.ko</span><br><span class="line">rmmod test_chain_1.ko</span><br><span class="line">rmmod test_chain_0.ko</span><br></pre></td></tr></table></figure><p><img src="/images/2019/8/1.png" alt></p><hr><p>参考资料：</p><ol><li><p><a href="https://blog.csdn.net/wuhzossibility/article/details/8079025" target="_blank" rel="noopener">Linux内核基础–事件通知链</a></p></li><li><p><a href="https://codingfreak.blogspot.com/2012/02/notification-chains-in-linux-kernel.html" target="_blank" rel="noopener">Notification Chains in Linux Kernel</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍Linux内核基础–事件通知链。&lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>linux ioctl()函数详解</title>
    <link href="http://liujunming.github.io/2019/07/20/linux-ioctl-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://liujunming.github.io/2019/07/20/linux-ioctl-函数详解/</id>
    <published>2019-07-20T02:19:28.000Z</published>
    <updated>2019-07-20T05:54:19.032Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要转载自<a href="https://opensourceforu.com/2011/08/io-control-in-linux/" target="_blank" rel="noopener">I/O Control in Linux</a>。</p><blockquote><p>Most drivers need the ability to perform various types of hardware control via the device driver. Most devices can perform operations beyond simple data transfers; user space must often be able to request, for example, that the device lock its door, eject its media, report error information, change a baud rate, or self destruct. These operations are usually supported via the <code>ioctl</code> method, which implements the system call by the same time.</p></blockquote><a id="more"></a><p>摘录自《Linux Device Drivers》第三版第六章。</p><h2 id="Introducing-ioctl"><a href="#Introducing-ioctl" class="headerlink" title="Introducing ioctl()"></a>Introducing <em>ioctl()</em></h2><p>Input/Output Control (<em>ioctl</em>, in short) is a common operation, or system call, available in most driver categories. It is a one-bill-fits-all kind of system call. If there is no other system call that meets a particular requirement, then <code>ioctl()</code> is the one to use.</p><p>Practical examples include volume control for an audio device, display configuration for a video device, reading device registers, and so on — basically, anything to do with device input/output, or device-specific operations, yet versatile enough for any kind of operation (for example, for debugging a driver by querying driver data structures).</p><p>The question is: how can all this be achieved by a single function prototype? The trick lies in using its two key parameters: <em>command</em> and <em>argument</em>. The <em>command</em> is a number representing an operation. The <em>argument</em> is the corresponding parameter for the operation. The <code>ioctl()</code> function implementation does a switch … <em>case</em> over the commmand to implement the corresponding functionality. The following has been its prototype in the Linux kernel for quite some time:</p><p><code>int ioctl(struct inode *i, struct file *f, unsigned int cmd, unsigned long arg);</code></p><p>However, from kernel 2.6.35, it changed to:</p><p><code>long ioctl(struct file *f, unsigned int cmd, unsigned long arg);</code></p><p>If there is a need for more arguments, all of them are put in a structure, and a pointer to the structure becomes the ‘one’ argument. Whether integer or pointer, the argument is taken as a long integer in kernel-space, and accordingly type-cast and processed.</p><p><code>ioctl()</code> is typically implemented as part of the corresponding driver, and then an appropriate function pointer is initialised with it, exactly as in other system calls like <code>open()</code>, <code>read()</code>, etc. For example, in character drivers, it is the <code>ioctl</code> or <code>unlocked_ioctl</code> (since kernel 2.6.35) function pointer field in the struct <code>file_operations</code> that is to be initialised.</p><p>Again, like other system calls, it can be equivalently invoked from user-space using the <code>ioctl()</code> system call, prototyped in <code>&lt;sys/ioctl.h&gt;</code>as:</p><p><code>int ioctl(int fd, int cmd, ...);</code></p><p>Here, <code>cmd</code> is the same as what is implemented in the driver’s <code>ioctl()</code>, and the variable argument construct (<code>...</code>) is a hack to be able to pass any type of argument (though only one) to the driver’s <code>ioctl()</code>. Other parameters will be ignored.</p><p>Note that both the command and argument type definitions need to be shared across the driver (in kernel-space) and the application (in user-space). Thus, these definitions are commonly put into header files for each space.</p><h2 id="Querying-driver-internal-variables"><a href="#Querying-driver-internal-variables" class="headerlink" title="Querying driver-internal variables"></a>Querying driver-internal variables</h2><p>To better understand the boring theory explained above, here’s the code set for the “debugging a driver” example. This driver has three static global variables: <code>status</code>, <code>dignity</code>, and <code>ego</code>, which need to be queried and possibly operated from an application. The header file <code>query_ioctl.h</code> defines the corresponding commands and argument type. A listing follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUERY_IOCTL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_IOCTL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> status, dignity, ego;</span><br><span class="line">&#125; <span class="keyword">query_arg_t</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_GET_VARIABLES _IOR(<span class="meta-string">'q'</span>, 1, query_arg_t *)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_CLR_VARIABLES _IO(<span class="meta-string">'q'</span>, 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_SET_VARIABLES _IOW(<span class="meta-string">'q'</span>, 3, query_arg_t *)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>Using these, the driver’s <code>ioctl()</code> implementation in <code>query_ioctl.c</code> would be as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"query_ioctl.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIRST_MINOR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR_CNT 1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dev_t</span> dev;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">c_dev</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">cl</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> status = <span class="number">1</span>, dignity = <span class="number">3</span>, ego = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_open</span><span class="params">(struct inode *i, struct file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_close</span><span class="params">(struct inode *i, struct file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,35))</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_ioctl</span><span class="params">(struct inode *i, struct file *f, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">my_ioctl</span><span class="params">(struct file *f, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">query_arg_t</span> q;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> QUERY_GET_VARIABLES:</span><br><span class="line">            q.status = status;</span><br><span class="line">            q.dignity = dignity;</span><br><span class="line">            q.ego = ego;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user((<span class="keyword">query_arg_t</span> *)arg, &amp;q, <span class="keyword">sizeof</span>(<span class="keyword">query_arg_t</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QUERY_CLR_VARIABLES:</span><br><span class="line">            status = <span class="number">0</span>;</span><br><span class="line">            dignity = <span class="number">0</span>;</span><br><span class="line">            ego = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QUERY_SET_VARIABLES:</span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;q, (<span class="keyword">query_arg_t</span> *)arg, <span class="keyword">sizeof</span>(<span class="keyword">query_arg_t</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">            &#125;</span><br><span class="line">            status = q.status;</span><br><span class="line">            dignity = q.dignity;</span><br><span class="line">            ego = q.ego;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">query_fops</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = my_open,</span><br><span class="line">    .release = my_close,</span><br><span class="line">#<span class="keyword">if</span> (LINUX_VERSION_CODE &lt; KERNEL_VERSION(<span class="number">2</span>,<span class="number">6</span>,<span class="number">35</span>))</span><br><span class="line">    .ioctl = my_ioctl</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    .unlocked_ioctl = my_ioctl</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">query_ioctl_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev_ret</span>;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((ret = alloc_chrdev_region(&amp;dev, FIRST_MINOR, MINOR_CNT, <span class="string">"query_ioctl"</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cdev_init(&amp;c_dev, &amp;query_fops);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((ret = cdev_add(&amp;c_dev, dev, MINOR_CNT)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(cl = class_create(THIS_MODULE, <span class="string">"char"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        cdev_del(&amp;c_dev);</span><br><span class="line">        unregister_chrdev_region(dev, MINOR_CNT);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(cl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev_ret = device_create(cl, <span class="literal">NULL</span>, dev, <span class="literal">NULL</span>, <span class="string">"query"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        class_destroy(cl);</span><br><span class="line">        cdev_del(&amp;c_dev);</span><br><span class="line">        unregister_chrdev_region(dev, MINOR_CNT);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(dev_ret);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">query_ioctl_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_destroy(cl, dev);</span><br><span class="line">    class_destroy(cl);</span><br><span class="line">    cdev_del(&amp;c_dev);</span><br><span class="line">    unregister_chrdev_region(dev, MINOR_CNT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(query_ioctl_init);</span><br><span class="line">module_exit(query_ioctl_exit);</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Anil Kumar Pugalia &lt;email_at_sarika-pugs_dot_com&gt;"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Query ioctl() Char Driver"</span>);</span><br></pre></td></tr></table></figure><p>And finally, the corresponding invocation functions from the application <code>query_app.c</code> would be as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"query_ioctl.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_vars</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">query_arg_t</span> q;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, QUERY_GET_VARIABLES, &amp;q) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"query_apps ioctl get"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Status : %d\n"</span>, q.status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Dignity: %d\n"</span>, q.dignity);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Ego    : %d\n"</span>, q.ego);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clr_vars</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, QUERY_CLR_VARIABLES) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"query_apps ioctl clr"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_vars</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">query_arg_t</span> q;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter Status: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">    getchar();</span><br><span class="line">    q.status = v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter Dignity: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">    getchar();</span><br><span class="line">    q.dignity = v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter Ego: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">    getchar();</span><br><span class="line">    q.ego = v;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, QUERY_SET_VARIABLES, &amp;q) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"query_apps ioctl set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *file_name = <span class="string">"/dev/query"</span>;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    &#123;</span><br><span class="line">        e_get,</span><br><span class="line">        e_clr,</span><br><span class="line">        e_set</span><br><span class="line">    &#125; option;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        option = e_get;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-g"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            option = e_get;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-c"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            option = e_clr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-s"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            option = e_set;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s [-g | -c | -s]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s [-g | -c | -s]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = open(file_name, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"query_apps open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (option)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> e_get:</span><br><span class="line">            get_vars(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> e_clr:</span><br><span class="line">            clr_vars(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> e_set:</span><br><span class="line">            set_vars(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    close (fd);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now try out <code>query_app.c</code> and <code>query_ioctl.c</code> with the following operations:</p><ul><li>Build the <code>query_ioctl</code> driver (<code>query_ioctl.ko</code> file) and the application (<code>query_app</code> file) by running <code>make</code>, using the following <code>Makefile</code>:</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If called directly from the command line, invoke the kernel build system.</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"> </span><br><span class="line">    KERNEL_SOURCE := /usr/src/linux</span><br><span class="line">    PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">default: module query_app</span></span><br><span class="line"> </span><br><span class="line"><span class="section">module:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_SOURCE)</span> SUBDIRS=<span class="variable">$(PWD)</span> modules</span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_SOURCE)</span> SUBDIRS=<span class="variable">$(PWD)</span> clean</span><br><span class="line">    $&#123;RM&#125; query_app</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Otherwise KERNELRELEASE is defined; we've been invoked from the</span></span><br><span class="line"><span class="comment"># kernel build system and can use its language.</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> </span><br><span class="line">    obj-m := query_ioctl.o</span><br><span class="line"> </span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><ul><li>Load the driver using insmod <code>query_ioctl.ko</code>.</li><li>With appropriate privileges and command-line arguments, run the application <code>query_app</code>:<ul><li><code>./query_app</code> — to display the driver variables</li><li><code>./query_app -c</code> — to clear the driver variables</li><li><code>./query_app -g</code> — to display the driver variables</li><li><code>./query_app -s</code> — to set the driver variables (not mentioned above)</li></ul></li><li>Unload the driver using <code>rmmod query_ioctl</code>.</li></ul><h2 id="Defining-the-ioctl-commands"><a href="#Defining-the-ioctl-commands" class="headerlink" title="Defining the ioctl() commands"></a>Defining the <em>ioctl()</em> commands</h2><p>You may wondere about <code>_IOR</code>, <code>_IO</code>, etc., which were used in defining commands in <code>query_ioctl.h</code>. These are usual numbers only, as mentioned earlier for an <code>ioctl()</code> command. Just that, now additionally, some useful command related information is also encoded as part of these numbers using various macros, as per the POSIX standard for <code>ioctl</code>. The standard talks about the 32-bit command numbers, formed of four components embedded into the [31:0] bits:</p><ol><li>The direction of command operation [bits 31:30] — read, write, both, or none — filled by the corresponding macro (<code>_IOR</code>, <code>_IOW</code>, <code>_IOWR</code>, <code>_IO</code>).</li><li>The size of the  argument [bits 29:16] — computed using <code>sizeof()</code> with the  argument’s type — the third argument to these macros.</li><li>The 8-bit magic number [bits 15:8] — to render the commands unique enough — typically an ASCII character (the first argument to these macros).</li><li>The original command number [bits 7:0] — the actual command number (1, 2, 3, …), defined as per our requirement — the second argument to these macros.</li></ol><p>Check out the header <a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/asm-generic/ioctl.h" target="_blank" rel="noopener">&lt;asm-generic/ioctl.h&gt;</a> for implementation details.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要转载自&lt;a href=&quot;https://opensourceforu.com/2011/08/io-control-in-linux/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;I/O Control in Linux&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Most drivers need the ability to perform various types of hardware control via the device driver. Most devices can perform operations beyond simple data transfers; user space must often be able to request, for example, that the device lock its door, eject its media, report error information, change a baud rate, or self destruct. These operations are usually supported via the &lt;code&gt;ioctl&lt;/code&gt; method, which implements the system call by the same time.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/categories/I-O%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>程序员眼中的PCI设备</title>
    <link href="http://liujunming.github.io/2019/07/19/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9C%BC%E4%B8%AD%E7%9A%84PCI%E8%AE%BE%E5%A4%87/"/>
    <id>http://liujunming.github.io/2019/07/19/程序员眼中的PCI设备/</id>
    <published>2019-07-19T10:18:52.000Z</published>
    <updated>2019-07-19T14:26:35.687Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文主要内容来自<a href="https://book.douban.com/subject/3619896/" target="_blank" rel="noopener">系统虚拟化</a>，再加上自己的一些理解，希望能将PCI设备的内容解释清楚。</p><p>何为PCI(Peripheral Component Interconnect)总线？PCI总线是CPU与外部设备沟通的桥梁。<a id="more"></a>PCI总线的优点：速度快、具有动态配置功能、独立于CPU架构等，因而迅速被各种平台接受，成为一种通用的总线架构。</p><h3 id="1-PCI总线架构"><a href="#1-PCI总线架构" class="headerlink" title="1. PCI总线架构"></a>1. PCI总线架构</h3><p>PCI总线是一种典型的树结构。把北桥中HOST-PCI桥看作根，总线中其他PCI-PCI桥、PCI-ISA桥等桥设备和直接接PCI总线的设备看作节点，整个PCI架构可以概括为下图所示。<br><img src="/images/2019/7/4.png" alt></p><h4 id="设备标识符"><a href="#设备标识符" class="headerlink" title="设备标识符"></a><strong>设备标识符</strong></h4><p><img src="/images/2019/7/5.png" alt></p><h3 id="2-PCI设备枚举过程"><a href="#2-PCI设备枚举过程" class="headerlink" title="2. PCI设备枚举过程"></a>2. PCI设备枚举过程</h3><p>PCI设备和总线一起构成了树结构，其中桥设备是子树的根节点，设备枚举的过程就是要在内存中建立一颗和实际总线情况相符合的设备树。枚举过程中最关键的步骤就是发现桥设备。<br><a href="https://www.youtube.com/watch?v=qhIHu8mFrdg" target="_blank" rel="noopener">PCI Basics and Bus Enumeration</a>很好地阐述了此动态过程，看完视频之后都理解的话，那么对PCI设备枚举过程也就理解了。</p><h3 id="3-PCI-configeration-space"><a href="#3-PCI-configeration-space" class="headerlink" title="3. PCI configeration space"></a>3. PCI configeration space</h3><p>通过BDF，我们可以唯一标志一个设备。每个设备，都有自己PCI configeration space，而PCI configeration space本质是registers。PCI设备规范规定，设备的配置空间最多为256个字节，其中前64个字节的格式和用途是统一的，如下图所示。<br><img src="/images/2019/7/6.png" alt></p><p><strong>例1：</strong>假设设备1的BDF编号是(0,3,2),当我们需要定位其Expansion ROM Base Address寄存器时，应输入(0,3,2,30h)。</p><p>x86架构把I/O端口地址空间中的0xCF8~0xCFF段预留给了PCI总线，用于访问设备的配置空间。其中，前32位的寄存器为”地址寄存器“，后32位为”值寄存器“。软件通过把设备的BDF和要访问的配置空间的字节偏移量写入”地址寄存器“中，就可以通过”值寄存器“读写该配置空间了。</p><p>BDF占据16bits，而PCI configeration space最多为256个字节，也就是64个DWORD(Double WORD,WORD占16位，DWORD即占32位)，所以Config. Addr只需占用6bits(能定位到64个DWORD)。具体位数含义可参见下图：<br><img src="/images/2019/7/7.png" alt></p><p>如例1所示，我们将(0,3,2,30h)写入pio的0xCF8h，就可以通过读0xCFCh来获取设备1的Expansion ROM Base Address寄存器值了。</p><p>讲完Accessing PCIe Config Registers后，我们需要介绍下程序员最关心的Base Address Registers和Interrupt Line了。</p><ul><li>Base Address Registers:基地址寄存器，也就是常说的PCI Bar。它报告设备寄存器或者设备RAM在I/O端口地址空间（或物理地址空间中）的地址。地址是由软件(BIOS或操作系统)动态设置的。通常枚举PCI设备的软件(BIOS或操作系统)会在获得平台所有PCI设备后，根据设备数量，依照固定的算法为每个设备的PCI Bar分配I/O端口(或物理地址)。设备的电子线路负责把这些端口(或地址)映射到自身的寄存器(设备RAM)上，这样CPU就可以通过端口号(Port I/O方式)、物理地址(MMIO方式)访问到设备了。</li></ul><ul><li>Interupt Line:设备的中断线。BIOS通常用它来保存设备所连的PIC/IOAPIC的管脚号。</li></ul><hr><p>参考资料：</p><ol><li><a href="https://book.douban.com/subject/3619896/" target="_blank" rel="noopener">系统虚拟化</a></li><li><a href="http://cpci.co.kr/eng/download/technote/config-pci.pdf" target="_blank" rel="noopener">PCI configuration mechanism </a></li><li><a href="https://www.youtube.com/watch?v=qhIHu8mFrdg" target="_blank" rel="noopener">PCI Basics and Bus Enumeration</a></li><li><a href="https://www.youtube.com/watch?v=6112AekrsqA" target="_blank" rel="noopener">Accessing PCIe Config Registers</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注：本文主要内容来自&lt;a href=&quot;https://book.douban.com/subject/3619896/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;系统虚拟化&lt;/a&gt;，再加上自己的一些理解，希望能将PCI设备的内容解释清楚。&lt;/p&gt;
&lt;p&gt;何为PCI(Peripheral Component Interconnect)总线？PCI总线是CPU与外部设备沟通的桥梁。
    
    </summary>
    
      <category term="系统" scheme="http://liujunming.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="http://liujunming.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Intel GPU 内存管理</title>
    <link href="http://liujunming.github.io/2019/07/16/Intel-GPU-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://liujunming.github.io/2019/07/16/Intel-GPU-内存管理/</id>
    <published>2019-07-16T13:18:59.000Z</published>
    <updated>2019-07-16T15:07:44.047Z</updated>
    
    <content type="html"><![CDATA[<p>本文将会介绍Intel GPU的内存管理。<a id="more"></a>由于不同GPU的参数可能不一致，本文给出的参数是demo性质的，如果想要查看GPU的具体参数，请参考<a href="https://01.org/zh/linuxgraphics/documentation/hardware-specification-prms" target="_blank" rel="noopener">HARDWARE SPECIFICATION - PRMS</a>。</p><p>PS:到目前为止，我司GPU的memory依然是system memory，而非on-die memory。</p><p>对于GPU的应用而言，GPU的virtual memory address space分为两部分，分别是global graphic memory和local graphic memory。在本文接下来的内容中，我们将global graphic memory和local graphic memory的大小设置为2GB。</p><h2 id="global-graphic-memory"><a href="#global-graphic-memory" class="headerlink" title="global graphic memory"></a>global graphic memory</h2><p>对于GPU的global graphic memory，是所有进程共享的：即所有的进程共用这2GB的虚拟地址空间。</p><p>当GPU访问global graphic memory时，利用global graphics translation table (GGTT) 来完成虚拟地址到物理地址的映射，过程如下图所示（可以将GGTT看作是GPU的页表，同时GGTT是一级页表，而寻址过程是由硬件来完成的）。</p><p><img src="/images/2019/7/1.png" alt></p><p>global graphic memory的部分内存，CPU是可以访问的，这样才能完成GPU与CPU的数据交互。对于CPU能访问的这部分内存，我们称之为<a href="https://www.wikiwand.com/en/Aperture_%28computer_memory%29" target="_blank" rel="noopener">aperture</a>。CPU的虚拟地址空间与GPU的虚拟地址空间是相互独立的，因此，CPU如果想要访问aperture，就需要将aperture mmap到CPU的虚拟地址空间。</p><p><img src="/images/2019/7/2.png" alt></p><p>如上图所示，在GPU的global graphic memory中，0~FFFFFF的内容是aperture，而CPU将aperture内存mmap到C000000~CFFFFFF地址范围内，这样CPU就可以访问aperture了。对于global graphic memory的非aperture部分，CPU是无法访问的。</p><h2 id="local-graphic-memory"><a href="#local-graphic-memory" class="headerlink" title="local graphic memory"></a>local graphic memory</h2><p>对于GPU的local graphic memory，每个进程都有2GB的虚拟地址空间。GPU通过per-process graphics translation table(PPGTT)来完成地址翻译，过程如下图所示。</p><p><img src="/images/2019/7/3.png" alt></p><p>值得注意的是：</p><ul><li>PPGTT是多级页表(具体级数跟GPU的架构相关)</li><li>CPU是无法访问local graphic memory的</li></ul><hr><p>参考资料：</p><ol><li><a href="https://01.org/zh/linuxgraphics/documentation/hardware-specification-prms" target="_blank" rel="noopener">HARDWARE SPECIFICATION - PRMS</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将会介绍Intel GPU的内存管理。
    
    </summary>
    
      <category term="GPU" scheme="http://liujunming.github.io/categories/GPU/"/>
    
    
      <category term="GPU" scheme="http://liujunming.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>计算机启动相关知识点</title>
    <link href="http://liujunming.github.io/2019/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://liujunming.github.io/2019/07/15/计算机启动相关知识点/</id>
    <published>2019-07-15T13:13:37.000Z</published>
    <updated>2019-07-15T13:23:55.504Z</updated>
    
    <content type="html"><![CDATA[<p>附件中将会介绍计算机启动的相关知识点，详细内容见参考链接。</p><p><a href="/pdf/computer_boot.pdf">计算机启动</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;附件中将会介绍计算机启动的相关知识点，详细内容见参考链接。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/pdf/computer_boot.pdf&quot;&gt;计算机启动&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="系统" scheme="http://liujunming.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="http://liujunming.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Paper Notes</title>
    <link href="http://liujunming.github.io/2019/06/23/Paper-Notes/"/>
    <id>http://liujunming.github.io/2019/06/23/Paper-Notes/</id>
    <published>2019-06-23T08:23:36.000Z</published>
    <updated>2019-07-21T02:14:47.926Z</updated>
    
    <content type="html"><![CDATA[<p>论文笔记。<br><a id="more"></a><br><a href="/pdf/paper/xen sosp.pdf">Xen and the Art of Virtualization</a><br><a href="/pdf/paper/Xen_notes.pdf">Notes</a> </p><p><a href="/pdf/paper/gVirt.pdf">A Full GPU Virtualization Solution with Mediated Pass-Through</a><br><a href="/pdf/paper/gVirt_notes.pdf">Notes</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;论文笔记。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Concurrency</title>
    <link href="http://liujunming.github.io/2019/06/08/Concurrency/"/>
    <id>http://liujunming.github.io/2019/06/08/Concurrency/</id>
    <published>2019-06-08T00:53:38.000Z</published>
    <updated>2019-06-23T08:21:38.427Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先介绍Concurrency的相关知识点。</p><a id="more"></a><p>Operating Systems: Three Easy Pieces中Concurrency的相关内容。</p><ol><li><a href="[http://liujunming.top/junming/os/26.threads-intro.pdf](http://liujunming.top/junming/os/26.threads-intro.pdf">Concurrency and Threads</a></li><li><a href="[http://liujunming.top/junming/os/27.threads-api.pdf](http://liujunming.top/junming/os/27.threads-api.pdf">Thread API</a></li><li><a href="[http://liujunming.top/junming/os/28.threads-locks.pdf](http://liujunming.top/junming/os/28.threads-locks.pdf">Locks</a></li><li><a href="[http://liujunming.top/junming/os/29.threads-locks-usage.pdf](http://liujunming.top/junming/os/29.threads-locks-usage.pdf">Locked Data Structures</a></li><li><a href="[http://liujunming.top/junming/os/30.threads-cv.pdf](http://liujunming.top/junming/os/30.threads-cv.pdf">Condition Variables</a></li><li><a href="[http://liujunming.top/junming/os/31.threads-sema.pdf](http://liujunming.top/junming/os/31.threads-sema.pdf">Semaphores</a></li><li><a href="[http://liujunming.top/junming/os/32.threads-bugs.pdf](http://liujunming.top/junming/os/32.threads-bugs.pdf">Concurrency Bugs</a></li><li><a href="[http://liujunming.top/junming/os/33.threads-events.pdf](http://liujunming.top/junming/os/33.threads-events.pdf">Event-based Concurrency</a></li></ol><p><a href="/pdf/Concurrency.pdf">Notes</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先介绍Concurrency的相关知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/categories/Concurrency/"/>
    
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化课程学习</title>
    <link href="http://liujunming.github.io/2019/05/27/%E8%99%9A%E6%8B%9F%E5%8C%96%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>http://liujunming.github.io/2019/05/27/虚拟化课程学习/</id>
    <published>2019-05-27T06:27:16.000Z</published>
    <updated>2019-05-30T08:21:56.761Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://lettieri.iet.unipi.it/virtualization/" target="_blank" rel="noopener">Concurrent and Distributed Systems</a>课程很好地讲述了虚拟化的相关原理，由浅入深，循序渐进。本文将记录下自己的学习笔记。<br><a id="more"></a></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p><a href="/pdf/Virtualization-Introduction.pdf">Virtualization Introduction</a></p><p><a href="/pdf/intro_virtual.pdf">Notes</a></p><h3 id="Emulation-amp-amp-Binary-Translation"><a href="#Emulation-amp-amp-Binary-Translation" class="headerlink" title="Emulation &amp;&amp; Binary Translation"></a>Emulation &amp;&amp; Binary Translation</h3><p><a href="/pdf/emulation.pdf">Emulation</a></p><p><a href="/pdf/binary-translation.pdf">Binary Translation</a></p><p><a href="/pdf/emulator &amp;&amp; binary translation.pdf">Notes</a></p><h3 id="Hardware-assisted-virtualization"><a href="#Hardware-assisted-virtualization" class="headerlink" title="Hardware assisted virtualization"></a>Hardware assisted virtualization</h3><p><a href="/pdf/hardware-assisted-intro.pdf">Introduction</a>(无需细读)</p><p><a href="/pdf/hardware-assisted-vmm.pdf">The Virtual Machine Monitor</a></p><p><a href="/pdf/hardware-assisted-intel-vmx.pdf">The Intel VMX technology</a></p><p><a href="/pdf/hardware-assisted-virtual-mmu.pdf">Virtualization of virtual memory</a></p><p><a href="/pdf/Hardware assisted virtualization.pdf">Notes</a></p><h3 id="Hardware-passthrough"><a href="#Hardware-passthrough" class="headerlink" title="Hardware passthrough"></a>Hardware passthrough</h3><p><a href="/pdf/passthrough.pdf">Hardware passthrough</a></p><p><a href="/pdf/Hardware passthrough.pdf">Notes</a></p><h3 id="Paravirtualization"><a href="#Paravirtualization" class="headerlink" title="Paravirtualization"></a>Paravirtualization</h3><p><a href="/pdf/paravirtualization.pdf">Introduction</a></p><p><a href="/pdf/20161124-io-paravirtualization-tour.pdf">Virtio networking: A case study of I/O paravirtualization</a></p><p><a href="/pdf/Para-virtualization.pdf">Notes</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://lettieri.iet.unipi.it/virtualization/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Concurrent and Distributed Systems&lt;/a&gt;课程很好地讲述了虚拟化的相关原理，由浅入深，循序渐进。本文将记录下自己的学习笔记。&lt;br&gt;
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>(转)Memory barrier</title>
    <link href="http://liujunming.github.io/2019/05/09/Memory-barrier/"/>
    <id>http://liujunming.github.io/2019/05/09/Memory-barrier/</id>
    <published>2019-05-09T11:56:29.000Z</published>
    <updated>2019-05-11T04:37:14.999Z</updated>
    
    <content type="html"><![CDATA[<p>程序在运行时，内存实际的访问顺序和程序代码编写的访问顺序不一定一致，基于这个前提，Memory barrier 就有存在的必要了。</p><p>Memory barrier 能够保证其之前的内存访问操作先于其后的完成。Memory barrier的主要应用场景如下：</p><ol><li>实现同步原语（synchronization primitives）</li><li>实现无锁数据结构（lock-free data structures）</li><li>驱动程序</li></ol><a id="more"></a><p>本文内容转载自：<a href="http://b2e699b3.wiz03.com/share/s/2OVFCP1_wkXs20LtbT1nXNrj0EqwFC1zZAjT2bCeRi3Tzco2" target="_blank" rel="noopener">Name5566:理解 Memory barrier</a>。</p><h2 id="1-Memory-barrier-简介"><a href="#1-Memory-barrier-简介" class="headerlink" title="1. Memory barrier 简介"></a>1. Memory barrier 简介</h2><p>程序在运行时，内存实际的访问顺序和程序代码编写的访问顺序不一定一致，这就是内存乱序访问。内存乱序访问出现的理由是为了提升程序运行时的性能。内存乱序访问主要发生在两个阶段：</p><ol><li>编译时，编译器优化导致内存乱序访问（指令重排）</li><li>运行时，多个CPU之间的交互引起内存乱序访问</li></ol><p>Memory barrier 能够让 CPU 或编译器在内存访问上有序。一个 Memory barrier 之前的内存访问操作必定先于其之后的完成。Memory barrier 包括两类：</p><ol><li>编译器 barrier</li><li>CPU Memory barrier</li></ol><p>通常情况下，编译器和 CPU 引起的内存乱序访问不会带来什么问题，但在一些特殊情况下，程序逻辑的正确性依赖于内存访问的顺序，此时内存乱序访问会带来逻辑上的错误，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread 1</span></span><br><span class="line"><span class="keyword">while</span> (!ok);</span><br><span class="line"><span class="keyword">do</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread 2</span></span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line">ok = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>此段代码中，ok 初始化为 0，线程 1 等待 ok 被设置为 1 后执行 do 函数。假如说，线程 2 对内存的写操作乱序执行，也就是 x 赋值后于 ok 赋值完成，那么 do 函数接受的实参就很可能不是 42。</p><h3 id="1-1-编译时内存乱序访问"><a href="#1-1-编译时内存乱序访问" class="headerlink" title="1.1 编译时内存乱序访问"></a>1.1 编译时内存乱序访问</h3><p>编译器对代码做出优化时，可能改变指令的执行顺序（例如 gcc 下 O2 或 O3 都可能会改变指令的执行顺序）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="keyword">int</span> x, y, r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = r;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器优化的结果可能导致 y = 1 在 x = r 之前执行完成。首先直接编译此源文件：<br><code>g++ -S test.cpp</code></p><p>得到相关的汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl    r(%rip), %eax</span><br><span class="line">movl    %eax, x(%rip)</span><br><span class="line">movl    $1, y(%rip)</span><br></pre></td></tr></table></figure></p><p>这里可以看到，x = r 和 y = 1 并没有乱序。现使用优化选项 O2（或 O3）编译上面的代码（g++ -O2 -S test.cpp），生成汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl    r(%rip), %eax</span><br><span class="line">movl    $1, y(%rip)</span><br><span class="line">movl    %eax, x(%rip)</span><br></pre></td></tr></table></figure></p><p>我们可以清楚的看到，经过编译器优化之后 ，movl $1, y(%rip) 先于 movl %eax, x(%rip) 执行。避免编译时内存乱序访问的办法就是使用<code>编译器 barrier</code>（又叫<code>优化 barrier</code>）。Linux 内核提供函数 <code>barrier()</code> 用于让编译器保证其之前的内存访问先于其之后的完成。内核实现 <code>barrier()</code>如下（X86-64 架构）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> barrier() __asm__ __volatile__(<span class="meta-string">""</span> ::: <span class="meta-string">"memory"</span>)</span></span><br></pre></td></tr></table></figure></p><p>现在把此编译器 barrier 加入代码中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = r;</span><br><span class="line">    __asm__ __volatile__(<span class="string">""</span> ::: <span class="string">"memory"</span>);</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就避免了编译器优化带来的内存乱序访问的问题了。本例中，我们还可以使用 <code>volatile</code> 这个关键字来避免编译时内存乱序访问（而无法避免后面要说的运行时内存乱序访问）。<code>volatile</code> 关键字能够避免相关的变量在内存访问上乱序访问，这里可以修改 x 和 y 的定义来解决问题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = r;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现加上了 <code>volatile</code> 关键字，这使得 x 相对于 y、y 相对于 x 在内存访问上有序。在 Linux 内核中，提供了一个宏 <code>ACCESS_ONCE</code> 来避免编译器对于连续的 <code>ACCESS_ONCE</code>实例进行指令重排。其实 <code>ACCESS_ONCE</code> 实现源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))</span></span><br></pre></td></tr></table></figure></p><p>此代码只是将变量 x 转换为 <code>volatile</code> 的而已。现在我们就有了第三个修改方案：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ACCESS_ONCE(x) = r;</span><br><span class="line">    ACCESS_ONCE(y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此基本上就阐述完了编译时内存乱序访问的问题。下面开始介绍运行时内存乱序访问。</p><h3 id="1-2-运行时内存乱序访问"><a href="#1-2-运行时内存乱序访问" class="headerlink" title="1.2 运行时内存乱序访问"></a>1.2 运行时内存乱序访问</h3><p>在运行时，CPU 虽然会乱序执行指令，但是在单个 CPU上，硬件能够保证程序执行时,所有的内存访问操作看起来像是按程序代码编写的顺序执行的，这时候 Memory barrier 没有必要使用（不考虑编译器优化的情况下）。这里我们了解一下 CPU 乱序执行的行为。在乱序执行时，一个处理器真正执行指令的顺序由可用的输入数据决定，而非程序员编写的顺序。<br>早期的处理器为有序处理器（In-order processors），有序处理器处理指令通常有以下几步：</p><ol><li>指令获取</li><li>如果指令的输入操作对象（input operands）可用（例如已经在寄存器中了），则将此指令分发到适当的功能单元中。如果一个或者多个操作对象不可用（通常是由于需要从内存中获取），则处理器会等待，直到它们可用</li><li>指令被适当的功能单元执行</li><li>功能单元将结果写回寄存器堆（Register file，一个 CPU 中的一组寄存器）</li></ol><p>相比之下，乱序处理器（Out-of-order processors）处理指令通常有以下几步：</p><ol><li>指令获取</li><li>指令被分发到指令队列</li><li>指令在指令队列中等待，直到输入操作对象可用（一旦输入操作对象可用，指令就可以离开队列，即便更早的指令未被执行）</li><li>指令被分配到适当的功能单元并执行</li><li>执行结果被放入队列（而不立即写入寄存器堆）</li><li>只有所有更早请求执行的指令的执行结果被写入寄存器堆后，指令执行的结果才被写入寄存器堆（执行结果重排序，让执行看起来是有序的）</li></ol><p>从上面的执行过程可以看出，相比有序执行，乱序执行能够避免等待不可用的操作对象（有序执行的第二步），从而提高了效率。处理器运行的速度比内存快很多，在有序处理器花在等待可用数据的时间里，已经可以处理大量指令了。<br>现在思考一下乱序处理器处理指令的过程，我们能得到几个结论：</p><ol><li>对于单个 CPU， 指令获取是有序的（通过队列实现）</li><li>对于单个 CPU，指令执行结果也是有序返回寄存器堆的（通过队列实现）</li></ol><p>由此可知，在单 CPU 上，当不考虑编译器优化导致乱序时，多线程执行不存在内存乱序访问的问题。我们从内核源码中也可以得到类似的结论：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smp_mb() mb()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smp_mb() barrier()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>这里可以看到，如果是 SMP， 则使用 mb，mb 被定义为 CPU Memory barrier（后面会讲到），而非 SMP 时，直接使用编译器 barrier。</p><p>多处理器架构一般采用NUMA，这种架构下的内存操作会有巨大的延时问题。为了缓解这些问题，处理器会采取一些优化措施, 而导致程序顺序被破坏。</p><ul><li><p>情景一: 设想某处理器发出一条某内存位置读的指令，恰好这个内存位置在远端内存，而且处理器本地缓存也没有命中。于是，为了等待这个值，处理器需要空转(stall)。这显然是效率的极大浪费，事实上，现代的处理器都有乱序执行引擎, 指令并不是直接被执行，而是放到等待队列里，等待操作数到位后才执行，而这期间处理器优先处理其他指令。也就是出于效率考虑，处理器会重排指令。</p></li><li><p>情景二: 设想有一个热点全局变量，那么在程序运行一段时间后，很可能很多个处理器的本地缓存都有该变量的一份拷贝。再设想现在有处理器A修改这个全局变量，这个修改会发布一条消息能过网络通知所有其他处理器更新该变量缓存。由于路径的问题，消息不会同时到达所有处理器，那么存在一种可能性，某处理器此时仍观察到旧的值，而采取一些基于该旧值的动作。</p></li></ul><p>有兴趣可以研究<a href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf" target="_blank" rel="noopener">Memory Barriers: a Hardware View for Software Hackers</a>一文，其详细的分析了以上过程。</p><h2 id="2-Memory-barrier的应用场景"><a href="#2-Memory-barrier的应用场景" class="headerlink" title="2. Memory barrier的应用场景"></a>2. Memory barrier的应用场景</h2><p>Memory barrier 常用场合包括：</p><ol><li>实现同步原语（synchronization primitives）</li><li>实现无锁数据结构（lock-free data structures）</li><li>驱动程序</li></ol><p>在应用程序开发中，开发者可能完全不知道 Memory barrier 就可以开发正确的多线程程序，这主要是因为各种同步机制中已经隐含了 Memory barrier（但和实际的 Memory barrier 有细微差别）。但是如果你希望编写诸如无锁数据结构，那么 Memory barrier 还是很有用的。</p><p>在 Linux 内核中，除了前面说到的编译器 barrier — <code>barrier()</code> 和 <code>ACCESS_ONCE()</code>，还有 CPU Memory barrier：</p><ol><li>通用 barrier，保证读写操作有序的，<code>mb()</code>和 <code>smp_mb()</code></li><li>写操作 barrier，仅保证写操作有序的，<code>wmb()</code> 和 <code>smp_wmb()</code></li><li>读操作 barrier，仅保证读操作有序的，<code>rmb()</code> 和 <code>smp_rmb()</code></li></ol><p>注意，以上的CPU Memory barrier都隐含了编译器 barrier。这里以smp 开头的 Memory barrier 会在单处理器上直接使用编译器 barrier，而在 SMP 上才使用 CPU Memory barrier。</p><p>最后需要注意的是，CPU Memory barrier 中某些类型的 Memory barrier 需要成对使用，否则会出错。例如：一个写操作 barrier 需要和读操作barrier 一起使用（当然，通用 barrier 也是可以的），反之依然。</p><h3 id="2-1-Memory-barrier-的示例"><a href="#2-1-Memory-barrier-的示例" class="headerlink" title="2.1 Memory barrier 的示例"></a>2.1 Memory barrier 的示例</h3><p>下面我们通过读内核代码来进一步学习 Memory barrier 的使用。<br>Linux 内核实现的无锁（只有一个读线程和一个写线程时）环形缓冲区 kfifo 就使用到了 Memory barrier，实现源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A simple kernel FIFO implementation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2004 Stelian Pop &lt;stelian@popies.net&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"> * it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span></span><br><span class="line"><span class="comment"> * (at your option) any later version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment"> * GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment"> * along with this program; if not, write to the Free Software</span></span><br><span class="line"><span class="comment"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kfifo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/log2.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_init - allocates a new FIFO using a preallocated buffer</span></span><br><span class="line"><span class="comment"> * @buffer: the preallocated buffer to be used.</span></span><br><span class="line"><span class="comment"> * @size: the size of the internal buffer, this have to be a power of 2.</span></span><br><span class="line"><span class="comment"> * @gfp_mask: get_free_pages mask, passed to kmalloc()</span></span><br><span class="line"><span class="comment"> * @lock: the lock to be used to protect the fifo buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do NOT pass the kfifo to kfifo_free() after use! Simply free the</span></span><br><span class="line"><span class="comment"> * &amp;struct kfifo with kfree().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct kfifo *<span class="title">kfifo_init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> *<span class="title">fifo</span>;</span></span><br><span class="line">    <span class="comment">/* size must be a power of 2 */</span></span><br><span class="line">    BUG_ON(!is_power_of_2(size));</span><br><span class="line">    fifo = kmalloc(<span class="keyword">sizeof</span>(struct kfifo), gfp_mask);</span><br><span class="line">    <span class="keyword">if</span> (!fifo)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    fifo-&gt;buffer = buffer;</span><br><span class="line">    fifo-&gt;size = size;</span><br><span class="line">    fifo-&gt;in = fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line">    fifo-&gt;lock = lock;</span><br><span class="line">    <span class="keyword">return</span> fifo;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfifo_init);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_alloc - allocates a new FIFO and its internal buffer</span></span><br><span class="line"><span class="comment"> * @size: the size of the internal buffer to be allocated.</span></span><br><span class="line"><span class="comment"> * @gfp_mask: get_free_pages mask, passed to kmalloc()</span></span><br><span class="line"><span class="comment"> * @lock: the lock to be used to protect the fifo buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The size will be rounded-up to a power of 2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct kfifo *<span class="title">kfifo_alloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> *<span class="title">ret</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * round up to the next power of 2, since our 'let the indices</span></span><br><span class="line"><span class="comment">     * wrap' technique works only in this case.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_power_of_2(size)) &#123;</span><br><span class="line">        BUG_ON(size &gt; <span class="number">0x80000000</span>);</span><br><span class="line">        size = roundup_pow_of_two(size);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer = kmalloc(size, gfp_mask);</span><br><span class="line">    <span class="keyword">if</span> (!buffer)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    ret = kfifo_init(buffer, size, gfp_mask, lock);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(ret))</span><br><span class="line">        kfree(buffer);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfifo_alloc);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kfifo_free - frees the FIFO</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be freed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfifo_free</span><span class="params">(struct kfifo *fifo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kfree(fifo-&gt;buffer);</span><br><span class="line">    kfree(fifo);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfifo_free);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __kfifo_put - puts some data into the FIFO, no locking version</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be used.</span></span><br><span class="line"><span class="comment"> * @buffer: the data to be added.</span></span><br><span class="line"><span class="comment"> * @len: the length of the data to be added.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function copies at most @len bytes from the @buffer into</span></span><br><span class="line"><span class="comment"> * the FIFO depending on the free space, and returns the number of</span></span><br><span class="line"><span class="comment"> * bytes copied.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that with only one concurrent reader and one concurrent</span></span><br><span class="line"><span class="comment"> * writer, you don't need extra locking to use these functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __kfifo_put(struct kfifo *fifo,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line">    len = min(len, fifo-&gt;size - fifo-&gt;in + fifo-&gt;out);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that we sample the fifo-&gt;out index -before- we</span></span><br><span class="line"><span class="comment">     * start putting bytes into the kfifo.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_mb();</span><br><span class="line">    <span class="comment">/* first put the data starting from fifo-&gt;in to buffer end */</span></span><br><span class="line">    l = min(len, fifo-&gt;size - (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">memcpy</span>(fifo-&gt;buffer + (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)), buffer, l);</span><br><span class="line">    <span class="comment">/* then put the rest (if any) at the beginning of the buffer */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(fifo-&gt;buffer, buffer + l, len - l);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that we add the bytes to the kfifo -before-</span></span><br><span class="line"><span class="comment">     * we update the fifo-&gt;in index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_wmb();</span><br><span class="line">    fifo-&gt;in += len;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kfifo_put);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __kfifo_get - gets some data from the FIFO, no locking version</span></span><br><span class="line"><span class="comment"> * @fifo: the fifo to be used.</span></span><br><span class="line"><span class="comment"> * @buffer: where the data must be copied.</span></span><br><span class="line"><span class="comment"> * @len: the size of the destination buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function copies at most @len bytes from the FIFO into the</span></span><br><span class="line"><span class="comment"> * @buffer and returns the number of copied bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that with only one concurrent reader and one concurrent</span></span><br><span class="line"><span class="comment"> * writer, you don't need extra locking to use these functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __kfifo_get(struct kfifo *fifo,</span><br><span class="line">                         <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line">    len = min(len, fifo-&gt;in - fifo-&gt;out);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that we sample the fifo-&gt;in index -before- we</span></span><br><span class="line"><span class="comment">     * start removing bytes from the kfifo.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_rmb();</span><br><span class="line">    <span class="comment">/* first get the data from fifo-&gt;out until the end of the buffer */</span></span><br><span class="line">    l = min(len, fifo-&gt;size - (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, fifo-&gt;buffer + (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)), l);</span><br><span class="line">    <span class="comment">/* then get the rest (if any) from the beginning of the buffer */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buffer + l, fifo-&gt;buffer, len - l);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that we remove the bytes from the kfifo -before-</span></span><br><span class="line"><span class="comment">     * we update the fifo-&gt;out index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_mb();</span><br><span class="line">    fifo-&gt;out += len;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kfifo_get);</span><br></pre></td></tr></table></figure></p><p>在上述代码中，我们只需关注Memory barrier 即可。代码中，索引 in 和 out 被两个线程访问。in 和 out 指明了缓冲区中实际数据的边界，由于未使用同步机制，那么如果想保证顺序关系的话，就需要使用到 Memory barrier 了。索引in被一个线程修改，被两个线程读取。 索引out被另一个线程修改，被两个线程读取。__kfifo_put 先通过 in 和 out 来确定可以向缓冲区中写入数据量的多少，这时，out 索引应该先被读取后，才能将用户 buffer 中的数据写入缓冲区，因此这里使用到了 <code>smp_mb()</code>，对应的，__kfifo_get 也使用 <code>smp_mb()</code> 来确保在修改 out 索引之前，缓冲区中数据已经被读取到用户的buffer 中了。对于 in 索引，在 __kfifo_put 中，要保证先向缓冲区写入数据后才修改 in 索引，由于这里只需要保证写入操作有序，故选用写操作 barrier，在 __kfifo_get 中，要保证先读取了 in 索引才开始读取缓冲区中数据，由于这里只需要保证读取操作有序，故选用读操作 barrier。</p><hr><p>参考文献：</p><ol><li><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt" target="_blank" rel="noopener">LINUX KERNEL MEMORY BARRIERS</a></li><li><a href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf" target="_blank" rel="noopener">Memory Barriers: a Hardware View for Software Hackers</a></li><li><a href="https://github.com/JianyuZhan/larmbr.github.com/tree/master/_posts" target="_blank" rel="noopener">the-memory-barriers-in-linux-kernel</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序在运行时，内存实际的访问顺序和程序代码编写的访问顺序不一定一致，基于这个前提，Memory barrier 就有存在的必要了。&lt;/p&gt;
&lt;p&gt;Memory barrier 能够保证其之前的内存访问操作先于其后的完成。Memory barrier的主要应用场景如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现同步原语（synchronization primitives）&lt;/li&gt;
&lt;li&gt;实现无锁数据结构（lock-free data structures）&lt;/li&gt;
&lt;li&gt;驱动程序&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/categories/Concurrency/"/>
    
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>CPU Cache一致性问题</title>
    <link href="http://liujunming.github.io/2019/04/29/CPU-cache%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>http://liujunming.github.io/2019/04/29/CPU-cache一致性问题/</id>
    <published>2019-04-29T06:40:48.000Z</published>
    <updated>2019-05-10T06:51:33.896Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先介绍下产生CPU cache一致性问题的原因，然后给出CPU cache一致性的定义，最后给出解决CPU Cache一致性问题的解决方案。<a id="more"></a></p><h2 id="1-为什么会有CPU-cache一致性问题？"><a href="#1-为什么会有CPU-cache一致性问题？" class="headerlink" title="1. 为什么会有CPU cache一致性问题？"></a>1. 为什么会有CPU cache一致性问题？</h2><p>在多处理器架构中，每个处理器都拥有自己的CPU Cache，同时这些处理器共享内存资源。这样会导致多个处理器的CPU cache缓存了相同的内存数据块(以Cache Line为粒度)，此时可能会出现cache不一致问题。为了直观地展示Cache不一致问题，下图给出了一个具体的例子：<br><img src="/images/2019/5/1.gif" alt><br>p1和p2代表两个不同的处理器，在内存中，x的值为5。p1和p2都需要读取x，因而会将x读取到各自的cache中，此时，在cache中，x的值都为5。p1执行x=x+3时，在p1的cache中，x=8。与此同时，p2执行x=x+5，在p2的cache中，x=10。之后，写回p1的cache数据，此时，在内存中，x的值为8。接着，写回p2的cache数据，此时，在内存中，x的值为10。此刻，就出现了cache不一致问题：p1 cache中的x值与p2 cache中的x值不同。</p><p>下图展示了cache一致的结果：<br><img src="/images/2019/5/2.gif" alt></p><blockquote><p>In a shared memory multiprocessor system with a separate cache memory for each processor, it is possible to have many copies of shared data: one copy in the main memory and one in the local cache of each processor that requested it. When one of the copies of data is changed, the other copies must reflect that change. Cache coherence is the discipline which ensures that the changes in the values of shared operands(data) are propagated throughout the system in a timely fashion.</p></blockquote><p>The following are the requirements for cache coherence:</p><ul><li><p>Write Propagation<br>Changes to the data in any cache must be propagated to other copies (of that cache line) in the peer caches.</p></li><li><p>Transaction Serialization<br>Reads/Writes to a single memory location must be seen by all processors in the same order.</p></li></ul><h2 id="2-CPU-cache一致性的定义"><a href="#2-CPU-cache一致性的定义" class="headerlink" title="2. CPU cache一致性的定义"></a>2. CPU cache一致性的定义</h2><p>Coherence defines the behavior of reads and writes to a single address location.</p><p>In a multiprocessor system, consider that more than one processor has cached a copy of the memory location X. The following conditions are necessary to achieve cache coherence:</p><ol><li>In a read made by a processor P to a location X that follows a write by the same processor P to X, with no writes to X by another processor occurring between the write and the read instructions made by P, X must always return the value written by P.</li><li>In a read made by a processor P1 to location X that follows a write by another processor P2 to X, with no other writes to X made by any processor occurring between the two accesses and with the read and write being sufficiently separated, X must always return the value written by P2. This condition defines the concept of coherent view of memory. Propagating the writes to the shared memory location ensures that all the caches have a coherent view of the memory. If processor P1 reads the old value of X, even after the write by P2, we can say that the memory is incoherent.</li></ol><p>The above conditions satisfy the Write Propagation criteria required for cache coherence. However, they are not sufficient as they do not satisfy the Transaction Serialization condition. To illustrate this better, consider the following example:</p><p>A multi-processor system consists of four processors - P1, P2, P3 and P4, all containing cached copies of a shared variable S whose initial value is 0. Processor P1 changes the value of S (in its cached copy) to 10 following which processor P2 changes the value of S in its own cached copy to 20. If we ensure only write propagation, then P3 and P4 will certainly see the changes made to S by P1 and P2. However, P3 may see the change made by P1 after seeing the change made by P2 and hence return 10 on a read to S. P4 on the other hand may see changes made by P1 and P2 in the order in which they are made and hence return 20 on a read to S. The processors P3 and P4 now have an incoherent view of the memory.</p><p>Therefore, in order to satisfy Transaction Serialization, and hence achieve Cache Coherence, the following condition along with the previous two mentioned in this section must be met:</p><ul><li>Writes to the same location must be sequenced. In other words, if location X received two different values A and B, in this order, from any two processors, the processors can never read location X as B and then read it as A. The location X must be seen with values A and B in that order.</li></ul><h2 id="3-CPU-Cache一致性问题的解决方案"><a href="#3-CPU-Cache一致性问题的解决方案" class="headerlink" title="3. CPU Cache一致性问题的解决方案"></a>3. CPU Cache一致性问题的解决方案</h2><p>for bus-based machines，通常采用Snooping based protocols方案。for NUMA machines using a scalable switch，通常采用Directory Based Solutions。</p><blockquote><p>Snooping based protocols tend to be faster, if enough bandwidth is available, since all transactions are a request/response seen by all processors. The drawback is that snooping isn’t scalable. Every request must be broadcast to all nodes in a system, meaning that as the system gets larger, the size of the (logical or physical) bus and the bandwidth it provides must grow. Directories, on the other hand, tend to have longer latencies (with a 3 hop request/forward/respond) but use much less bandwidth since messages are point to point and not broadcast. For this reason, many of the larger systems (&gt;64 processors) use this type of cache coherence.</p></blockquote><h3 id="3-1-Snooping-based-protocols"><a href="#3-1-Snooping-based-protocols" class="headerlink" title="3.1 Snooping based protocols"></a>3.1 Snooping based protocols</h3><p>Snooping is a process where the individual caches monitor address lines for accesses to memory locations that they have cached. </p><p>Write propagation in snoopy protocols can be implemented by either of the following methods:</p><ul><li><p>Write Invalidate<br>When a processor writes into x, all copies of it in other processors are invalidated. These processors have to read a valid copy either from memory, or from the processor that modified the variable.</p></li><li><p>Write Broadcast<br>Instead of invalidating, why not broadcast the updated value to the other processors sharing that copy? </p></li></ul><p>MSI、MESI等protocol是较为常见的Snooping based protocols。<a href="https://www.youtube.com/watch?v=-p9tfMMu1PE" target="_blank" rel="noopener">MESI Cache Coherence Protocol | Vasileios Trigonakis</a>很好了阐述了MESI protocol。</p><p><img src="/images/2019/5/3.png" alt></p><p><img src="/images/2019/5/4.png" alt></p><p>概要地讲：在MESI协议中，每个cache line有四种状态，当遇到不同事件时，会改变cache line的状态，由此构成了一个有限自动机。</p><h3 id="3-2-Directory-Based-Solutions"><a href="#3-2-Directory-Based-Solutions" class="headerlink" title="3.2 Directory Based Solutions"></a>3.2 Directory Based Solutions</h3><p>In a directory-based system, the data being shared is placed in a common directory that maintains the coherence between caches. </p><p><a href="https://www.youtube.com/watch?v=6QZ_XiBEAF4" target="_blank" rel="noopener">Directory Entry</a>与<a href="https://www.youtube.com/watch?v=lZZYILcQ68Y" target="_blank" rel="noopener">Directory Example</a>给出了Directory的具体例子。</p><hr><p>参考资料：</p><ol><li><a href="https://www.wikiwand.com/en/Cache_coherence" target="_blank" rel="noopener">wikiwand Cache coherence</a></li><li><a href="https://www.wikiwand.com/en/Bus_snooping" target="_blank" rel="noopener">wikiwand Bus snooping</a></li><li><a href="https://www.wikiwand.com/en/Directory-based_coherence" target="_blank" rel="noopener">wikiwand Directory-based coherence</a></li><li><a href="https://zhuanlan.zhihu.com/p/25876351" target="_blank" rel="noopener">缓存/内存Coherence模型</a></li><li><a href="http://www.divms.uiowa.edu/~ghosh/4-20-06.pdf" target="_blank" rel="noopener">Multiprocessor Cache Coherence</a></li><li><a href="https://www.youtube.com/watch?v=-p9tfMMu1PE" target="_blank" rel="noopener">MESI Cache Coherence Protocol | Vasileios Trigonakis</a></li><li><a href="https://www.youtube.com/watch?v=lZZYILcQ68Y" target="_blank" rel="noopener">Directory Example - Georgia Tech - HPCA: Part 5</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先介绍下产生CPU cache一致性问题的原因，然后给出CPU cache一致性的定义，最后给出解决CPU Cache一致性问题的解决方案。
    
    </summary>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/categories/Concurrency/"/>
    
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>CPU Cache</title>
    <link href="http://liujunming.github.io/2019/04/20/CPU-cache/"/>
    <id>http://liujunming.github.io/2019/04/20/CPU-cache/</id>
    <published>2019-04-20T10:30:09.000Z</published>
    <updated>2019-05-09T09:42:06.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要有CPU-Cache"><a href="#1-为什么要有CPU-Cache" class="headerlink" title="1. 为什么要有CPU Cache"></a>1. 为什么要有CPU Cache</h2><ol><li>CPU的处理速度和内存的访问速度差距</li><li>内存数据访问的局部性原理<a id="more"></a><img src="/images/2019/4/8.png" alt><center>Cache Performance</center></li></ol><h2 id="2-为什么要有多级CPU-Cache"><a href="#2-为什么要有多级CPU-Cache" class="headerlink" title="2. 为什么要有多级CPU Cache"></a>2. 为什么要有多级CPU Cache</h2><blockquote><p>Soon after the introduction of the cache the system got more complicated. The speed difference between the cache and the main memory increased again, to a point that another level of cache was added, bigger and slower than the first-level cache. Only increasing the size of the first-level cache was not an option for economical reasons.</p></blockquote><p>此外，又由于程序指令和程序数据的行为和热点分布差异很大，因此L1 Cache也被划分成L1i (i for instruction)和L1d (d for data)两种专门用途的缓存。</p><h2 id="3-CPU-Cache-是如何存放数据的"><a href="#3-CPU-Cache-是如何存放数据的" class="headerlink" title="3. CPU Cache 是如何存放数据的"></a>3. CPU Cache 是如何存放数据的</h2><p>如果对这部分知识有些遗忘，可以看下<a href="https://courses.cs.washington.edu/courses/cse378/09wi/lectures/lec15.pdf" target="_blank" rel="noopener">cse378</a>即可。</p><h3 id="3-1-为什么Cache不能做成Direct-Mapped"><a href="#3-1-为什么Cache不能做成Direct-Mapped" class="headerlink" title="3.1 为什么Cache不能做成Direct Mapped"></a>3.1 为什么Cache不能做成Direct Mapped</h3><p><img src="/images/2019/4/7.png" alt></p><blockquote><p>Direct-Mapped Cache is simplier (requires just one comparator and one multiplexer), as a result is cheaper and works faster. Given any address, it is easy to identify the single entry in cache, where it can be. A major drawback when using DM cache is called a conflict miss, when two different addresses correspond to one entry in the cache. Even if the cache is big and contains many stale entries, it can’t simply evict those, because the position within cache is predetermined by the address.</p></blockquote><h3 id="3-2-为什么Cache不能做成Fully-Associative"><a href="#3-2-为什么Cache不能做成Fully-Associative" class="headerlink" title="3.2 为什么Cache不能做成Fully Associative"></a>3.2 为什么Cache不能做成Fully Associative</h3><blockquote><p>Full Associative Cache is much more complex, and it allows to store an address into any entry. There is a price for that. In order to check if a particular address is in the cache, it has to compare all current entries (the tags to be exact).</p></blockquote><p><img src="/images/2019/4/9.png" alt></p><h3 id="3-3-什么是N-Way-Set-Associative"><a href="#3-3-什么是N-Way-Set-Associative" class="headerlink" title="3.3 什么是N-Way Set Associative"></a>3.3 什么是N-Way Set Associative</h3><p><img src="/images/2019/4/10.png" alt></p><p>阅读<a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="noopener">Gallery of Processor Cache Effects</a>和<a href="https://coolshell.cn/articles/10249.html" target="_blank" rel="noopener">7个示例科普CPU CACHE</a>可以加深对N-Way Set Associative的理解。</p><hr><p>参考资料：</p><ol><li><a href="https://courses.cs.washington.edu/courses/cse378/09wi/lectures/lec15.pdf" target="_blank" rel="noopener">cse378</a></li><li><a href="http://cenalulu.github.io/linux/all-about-cpu-cache/" target="_blank" rel="noopener">关于CPU Cache – 程序猿需要知道的那些事</a></li><li><a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="noopener">Gallery of Processor Cache Effects</a></li><li><a href="https://coolshell.cn/articles/10249.html" target="_blank" rel="noopener">7个示例科普CPU CACHE</a></li><li><a href="https://stackoverflow.com/questions/30097648/difference-between-a-direct-mapped-cache-and-fully-associative-cache" target="_blank" rel="noopener">Difference Between a Direct-Mapped Cache and Fully Associative Cache</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-为什么要有CPU-Cache&quot;&gt;&lt;a href=&quot;#1-为什么要有CPU-Cache&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要有CPU Cache&quot;&gt;&lt;/a&gt;1. 为什么要有CPU Cache&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;CPU的处理速度和内存的访问速度差距&lt;/li&gt;
&lt;li&gt;内存数据访问的局部性原理
    
    </summary>
    
      <category term="体系结构" scheme="http://liujunming.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>(转)CPU Cache Line伪共享问题的总结和分析</title>
    <link href="http://liujunming.github.io/2019/04/10/%E8%BD%AC-CPU-Cache-Line%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%88%86%E6%9E%90/"/>
    <id>http://liujunming.github.io/2019/04/10/转-CPU-Cache-Line伪共享问题的总结和分析/</id>
    <published>2019-04-10T08:45:04.000Z</published>
    <updated>2019-05-07T06:39:01.469Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://mp.weixin.qq.com/s/RHIjnQDqC-2AOjjBAoMKMg" target="_blank" rel="noopener">CPU Cache Line伪共享问题的总结和分析</a></p><h2 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1 背景知识"></a>1 背景知识</h2><p>要搞清楚 Cache Line 伪共享的概念及其性能影响，需要对现代理器架构和硬件实现有一个基本的了解。 <a id="more"></a> </p><h3 id="1-1-存储器层次结构"><a href="#1-1-存储器层次结构" class="headerlink" title="1.1 存储器层次结构"></a>1.1 存储器层次结构</h3><p>众所周知，现代计算机体系结构，通过存储器层次结构 (Memory Hierarchy) 的设计，使系统在性能，成本和制造工艺之间作出取舍，从而达到一个平衡。<br>下图给出了不同层次的硬件访问延迟，可以看到，各个层次硬件访问延迟存在数量级上的差异，越高的性能，往往意味着更高的成本和更小的容量：<br><img src="/images/2019/4/1.jpg" alt></p><p>通过上图，可以对各级存储器 Cache Miss 带来的性能惩罚有个大致的概念。</p><h3 id="1-2-多核架构"><a href="#1-2-多核架构" class="headerlink" title="1.2 多核架构"></a>1.2 多核架构</h3><p>随着多核架构的普及，对称多处理器 (SMP) 系统成为主流。例如，一个物理 CPU 可以存在多个物理 Core，而每个 Core 又可以存在多个硬件线程。<br>x86 以下图为例，1 个 x86 CPU 有 4 个物理 Core，每个 Core 有两个 HT (Hyper Thread)，</p><p><img src="/images/2019/4/2.png" alt></p><p>从硬件的角度，上图的 L1 和 L2 Cache 都被两个 HT 共享，且在同一个物理 Core。而 L3 Cache 则在物理 CPU 里，被多个 Core 来共享。<br>而从 OS 内核角度，每个 HT 都是一个逻辑 CPU，因此，这个处理器在 OS 来看，就是一个 8 个 CPU 的 SMP 系统。</p><h3 id="1-3-NUMA-架构"><a href="#1-3-NUMA-架构" class="headerlink" title="1.3 NUMA 架构"></a>1.3 NUMA 架构</h3><p>按照 CPU 和内存的互连方式，可以分为 UMA (均匀内存访问) 和 NUMA (非均匀内存访问) 两种架构。<br>其中，在多个物理 CPU 之间保证 Cache 一致性的 NUMA 架构，又被称做 ccNUMA (Cache Coherent NUMA) 架构。值得注意的是：SMP也被称为UMA。</p><p>以 x86 为例，早期的 x86 就是典型的 UMA 架构。例如下图，四路处理器通过 FSB (前端系统总线) 和主板上的内存控制器芯片 (MCH) 相连，DRAM 是以 UMA 方式组织的，延迟并无访问差异。</p><p><img src="/images/2019/4/3.png" alt></p><p>然而，这种架构带来了严重的内存总线的性能瓶颈，影响了 x86 在多路服务器上的可扩展性和性能。<a href="http://cenalulu.github.io/linux/numa/" target="_blank" rel="noopener">NUMA架构的CPU – 你真的用好了么？</a></p><p>因此，从 Nehalem 架构开始，x86 开始转向 NUMA 架构，内存控制器芯片被集成到处理器内部，多个处理器通过 QPI 链路相连，从此 DRAM 有了远近之分。<br>而 Sandybridge 架构则更近一步，将片外的 IOH 芯片也集成到了处理器内部，至此，内存控制器和 PCIe Root Complex 全部在处理器内部了。 </p><p>下图就是一个典型的 x86 的 NUMA 架构：</p><p><img src="/images/2019/4/4.png" alt></p><p>由于 NUMA 架构的引入，以下主要部件产生了因物理链路的远近带来的延迟差异：</p><ul><li>Cache</li></ul><p>除物理 CPU 有本地的 Cache 的层级结构以外，还存在跨越系统总线 (QPI) 的远程 Cache 命中访问的情况。需要注意的是，远程的 Cache 命中，对发起 Cache 访问的 CPU 来说，还是被记入了 LLC Cache Miss。</p><ul><li>DRAM</li></ul><p>在两路及以上的服务器，远程 DRAM 的访问延迟，远远高于本地 DRAM 的访问延迟，有些系统可以达到 2 倍的差异。<br>需要注意的是，即使服务器 BIOS 里关闭了 NUMA 特性，也只是对 OS 内核屏蔽了这个特性，这种延迟差异还是存在的。</p><ul><li>Device</li></ul><p>对 CPU 访问设备内存，及设备发起 DMA 内存的读写活动而言，存在本地 Device 和远程 Device 的差别，有显著的延迟访问差异。</p><p>因此，对以上 NUMA 系统，一个 NUMA 节点通常可以被认为是一个物理 CPU 加上它本地的 DRAM 和 Device 组成。那么，四路服务器就拥有四个 NUMA 节点。<br>如果 BIOS 打开了 NUMA 支持，Linux 内核则会根据 ACPI 提供的表格，针对 NUMA 节点做一系列的 NUMA 亲和性的优化。</p><p>在 Linux 上，<code>numactl --hardware</code> 可以返回当前系统的 NUMA 节点信息，特别是 CPU 和 NUMA 节点的对应信息。</p><h3 id="1-4-Cache-的结构"><a href="#1-4-Cache-的结构" class="headerlink" title="1.4 Cache 的结构"></a>1.4 Cache 的结构</h3><p>Cache Line 是 CPU 和主存之间数据传输的最小单位。当一行 Cache Line 被从内存拷贝到 Cache 里，Cache 里会为这个 Cache Line 创建一个条目。<br>这个 Cache 条目里既包含了拷贝的内存数据，即 Cache Line，又包含了这行数据在内存里的位置等元数据信息。</p><p>详情可以参考<a href="https://courses.cs.washington.edu/courses/cse378/09wi/lectures/lec15.pdf" target="_blank" rel="noopener">cse378</a></p><p>Cache Line 的大小和处理器硬件架构有关。在 Linux 上，通过 <code>getconf</code> 就可以拿到 CPU 的 Cache Line 的大小。</p><p><img src="/images/2019/4/5.png" alt></p><p>除了 *_LINESIZE 指示了系统的 Cache Line 的大小是 64 字节外，还给出了 Cache 类别，大小。<br>其中 *_ASSOC 则指示了该 Cache 是几路关联 (Way Associative) 的。</p><h3 id="1-5-Cache-一致性"><a href="#1-5-Cache-一致性" class="headerlink" title="1.5 Cache 一致性"></a>1.5 Cache 一致性</h3><p>如前所述，在 SMP 系统里，每个 CPU 都有自己本地的 Cache。因此，同一个变量，或者同一行 Cache Line，有在多个处理器的本地 Cache 里存在多份拷贝的可能性，因此就存在数据一致性问题。<br>通常，处理器都实现了 Cache 一致性 (Cache Coherence）协议。如历史上 x86 曾实现了 MESI 协议以及 MESIF 协议。</p><p>假设两个处理器 A 和 B, 都在各自本地 Cache Line 里有同一个变量的拷贝时，此时该 Cache Line 处于 Shared 状态。当处理器 A 在本地修改了变量，除去把本地变量所属的 Cache Line 置为 Modified 状态以外，<br>还必须在另一个处理器 B 读同一个变量前，对该变量所在的 B 处理器本地 Cache Line 发起 Invaidate 操作，标记 B 处理器的那条 Cache Line 为 Invalidate 状态。<br>随后，若处理器 B 在对变量做读写操作时，如果遇到这个标记为 Invalidate 的状态的 Cache Line，即会引发 Cache Miss，<br>从而将内存中最新的数据拷贝到 Cache Line 里，然后处理器 B 再对此 Cache Line 对变量做读写操作。</p><p>本文中的 Cache Line 伪共享场景，就基于上述场景来讲解，关于 Cache 一致性协议更多的细节，请参考相关文档。</p><h3 id="1-6-Cache-Line-伪共享"><a href="#1-6-Cache-Line-伪共享" class="headerlink" title="1.6 Cache Line 伪共享"></a>1.6 Cache Line 伪共享</h3><p>Cache Line 伪共享问题，就是由多个 CPU 上的多个线程同时修改自己的变量引发的。这些变量表面上是不同的变量，但是实际上却存储在同一条 Cache Line 里。<br>在这种情况下，由于 Cache 一致性协议，两个处理器都存储有相同的 Cache Line 拷贝的前提下，本地 CPU 变量的修改会导致本地 Cache Line 变成 Modified 状态，然后在其它共享此 Cache Line 的 CPU 上，<br>引发 Cache Line 的 Invaidate 操作，导致 Cache Line 变为 Invalidate 状态，从而使 Cache Line 再次被访问时，发生本地 Cache Miss，从而伤害到应用的性能。<br>在此场景下，多个线程在不同的 CPU 上高频反复访问这种 Cache Line 伪共享的变量，则会因 Cache 颠簸引发严重的性能问题。</p><p>下图即为两个线程间的 Cache Line 伪共享问题的示意图。</p><p><img src="/images/2019/4/6.png" alt></p><h2 id="2-Perf-c2c-发现伪共享"><a href="#2-Perf-c2c-发现伪共享" class="headerlink" title="2 Perf c2c 发现伪共享"></a>2 Perf c2c 发现伪共享</h2><p>当应用在 NUMA 环境中运行，或者应用是多线程的，又或者是多进程间有共享内存，满足其中任意一条，那么这个应用就可能因为 Cache Line 伪共享而性能下降。</p><p>但是，要怎样才能知道一个应用是不是受伪共享所害呢？<a href="https://joemario.github.io/blog/2016/09/01/c2c-blog/" target="_blank" rel="noopener">Joe Mario</a> 提交的 patch 能够解决这个问题。Joe 的 patch 是在 Linux 的著名的 perf 工具上，添加了一些新特性，叫做 c2c，意思是“缓存到缓存” (cache-2-cache)。</p><p>Redhat 在很多 Linux 的大型应用上使用了 c2c 的原型，成功地发现了很多热的伪共享的 Cache Line。<br>Joe 在博客里总结了一下 perf c2c 的主要功能：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://mp.weixin.qq.com/s/RHIjnQDqC-2AOjjBAoMKMg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CPU Cache Line伪共享问题的总结和分析&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-背景知识&quot;&gt;&lt;a href=&quot;#1-背景知识&quot; class=&quot;headerlink&quot; title=&quot;1 背景知识&quot;&gt;&lt;/a&gt;1 背景知识&lt;/h2&gt;&lt;p&gt;要搞清楚 Cache Line 伪共享的概念及其性能影响，需要对现代理器架构和硬件实现有一个基本的了解。
    
    </summary>
    
      <category term="体系结构" scheme="http://liujunming.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ppt制作资源集锦</title>
    <link href="http://liujunming.github.io/2019/01/08/ppt%E5%88%B6%E4%BD%9C%E8%B5%84%E6%BA%90%E9%9B%86%E9%94%A6/"/>
    <id>http://liujunming.github.io/2019/01/08/ppt制作资源集锦/</id>
    <published>2019-01-08T04:48:29.000Z</published>
    <updated>2019-01-12T04:02:47.416Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录ppt制作过程中的心得以及遇到的优质资源，将持续更新。</p><a id="more"></a><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>学术、技术报告：</p><p>英文 <code>Arial Unicode MS</code></p><p>中文 <code>微软雅黑</code></p><h2 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h2><p><a href="https://brandcolors.net/" target="_blank" rel="noopener">美国世界知名品牌颜色收集网</a></p><p><img src="/images/2019/1/23.png" alt></p><h2 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h2><p>在说明问题的优缺点时，可以添加下表情。</p><p><a href="https://emojipedia.org/apple/" target="_blank" rel="noopener">emoji表情</a></p><p><img src="/images/2019/1/24.png" alt></p><h2 id="图片素材"><a href="#图片素材" class="headerlink" title="图片素材"></a>图片素材</h2><ul><li>Google图片</li></ul><p>有时候，ppt中需要添加一些高大上图片，比如需要添加数据中心的图片，此刻，可以去谷歌中搜索<code>datacenter</code>。</p><p><img src="/images/2019/1/25.png" alt></p><ul><li><a href="https://www.pexels.com/" target="_blank" rel="noopener">pexels</a></li></ul><p>  免费高清素材下载网站</p><ul><li><a href="https://pixabay.com/" target="_blank" rel="noopener">pixabay</a></li></ul><p>免费高清矢量图片资源</p><ul><li><a href="https://www.ssyer.com/home" target="_blank" rel="noopener">莎莎野</a></li></ul><p>免费高清素材下载网站</p><ul><li><a href="https://www.flaticon.com/" target="_blank" rel="noopener">flaticon</a></li></ul><p>免费图标下载资源</p><ul><li><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">阿里巴巴图标素材库</a></li></ul><h2 id="ppt排版"><a href="#ppt排版" class="headerlink" title="ppt排版"></a>ppt排版</h2><ul><li><a href="https://www.pinterest.com/a0802725pinyu/ppt-typesetting/" target="_blank" rel="noopener">PPT typesetting</a></li><li><a href="http://huaban.com/boards/19375308/" target="_blank" rel="noopener">观海PPT收集</a></li><li><a href="https://www.zhihu.com/question/47791746/answer/108730202" target="_blank" rel="noopener">如何做好一张包括一段字和几张图片的ppt,应该如何排版?</a></li></ul><h2 id="神器"><a href="#神器" class="headerlink" title="神器"></a>神器</h2><ul><li>PHOTOZOOM PRO</li></ul><p>做PPT时，我们经常需要用到图片，一张清晰出彩的图片可以为演示增分不少，而往往我们找到一张称心的图片，却发现分辨率过低，插入到PPT中变得模糊，着实令人懊恼。PHOTOZOOM PRO，就是为解决这个痛点而生的。</p><ul><li>PPTMinimizer</li></ul><p>PPT压缩软件</p><ul><li>iSlide 插件</li><li>文字云制作工具</li></ul><p><a href="https://wordart.com/" target="_blank" rel="noopener">Word Cloud Art Creator</a>，是一个支持中文的文字云生成工具</p><ul><li>Collagelt</li></ul><p>这款软件就是可以轻松将很多图片拼接在一起的一款工具。</p><h2 id="PPT-模板下载网站"><a href="#PPT-模板下载网站" class="headerlink" title="PPT 模板下载网站"></a>PPT 模板下载网站</h2><ul><li><a href="http://www.officeplus.cn/Template/Home.shtml" target="_blank" rel="noopener">officeplus</a></li><li><a href="https://slidemodel.com/" target="_blank" rel="noopener">slidemodel</a></li><li><a href="https://www.presentationmagazine.com/" target="_blank" rel="noopener">presentationmagazine</a></li><li><a href="https://slidehunter.com/" target="_blank" rel="noopener">slidehunter</a></li><li><a href="https://www.free-powerpoint-templates-design.com/" target="_blank" rel="noopener">AllPPT</a></li></ul><h2 id="keynote"><a href="#keynote" class="headerlink" title="keynote"></a>keynote</h2><p><a href="http://keynotetemplate.com/" target="_blank" rel="noopener">keynote template</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录ppt制作过程中的心得以及遇到的优质资源，将持续更新。&lt;/p&gt;
    
    </summary>
    
      <category term="设计" scheme="http://liujunming.github.io/categories/%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="设计" scheme="http://liujunming.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Understanding the Linux Kernel 读书笔记-The Page Cache</title>
    <link href="http://liujunming.github.io/2019/01/04/Understanding-the-Linux-Kernel-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-The-Page-Cache/"/>
    <id>http://liujunming.github.io/2019/01/04/Understanding-the-Linux-Kernel-读书笔记-The-Page-Cache/</id>
    <published>2019-01-04T02:36:01.000Z</published>
    <updated>2019-01-04T02:44:18.527Z</updated>
    
    <content type="html"><![CDATA[<p>A disk cache is a software mechanism that allows the system to keep in RAM some data that is normally stored on a disk, so that further accesses to that data can be sat- isfied quickly without accessing the disk.<br><a id="more"></a><br>The dentry cache, which stores dentry objects representing filesystem pathnames, and the inode cache, which stores inode objects representing disk inodes. The <em>page cache</em>, which is a disk cache working on whole pages of data.</p><h2 id="1-The-Page-Cache"><a href="#1-The-Page-Cache" class="headerlink" title="1 The Page Cache"></a>1 The Page Cache</h2><p>The <em>page cache</em> is the main disk cache used by the Linux kernel. In most cases, the kernel refers to the page cache when reading from or writing to disk. New pages are added to the page cache to satisfy User Mode processes’s read requests. If the page is not already in the cache, a new entry is added to the cache and filled with the data read from the disk.</p><p>Kernel designers have implemented the page cache to fulfill two main requirements:</p><ul><li>Quickly locate a specific page containing data relative to a given owner. </li><li>Keep track of how every page in the cache should be handled when reading or writing its content.</li></ul><p>A page does not necessarily contain physically adjacent disk blocks, so it cannot be identified by a device number and a block number. Instead, a page in the page cache is identified by an owner and by an index within the owner’s data—usually, an inode and an offset inside the corresponding file.</p><h3 id="1-1-The-address-space-Object"><a href="#1-1-The-address-space-Object" class="headerlink" title="1.1 The address_space Object"></a>1.1 The address_space Object</h3><p><a href="http://liujunming.top/2017/06/25/address-space-%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/" target="_blank" rel="noopener">address_space,页高速缓存</a><br>The core data structure of the page cache is the <code>address_space</code> object, a data structure embedded in the inode object that owns the page. Many pages in the cache may refer to the same owner, thus they may be linked to the same <code>address_space</code> object. This object also establishes a link between the owner’s pages and a set of methods that operate on these pages.</p><h3 id="1-2-The-Radix-Tree"><a href="#1-2-The-Radix-Tree" class="headerlink" title="1.2 The Radix Tree"></a>1.2 The Radix Tree</h3><h3 id="1-3-Page-Cache-Handling-Functions"><a href="#1-3-Page-Cache-Handling-Functions" class="headerlink" title="1.3 Page Cache Handling Functions"></a>1.3 Page Cache Handling Functions</h3><h3 id="1-4-The-Tags-of-the-Radix-Tree"><a href="#1-4-The-Tags-of-the-Radix-Tree" class="headerlink" title="1.4 The Tags of the Radix Tree"></a>1.4 The Tags of the Radix Tree</h3><h2 id="2-Storing-Blocks-in-the-Page-Cache"><a href="#2-Storing-Blocks-in-the-Page-Cache" class="headerlink" title="2 Storing Blocks in the Page Cache"></a>2 Storing Blocks in the Page Cache</h2><p><em>page cache</em> vs <em>buffer cache</em>.</p><p>Starting from stable version 2.4.10, the buffer cache does not really exist anymore. In fact, for reasons of efficiency, block buffers are no longer allocated individually; instead, they are stored in dedicated pages called “buffer pages,” which are kept in the page cache.</p><p>A buffer page is a page of data associated with additional descriptors called “buffer heads,” whose main purpose is to quickly locate the disk address of each individual block in the page. In fact, the chunks of data stored in a page belonging to the page cache are not necessarily adjacent on disk.</p><h3 id="2-1-Block-Buffers-and-Buffer-Heads"><a href="#2-1-Block-Buffers-and-Buffer-Heads" class="headerlink" title="2.1 Block Buffers and Buffer Heads"></a>2.1 Block Buffers and Buffer Heads</h3><h3 id="2-2-Managing-the-Buffer-Heads"><a href="#2-2-Managing-the-Buffer-Heads" class="headerlink" title="2.2 Managing the Buffer Heads"></a>2.2 Managing the Buffer Heads</h3><h3 id="2-3-Buffer-Pages"><a href="#2-3-Buffer-Pages" class="headerlink" title="2.3 Buffer Pages"></a>2.3 Buffer Pages</h3><p><img src="/images/2019/1/21.png" alt></p><p><a href="http://sundayhut.is-programmer.com/posts/62477" target="_blank" rel="noopener">buffer_head理解、解析</a></p><p>bio 相对 buffer_head 的好处有：bio 可以更方便的使用高端内存，因为它只与 page 打交道，并不直接使用地址。bio 可以表示 direct I/O。对向量形式的 I/O支持更好，防止 I/O 被打散。但是 buffer_head 还是需要的，它用于映射磁盘块到内存，因为 bio 中并没有包含 kernel 需要的 buffer 状态的成员以及一些其它信息。</p><h2 id="3-Writing-Dirty-Pages-to-Disk"><a href="#3-Writing-Dirty-Pages-to-Disk" class="headerlink" title="3 Writing Dirty Pages to Disk"></a>3 Writing Dirty Pages to Disk</h2><hr><p>参考资料：</p><ol><li><a href="http://sundayhut.is-programmer.com/posts/62477" target="_blank" rel="noopener">buffer_head理解、解析</a></li><li><a href="http://www.ilinuxkernel.com/files/Linux.Generic.Block.Layer.pdf" target="_blank" rel="noopener">Linux通用块设备层</a></li><li><a href="https://zohead.com/archives/linux-kernel-learning-block-layer/" target="_blank" rel="noopener">Linux kernel学习-block层</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A disk cache is a software mechanism that allows the system to keep in RAM some data that is normally stored on a disk, so that further accesses to that data can be sat- isfied quickly without accessing the disk.&lt;br&gt;
    
    </summary>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/categories/I-O%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="读书笔记" scheme="http://liujunming.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Understanding the Linux Kernel 读书笔记-Block Device Drivers</title>
    <link href="http://liujunming.github.io/2019/01/03/Understanding-the-Linux-Kernel-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Block-Device-Drivers/"/>
    <id>http://liujunming.github.io/2019/01/03/Understanding-the-Linux-Kernel-读书笔记-Block-Device-Drivers/</id>
    <published>2019-01-03T05:12:09.000Z</published>
    <updated>2019-01-03T10:14:56.327Z</updated>
    
    <content type="html"><![CDATA[<p>We start in the first section “Block Devices Handling” to explain the general architecture of the Linux block I/O subsystem. In the sections “The Generic Block Layer,” “The I/O Scheduler,” and “Block Device Drivers,” we will describe the main components of the block I/O subsystem. Finally, in the last section, “Opening a Block Device File,” we will outline the steps performed by the kernel when opening a block device file.<a id="more"></a></p><p><a href="http://www.ilinuxkernel.com/files/IO.Data.Structure.pdf" target="_blank" rel="noopener">Linux内核I/O流程主要数据结构</a></p><p>阅读时注意request的上下文，可能代表普遍意义上的请求，也可能代表<code>request</code>结构体。</p><h2 id="1-Block-Devices-Handling"><a href="#1-Block-Devices-Handling" class="headerlink" title="1 Block Devices Handling"></a>1 Block Devices Handling</h2><p>Each operation on a block device driver involves a large number of kernel components; the most important ones are shown in Figure 14-1.<br><img src="/images/2019/1/16.png" alt><br>Let us suppose, for instance, that a process issued a read() system call on some disk file. Here is what the kernel typically does to service the process request:</p><ol><li>The service routine of the <code>read()</code> system call activates a suitable VFS function, passing to it a file descriptor and an offset inside the file. </li><li>The VFS function determines if the requested data is already available and, if necessary, how to perform the read operation.</li><li>Let’s assume that the kernel must read the data from the block device, thus it must determine the physical location of that data. To do this, the kernel relies on the <em>mapping layer</em>, which typically executes two steps:<ul><li>It determines the block size of the filesystem including the file and computes the extent of the requested data in terms of <em>file block numbers</em>. Essentially, the file is seen as split in many blocks, and the kernel determines the numbers (indices relative to the beginning of file) of the blocks containing the requested data.</li><li>Next, the mapping layer invokes a filesystem-specific function that accesses the file’s disk inode and determines the position of the requested data on disk in terms of <em>logical block numbers</em>. Essentially, the disk is seen as split in blocks, and the kernel determines the numbers (indices relative to the beginning of the disk or partition) corresponding to the blocks storing the requested data. Because a file may be stored in nonadjacent blocks on disk, a data structure stored in the disk inode maps each file block number to a logical block number.</li></ul></li><li>The kernel can now issue the read operation on the block device. It makes use of the <em>generic block layer</em>, which starts the I/O operations that transfer the requested data. In general, each I/O operation involves a group of blocks that are adjacent on disk. Because the requested data is not necessarily adjacent on disk, the generic block layer might start several I/O operations. Each I/O operation is represented by a “block I/O” (in short, “bio”) structure, which collects all information needed by the lower components to satisfy the request.<br>The generic block layer hides the peculiarities of each hardware block device, thus offering an abstract view of the block devices. Because almost all block devices are disks, the generic block layer also provides some general data structures that describe “disks” and “disk partitions.” </li><li>Below the generic block layer, the “I/O scheduler” sorts the pending I/O data transfer requests according to predefined kernel policies. The purpose of the scheduler is to group requests of data that lie near each other on the physical medium.</li><li>Finally, the <em>block device drivers</em> take care of the actual data transfer by sending suitable commands to the hardware interfaces of the disk controllers.</li></ol><p>As you can see, there are many kernel components that are concerned with data stored in block devices; each of them manages the disk data using chunks of different length:</p><ul><li>The controllers of the hardware block devices transfer data in chunks of fixed length called “sectors.” Therefore, the I/O scheduler and the block device drivers must manage sectors of data.</li><li>The Virtual Filesystem, the mapping layer, and the filesystems group the disk data in logical units called “blocks.” A block corresponds to the minimal disk storage unit inside a filesystem.</li><li>Block device drivers should be able to cope with “segments” of data: each segment is a memory page—or a portion of a memory page—including chunks of data that are physically adjacent on disk.</li><li>The disk caches work on “pages” of disk data, each of which fits in a page frame.</li><li>The generic block layer glues together all the upper and lower components, thus it knows about sectors, blocks, segments, and pages of data.</li></ul><p><img src="/images/2019/1/17.png" alt></p><h3 id="1-1-Sectors"><a href="#1-1-Sectors" class="headerlink" title="1.1 Sectors"></a>1.1 Sectors</h3><h3 id="1-2-Blocks"><a href="#1-2-Blocks" class="headerlink" title="1.2 Blocks"></a>1.2 Blocks</h3><h3 id="1-3-Segments"><a href="#1-3-Segments" class="headerlink" title="1.3 Segments"></a>1.3 Segments</h3><h2 id="2-The-Generic-Block-Layer"><a href="#2-The-Generic-Block-Layer" class="headerlink" title="2 The Generic Block Layer"></a>2 The Generic Block Layer</h2><p>The generic block layer is a kernel component that handles the requests for all block devices in the system. Thanks to its functions, the kernel may easily:</p><ul><li>Implement—with some additional effort—a “zero-copy” schema, where disk data is directly put in the User Mode address space without being copied to kernel memory first.</li><li>Manage logical volumes—such as those used by LVM(the Logical Volume Manager) and RAID (Redundant Array of Inexpensive Disks): several disk partitions, even on different block devices, can be seen as a single partition.</li><li>Exploit the advanced features of the most recent disk controllers.</li></ul><h3 id="2-1-The-Bio-Structure"><a href="#2-1-The-Bio-Structure" class="headerlink" title="2.1 The Bio Structure"></a>2.1 The Bio Structure</h3><p>The core data structure of the generic block layer is a descriptor of an ongoing I/O block device operation called <em>bio</em>. Each bio essentially includes an identifier for a disk storage area—the initial sector number and the number of sectors included in the storage area—and one or more segments describing the memory areas involved in the I/O operation. A bio is implemented by the <code>bio</code> data structure.</p><p>Each segment in a bio is represented by a <code>bio_vec</code> data structure.<br><img src="/images/2019/1/18.png" alt></p><h3 id="2-2-Representing-Disks-and-Disk-Partitions"><a href="#2-2-Representing-Disks-and-Disk-Partitions" class="headerlink" title="2.2 Representing Disks and Disk Partitions"></a>2.2 Representing Disks and Disk Partitions</h3><p>A <em>disk</em> is a logical block device that is handled by the generic block layer. Usually a disk corresponds to a hardware block device such as a hard disk, a floppy disk, or a CD-ROM disk. However, a disk can be a virtual device built upon several physical disk partitions, or a storage area living in some dedicated pages of RAM. In any case, the upper kernel components operate on all disks in the same way thanks to the services offered by the generic block layer.</p><p>A disk is represented by the <code>gendisk</code> object.</p><p>Hard disks are commonly split into <em>logical partitions</em>. Each block device file may represent either a whole disk or a partition inside the disk. If a disk is split in partitions, their layout is kept in an array of <code>hd_struct</code> structures whose address is stored in the <code>part</code> field of the <code>gendisk</code> object.</p><h3 id="2-3-Submitting-a-Request"><a href="#2-3-Submitting-a-Request" class="headerlink" title="2.3 Submitting a Request"></a>2.3 Submitting a Request</h3><h2 id="3-The-I-O-Scheduler"><a href="#3-The-I-O-Scheduler" class="headerlink" title="3 The I/O Scheduler"></a>3 The I/O Scheduler</h2><p><img src="/images/2019/1/20.jpg" alt></p><p><img src="/images/2019/1/19.png" alt></p><p>Although block device drivers are able to transfer a single sector at a time, the block I/O layer does not perform an individual I/O operation for each sector to be accessed on disk; this would lead to poor disk performance, because locating the physical position of a sector on the disk surface is quite time-consuming. Instead, the kernel tries, whenever possible, to cluster several sectors and handle them as a whole, thus reducing the average number of head movements.</p><p>When a kernel component wishes to read or write some disk data, it actually creates a block device request. That request essentially describes the requested sectors and the kind of operation to be performed on them (read or write). However, the kernel does not satisfy a request as soon as it is created—the I/O operation is just scheduled and will be performed at a later time.</p><p>Each block device driver maintains its own <em>request queue</em>, which contains the list of pending requests for the device. If the disk controller is handling several disks, there is usually one request queue for each physical block device. I/O scheduling is performed separately on each request queue, thus increasing disk performance.</p><h3 id="3-1-Request-Queue-Descriptors"><a href="#3-1-Request-Queue-Descriptors" class="headerlink" title="3.1 Request Queue Descriptors"></a>3.1 Request Queue Descriptors</h3><p>The <code>backing_dev_info</code> field is a small object of type <code>backing_dev_info</code>, which stores information about the I/O data flow traffic for the underlying hardware block device. For instance, it holds information about read-ahead and about request queue congestion state.</p><h3 id="3-2-Request-Descriptors"><a href="#3-2-Request-Descriptors" class="headerlink" title="3.2 Request Descriptors"></a>3.2 Request Descriptors</h3><p>每个bio到达了磁盘设备的request_queue，接下来需要对该bio进行深加工，提高IO效率。这里的关键在于将bio合并至已存在request内，所谓的合并指的是该bio所请求的io是否与当前已有request在物理磁盘块上连续，如果是，无需分配新的request，直接将该请求添加至已有request，这样一次便可传输更多数据，提升IO效率，这其实也是整个IO系统的核心所在。</p><h3 id="3-3-Activating-the-Block-Device-Driver"><a href="#3-3-Activating-the-Block-Device-Driver" class="headerlink" title="3.3 Activating the Block Device Driver"></a>3.3 Activating the Block Device Driver</h3><h3 id="3-4-I-O-Scheduling-Algorithms"><a href="#3-4-I-O-Scheduling-Algorithms" class="headerlink" title="3.4 I/O Scheduling Algorithms"></a>3.4 I/O Scheduling Algorithms</h3><p>When a new request is added to a request queue, the generic block layer invokes the I/O scheduler to determine that exact position of the new element in the queue. The I/O scheduler tries to keep the request queue sorted sector by sector. If the requests to be processed are taken sequentially from the list, the amount of disk seeking is significantly reduced because the disk head moves in a linear way from the inner track to the outer one (or vice versa) instead of jumping randomly from one track to another.</p><h3 id="3-5-Issuing-a-Request-to-the-I-O-Scheduler"><a href="#3-5-Issuing-a-Request-to-the-I-O-Scheduler" class="headerlink" title="3.5 Issuing a Request to the I/O Scheduler"></a>3.5 Issuing a Request to the I/O Scheduler</h3><h2 id="4-Block-Device-Drivers"><a href="#4-Block-Device-Drivers" class="headerlink" title="4 Block Device Drivers"></a>4 Block Device Drivers</h2><h3 id="4-1-Block-Devices"><a href="#4-1-Block-Devices" class="headerlink" title="4.1 Block Devices"></a>4.1 Block Devices</h3><h3 id="4-2-Device-Driver-Registration-and-Initialization"><a href="#4-2-Device-Driver-Registration-and-Initialization" class="headerlink" title="4.2 Device Driver Registration and Initialization"></a>4.2 Device Driver Registration and Initialization</h3><h3 id="4-3-The-Strategy-Routine"><a href="#4-3-The-Strategy-Routine" class="headerlink" title="4.3 The Strategy Routine"></a>4.3 The Strategy Routine</h3><h3 id="4-4-The-Interrupt-Handler"><a href="#4-4-The-Interrupt-Handler" class="headerlink" title="4.4 The Interrupt Handler"></a>4.4 The Interrupt Handler</h3><h2 id="5-Opening-a-Block-Device-File"><a href="#5-Opening-a-Block-Device-File" class="headerlink" title="5 Opening a Block Device File"></a>5 Opening a Block Device File</h2><hr><p>参考资料：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/39199521" target="_blank" rel="noopener">Linux IO请求处理流程-bio和request</a></li><li><a href="http://sundayhut.is-programmer.com/posts/62921.html" target="_blank" rel="noopener">bio，request，request_queue的学习</a></li><li><a href="http://www.ilinuxkernel.com/files/IO.Data.Structure.pdf" target="_blank" rel="noopener">Linux内核I/O流程主要数据结构</a></li><li><a href="http://ilinuxkernel.com/?p=1693" target="_blank" rel="noopener">Linux内核I/O调度层</a></li><li><a href="http://sundayhut.is-programmer.com/posts/49095.html" target="_blank" rel="noopener">文件系统写浅析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;We start in the first section “Block Devices Handling” to explain the general architecture of the Linux block I/O subsystem. In the sections “The Generic Block Layer,” “The I/O Scheduler,” and “Block Device Drivers,” we will describe the main components of the block I/O subsystem. Finally, in the last section, “Opening a Block Device File,” we will outline the steps performed by the kernel when opening a block device file.
    
    </summary>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/categories/I-O%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="读书笔记" scheme="http://liujunming.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
