<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2022-02-28T10:17:23.634Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Time-Stamp Counter Virtualization</title>
    <link href="http://liujunming.github.io/2022/02/28/Time-Stamp-Counter-virtualization/"/>
    <id>http://liujunming.github.io/2022/02/28/Time-Stamp-Counter-virtualization/</id>
    <published>2022-02-28T06:56:25.000Z</published>
    <updated>2022-02-28T10:17:23.634Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录Time-Stamp Counter Virtualization相关内容。<a id="more"></a></p><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p><img src="/images/2022/02/28.PNG" alt></p><p>The product means <em>the result obtained by multiplying two or more quantities together</em>.</p><h3 id="TSC-offsetting"><a href="#TSC-offsetting" class="headerlink" title="TSC offsetting"></a>TSC offsetting</h3><p><strong>Timestamp-counter offsetting</strong> (<strong>TSC offsetting</strong>) is an existing feature that allows VMM software to specify a value (the <strong>TSC offset</strong>) that is added to the TSC when it is read by guest software. A VMM can use this feature to provide guest software with the illusion that it is operating at a time later or earlier than that represented by the current TSC value.</p><h3 id="TSC-scaling"><a href="#TSC-scaling" class="headerlink" title="TSC scaling"></a>TSC scaling</h3><p>With TSC offsetting, guest software perceives a TSC that is offset from the real hardware, but which advances at the same rate. That may be adequate for usages in which the offset is used to account for execution time before virtual machine was created. But it might not suffice if the VMM migrates a virtual machine between platforms on which the TSC moves at different rates.</p><p>TSC scaling provides VMM software with a mechanism by which is it can adjust the TSC rate perceived by guest software. When TSC scaling and TSC offsetting are both enabled, reads from the TSC in VMX nonroot operation multiply the actual TSC value by a new <strong>TSC multiplier</strong>, add the TSC offset to the product, and return the sum to guest software.</p><p>With both TSC offsetting and TSC scaling, a VMM that migrates a virtual machine from one platform to another can configure the TSC offset and the TSC multiplier on the new platform so that the TSC (as perceived by the guest) appears to proceed from the same value that it had before the migration <strong>and at the same rate</strong>.</p><hr><p>参考资料:</p><ol><li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/timestamp-counter-scaling-virtualization-white-paper.pdf" target="_blank" rel="noopener">Timestamp-Counter Scaling (TSC scaling) for Virtualization</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录Time-Stamp Counter Virtualization相关内容。
    
    </summary>
    
      <category term="VT-x" scheme="http://liujunming.github.io/categories/VT-x/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-x" scheme="http://liujunming.github.io/tags/VT-x/"/>
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>Dive into Time-Stamp Counter</title>
    <link href="http://liujunming.github.io/2022/02/28/Dive-into-Time-Stamp-Counter/"/>
    <id>http://liujunming.github.io/2022/02/28/Dive-into-Time-Stamp-Counter/</id>
    <published>2022-02-28T06:23:39.000Z</published>
    <updated>2022-02-28T10:09:54.798Z</updated>
    
    <content type="html"><![CDATA[<p>本文将深入研究Time-Stamp Counter。<a id="more"></a></p><p><img src="/images/2022/02/24.PNG" alt></p><p><img src="/images/2022/02/25.PNG" alt></p><p><img src="/images/2022/02/26.PNG" alt></p><p><img src="/images/2022/02/27.PNG" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将深入研究Time-Stamp Counter。
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s serializing instruction in Intel terminology</title>
    <link href="http://liujunming.github.io/2022/02/28/What-s-serializing-instruction-in-Intel-terminology/"/>
    <id>http://liujunming.github.io/2022/02/28/What-s-serializing-instruction-in-Intel-terminology/</id>
    <published>2022-02-28T05:53:10.000Z</published>
    <updated>2022-02-28T10:09:54.799Z</updated>
    
    <content type="html"><![CDATA[<p>What’s serializing instruction in Intel terminology?<a id="more"></a></p><p><img src="/images/2022/02/23.PNG" alt></p><p>Serializing instructions <strong>force the processor to complete all modifications to flags, registers, and memory by previous instructions and to drain all buffered writes to memory before the next instruction is fetched and executed</strong>. For example, when a MOV to control register instruction is used to load a new value into control register CR0 to enable protected mode, the processor must perform a serializing operation before it enters protected mode. This serializing operation ensures that all operations that were started while the processor was in real-address mode are completed before the switch to protected mode is made.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;What’s serializing instruction in Intel terminology?
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to PKS</title>
    <link href="http://liujunming.github.io/2022/02/27/Introduction-to-PKS/"/>
    <id>http://liujunming.github.io/2022/02/27/Introduction-to-PKS/</id>
    <published>2022-02-27T05:54:21.000Z</published>
    <updated>2022-02-27T06:58:14.794Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍PKS(<strong>P</strong>rotection <strong>K</strong>eys for <strong>S</strong>upervisor Pages).<a id="more"></a></p><h3 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h3><p><a href="/2020/03/07/Introduction-to-pkeys/">Introduction to PKU</a></p><h3 id="2-SPEC"><a href="#2-SPEC" class="headerlink" title="2. SPEC"></a>2. SPEC</h3><p><img src="/images/2022/02/21.PNG" alt></p><p><img src="/images/2022/02/22.PNG" alt></p><h3 id="3-Description"><a href="#3-Description" class="headerlink" title="3. Description"></a>3. Description</h3><p>参见<a href="https://lpc.events/event/11/contributions/907/attachments/787/1699/lpc-2021-PKS-22-Sept-2021.pdf" target="_blank" rel="noopener">Protection Keys, Supervisor (PKS)</a>中的<strong>PKS Hardware Overview</strong>一节。</p><p>Protection Keys for Supervisor Pages(PKS) is a feature that extends the Protection Keys architecture to support thread-specific permission restrictions on supervisor pages.</p><p>PKS works similar to an existing feature named PKU(protecting user pages). They both perform an additional check after normal paging permission checks are done. Access or Writes can be disabled via a MSR update without TLB flushes when permissions changes. If violating this addional check, #PF occurs and PFEC.PK bit will be set.</p><p>PKS introduces MSR IA32_PKRS to manage supervisor protection key rights. The MSR contains 16 pairs of ADi and WDi bits. Each pair advertises on a group of pages with the same key which is set in the leaf paging-structure entries(bits[62:59]). Currently, IA32_PKRS is not supported by XSAVES architecture.</p><hr><p>参考资料:</p><ol><li><a href="https://lpc.events/event/11/contributions/907/attachments/787/1699/lpc-2021-PKS-22-Sept-2021.pdf" target="_blank" rel="noopener">Protection Keys, Supervisor (PKS)</a></li><li><a href="https://lore.kernel.org/lkml/20210505003032.489164-1-rick.p.edgecombe@intel.com/" target="_blank" rel="noopener">PKS write protected page tables</a></li><li><a href="https://lore.kernel.org/lkml/20220127175505.851391-1-ira.weiny@intel.com/" target="_blank" rel="noopener">PKS/PMEM: Add Stray Write Protection</a></li><li><a href="https://lore.kernel.org/lkml/20220221080840.7369-1-chenyi.qiang@intel.com/" target="_blank" rel="noopener">KVM: PKS Virtualization support</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍PKS(&lt;strong&gt;P&lt;/strong&gt;rotection &lt;strong&gt;K&lt;/strong&gt;eys for &lt;strong&gt;S&lt;/strong&gt;upervisor Pages).
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Intel VT-rp</title>
    <link href="http://liujunming.github.io/2022/02/16/Introduction-to-Intel-VT-rp/"/>
    <id>http://liujunming.github.io/2022/02/16/Introduction-to-Intel-VT-rp/</id>
    <published>2022-02-16T08:50:20.000Z</published>
    <updated>2022-02-16T13:01:30.095Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍Intel的VT-rp技术。<a id="more"></a></p><h3 id="1-Material"><a href="#1-Material" class="headerlink" title="1. Material"></a>1. Material</h3><ul><li>SPEC:<a href="https://software.intel.com/content/www/us/en/develop/download/intel-architecture-instruction-set-extensions-programming-reference.html" target="_blank" rel="noopener">ISE</a></li><li><a href="https://static.sched.com/hosted_files/kvmforum2020/34/kvm2020_hypervisor-managed%20linear%20address%20translation_v3.pdf" target="_blank" rel="noopener">Hypervisor-managed Linear Address Translation by Chao Gao slides</a></li><li><a href="https://www.youtube.com/watch?v=j2T90htYSko" target="_blank" rel="noopener">Hypervisor-managed Linear Address Translation by Chao Gao video</a></li></ul><h3 id="2-Background"><a href="#2-Background" class="headerlink" title="2. Background"></a>2. Background</h3><p><img src="/images/2022/02/08.png" alt><br>对于write-protecting CR3 page table leads to high performance penalty的解释如下：<br>VMMs could enforce the integrity of these specific guest linear to guest physical mappings (paging structures) by using legacy EPT permissions to mark the guest physical memory containing the relevant guest paging structures as read-only. The intent of marking these guest paging structures as read-only is to ensure an invalid mapping is not created by guest software. However, such page-table edit control techniques are known to cause very high overheads(EPT violation VM Exit)  due to the requirement that the VMM must monitor all paging contexts created by the (Guest) operating system.<br><img src="/images/2022/02/09.png" alt></p><h3 id="3-Terms"><a href="#3-Terms" class="headerlink" title="3. Terms"></a>3. Terms</h3><ul><li>Intel VT-rp(Intel Virtualization Technology - Redirect Protection)</li><li>HLAT(Hypervisor-managed Linear Address Translation)</li><li>PLR(Protected Linear Range)</li><li>PW(Paging Write)</li><li>VPW(Verify Paging-Write)</li></ul><h3 id="4-VT-rp"><a href="#4-VT-rp" class="headerlink" title="4. VT-rp"></a>4. VT-rp</h3><p><img src="/images/2022/02/10.png" alt></p><h4 id="4-1-HLAT"><a href="#4-1-HLAT" class="headerlink" title="4.1 HLAT"></a>4.1 HLAT</h4><p><img src="/images/2022/02/11.png" alt><br><img src="/images/2022/02/12.png" alt><br><img src="/images/2022/02/13.png" alt></p><h4 id="4-2-EPT-Control-Bit-“Paging-Write”"><a href="#4-2-EPT-Control-Bit-“Paging-Write”" class="headerlink" title="4.2 EPT Control Bit “Paging-Write”"></a>4.2 EPT Control Bit “Paging-Write”</h4><p>A new EPT control bit called <strong>“Paging-Write”</strong> specified in EPT leaf entries. </p><p><img src="/images/2022/02/16.png" alt></p><p><img src="/images/2022/02/14.png" alt></p><p>硬件会更新guest paging structure pages的A/D bits without EPT violation VM exits</p><h4 id="4-3-EPT-Control-Bit-“Verify-Paging-write”"><a href="#4-3-EPT-Control-Bit-“Verify-Paging-write”" class="headerlink" title="4.3 EPT Control Bit “Verify Paging-write”"></a>4.3 EPT Control Bit “Verify Paging-write”</h4><p>A new EPT control bit called <strong>“Verify Paging-Write”</strong> specified in EPT leaf entries (that refer to the final host physical page in the translation).</p><p><img src="/images/2022/02/17.png" alt></p><p><img src="/images/2022/02/15.png" alt></p><h4 id="4-4-Prevent-Alias-Mapping-with-PW-amp-VPW"><a href="#4-4-Prevent-Alias-Mapping-with-PW-amp-VPW" class="headerlink" title="4.4 Prevent Alias Mapping with PW &amp; VPW"></a>4.4 Prevent Alias Mapping with PW &amp; VPW</h4><p><img src="/images/2022/02/19.png" alt></p><h3 id="5-Implementaion"><a href="#5-Implementaion" class="headerlink" title="5. Implementaion"></a>5. Implementaion</h3><p><img src="/images/2022/02/18.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍Intel的VT-rp技术。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
      <category term="Security" scheme="http://liujunming.github.io/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to IPIv</title>
    <link href="http://liujunming.github.io/2022/02/15/Introduction-to-IPIv/"/>
    <id>http://liujunming.github.io/2022/02/15/Introduction-to-IPIv/</id>
    <published>2022-02-15T07:17:34.000Z</published>
    <updated>2022-02-16T13:01:30.095Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍Intel的IPIv(IPI Virtualization)硬件技术。<a id="more"></a></p><h3 id="1-Previous-software-technology"><a href="#1-Previous-software-technology" class="headerlink" title="1. Previous software technology"></a>1. Previous software technology</h3><ul><li><a href="/2022/02/12/Introduction-to-PV-IPI/">PV IPI</a></li><li><a href="/2022/02/13/Introduction-to-Passthrough-IPI/">Passthrough IPI</a></li></ul><p>软件方案终究不够完美，还是需要Intel推出硬件方案来解决该问题。</p><h3 id="2-Motivation"><a href="#2-Motivation" class="headerlink" title="2. Motivation"></a>2. Motivation</h3><p>Currently, issuing an IPI except self-ipi in guest on Intel CPU always causes a VM-exit. It can lead to non-negligible overhead to some workloads involving frequent IPIs when running in VMs.</p><p>IPI virtualization is a new VT-x feature, targeting to eliminate VM-exits on source vCPUs <strong>when issuing unicast, physical-addressing IPIs</strong>. Once it is enabled, the processor virtualizes following kinds of operations that send IPIs without causing VM-exits:</p><ul><li>Memory-mapped ICR writes</li><li>MSR-mapped ICR writes</li><li>SENDUIPI execution</li></ul><h3 id="3-Spec"><a href="#3-Spec" class="headerlink" title="3. Spec"></a>3. Spec</h3><p>latest <a href="https://software.intel.com/content/www/us/en/develop/download/intel-architecture-instruction-set-extensions-programming-reference.html" target="_blank" rel="noopener">Intel Architecture Instruction Set Extensions Programming Reference</a><br><img src="/images/2022/02/05.png" alt></p><p>Idea:</p><ul><li>The processor uses a data structure called the PID-pointer table. Each entry in the PID-pointer table contains the 64-bit physical address of a PID.</li><li>The processor indexes into a PID-pointer table using a virtual APIC ID<br><img src="/images/2022/02/06.png" alt></li></ul><p>不是所有类型的IPI都可以利用IPIv的，只有满足一定条件时，硬件的IPIv才能生效，否则，依然需要发生VM Exit。<br><img src="/images/2022/02/07.png" alt><br>这也是为什么 <a href="https://lore.kernel.org/kvm/20211231142849.611-1-guang.zeng@intel.com/" target="_blank" rel="noopener">IPI virtualization support for VM</a>的cover letter中有这样的描述:<em>when issuing unicast, physical-addressing IPIs</em>. 像SIPI/NMI/INIT等IPI就不能使用IPIv。</p><h3 id="4-Implementation"><a href="#4-Implementation" class="headerlink" title="4. Implementation"></a>4. Implementation</h3><p>mailing patch: <a href="https://lore.kernel.org/kvm/20211231142849.611-1-guang.zeng@intel.com/" target="_blank" rel="noopener">IPI virtualization support for VM</a><br>等以后IPIv feature upstream了再更新吧，说白了，patch的功能就是让硬件happy。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍Intel的IPIv(IPI Virtualization)硬件技术。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Passthrough IPI</title>
    <link href="http://liujunming.github.io/2022/02/13/Introduction-to-Passthrough-IPI/"/>
    <id>http://liujunming.github.io/2022/02/13/Introduction-to-Passthrough-IPI/</id>
    <published>2022-02-13T06:32:42.000Z</published>
    <updated>2022-02-15T09:42:45.804Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍Passthrough IPI技术。<a id="more"></a></p><p>了解这项技术之前，需要读者对posted interrupt有深刻的理解。</p><h3 id="1-Idea"><a href="#1-Idea" class="headerlink" title="1. Idea"></a>1. Idea</h3><blockquote><p>Exposing the PI_DESC  and msr.icr to guest. When sending a IPI, set  the PIR of destination VCPU’s PI_DESC from guest directly and write the ICR with notification vector and destination PCPU which are got  from hypervisor.<br>This mechanism only handle the normal IPI. For SIPI/NMI/INIT, still  goes to legacy way but which write a new msr instead msr.icr.</p></blockquote><h3 id="2-Steps"><a href="#2-Steps" class="headerlink" title="2. Steps"></a>2. Steps</h3><p><img src="/images/2022/02/03.png" alt></p><p><img src="/images/2022/02/04.png" alt></p><h3 id="3-Pros-and-cons"><a href="#3-Pros-and-cons" class="headerlink" title="3. Pros and cons"></a>3. Pros and cons</h3><p>It can achieve huge performance improvement.</p><p>However it may increase the risk in the system since the guest could decide to send IPI to any processor. It’s OK in private cloud only.</p><h3 id="4-Implementation"><a href="#4-Implementation" class="headerlink" title="4. Implementation"></a>4. Implementation</h3><p>代码的解析可以参考<a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/09/10/kvm-performance-1" target="_blank" rel="noopener">kvm performance optimization technologies, part one</a>。</p><hr><p>参考资料:</p><ol><li><a href="https://lore.kernel.org/kvm/0C23CC2D-B770-43D0-8215-20CE591F2E8F@bytedance.com/" target="_blank" rel="noopener">KVM: X86: implement Passthrough IPI</a></li><li><a href="https://static.sched.com/hosted_files/kvmforum2020/1f/Minimizing%20VMExits%20in%20Private%20Cloud%20by%20%20Aggressive%20PV%20IPI%20%20and%20Passthrough%20Timer.pdf" target="_blank" rel="noopener">Minimizing VMExits in Private Cloud by Aggressive PV IPI and Passthrough Timer</a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/09/10/kvm-performance-1" target="_blank" rel="noopener">kvm performance optimization technologies, part one</a></li><li><a href="https://dl.acm.org/doi/abs/10.1145/3381052.3381317" target="_blank" rel="noopener">Directvisor: virtualization for bare-metal cloud</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍Passthrough IPI技术。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to PV IPI</title>
    <link href="http://liujunming.github.io/2022/02/12/Introduction-to-PV-IPI/"/>
    <id>http://liujunming.github.io/2022/02/12/Introduction-to-PV-IPI/</id>
    <published>2022-02-12T03:32:02.000Z</published>
    <updated>2022-02-15T09:42:45.803Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍PV IPI技术。<a id="more"></a>部分内容转载自:<a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/09/10/kvm-performance-1" target="_blank" rel="noopener">kvm performance optimization technologies, part one</a>。</p><h3 id="1-Idea"><a href="#1-Idea" class="headerlink" title="1. Idea"></a>1. Idea</h3><p><img src="/images/2022/02/02.png" alt></p><p>Instead of sending the IPI to vcpu one by one, the pv ipi send uses a bitmap to to record the IPI vcpu and then make a hypercall thus reduce the VM-exit. The patchset is <a href="https://lore.kernel.org/kvm/1532327996-17619-1-git-send-email-wanpengli@tencent.com/" target="_blank" rel="noopener">here</a>. </p><h3 id="2-Usage"><a href="#2-Usage" class="headerlink" title="2. Usage"></a>2. Usage</h3><p><a href="https://www.kernel.org/doc/Documentation/virtual/kvm/hypercalls.txt" target="_blank" rel="noopener">Doc</a>:</p><pre><code>6. KVM_HC_SEND_IPI------------------------Architecture: x86Status: activePurpose: Send IPIs to multiple vCPUs.a0: lower part of the bitmap of destination APIC IDsa1: higher part of the bitmap of destination APIC IDsa2: the lowest APIC ID in bitmapa3: APIC ICRThe hypercall lets a guest send multicast IPIs, with at most 128128 destinations per hypercall in 64-bit mode and 64 vCPUs perhypercall in 32-bit mode.  The destinations are represented by abitmap contained in the first two arguments (a0 and a1). Bit 0 ofa0 corresponds to the APIC ID in the third argument (a2), bit 1corresponds to the APIC ID a2+1, and so on.Returns the number of CPUs to which the IPIs were delivered successfully.</code></pre><p>The test code in KVM unit test:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_pv_ipi</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> a0 = <span class="number">0xFFFFFFFF</span>, a1 = <span class="number">0</span>, a2 = <span class="number">0xFFFFFFFF</span>, a3 = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">    asm volatile("vmcall" : "=a"(ret) :"a"(KVM_HC_SEND_IPI), "b"(a0), "c"(a1), "d"(a2), "S"(a3));</span><br><span class="line">    report(!ret, <span class="string">"PV IPIs testing"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>a3</code>就是<code>kvm_pv_send_ipi</code>函数中的<code>icr</code>参数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_pv_send_ipi</span><span class="params">(struct kvm *kvm, <span class="keyword">unsigned</span> <span class="keyword">long</span> ipi_bitmap_low,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ipi_bitmap_high, u32 min,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">long</span> icr, <span class="keyword">int</span> op_64_bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (icr &amp; (APIC_DEST_MASK | APIC_SHORT_MASK))</span><br><span class="line"><span class="keyword">return</span> -KVM_EINVAL;</span><br><span class="line"></span><br><span class="line">irq.<span class="built_in">vector</span> = icr &amp; APIC_VECTOR_MASK;</span><br><span class="line">irq.delivery_mode = icr &amp; APIC_MODE_MASK;</span><br><span class="line">irq.level = (icr &amp; APIC_INT_ASSERT) != <span class="number">0</span>;</span><br><span class="line">irq.trig_mode = icr &amp; APIC_INT_LEVELTRIG;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-Implementation"><a href="#3-Implementation" class="headerlink" title="3. Implementation"></a>3. Implementation</h3><p>源码基于Kernel v5.17.0-rc1。</p><h4 id="3-1-kvm-side"><a href="#3-1-kvm-side" class="headerlink" title="3.1 kvm side"></a>3.1 kvm side</h4><ul><li><p>Expose PV_SEND_IPI CPUID feature bit to guest<br><code>KVM_FEATURE_PV_SEND_IPI</code></p></li><li><p>Implement PV IPIs send hypercall<br><code>KVM_HC_SEND_IPI</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_pv_send_ipi</span><span class="params">(struct kvm *kvm, <span class="keyword">unsigned</span> <span class="keyword">long</span> ipi_bitmap_low,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ipi_bitmap_high, u32 min,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">long</span> icr, <span class="keyword">int</span> op_64_bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_apic_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_lapic_irq</span> <span class="title">irq</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cluster_size = op_64_bit ? <span class="number">64</span> : <span class="number">32</span>;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (icr &amp; (APIC_DEST_MASK | APIC_SHORT_MASK))</span><br><span class="line"><span class="keyword">return</span> -KVM_EINVAL;</span><br><span class="line"></span><br><span class="line">irq.<span class="built_in">vector</span> = icr &amp; APIC_VECTOR_MASK;</span><br><span class="line">irq.delivery_mode = icr &amp; APIC_MODE_MASK;</span><br><span class="line">irq.level = (icr &amp; APIC_INT_ASSERT) != <span class="number">0</span>;</span><br><span class="line">irq.trig_mode = icr &amp; APIC_INT_LEVELTRIG;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line"><span class="built_in">map</span> = rcu_dereference(kvm-&gt;arch.apic_map);</span><br><span class="line"></span><br><span class="line">count = -EOPNOTSUPP;</span><br><span class="line"><span class="keyword">if</span> (likely(<span class="built_in">map</span>)) &#123;</span><br><span class="line">count = __pv_send_ipi(&amp;ipi_bitmap_low, <span class="built_in">map</span>, &amp;irq, min);</span><br><span class="line">min += cluster_size;</span><br><span class="line">count += __pv_send_ipi(&amp;ipi_bitmap_high, <span class="built_in">map</span>, &amp;irq, min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __pv_send_ipi(<span class="keyword">unsigned</span> <span class="keyword">long</span> *ipi_bitmap, struct kvm_apic_map *<span class="built_in">map</span>,</span><br><span class="line"> struct kvm_lapic_irq *irq, u32 min)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i, count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (min &gt; <span class="built_in">map</span>-&gt;max_apic_id)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">for_each_set_bit(i, ipi_bitmap,</span><br><span class="line">min((u32)BITS_PER_LONG, (<span class="built_in">map</span>-&gt;max_apic_id - min + <span class="number">1</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;phys_map[min + i]) &#123;</span><br><span class="line">vcpu = <span class="built_in">map</span>-&gt;phys_map[min + i]-&gt;vcpu;</span><br><span class="line">count += kvm_apic_set_irq(vcpu, irq, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-guest-side"><a href="#3-2-guest-side" class="headerlink" title="3.2 guest side"></a>3.2 guest side</h4><ul><li><p>Set the IPI entry points</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_setup_pv_ipi</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">apic-&gt;send_IPI_mask = kvm_send_ipi_mask;</span><br><span class="line">apic-&gt;send_IPI_mask_allbutself = kvm_send_ipi_mask_allbutself;</span><br><span class="line">pr_info(<span class="string">"setup PV IPIs\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Guest trigger IPI</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __send_ipi_mask(<span class="keyword">const</span> struct cpumask *mask, <span class="keyword">int</span> <span class="built_in">vector</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">int</span> cpu, apic_id, icr;</span><br><span class="line"><span class="keyword">int</span> min = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"><span class="keyword">__uint128_t</span> ipi_bitmap = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">u64 ipi_bitmap = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">long</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpumask_empty(mask))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">vector</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">icr = APIC_DM_FIXED | <span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NMI_VECTOR:</span><br><span class="line">icr = APIC_DM_NMI;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each_cpu(cpu, mask) &#123;</span><br><span class="line">apic_id = per_cpu(x86_cpu_to_apicid, cpu);</span><br><span class="line"><span class="keyword">if</span> (!ipi_bitmap) &#123;</span><br><span class="line">min = max = apic_id;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (apic_id &lt; min &amp;&amp; max - apic_id &lt; KVM_IPI_CLUSTER_SIZE) &#123;</span><br><span class="line">ipi_bitmap &lt;&lt;= min - apic_id;</span><br><span class="line">min = apic_id;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (apic_id &lt; min + KVM_IPI_CLUSTER_SIZE) &#123;</span><br><span class="line">max = apic_id &lt; max ? max : apic_id;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret = kvm_hypercall4(KVM_HC_SEND_IPI, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ipi_bitmap,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(ipi_bitmap &gt;&gt; BITS_PER_LONG), min, icr);</span><br><span class="line">WARN_ONCE(ret &lt; <span class="number">0</span>, <span class="string">"kvm-guest: failed to send PV IPI: %ld"</span>,</span><br><span class="line">  ret);</span><br><span class="line">min = max = apic_id;</span><br><span class="line">ipi_bitmap = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">__set_bit(apic_id - min, (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;ipi_bitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ipi_bitmap) &#123;</span><br><span class="line">ret = kvm_hypercall4(KVM_HC_SEND_IPI, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ipi_bitmap,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(ipi_bitmap &gt;&gt; BITS_PER_LONG), min, icr);</span><br><span class="line">WARN_ONCE(ret &lt; <span class="number">0</span>, <span class="string">"kvm-guest: failed to send PV IPI: %ld"</span>,</span><br><span class="line">  ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>It will set the bitmap accross the IPI target vcpu and finally call the <code>kvm_hypercall4(KVM_HC_SEND_IPI)</code>.</p><hr><p>参考资料:</p><ol><li><a href="https://lore.kernel.org/kvm/1532327996-17619-1-git-send-email-wanpengli@tencent.com/" target="_blank" rel="noopener">KVM: X86: Implement Exit-less IPIs support</a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/09/10/kvm-performance-1" target="_blank" rel="noopener">kvm performance optimization technologies, part one</a></li><li><a href="https://static.sched.com/hosted_files/kvmforum2019/e3/Boosting%20Dedicated%20Instances%20by%20KVM%20Tax%20Cut.pdf" target="_blank" rel="noopener">Boosting Dedicated InstanceviaKVMTaxCut</a></li><li><a href="https://zhuanlan.zhihu.com/p/372958922" target="_blank" rel="noopener">IOMMU(六)-post interrupt</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍PV IPI技术。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to QEMU-KVM Live Migration</title>
    <link href="http://liujunming.github.io/2022/02/10/Introduction-to-QEMU-KVM-Live-Migration/"/>
    <id>http://liujunming.github.io/2022/02/10/Introduction-to-QEMU-KVM-Live-Migration/</id>
    <published>2022-02-10T07:28:03.000Z</published>
    <updated>2022-02-11T11:00:12.981Z</updated>
    
    <content type="html"><![CDATA[<p>Introduction to QEMU-KVM Live Migration.<a id="more"></a></p><p>本文只介绍<a href="https://en.wikipedia.org/wiki/Live_migration#Pre-copy_memory_migration" target="_blank" rel="noopener">Pre-copy memory migration</a>，大部分内容转载自:<a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/03/01/qemu-live-migration" target="_blank" rel="noopener">qemu热迁移简介</a>.</p><p>文中的代码解析基于QEMU 5.1.0。</p><h3 id="1-Usage"><a href="#1-Usage" class="headerlink" title="1. Usage"></a>1. Usage</h3><p><a href="/2021/12/04/The-usage-of-QEMU-KVM-live-migration/">The usage of QEMU&amp;&amp;KVM live migration</a></p><h3 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2. 基本原理"></a>2. 基本原理</h3><p>推荐读下<a href="https://github.com/liujunming/paper_reading_notes/issues/9" target="_blank" rel="noopener">NSDI‘05 Live Migration of Virtual Machines</a>。</p><p><img src="/images/2022/02/01.png" alt></p><p>首先看看热迁移过程中qemu的哪些部分会包含进来。上图中间的灰色部分是虚拟机的内存，它对于qemu来说是黑盒，qemu不会做任何假设，而只是一股脑儿的发送到dst(destination host)。左边的区域是表示设备的状态，这部分是虚拟机可见的，qemu使用自己的协议来发送这部分。右边的是不会迁移的部分，但是还是需要dst和src(source host)保持一致，一般来说，src和dst的虚拟机使用相同的qemu command line能够保证这部分一致。</p><p>需要满足很多条件才能进行热迁:</p><ol><li>使用共享存储，如NFS</li><li>host的时间要一致</li><li>网络配置要一致，不能说src能访问某个网络，dst不能</li><li>host CPU类型要一致，毕竟host导出指令集给guest</li><li>虚拟机的机器类型，QEMU版本，rom版本等</li></ol><p>热迁移主要包括三个步骤：</p><ol><li>将虚拟机所有RAM pages设置成dirty，主要函数:<code>ram_save_setup</code></li><li>持续迭代将虚拟机的dirty pages发送到dst，直到达到一定条件，比如dirty pages数量比较少, 主要函数:<code>ram_save_iterate</code></li><li>停止src上面的guest，把剩下的dirty pages发送到dst，之后发送设备状态，主要函数: <code>qemu_savevm_state_complete_precopy</code></li></ol><p>其中步骤1和步骤2是上图中的灰色区域，步骤3是灰色和左边的区域。</p><p>之后就可以在dst上面继续运行qemu程序了。</p><h3 id="3-Algorithm"><a href="#3-Algorithm" class="headerlink" title="3. Algorithm"></a>3. Algorithm</h3><ol><li>Setup</li></ol><ul><li>Start guest on destination, connect, enable dirty page logging and more</li></ul><ol start="2"><li>Transfer Memory</li></ol><ul><li>Guest continues to run</li><li>Bandwidth limitation (controlled by the user)</li><li>First transfer the whole memory</li><li>Iteratively transfer all dirty pages (pages that were written to by the guest).</li></ul><ol start="3"><li>Stop the guest</li></ol><ul><li>And sync VM image(s) (guest’s hard drives).</li></ul><ol start="4"><li>Transfer State</li></ol><ul><li>As fast as possible (no bandwidth limitation)</li><li>All VM devices’ state and dirty pages yet to be transferred</li></ul><ol start="5"><li>Continue the guest</li></ol><ul><li>On destination upon success<ul><li>Broadcast “I’m over here” Ethernet packet to announce new location of NIC(s).</li></ul></li><li>On source upon failure (with one exception).</li></ul><h3 id="4-发送端源码分析"><a href="#4-发送端源码分析" class="headerlink" title="4. 发送端源码分析"></a>4. 发送端源码分析</h3><p>在qemu的monitor输入migrate命令后，经过的一些函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hmp_migrate</span><br><span class="line">qmp_migrate</span><br><span class="line">tcp_start_outgoing_migration</span><br><span class="line">socket_start_outgoing_migration</span><br><span class="line">socket_outgoing_migration</span><br><span class="line">migration_channel_connect</span><br><span class="line">qemu_fopen_channel_output</span><br><span class="line">migrate_fd_connect</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">migrate_fd_connect</span><span class="params">(MigrationState *s, Error *error_in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    qemu_thread_create(&amp;s-&gt;thread, <span class="string">"live_migration"</span>, migration_thread, s,</span><br><span class="line">                       QEMU_THREAD_JOINABLE);</span><br><span class="line">    s-&gt;migration_thread_running = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>migrate_fd_connect</code>函数创建了一个迁移线程，线程函数为<code>migration_thread</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">migration_thread</span><br><span class="line">qemu_savevm_state_setup</span><br><span class="line">ram_save_setup[save_setup]</span><br><span class="line">ram_init_all</span><br><span class="line">ram_init_bitmaps</span><br><span class="line">ram_list_init_bitmaps</span><br><span class="line">bitmap_new</span><br><span class="line">bitmap_set</span><br><span class="line">migration_iteration_run</span><br><span class="line">qemu_savevm_state_pending</span><br><span class="line">ram_save_pending[save_live_pending]</span><br><span class="line">qemu_savevm_state_iterate</span><br><span class="line">ram_save_iterate[save_live_iterate]</span><br><span class="line">ram_find_and_save_block</span><br><span class="line">migration_completion</span><br><span class="line">vm_stop_force_state</span><br><span class="line">qemu_savevm_state_complete_precopy</span><br><span class="line">qemu_savevm_state_complete_precopy_iterable</span><br><span class="line">ram_save_complete[save_live_complete_precopy]</span><br><span class="line">ram_find_and_save_block</span><br></pre></td></tr></table></figure><p><code>migration_thread</code>主要就是用来完成之前提到的热迁移的三个步骤。<br>首先来看第一个步骤，<code>qemu_savevm_state_setup</code>标记所有RAM pages为dirty。</p><p>接着看第二个步骤，由while循环中的两个函数完成: <code>qemu_savevm_state_pending</code>和<code>qemu_savevm_state_iterate</code>。</p><p>第一个函数通过调用回调函数<code>ram_save_pending</code>确定还要传输的字节数，比较简单。 第二个函数通过调用回调函数<code>ram_save_iterate</code>用来把dirty  pages传到dst上面。</p><p><code>ram_find_and_save_block</code>–&gt;<code>find_dirty_block</code>–&gt;<code>ram_save_host_page</code>–&gt;<code>migration_bitmap_clear_dirty</code>–&gt;<code>ram_save_target_page</code>–&gt;<code>ram_save_page</code>–&gt;<code>save_normal_page</code>-&gt;<code>qemu_put_buffer_async</code> –&gt;…-&gt;<code>qemu_fflush</code> –&gt;…-&gt;<code>send</code></p><p>在while循环中反复调用<code>ram_save_pending</code>和<code>ram_save_iterate</code>不停向dst发送虚拟机脏页，直到达到一定的条件，然后进入第三个步骤。</p><p>第三个步骤就是调用<code>migration_completion</code>，在这一步中会停止src虚拟机，然后把最后剩的一点脏页拷贝到dst去。</p><h3 id="5-接收端源码分析"><a href="#5-接收端源码分析" class="headerlink" title="5. 接收端源码分析"></a>5. 接收端源码分析</h3><p>接收端的qemu运行参数跟发送端的一样，但是多了一个参数<code>-incoming tcp:0:6666</code>, qemu在解析到<code>-incoming</code>后，就会等待src迁移过来，我们来看看这个流程。</p><p><code>main</code> –&gt;<code>qemu_init</code> –&gt;<code>qemu_start_incoming_migration</code> –&gt;<code>tcp_start_incoming_migration</code> –&gt;<code>socket_start_incoming_migration</code> –&gt;<code>socket_accept_incoming_migration</code> –&gt;<code>migration_channel_process_incoming</code> -&gt;<code>migration_ioc_process_incoming</code> -&gt;<code>migration_incoming_process</code> -&gt;<code>process_incoming_migration_co</code> -&gt;<code>qemu_loadvm_state</code> -&gt;<code>qemu_loadvm_state_main</code></p><p><code>process_incoming_migration_co</code>函数用来完成数据接收，恢复虚拟机的运行。最重要的是<code>qemu_loadvm_state</code>，用于接收数据，在dst重构虚拟机。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qemu_loadvm_state</span><span class="params">(QEMUFile *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ret = qemu_loadvm_state_main(f, mis);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，<code>qemu_loadvm_state_main</code>是构建虚拟机的主要函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qemu_loadvm_state_main</span><span class="params">(QEMUFile *f, MigrationIncomingState *mis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> section_type;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        section_type = qemu_get_byte(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qemu_file_get_error(f)) &#123;</span><br><span class="line">            ret = qemu_file_get_error(f);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trace_qemu_loadvm_state_section(section_type);</span><br><span class="line">        <span class="keyword">switch</span> (section_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> QEMU_VM_SECTION_START:</span><br><span class="line">        <span class="keyword">case</span> QEMU_VM_SECTION_FULL:</span><br><span class="line">            ret = qemu_loadvm_section_start_full(f, mis);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QEMU_VM_SECTION_PART:</span><br><span class="line">        <span class="keyword">case</span> QEMU_VM_SECTION_END:</span><br><span class="line">            ret = qemu_loadvm_section_part_end(f, mis);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QEMU_VM_COMMAND:</span><br><span class="line">            ret = loadvm_process_command(f);</span><br><span class="line">            trace_qemu_loadvm_state_section_command(ret);</span><br><span class="line">            <span class="keyword">if</span> ((ret &lt; <span class="number">0</span>) || (ret == LOADVM_QUIT)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QEMU_VM_EOF:</span><br><span class="line">            <span class="comment">/* This is the end of migration */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            error_report(<span class="string">"Unknown savevm section type %d"</span>, section_type);</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        qemu_file_set_error(f, ret);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Cancel bitmaps incoming regardless of recovery */</span></span><br><span class="line">        dirty_bitmap_mig_cancel_incoming();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we are during an active postcopy, then we pause instead</span></span><br><span class="line"><span class="comment">         * of bail out to at least keep the VM's dirty data.  Note</span></span><br><span class="line"><span class="comment">         * that POSTCOPY_INCOMING_LISTENING stage is still not enough,</span></span><br><span class="line"><span class="comment">         * during which we're still receiving device states and we</span></span><br><span class="line"><span class="comment">         * still haven't yet started the VM on destination.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Only RAM postcopy supports recovery. Still, if RAM postcopy is</span></span><br><span class="line"><span class="comment">         * enabled, canceled bitmaps postcopy will not affect RAM postcopy</span></span><br><span class="line"><span class="comment">         * recovering.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (postcopy_state_get() == POSTCOPY_INCOMING_RUNNING &amp;&amp;</span><br><span class="line">            migrate_postcopy_ram() &amp;&amp; postcopy_pause_incoming(mis)) &#123;</span><br><span class="line">            <span class="comment">/* Reset f to point to the newly created channel */</span></span><br><span class="line">            f = mis-&gt;from_src_file;</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>qemu_loadvm_state_main</code>分别处理各个section, src会把<code>QEMU_VM_SECTION_START</code>等标志放到流中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu_loadvm_section_start_full</span><br><span class="line">find_se</span><br><span class="line">vmstate_load</span><br><span class="line">ram_load[load_state]</span><br><span class="line">ram_load_precopy</span><br><span class="line">qemu_get_buffer</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><code>ram_load</code>负责把接收到的数据拷贝到dst这端虚拟机的内存上。 </p><h3 id="6-MISC"><a href="#6-MISC" class="headerlink" title="6. MISC"></a>6. MISC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SaveVMHandlers</span> &#123;</span></span><br><span class="line">    <span class="comment">/* This runs inside the iothread lock.  */</span></span><br><span class="line">    SaveStateHandler *save_state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*save_cleanup)(<span class="keyword">void</span> *opaque);</span><br><span class="line">    <span class="keyword">int</span> (*save_live_complete_postcopy)(QEMUFile *f, <span class="keyword">void</span> *opaque);</span><br><span class="line">    <span class="keyword">int</span> (*save_live_complete_precopy)(QEMUFile *f, <span class="keyword">void</span> *opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This runs both outside and inside the iothread lock.  */</span></span><br><span class="line">    <span class="keyword">bool</span> (*is_active)(<span class="keyword">void</span> *opaque);</span><br><span class="line">    <span class="keyword">bool</span> (*has_postcopy)(<span class="keyword">void</span> *opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* is_active_iterate</span></span><br><span class="line"><span class="comment">     * If it is not NULL then qemu_savevm_state_iterate will skip iteration if</span></span><br><span class="line"><span class="comment">     * it returns false. For example, it is needed for only-postcopy-states,</span></span><br><span class="line"><span class="comment">     * which needs to be handled by qemu_savevm_state_setup and</span></span><br><span class="line"><span class="comment">     * qemu_savevm_state_pending, but do not need iterations until not in</span></span><br><span class="line"><span class="comment">     * postcopy stage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">bool</span> (*is_active_iterate)(<span class="keyword">void</span> *opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This runs outside the iothread lock in the migration case, and</span></span><br><span class="line"><span class="comment">     * within the lock in the savevm case.  The callback had better only</span></span><br><span class="line"><span class="comment">     * use data that is local to the migration thread or protected</span></span><br><span class="line"><span class="comment">     * by other locks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*save_live_iterate)(QEMUFile *f, <span class="keyword">void</span> *opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This runs outside the iothread lock!  */</span></span><br><span class="line">    <span class="keyword">int</span> (*save_setup)(QEMUFile *f, <span class="keyword">void</span> *opaque);</span><br><span class="line">    <span class="keyword">void</span> (*save_live_pending)(QEMUFile *f, <span class="keyword">void</span> *opaque,</span><br><span class="line">                              <span class="keyword">uint64_t</span> threshold_size,</span><br><span class="line">                              <span class="keyword">uint64_t</span> *res_precopy_only,</span><br><span class="line">                              <span class="keyword">uint64_t</span> *res_compatible,</span><br><span class="line">                              <span class="keyword">uint64_t</span> *res_postcopy_only);</span><br><span class="line">    <span class="comment">/* Note for save_live_pending:</span></span><br><span class="line"><span class="comment">     * - res_precopy_only is for data which must be migrated in precopy phase</span></span><br><span class="line"><span class="comment">     *     or in stopped state, in other words - before target vm start</span></span><br><span class="line"><span class="comment">     * - res_compatible is for data which may be migrated in any phase</span></span><br><span class="line"><span class="comment">     * - res_postcopy_only is for data which must be migrated in postcopy phase</span></span><br><span class="line"><span class="comment">     *     or in stopped state, in other words - after source vm stop</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sum of res_postcopy_only, res_compatible and res_postcopy_only is the</span></span><br><span class="line"><span class="comment">     * whole amount of pending data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LoadStateHandler *load_state;</span><br><span class="line">    <span class="keyword">int</span> (*load_setup)(QEMUFile *f, <span class="keyword">void</span> *opaque);</span><br><span class="line">    <span class="keyword">int</span> (*load_cleanup)(<span class="keyword">void</span> *opaque);</span><br><span class="line">    <span class="comment">/* Called when postcopy migration wants to resume from failure */</span></span><br><span class="line">    <span class="keyword">int</span> (*resume_prepare)(MigrationState *s, <span class="keyword">void</span> *opaque);</span><br><span class="line">&#125; SaveVMHandlers;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> SaveVMHandlers savevm_ram_handlers = &#123;</span><br><span class="line">    .save_setup = ram_save_setup,</span><br><span class="line">    .save_live_iterate = ram_save_iterate,</span><br><span class="line">    .save_live_complete_postcopy = ram_save_complete,</span><br><span class="line">    .save_live_complete_precopy = ram_save_complete,</span><br><span class="line">    .has_postcopy = ram_has_postcopy,</span><br><span class="line">    .save_live_pending = ram_save_pending,</span><br><span class="line">    .load_state = ram_load,</span><br><span class="line">    .save_cleanup = ram_save_cleanup,</span><br><span class="line">    .load_setup = ram_load_setup,</span><br><span class="line">    .load_cleanup = ram_load_cleanup,</span><br><span class="line">    .resume_prepare = ram_resume_prepare,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以这些callback函数为接口来研究Live Migration，也是学习源码的一个极佳途径，能掌握全局。</p><hr><p>参考资料:</p><ol><li><a href="https://www.linux-kvm.org/page/Migration" target="_blank" rel="noopener">Migration | KVM Docs</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Introduction to QEMU-KVM Live Migration.
    
    </summary>
    
      <category term="live migration" scheme="http://liujunming.github.io/categories/live-migration/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="live migration" scheme="http://liujunming.github.io/tags/live-migration/"/>
    
  </entry>
  
  <entry>
    <title>GDB Conditional Breakpoints</title>
    <link href="http://liujunming.github.io/2022/02/08/GDB-Conditional-Breakpoints/"/>
    <id>http://liujunming.github.io/2022/02/08/GDB-Conditional-Breakpoints/</id>
    <published>2022-02-08T06:01:15.000Z</published>
    <updated>2022-02-08T10:00:14.938Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自<a href="https://www.fayewilliams.com/2011/07/13/gdb-conditional-breakpoints/" target="_blank" rel="noopener">GDB Conditional Breakpoints</a>。<a id="more"></a></p><p>What if you have a large loop running and you only want to look at what’s happening as it nears the end? Do you really have to step through 99 iterations in a 100 item loop?</p><p>Of course you don’t. Step forward the conditional breakpoint.</p><h3 id="Set-a-conditional-breakpoint-using-a-condition"><a href="#Set-a-conditional-breakpoint-using-a-condition" class="headerlink" title="Set a conditional breakpoint using a condition"></a>Set a conditional breakpoint using a condition</h3><p>In GDB you can specify a condition in the programming language you are debugging and apply it to any breakpoint. Let’s stop a loop at the 99th iteration (I’m debugging C/C++, so my conditions are written in C/C++):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b Message.cpp:112 if i == 99</span><br></pre></td></tr></table></figure><p>That’s all there is to it.</p><p>To ensure gdb stops execution, use <em>the first line of code inside the loop</em> as the stopping point, not the loop itself.</p><p>You can also specify a condition on an existing breakpoint by using the breakpoint number as a reference:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) cond 3 i == 99</span><br></pre></td></tr></table></figure><p>And remove a condition from a breakpoint using:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) cond 3</span><br><span class="line">Breakpoint 3 now unconditional.</span><br></pre></td></tr></table></figure><h3 id="That’s-great-What-else-can-you-do"><a href="#That’s-great-What-else-can-you-do" class="headerlink" title="That’s great! What else can you do?"></a>That’s great! What else can you do?</h3><p>Pretty much anything you like! Just write the condition exactly as if you were testing for it in your code, e.g.:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) cond 1 strcmp(message,&quot;earthquake&quot;) == 0</span><br><span class="line">//stop if the array message is equal to &apos;earthquake&apos;</span><br><span class="line"></span><br><span class="line">(gdb) cond 2 *p == &apos;r&apos;</span><br><span class="line">//stop if the char* pointer p points to the letter &apos;r&apos;</span><br><span class="line"></span><br><span class="line">(gdb) cond 3 num &lt; 0.75</span><br><span class="line">//stop while the float num is less than 0.75</span><br></pre></td></tr></table></figure><p>Conditional breakpoints covered and your efficiency increased, all in less than 5 minutes!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自&lt;a href=&quot;https://www.fayewilliams.com/2011/07/13/gdb-conditional-breakpoints/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GDB Conditional Breakpoints&lt;/a&gt;。
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Interrupt and Interrupt Virtualization</title>
    <link href="http://liujunming.github.io/2022/02/06/Interrupt-and-Interrupt-Virtualization/"/>
    <id>http://liujunming.github.io/2022/02/06/Interrupt-and-Interrupt-Virtualization/</id>
    <published>2022-02-06T11:08:31.000Z</published>
    <updated>2022-02-06T11:28:46.357Z</updated>
    
    <content type="html"><![CDATA[<p>个人在学习中断及其虚拟化过程中的笔记。<a id="more"></a></p><p><a href="/pdf/Interrupt_and_interrupt_virtualization.pdf">Interrupt and Interrupt Virtualization</a>。若有疑问，可邮箱联系作者：<a href="mailto:ljm0910@mail.ustc.edu.cn" target="_blank" rel="noopener">ljm0910@mail.ustc.edu.cn</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人在学习中断及其虚拟化过程中的笔记。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel uapi header file</title>
    <link href="http://liujunming.github.io/2022/02/05/Linux-kernel-uapi-header-file/"/>
    <id>http://liujunming.github.io/2022/02/05/Linux-kernel-uapi-header-file/</id>
    <published>2022-02-05T02:04:08.000Z</published>
    <updated>2022-02-05T07:13:39.423Z</updated>
    
    <content type="html"><![CDATA[<p>What’s in include/uapi of kernel source project?<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>The <code>uapi</code> folder is supposed to contain the user space API of the kernel. Then upon kernel installation, the <code>uapi</code> include files become the top level <code>/usr/include/linux/</code> files. </p><p>The other headers in theory are then private to the kernel. This allow clean separation of the user-visible and kernel-only structures which previously were intermingled in a single header file.</p><blockquote><p>the “uapi” include file cleanups. The idea is that the stuff exported to user space should now be found under include/uapi and arch/$(ARCH)/include/uapi.</p></blockquote><h3 id="2-Where"><a href="#2-Where" class="headerlink" title="2. Where"></a>2. Where</h3><p><a href="https://elixir.bootlin.com/linux/v5.17-rc1/source/include/uapi" target="_blank" rel="noopener">include/uapi</a> corresponding to <code>/user/include/linux/</code> files.</p><p><a href="https://elixir.bootlin.com/linux/v5.17-rc1/source/arch/x86/include/uapi/asm" target="_blank" rel="noopener">arch/x86/include/uapi/asm</a> corresponding to <code>/usr/include/x86_64-linux-gnu/asm</code> files.</p><h3 id="3-What"><a href="#3-What" class="headerlink" title="3. What"></a>3. What</h3><p>Split out the user-space API content of the kernel header files in the <code>include</code> and <code>arch/xxxxxx/include</code> directories, placing that content into corresponding headers created in new uapi/ subdirectories that reside under each of the original directories. </p><h3 id="4-Benefit"><a href="#4-Benefit" class="headerlink" title="4. Benefit"></a>4. Benefit</h3><ul><li>simplifies and reduces the size of the kernel-only headers</li><li>simplifies the complex interdependencies between headers that are [currently] partly exported to userspace</li><li>There is one other benefit of the UAPI split that may be of particular interest to the wider Linux ecosystem. By placing all of the user-space API-related definitions into files dedicated solely to that task, it becomes easier to track changes to the APIs that the kernel presents to user space. In the first instance, these changes can be discovered by scanning the git logs for changes in files under the <code>uapi/</code> subdirectories. Easing the task of tracking user-space APIs would help many other parts of the ecosystem, for example, C library maintainers, scripting language projects that maintain language bindings for the user-space API, testing projects such as <a href="http://ltp.sourceforge.net/" target="_blank" rel="noopener">LTP</a>, documentation projects such as <a href="http://www.kernel.org/doc/man-pages/" target="_blank" rel="noopener">man-pages</a>, and perhaps even LWN editors preparing summaries of changes in the merge window that occurs at the start of each kernel release cycle.</li></ul><h3 id="5-How"><a href="#5-How" class="headerlink" title="5. How"></a>5. How</h3><p>The task of disintegrating each of the header files into two pieces is in principle straightforward. In the general case, each header file has the following form:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Header comments (copyright, etc.) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _XXXXXX_H     <span class="comment">/* Guard macro preventing double inclusion */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _XXXXXX_H</span></span><br><span class="line"></span><br><span class="line">[User-space definitions]</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __KERNEL__</span></span><br><span class="line"></span><br><span class="line">[Kernel-space definitions]</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __KERNEL__ */</span></span></span><br><span class="line"></span><br><span class="line">[User-space definitions]</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* End prevent double inclusion */</span></span></span><br></pre></td></tr></table></figure><p>Each of the above parts may or may not be present in individual header files, and there may be multiple blocks governed by <code>#ifdef __KERNEL__</code> preprocessor directives.</p><p>The part of this file that is of most interest is the code that falls inside the outermost <code>#ifndef</code> block that prevents double inclusion of the header file. <em>[User-space definitions]</em> should move to the corresponding <code>uapi/</code> header file. The content inside the <code>#ifdef __KERNEL__</code> block remains in the original header file, but the <code>#ifdef __KERNEL__</code> and its accompanying <code>#endif</code> are removed.</p><p>A copy of the header comments remains in the original header file, and is duplicated in the new <code>uapi/</code> header file. In addition, a <code>#include</code> directive needs to be added to the original header file so that it includes the new <code>uapi/</code> header file, and of course a suitable <code>git commit</code> message needs to be supplied for the change.</p><p>The goal is to modify the original header file to look like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Header comments (copyright, etc.) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _XXXXXX_H     <span class="comment">/* Guard macro preventing double inclusion */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _XXXXXX_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;include/uapi/path/to/header.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">[Kernel-space definitions]</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* End prevent double inclusion */</span></span></span><br></pre></td></tr></table></figure><p>The corresponding <code>uapi/</code> header file will look like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Header comments (copyright, etc.) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _UAPI__XXXXXX_H     <span class="comment">/* Guard macro preventing double inclusion */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _UAPI__XXXXXX_H</span></span><br><span class="line"></span><br><span class="line">[User-space definitions]</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* End prevent double inclusion */</span></span></span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://lwn.net/Articles/507794/" target="_blank" rel="noopener">The UAPI header file split</a></li><li><a href="https://lwn.net/Articles/507832/" target="_blank" rel="noopener">UAPI header file split</a></li><li><a href="https://stackoverflow.com/questions/18858190/whats-in-include-uapi-of-kernel-source-project" target="_blank" rel="noopener">What’s in include/uapi of kernel source project</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;What’s in include/uapi of kernel source project?
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>FPU virtualization in KVM</title>
    <link href="http://liujunming.github.io/2022/01/24/FPU-virtualization-in-KVM/"/>
    <id>http://liujunming.github.io/2022/01/24/FPU-virtualization-in-KVM/</id>
    <published>2022-01-24T06:06:08.000Z</published>
    <updated>2022-01-26T11:37:44.753Z</updated>
    
    <content type="html"><![CDATA[<p>本文将以<a href="https://elixir.bootlin.com/linux/v5.16-rc1/source" target="_blank" rel="noopener">v5.16-rc1</a>源码为例，介绍下KVM中FPU virtualization的实现。<a id="more"></a></p><h3 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h3><ul><li><a href="/2021/11/12/Notes-about-XSAVE-feature-set/">Notes about XSAVE feature set</a></li><li><a href="/2022/01/08/Notes-about-FPU-implementation-in-Linux-kernel/">Notes about FPU implementation in Linux kernel</a></li></ul><h3 id="2-xsave-state"><a href="#2-xsave-state" class="headerlink" title="2. xsave state"></a>2. xsave state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmx_vcpu_run</span><br><span class="line">kvm_load_guest_xsave_state</span><br><span class="line">vmx_vcpu_enter_exit(vcpu, vmx); <span class="comment">/* The actual VMENTER/EXIT is in the .noinstr.text section. */</span></span><br><span class="line">kvm_load_host_xsave_state</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvm_load_guest_xsave_state</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vcpu-&gt;arch.xcr0 != host_xcr0)</span><br><span class="line">xsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu-&gt;arch.xcr0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vcpu-&gt;arch.xsaves_enabled &amp;&amp;</span><br><span class="line">    vcpu-&gt;arch.ia32_xss != host_xss)</span><br><span class="line">wrmsrl(MSR_IA32_XSS, vcpu-&gt;arch.ia32_xss);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvm_load_host_xsave_state</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vcpu-&gt;arch.xcr0 != host_xcr0)</span><br><span class="line">xsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vcpu-&gt;arch.xsaves_enabled &amp;&amp;</span><br><span class="line">    vcpu-&gt;arch.ia32_xss != host_xss)</span><br><span class="line">wrmsrl(MSR_IA32_XSS, host_xss);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-kvm-load-guest-fpu-and-kvm-put-guest-fpu"><a href="#3-kvm-load-guest-fpu-and-kvm-put-guest-fpu" class="headerlink" title="3. kvm_load_guest_fpu and kvm_put_guest_fpu"></a>3. kvm_load_guest_fpu and kvm_put_guest_fpu</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu_arch</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * QEMU userspace and the guest each have their own FPU state.</span></span><br><span class="line"><span class="comment"> * In vcpu_run, we switch between the user and guest FPU contexts.</span></span><br><span class="line"><span class="comment"> * While running a VCPU, the VCPU thread will have the guest FPU</span></span><br><span class="line"><span class="comment"> * context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that while the PKRU state lives inside the fpu registers,</span></span><br><span class="line"><span class="comment"> * it is switched out separately at VMENTER and VMEXIT time. The</span></span><br><span class="line"><span class="comment"> * "guest_fpstate" state here contains the guest FPU context, with the</span></span><br><span class="line"><span class="comment"> * host PRKU bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpu_guest</span> <span class="title">guest_fpu</span>;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Swap (qemu) user FPU context for the guest FPU context. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_load_guest_fpu</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Exclude PKRU from restore as restored separately in</span></span><br><span class="line"><span class="comment"> * kvm_x86_ops.run().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fpu_swap_kvm_fpstate(&amp;vcpu-&gt;arch.guest_fpu, <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When vcpu_run ends, restore user space FPU context. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_put_guest_fpu</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fpu_swap_kvm_fpstate(&amp;vcpu-&gt;arch.guest_fpu, <span class="literal">false</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @fpstate:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pointer to the active struct fpstate. Initialized to</span></span><br><span class="line"><span class="comment"> * point at @__fpstate below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpstate</span>*<span class="title">fpstate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @__task_fpstate:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pointer to an inactive struct fpstate. Initialized to NULL. Is</span></span><br><span class="line"><span class="comment"> * used only for KVM support to swap out the regular task fpstate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpstate</span>*__<span class="title">task_fpstate</span>;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpu_swap_kvm_fpstate</span><span class="params">(struct fpu_guest *guest_fpu, <span class="keyword">bool</span> enter_guest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpstate</span> *<span class="title">guest_fps</span> = <span class="title">guest_fpu</span>-&gt;<span class="title">fpstate</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">fpu</span> = &amp;<span class="title">current</span>-&gt;<span class="title">thread</span>.<span class="title">fpu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpstate</span> *<span class="title">cur_fps</span> = <span class="title">fpu</span>-&gt;<span class="title">fpstate</span>;</span></span><br><span class="line"></span><br><span class="line">fpregs_lock();</span><br><span class="line"><span class="keyword">if</span> (!cur_fps-&gt;is_confidential &amp;&amp; !test_thread_flag(TIF_NEED_FPU_LOAD))</span><br><span class="line">save_fpregs_to_fpstate(fpu);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Swap fpstate */</span></span><br><span class="line"><span class="keyword">if</span> (enter_guest) &#123;</span><br><span class="line">fpu-&gt;__task_fpstate = cur_fps;</span><br><span class="line">fpu-&gt;fpstate = guest_fps;</span><br><span class="line">guest_fps-&gt;in_use = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">guest_fps-&gt;in_use = <span class="literal">false</span>;</span><br><span class="line">fpu-&gt;fpstate = fpu-&gt;__task_fpstate;</span><br><span class="line">fpu-&gt;__task_fpstate = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur_fps = fpu-&gt;fpstate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cur_fps-&gt;is_confidential) &#123;</span><br><span class="line"><span class="comment">/* Includes XFD update */</span></span><br><span class="line">restore_fpregs_from_fpstate(cur_fps, XFEATURE_MASK_FPSTATE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * XSTATE is restored by firmware from encrypted</span></span><br><span class="line"><span class="comment"> * memory. Make sure XFD state is correct while</span></span><br><span class="line"><span class="comment"> * running with guest fpstate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">xfd_update_state(cur_fps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fpregs_mark_activate();</span><br><span class="line">fpregs_unlock();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-KVM-GET-XSAVE-and-KVM-SET-XSAVE-ioctl"><a href="#4-KVM-GET-XSAVE-and-KVM-SET-XSAVE-ioctl" class="headerlink" title="4. KVM_GET_XSAVE and KVM_SET_XSAVE ioctl"></a>4. KVM_GET_XSAVE and KVM_SET_XSAVE ioctl</h3><p><a href="https://lore.kernel.org/lkml/20211017152048.666354328@linutronix.de/" target="_blank" rel="noopener">x86/kvm: Convert FPU handling to a single swap buffer</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kvm_arch_vcpu_ioctl</span><br><span class="line">kvm_vcpu_ioctl_x86_get_xsave[KVM_GET_XSAVE]</span><br><span class="line">fpu_copy_guest_fpstate_to_uabi</span><br><span class="line">__copy_xstate_to_uabi_buf</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __copy_xstate_to_uabi_buf - Copy kernel saved xstate to a UABI buffer</span></span><br><span class="line"><span class="comment"> * @to:membuf descriptor</span></span><br><span class="line"><span class="comment"> * @fpstate:The fpstate buffer from which to copy</span></span><br><span class="line"><span class="comment"> * @pkru_val:The PKRU value to store in the PKRU component</span></span><br><span class="line"><span class="comment"> * @copy_mode:The requested copy mode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Converts from kernel XSAVE or XSAVES compacted format to UABI conforming</span></span><br><span class="line"><span class="comment"> * format, i.e. from the kernel internal hardware dependent storage format</span></span><br><span class="line"><span class="comment"> * to the requested @mode. UABI XSTATE is always uncompacted!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It supports partial copy but @to.pos always starts from zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __copy_xstate_to_uabi_buf(struct membuf to, struct fpstate *fpstate,</span><br><span class="line">       u32 pkru_val, <span class="keyword">enum</span> xstate_copy_mode copy_mode)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://elixir.bootlin.com/linux/v5.16-rc1/source/arch/x86/kernel/fpu/xstate.c#L1132" target="_blank" rel="noopener">__copy_xstate_to_uabi_buf</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kvm_arch_vcpu_ioctl</span><br><span class="line">kvm_vcpu_ioctl_x86_set_xsave[KVM_SET_XSAVE]</span><br><span class="line">fpu_copy_uabi_to_guest_fpstate</span><br><span class="line">copy_uabi_from_kernel_to_xstate</span><br><span class="line">copy_uabi_to_xstate</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将以&lt;a href=&quot;https://elixir.bootlin.com/linux/v5.16-rc1/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v5.16-rc1&lt;/a&gt;源码为例，介绍下KVM中FPU virtualization的实现。
    
    </summary>
    
      <category term="KVM" scheme="http://liujunming.github.io/categories/KVM/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>Notes about bus lock detection</title>
    <link href="http://liujunming.github.io/2022/01/18/Notes-about-bus-lock-detection/"/>
    <id>http://liujunming.github.io/2022/01/18/Notes-about-bus-lock-detection/</id>
    <published>2022-01-18T11:33:31.000Z</published>
    <updated>2022-01-20T13:08:32.097Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about bus lock detection.<a id="more"></a></p><ul><li>fault vs trap</li></ul><p>#AC for <a href="/2022/01/13/split-lock-and-its-virtualization/">Split-locked Access</a> is fault, #DB for bus lock detection is trap.</p><p><img src="/images/2022/01/26.png" alt></p><p>A bus lock is acquired through either <strong>split locked access to writeback (WB) memory</strong> or <strong>any locked access to non-WB memory</strong>. This is typically &gt;1000 cycles slower than an atomic operation within a cache line. It also disrupts performance on other cores.</p><p>Although split lock can be detected by #AC fault, the fault is triggered before the instruction acquires bus lock. This makes it difficult to mitigate bus lock (e.g. throttle(限制) the user application).</p><p>How to explain <u>it difficult to mitigate bus lock(e.g. throttle the user application)</u>?<br><code>split_lock_detect</code> default value is warn, that is the split lock state will be changed for one instruction. But this requires changing the split lock state using the test MSR for the complete core, impacting other threads.  <strong>Keypoint:</strong> #AC fault: The return address for the fault handler points to the faulting instruction, rather than to the instruction following the faulting instruction. <strong>Think:</strong> What does #AC handler do when <code>split_lock_detect</code> value is warn?<br><img src="/images/2022/01/27.png" alt><br><code>ratelimit</code>可以理解为throttle the user application!</p><p>Some CPUs have ability to notify the kernel by an #DB trap after a user instruction acquires a bus lock and is executed. This allows the kernel to enforce user application throttling or mitigations.</p><p>#DB for bus lock detect fixes issues in #AC for split lock detect:</p><ol><li>It’s architectural … just need to look at one CPUID bit to know it exists</li><li>The IA32_DEBUGCTL MSR, which reports bus lock in #DB, is per-thread. So each process or guest can have different behavior.</li><li>It has support for VMM/guests (new VMEXIT codes, etc).</li><li>It detects not only split locks but also bus locks from non-WB.</li></ol><p>Hardware only generates #DB for bus lock detect when CPL&gt;0 to avoid nested #DB from multiple bus locks while the first #DB is being handled.</p><p>Use the existing kernel command line parameter “split_lock_detect=” to handle #DB for bus lock with an additional option “ratelimit=N” to set bus lock rate limit for a user.</p><hr><p>参考资料:</p><ol><li><a href="https://software.intel.com/content/www/us/en/develop/download/intel-architecture-instruction-set-extensions-programming-reference.html" target="_blank" rel="noopener">Intel Instruction Set Extension</a> Chapter 9</li><li><a href="https://lore.kernel.org/lkml/20210322135325.682257-1-fenghua.yu@intel.com/" target="_blank" rel="noopener">x86/bus_lock: Enable bus lock detection</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about bus lock detection.
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Notes about IRQ Affinity</title>
    <link href="http://liujunming.github.io/2022/01/16/Notes-about-IRQ-Affinity/"/>
    <id>http://liujunming.github.io/2022/01/16/Notes-about-IRQ-Affinity/</id>
    <published>2022-01-15T17:28:51.000Z</published>
    <updated>2022-01-16T11:25:09.226Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about IRQ Affinity.<a id="more"></a></p><h3 id="1-irqaffinity"><a href="#1-irqaffinity" class="headerlink" title="1. irqaffinity"></a>1. irqaffinity</h3><p>If <code>irqaffinity</code> is appended as described in <a href="https://github.com/intel-innersource/virtualization.hypervisors.client.idv.docs#kernel-parameters" target="_blank" rel="noopener">Kernel Parameters</a>, It’s used to set the default irq affinity mask.<br>The set value can be checked by:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/irq/default_smp_affinity</span><br></pre></td></tr></table></figure><h3 id="2-IRQ-Affinity"><a href="#2-IRQ-Affinity" class="headerlink" title="2. IRQ Affinity"></a>2. IRQ Affinity</h3><p>Binding IRQs to a group of CPUs is now a generic and independent kernel feature. Every IRQ source in Linux has an entry in <code>/proc/irq</code> directory. For example, the settings for IRQ 40 is stored in <code>/proc/irq/40</code>. IRQ affinity, or IRQ bindings, is configured though the <code>smp_affinity</code> setting in that directory. For example, the <code>smp_affinity</code> for IRQ 40 is in <code>/proc/irq/40/smp_affinity</code>. The value of the <code>smp_affinity</code> setting is a bitmask of all CPUs that are permitted as a resource for the given IRQ. The default value for <code>smp_affinity</code>is  <code>0xffffffff</code>. This means the processes for the IRQ are sent to all CPUs. You are not allowed to turn off all CPUs for an IRQ. If the IRQ controller does not support IRQ affinity, the value can not be changed from the default. If multiple CPUs are defined, then the IRQ source uses the least busy CPU. This is called <em>lowest priority APIC routing</em>. IRQ affinity is achieved by binding an IRQ to a specific CPU or group of CPUs by echoing a HEX value to <code>smp_affinity</code> for the IRQ.</p><h3 id="3-Example"><a href="#3-Example" class="headerlink" title="3. Example"></a>3. Example</h3><p>Here is an example of restricting IRQ44 (eth1) to CPU0-3 then restricting it to CPU4-7 (this is an 8-CPU SMP box):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@moon 44]# cd /proc/irq/44</span><br><span class="line">[root@moon 44]# cat smp_affinity</span><br><span class="line">ffffffff</span><br><span class="line"></span><br><span class="line">[root@moon 44]# echo 0f &gt; smp_affinity</span><br><span class="line">[root@moon 44]# cat smp_affinity</span><br><span class="line">0000000f</span><br><span class="line">[root@moon 44]# ping -f h</span><br><span class="line">PING hell (195.4.7.3): 56 data bytes</span><br><span class="line">...</span><br><span class="line">--- hell ping statistics ---</span><br><span class="line">6029 packets transmitted, 6027 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 0.1/0.1/0.4 ms</span><br><span class="line">[root@moon 44]# cat /proc/interrupts | grep &apos;CPU\|44:&apos;</span><br><span class="line">        CPU0       CPU1       CPU2       CPU3      CPU4       CPU5        CPU6       CPU7</span><br><span class="line">44:       1068       1785       1785       1783         0          0           0         0    IO-APIC-level  eth1</span><br></pre></td></tr></table></figure><p>As can be seen from the line above IRQ44 was delivered only to the first four processors (0-3). Now lets restrict that IRQ to CPU(4-7).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@moon 44]# echo f0 &gt; smp_affinity</span><br><span class="line">[root@moon 44]# cat smp_affinity</span><br><span class="line">000000f0</span><br><span class="line">[root@moon 44]# ping -f h</span><br><span class="line">PING hell (195.4.7.3): 56 data bytes</span><br><span class="line">..</span><br><span class="line">--- hell ping statistics ---</span><br><span class="line">2779 packets transmitted, 2777 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 0.1/0.5/585.4 ms</span><br><span class="line">[root@moon 44]# cat /proc/interrupts |  &apos;CPU\|44:&apos;</span><br><span class="line">        CPU0       CPU1       CPU2       CPU3      CPU4       CPU5        CPU6       CPU7</span><br><span class="line">44:       1068       1785       1785       1783      1784       1069        1070       1069   IO-APIC-level  eth1</span><br></pre></td></tr></table></figure><p>This time around IRQ44 was delivered only to the last four processors. i.e counters for the CPU0-3 did not change.</p><hr><p>参考资料:</p><ol><li><a href="https://www.kernel.org/doc/html/latest/core-api/irq/irq-affinity.html" target="_blank" rel="noopener">SMP IRQ affinity</a></li><li><a href="https://blog.csdn.net/shenhuxi_yu/article/details/77991535" target="_blank" rel="noopener">linux irq/affinity理解</a></li><li><a href="https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt" target="_blank" rel="noopener">kernel-parameters.txt</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about IRQ Affinity.
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Notes about force_emulation_prefix in KVM</title>
    <link href="http://liujunming.github.io/2022/01/14/Notes-about-force-emulation-prefix-in-KVM/"/>
    <id>http://liujunming.github.io/2022/01/14/Notes-about-force-emulation-prefix-in-KVM/</id>
    <published>2022-01-14T05:19:04.000Z</published>
    <updated>2022-01-14T15:34:20.420Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about force_emulation_prefix in KVM.<a id="more"></a></p><h3 id="1-Materials"><a href="#1-Materials" class="headerlink" title="1. Materials"></a>1. Materials</h3><p>commit id: 6c86eedc206dd1f9d37a2796faa8e6f2278215d2<br><a href="https://lore.kernel.org/kvm/1522798129-14588-1-git-send-email-wanpengli@tencent.com/" target="_blank" rel="noopener">https://lore.kernel.org/kvm/1522798129-14588-1-git-send-email-wanpengli@tencent.com/</a></p><h3 id="2-Motivation"><a href="#2-Motivation" class="headerlink" title="2. Motivation"></a>2. Motivation</h3><p>There is no easy way to force KVM to run an instruction through the emulator(by design as that will expose the x86 emulator as a significant attack-surface).</p><p>However, we do wish to expose the x86 emulator in case we are testing it(e.g. via kvm-unit-tests). Therefore, this patch adds a “force emulation prefix” that is designed to raise #UD which KVM will trap and it’s #UD exit-handler will match “force emulation prefix” to run instruction after prefix by the x86 emulator.</p><p>To not expose the x86 emulator by default, we add a module parameter that should be off by default.</p><p>The  x86 emulator is the function: <a href="https://elixir.bootlin.com/linux/v5.15-rc5/source/arch/x86/kvm/x86.c#L7988" target="_blank" rel="noopener">kvm_emulate_instruction</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kvm_emulate_instruction</span><br><span class="line">x86_emulate_instruction</span><br></pre></td></tr></table></figure><h3 id="3-Example"><a href="#3-Example" class="headerlink" title="3. Example"></a>3. Example</h3><ul><li>use <code>kvm.force_emulation_prefix=1</code> to enable</li></ul><p><a href="https://gitlab.com/kvm-unit-tests/kvm-unit-tests/-/blob/master/x86/emulator.c" target="_blank" rel="noopener">emulator.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Forced emulation prefix, used to invoke the emulator unconditionally.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEP <span class="meta-string">"ud2; .byte 'k', 'v', 'm';"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEP_LENGTH 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fep_available = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">handle_exception(UD_VECTOR, record_no_fep);</span><br><span class="line"><span class="keyword">asm</span>(KVM_FEP <span class="string">"nop"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">record_no_fep</span><span class="params">(struct ex_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fep_available = <span class="number">0</span>;</span><br><span class="line">regs-&gt;rip += KVM_FEP_LENGTH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在guest中不会因为执行<code>asm(&quot;nop&quot;)</code>而发生VM Exit.</li><li>如果<code>kvm.force_emulation_prefix=1</code> ,那么在kvm unit test中，执行<code>asm(KVM_FEP &quot;nop&quot;)</code>的结果就是执行<code>asm(&quot;nop&quot;)</code>的结果，在guest中不会产生#UD.</li><li>如果<code>kvm.force_emulation_prefix=0</code> ,那么在kvm unit test中，执行<code>asm(KVM_FEP &quot;nop&quot;)</code>的结果就是在guest中产生#UD，那么#UD handler会被调用，全局变量<code>fep_available</code>就会被设置为0.</li></ul><p>Test cases:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://gitlab.com/kvm-unit-tests/kvm-unit-tests/-/blob/master/x86/emulator.c#L1185-1190</span></span><br><span class="line"><span class="keyword">if</span> (fep_available) &#123;</span><br><span class="line">...</span><br><span class="line">test_nop(mem);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>目的是测试<a href="https://elixir.bootlin.com/linux/v5.15-rc5/source/arch/x86/kvm/x86.c#L7988" target="_blank" rel="noopener">kvm_emulate_instruction</a>是否正确模拟了<code>nop</code>指令。</p><p>在guest中不会因为执行<code>asm(&quot;nop&quot;)</code>而发生VM Exit，就无法测试<a href="https://elixir.bootlin.com/linux/v5.15-rc5/source/arch/x86/kvm/x86.c#L7988" target="_blank" rel="noopener">kvm_emulate_instruction</a>是否正确模拟了<code>nop</code>指令。<code>force_emulation_prefix</code>就帮上了忙，细节请参考下节的内容。</p><h3 id="4-Source-code"><a href="#4-Source-code" class="headerlink" title="4. Source code"></a>4. Source code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v5.15-rc5/source/arch/x86/kvm/x86.c#L6541</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_ud</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> kvm_emulate_prefix[] = &#123; __KVM_EMULATE_PREFIX &#125;;</span><br><span class="line"><span class="keyword">int</span> emul_type = EMULTYPE_TRAP_UD;</span><br><span class="line"><span class="keyword">char</span> sig[<span class="number">5</span>]; <span class="comment">/* ud2; .ascii "kvm" */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x86_exception</span> <span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!static_call(kvm_x86_can_emulate_instruction)(vcpu, <span class="literal">NULL</span>, <span class="number">0</span>)))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (force_emulation_prefix &amp;&amp;</span><br><span class="line">    kvm_read_guest_virt(vcpu, kvm_get_linear_rip(vcpu),</span><br><span class="line">sig, <span class="keyword">sizeof</span>(sig), &amp;e) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">memcmp</span>(sig, kvm_emulate_prefix, <span class="keyword">sizeof</span>(sig)) == <span class="number">0</span>) &#123;</span><br><span class="line">kvm_rip_write(vcpu, kvm_rip_read(vcpu) + <span class="keyword">sizeof</span>(sig));</span><br><span class="line">emul_type = EMULTYPE_TRAP_UD_FORCED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kvm_emulate_instruction(vcpu, emul_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v5.15-rc5/source/arch/x86/include/asm/emulate_prefix.h#L12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KVM_EMULATE_PREFIX  0x0f,0x0b,0x6b,0x76,0x6d<span class="comment">/* ud2 ; .ascii "kvm" */</span></span></span><br></pre></td></tr></table></figure><p>在上节的例子中，<code>handle_ud</code> 会执行<code>kvm_rip_write(vcpu, kvm_rip_read(vcpu) + sizeof(sig))</code>，<code>kvm_emulate_instruction</code>将模拟<code>nop</code>指令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about force_emulation_prefix in KVM.
    
    </summary>
    
      <category term="KVM" scheme="http://liujunming.github.io/categories/KVM/"/>
    
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>Notes about split lock detect</title>
    <link href="http://liujunming.github.io/2022/01/13/split-lock-and-its-virtualization/"/>
    <id>http://liujunming.github.io/2022/01/13/split-lock-and-its-virtualization/</id>
    <published>2022-01-13T00:04:29.000Z</published>
    <updated>2022-02-11T11:00:12.984Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about split lock detect.<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>A split lock is any atomic operation whose operand crosses two cache lines. Since the operand spans two cache lines and the operation must be atomic, the system locks the bus while the CPU accesses the two cache lines.</p><p>During bus locking, request from other CPUs or bus agents for control of the bus are blocked. Blocking bus access from other CPUs plus overhead of configuring bus locking protocol degrade not only performance on one CPU but also overall system performance.</p><p>If the operand is cacheable and completely contained in one cache line, the atomic operation is optimized by less expensive cache locking on Intel P6 and recent processors. If a split lock operation is detected and a developer fixes the issue so that the operand can be operated in one cache line, cache locking instead of more expensive bus locking will be used for the atomic operation. Removing the split lock can improve overall performance.</p><p>Intel-64 and IA32 multiple-processor systems support locked atomic operations on locations in system memory. For example, The LOCK instruction prefix can be prepended to the following instructions: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG, when these instructions use memory destination operand forms. </p><p>More information about split lock, bus locking, and cache locking can be found in the latest Intel 64 and IA-32 Architecture Software Developer’s Manual.</p><h3 id="2-Split-lock-detection"><a href="#2-Split-lock-detection" class="headerlink" title="2. Split lock detection"></a>2. Split lock detection</h3><p>Intel introduces a mechanism to detect split lock via Alignment Check(#AC) exception before badly aligned atomic instructions might impact whole system performance in Tremont and other future processors. </p><p>This capability is critical for real time system designers who build consolidated real time systems. These systems run hard real time code on some cores and run “untrusted” user processes on some other cores. The hard real time cannot afford to have any bus lock from the untrusted processes to hurt real time performance. To date the designers have been unable to deploy these solutions as they have no way to prevent the “untrusted” user code from generating split lock and bus lock to block the hard real time code to access memory during bus locking.</p><p>This capability may also find usage in cloud. A user process with split lock running in one guest can block other cores from accessing shared memory during its split locked memory access. That may cause overall<br>system performance degradation.</p><p>Split lock may open a security hole where malicious user code may slow down overall system by executing instructions with split lock.</p><h3 id="3-Feature-Enumeration-and-Control"><a href="#3-Feature-Enumeration-and-Control" class="headerlink" title="3. Feature Enumeration and Control"></a>3. Feature Enumeration and Control</h3><p>#AC for Split-locked Access feature is enumerated and controlled via CPUID and MSR registers.</p><ul><li>CPUID.(EAX=0x7, ECX=0):EDX[30], the 30th bit of output value in EDX indicates if the platform has IA32_CORE_CAPABILITIES MSR.</li><li>The 5th bit of IA32_CORE_CAPABILITIES MSR(0xcf), enumerates whether the CPU supports #AC for Split-locked Access (and has TEST_CTRL MSR).</li><li>The 29th bit of TEST_CTL MSR(0x33) controls enabling and disabling #AC for Split-locked Access.</li></ul><p><img src="/images/2022/01/24.png" alt></p><p><img src="/images/2022/01/25.png" alt></p><h3 id="4-Handle-split-lock"><a href="#4-Handle-split-lock" class="headerlink" title="4. Handle split lock"></a>4. Handle split lock</h3><p>Because #AC is a fault, the instruction is not executed, giving the #AC handler an opportunity to decide how to handle this instruction:</p><ul><li>It can allow the instruction to run with LOCK# bus signal potentially impacting performance of other CPUs.</li><li>It can terminate the software at this instruction.</li><li>and so on.</li></ul><h3 id="5-Interface"><a href="#5-Interface" class="headerlink" title="5. Interface"></a>5. Interface</h3><p><code>split_lock_detect</code> kernel parameter:<br><img src="/images/2022/01/23.png" alt></p><h3 id="6-Example"><a href="#6-Example" class="headerlink" title="6. Example"></a>6. Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//https://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Structure_002dPacking-Pragmas.html</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push,2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">62</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">counter</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(struct counter);</span><br><span class="line">    <span class="keyword">int</span> prot = PROT_READ | PROT_WRITE;</span><br><span class="line">    <span class="keyword">int</span> flags = MAP_PRIVATE | MAP_ANONYMOUS;</span><br><span class="line"></span><br><span class="line">    p = (struct counter *) mmap(<span class="number">0</span>, size, prot, flags, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    __sync_fetch_and_add(&amp;p-&gt;c, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Intel CPU中，一个cache line 只有64个字节，struct counter中的成员 c 占8个字节，buf填充了62个字节。因此，一旦访问成员c，就涉及两个cache lines的内容的拼接；执行原子操作 <code>__sync_fetch_and_add()</code>会触发split lock。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[124994.391805] x86/split lock detection: #AC: a.out/91418 took a split_lock trap at address: 0x556c2928819a</span><br></pre></td></tr></table></figure><p>Another example:</p><p><a href="https://lore.kernel.org/kvm/20220124111444.12548-1-junming.liu@intel.com/" target="_blank" rel="noopener">x86: Align incw instruction to avoid split lock</a></p><h3 id="7-Implementation-in-Kernel"><a href="#7-Implementation-in-Kernel" class="headerlink" title="7. Implementation in Kernel"></a>7. Implementation in Kernel</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_FEATURE_SPLIT_LOCK_DETECT   (11*32+ 6) <span class="comment">/* #AC for split lock */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_FEATURE_BUS_LOCK_DETECT     (16*32+24) <span class="comment">/* Bus Lock detect */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Abbreviated from Intel SDM name IA32_CORE_CAPABILITIES */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_IA32_CORE_CAPS  0x000000cf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT_BIT  5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT  BIT(MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_TEST_CTRL0x00000033</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_TEST_CTRL_SPLIT_LOCK_DETECT_BIT29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_TEST_CTRL_SPLIT_LOCK_DETECTBIT(MSR_TEST_CTRL_SPLIT_LOCK_DETECT_BIT)</span></span><br></pre></td></tr></table></figure><p>If bit 5 is set in <code>MSR_IA32_CORE_CAPS</code>, the feature <code>X86_FEATURE_SPLIT_LOCK_DETECT</code> will be enabled and “split_lock_detect” will be displayed.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">early_cpu_init</span><br><span class="line">early_identify_cpu</span><br><span class="line">sld_setup</span><br><span class="line">split_lock_setup</span><br><span class="line">__split_lock_setup</span><br><span class="line">setup_force_cpu_cap(X86_FEATURE_SPLIT_LOCK_DETECT)</span><br><span class="line">sld_state_setup</span><br><span class="line">sld_state_show</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">split_lock_setup</span><span class="params">(struct cpuinfo_x86 *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">x86_cpu_id</span> *<span class="title">m</span>;</span></span><br><span class="line">u64 ia32_core_caps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (boot_cpu_has(X86_FEATURE_HYPERVISOR))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">m = x86_match_cpu(split_lock_cpu_ids);</span><br><span class="line"><span class="keyword">if</span> (!m)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (m-&gt;driver_data) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> (!cpu_has(c, X86_FEATURE_CORE_CAPABILITIES))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">rdmsrl(MSR_IA32_CORE_CAPS, ia32_core_caps);</span><br><span class="line"><span class="keyword">if</span> (!(ia32_core_caps &amp; MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpu_model_supports_sld = <span class="literal">true</span>;</span><br><span class="line">__split_lock_setup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">identify_cpu</span><br><span class="line">init_intel[this_cpu-&gt;c_init]</span><br><span class="line">split_lock_init</span><br><span class="line">split_lock_verify_msr</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://lwn.net/ml/linux-kernel/1556134382-58814-1-git-send-email-fenghua.yu%40intel.com/" target="_blank" rel="noopener">x86/split_lock: Enable split lock detection</a></li><li><a href="https://kernel.taobao.org/2019/07/Detecting-and-handling-split-locks/" target="_blank" rel="noopener">Detecting and handling split locks</a></li><li><a href="https://projectacrn.github.io/latest/developer-guides/hld/hld-splitlock.html" target="_blank" rel="noopener">Handling Split-Locked Access in ACRN</a></li><li><a href="https://drive.google.com/drive/folders/1MQLEV5samjExLukxFZ1A5GB1TaZS5ZSo" target="_blank" rel="noopener">TCC feature introduction - split lock</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about split lock detect.
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to VT-x FlexPriority</title>
    <link href="http://liujunming.github.io/2022/01/12/Introduction-to-VT-x-FlexPriority/"/>
    <id>http://liujunming.github.io/2022/01/12/Introduction-to-VT-x-FlexPriority/</id>
    <published>2022-01-12T04:36:09.000Z</published>
    <updated>2022-01-12T10:11:09.083Z</updated>
    
    <content type="html"><![CDATA[<p>VT-x FlexPriority是<a href="/2020/10/08/The-motivation-of-APICv/">APICv</a>之前的一个过渡性的技术，本文特意考古一下。<a id="more"></a></p><p>VT-x FlexPriority引入了Shadow TPR，即VTPR寄存器（Virtual-APIC Page也是此时引入的）。此时，Virtual-APIC Page中仅实现了VTPR一个寄存器，并且尚未发明<strong>APIC Write</strong> VM Exit，因此对VTPR寄存器的写入会起到类似APIC-Write Emulation的效果，不会引起VM Exit。</p><p><img src="/images/2022/01/22.png" alt></p><p>考古patch <a href="https://lore.kernel.org/kvm/DB3BD37E3533EE46BED2FBA80995557F87DA24@pdsmsx414.ccr.corp.intel.com/" target="_blank" rel="noopener">Memory mapped TPR shadow feature enabling</a>，读者若有兴趣，可以读一读。</p><hr><p>参考资料:</p><ol><li><a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/" target="_blank" rel="noopener">Intel SDM Chapter 29: APIC Virtualizaton &amp; Virtual Interrupts</a></li><li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/virtualization-enabling-intel-virtualization-technology-features-and-benefits-paper.pdf" target="_blank" rel="noopener">Enabling Intel® Virtualization Technology Features and Benefits</a></li><li><a href="https://lore.kernel.org/kvm/DB3BD37E3533EE46BED2FBA80995557F87DA24@pdsmsx414.ccr.corp.intel.com/" target="_blank" rel="noopener">Memory mapped TPR shadow feature enabling</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VT-x FlexPriority是&lt;a href=&quot;/2020/10/08/The-motivation-of-APICv/&quot;&gt;APICv&lt;/a&gt;之前的一个过渡性的技术，本文特意考古一下。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>How to verify the difference between posted interrupt and event injection</title>
    <link href="http://liujunming.github.io/2022/01/11/How-to-verify-the-difference-between-posted-interrupt-and-event-injection/"/>
    <id>http://liujunming.github.io/2022/01/11/How-to-verify-the-difference-between-posted-interrupt-and-event-injection/</id>
    <published>2022-01-11T06:38:25.000Z</published>
    <updated>2022-01-11T10:34:52.524Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍利用ftrace to verify the difference between posted interrupt and event injection.<a id="more"></a></p><h3 id="1-Posted-Interrupt-scenarios"><a href="#1-Posted-Interrupt-scenarios" class="headerlink" title="1. Posted Interrupt scenarios"></a>1. Posted Interrupt scenarios</h3><ul><li>Enable Posted Interrupt<ul><li>kernel parameter: <code>kvm_intel.enable_apicv=1</code></li><li><code>rmmod kvm-intel kvm &amp;&amp; modprobe kvm-intel enable_apicv=1</code></li></ul></li><li>Need to ensure <code>cat /sys/module/kvm_intel/parameters/enable_apicv</code> is <strong>Y</strong></li></ul><h3 id="2-Event-Injection-scenarios"><a href="#2-Event-Injection-scenarios" class="headerlink" title="2. Event Injection scenarios"></a>2. Event Injection scenarios</h3><ul><li><p>Disable Posted Interrupt</p><ul><li>kernel parameter: <code>kvm_intel.enable_apicv=0</code></li><li><code>rmmod kvm-intel kvm &amp;&amp; modprobe kvm-intel enable_apicv=0</code></li></ul></li><li><p>Need to ensure <code>cat /sys/module/kvm_intel/parameters/enable_apicv</code> is <strong>N</strong></p></li></ul><h3 id="3-Trace-verification"><a href="#3-Trace-verification" class="headerlink" title="3. Trace verification"></a>3. Trace verification</h3><ul><li>sudo trace-cmd record -e kvm_inj_virq</li><li>sudo trace-cmd report</li></ul><h4 id="3-1-trace-for-Posted-Interrupt"><a href="#3-1-trace-for-Posted-Interrupt" class="headerlink" title="3.1 trace for Posted Interrupt"></a>3.1 trace for Posted Interrupt</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86-930906 [173] 703091.577738: kvm_inj_virq:         irq 8</span><br><span class="line">qemu-system-x86-930906 [173] 703091.577741: kvm_inj_virq:         irq 8</span><br><span class="line">qemu-system-x86-930906 [173] 703091.581667: kvm_inj_virq:         irq 16</span><br><span class="line">qemu-system-x86-930906 [173] 703091.582496: kvm_inj_virq:         irq 16</span><br><span class="line">qemu-system-x86-930906 [173] 703091.592551: kvm_inj_virq:         irq 25</span><br></pre></td></tr></table></figure><h4 id="3-2-trace-for-Event-Injection"><a href="#3-2-trace-for-Event-Injection" class="headerlink" title="3.2 trace for Event Injection"></a>3.2 trace for Event Injection</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86-931437 [222] 703390.933279: kvm_inj_virq:         irq 8</span><br><span class="line">qemu-system-x86-931437 [222] 703390.933282: kvm_inj_virq:         irq 8</span><br><span class="line">qemu-system-x86-931437 [222] 703390.940684: kvm_inj_virq:         irq 16</span><br><span class="line">qemu-system-x86-931437 [222] 703390.941541: kvm_inj_virq:         irq 16</span><br><span class="line">qemu-system-x86-931437 [222] 703390.951859: kvm_inj_virq:         irq 25</span><br><span class="line">qemu-system-x86-931438 [223] 703391.322195: kvm_inj_virq:         irq 32</span><br><span class="line">qemu-system-x86-931437 [222] 703391.330941: kvm_inj_virq:         irq 236</span><br><span class="line">qemu-system-x86-931437 [222] 703391.331953: kvm_inj_virq:         irq 236</span><br><span class="line">qemu-system-x86-931437 [222] 703392.385846: kvm_inj_virq:         irq 236</span><br></pre></td></tr></table></figure><h4 id="3-3-summary"><a href="#3-3-summary" class="headerlink" title="3.3 summary"></a>3.3 summary</h4><p>Interrupts 32 to 255—User Defined Interrupts</p><p>相对于Event Injection，当enable Posted Interrupt之后，trace中没有出现User Defined Interrupts的kvm_inj_virq事件！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍利用ftrace to verify the difference between posted interrupt and event injection.
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>caller-saved registers and callee-saved registers</title>
    <link href="http://liujunming.github.io/2022/01/11/What-is-callee-saved-registers/"/>
    <id>http://liujunming.github.io/2022/01/11/What-is-callee-saved-registers/</id>
    <published>2022-01-11T00:42:56.000Z</published>
    <updated>2022-01-11T10:34:52.525Z</updated>
    
    <content type="html"><![CDATA[<p>The introduction to caller-saved registers and callee-saved registers.<a id="more"></a></p><h3 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h3><p><a href="/2020/04/11/Introduction-to-System-V-ABI/">Introduction to System V ABI</a></p><h3 id="2-Definition"><a href="#2-Definition" class="headerlink" title="2. Definition"></a>2. Definition</h3><h4 id="2-1-Caller-saved-registers"><a href="#2-1-Caller-saved-registers" class="headerlink" title="2.1 Caller-saved registers"></a>2.1 Caller-saved registers</h4><blockquote><p><strong>Caller-saved registers</strong> (AKA <strong>volatile</strong> registers, or <strong>call-clobbered</strong>) are used to hold temporary quantities that need not be preserved across calls.</p></blockquote><p>For that reason, it is the caller’s responsibility to push these registers onto the stack or copy them somewhere else if it wants to restore this value after a procedure call.</p><p>It’s normal to let a <code>call</code> destroy temporary values in these registers, though.</p><h4 id="2-2-Callee-saved-registers"><a href="#2-2-Callee-saved-registers" class="headerlink" title="2.2 Callee-saved registers"></a>2.2 Callee-saved registers</h4><blockquote><p><strong>Callee-saved registers</strong> (AKA <strong>non-volatile</strong> registers, or <strong>call-preserved</strong>) are used to hold long-lived values that should be preserved across calls.</p></blockquote><p>When the caller makes a procedure call, it can expect that those registers will hold the same value after the callee returns, making it the responsibility of the callee to save them and restore them before returning to the caller. Or to not touch them.</p><h3 id="3-Linux-x86-64-function-call"><a href="#3-Linux-x86-64-function-call" class="headerlink" title="3. Linux x86-64 function call"></a>3. Linux x86-64 function call</h3><p><a href="https://www.uclibc.org/docs/psABI-x86_64.pdf" target="_blank" rel="noopener">spec</a></p><h4 id="3-1-Callee-saved-registers"><a href="#3-1-Callee-saved-registers" class="headerlink" title="3.1 Callee-saved registers"></a>3.1 Callee-saved registers</h4><p><img src="/images/2022/01/20.png" alt></p><p><code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code>, <code>rbx</code>, <code>rsp</code>, <code>rbp</code> are the callee-saved registers - they have a “Yes” in the “Preserved across function calls” column.</p><h4 id="3-2-Caller-saved-registers"><a href="#3-2-Caller-saved-registers" class="headerlink" title="3.2 Caller-saved registers"></a>3.2 Caller-saved registers</h4><p><img src="/images/2022/01/21.png" alt></p><h3 id="4-Example"><a href="#4-Example" class="headerlink" title="4. Example"></a>4. Example</h3><h4 id="4-1-setjmp"><a href="#4-1-setjmp" class="headerlink" title="4.1 setjmp"></a>4.1 setjmp</h4><p><a href="https://gitlab.com/kvm-unit-tests/kvm-unit-tests/-/blob/master/lib/x86/setjmp64.S" target="_blank" rel="noopener">https://gitlab.com/kvm-unit-tests/kvm-unit-tests/-/blob/master/lib/x86/setjmp64.S</a></p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.globl setjmp</span><br><span class="line">setjmp:</span><br><span class="line">mov (%rsp), %rsi</span><br><span class="line">mov %rsi, (%rdi)</span><br><span class="line">mov %rsp, <span class="number">0x8</span>(%rdi)</span><br><span class="line">mov %rbp, <span class="number">0x10</span>(%rdi)</span><br><span class="line">mov %rbx, <span class="number">0x18</span>(%rdi)</span><br><span class="line">mov %r12, <span class="number">0x20</span>(%rdi)</span><br><span class="line">mov %r13, <span class="number">0x28</span>(%rdi)</span><br><span class="line">mov %r14, <span class="number">0x30</span>(%rdi)</span><br><span class="line">mov %r15, <span class="number">0x38</span>(%rdi)</span><br><span class="line">xor %eax, %eax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">.globl longjmp</span><br><span class="line">longjmp:</span><br><span class="line">mov %esi, %eax</span><br><span class="line">mov <span class="number">0x38</span>(%rdi), %r15</span><br><span class="line">mov <span class="number">0x30</span>(%rdi), %r14</span><br><span class="line">mov <span class="number">0x28</span>(%rdi), %r13</span><br><span class="line">mov <span class="number">0x20</span>(%rdi), %r12</span><br><span class="line">mov <span class="number">0x18</span>(%rdi), %rbx</span><br><span class="line">mov <span class="number">0x10</span>(%rdi), %rbp</span><br><span class="line">mov <span class="number">0x8</span>(%rdi), %rsp</span><br><span class="line">mov (%rdi), %rsi</span><br><span class="line">mov %rsi, (%rsp)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h4 id="4-2-arch-switch-to"><a href="#4-2-arch-switch-to" class="headerlink" title="4.2 arch_switch_to"></a>4.2 arch_switch_to</h4><p><a href="https://github.com/projectacrn/acrn-hypervisor/blob/release_2.7/hypervisor/arch/x86/sched.S" target="_blank" rel="noopener">https://github.com/projectacrn/acrn-hypervisor/blob/release_2.7/hypervisor/arch/x86/sched.S</a></p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    .text</span><br><span class="line"></span><br><span class="line">   .code64</span><br><span class="line">   .align       <span class="number">8</span></span><br><span class="line">   .global      arch_switch_to</span><br><span class="line">arch_switch_to:</span><br><span class="line">pushf</span><br><span class="line">pushq %rbx</span><br><span class="line">pushq %rbp</span><br><span class="line">pushq %r12</span><br><span class="line">pushq %r13</span><br><span class="line">pushq %r14</span><br><span class="line">pushq %r15</span><br><span class="line">pushq %rdi</span><br><span class="line">movq %rsp, (%rdi)</span><br><span class="line">movq (%rsi), %rsp</span><br><span class="line">popq %rdi</span><br><span class="line">popq %r15</span><br><span class="line">popq %r14</span><br><span class="line">popq %r13</span><br><span class="line">popq %r12</span><br><span class="line">popq %rbp</span><br><span class="line">popq %rbx</span><br><span class="line">popf</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://stackoverflow.com/questions/9268586/what-are-callee-and-caller-saved-registers" target="_blank" rel="noopener">What are callee and caller saved registers?</a></li><li><a href="https://stackoverflow.com/questions/18024672/what-registers-are-preserved-through-a-linux-x86-64-function-call" target="_blank" rel="noopener">What registers are preserved through a linux x86-64 function call</a></li><li><a href="https://www.cs.virginia.edu/~evans/cs216/guides/x86.html" target="_blank" rel="noopener">x86 Assembly Guide</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The introduction to caller-saved registers and callee-saved registers.
    
    </summary>
    
      <category term="计算机编程" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机编程" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
