<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2022-01-20T13:08:32.097Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notes about bus lock detection</title>
    <link href="http://liujunming.github.io/2022/01/18/Notes-about-bus-lock-detection/"/>
    <id>http://liujunming.github.io/2022/01/18/Notes-about-bus-lock-detection/</id>
    <published>2022-01-18T11:33:31.000Z</published>
    <updated>2022-01-20T13:08:32.097Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about bus lock detection.<a id="more"></a></p><ul><li>fault vs trap</li></ul><p>#AC for <a href="/2022/01/13/split-lock-and-its-virtualization/">Split-locked Access</a> is fault, #DB for bus lock detection is trap.</p><p><img src="/images/2022/01/26.png" alt></p><p>A bus lock is acquired through either <strong>split locked access to writeback (WB) memory</strong> or <strong>any locked access to non-WB memory</strong>. This is typically &gt;1000 cycles slower than an atomic operation within a cache line. It also disrupts performance on other cores.</p><p>Although split lock can be detected by #AC fault, the fault is triggered before the instruction acquires bus lock. This makes it difficult to mitigate bus lock (e.g. throttle(限制) the user application).</p><p>How to explain <u>it difficult to mitigate bus lock(e.g. throttle the user application)</u>?<br><code>split_lock_detect</code> default value is warn, that is the split lock state will be changed for one instruction. But this requires changing the split lock state using the test MSR for the complete core, impacting other threads.  <strong>Keypoint:</strong> #AC fault: The return address for the fault handler points to the faulting instruction, rather than to the instruction following the faulting instruction. <strong>Think:</strong> What does #AC handler do when <code>split_lock_detect</code> value is warn?<br><img src="/images/2022/01/27.png" alt><br><code>ratelimit</code>可以理解为throttle the user application!</p><p>Some CPUs have ability to notify the kernel by an #DB trap after a user instruction acquires a bus lock and is executed. This allows the kernel to enforce user application throttling or mitigations.</p><p>#DB for bus lock detect fixes issues in #AC for split lock detect:</p><ol><li>It’s architectural … just need to look at one CPUID bit to know it exists</li><li>The IA32_DEBUGCTL MSR, which reports bus lock in #DB, is per-thread. So each process or guest can have different behavior.</li><li>It has support for VMM/guests (new VMEXIT codes, etc).</li><li>It detects not only split locks but also bus locks from non-WB.</li></ol><p>Hardware only generates #DB for bus lock detect when CPL&gt;0 to avoid nested #DB from multiple bus locks while the first #DB is being handled.</p><p>Use the existing kernel command line parameter “split_lock_detect=” to handle #DB for bus lock with an additional option “ratelimit=N” to set bus lock rate limit for a user.</p><hr><p>参考资料:</p><ol><li><a href="https://software.intel.com/content/www/us/en/develop/download/intel-architecture-instruction-set-extensions-programming-reference.html" target="_blank" rel="noopener">Intel Instruction Set Extension</a> Chapter 9</li><li><a href="https://lore.kernel.org/lkml/20210322135325.682257-1-fenghua.yu@intel.com/" target="_blank" rel="noopener">x86/bus_lock: Enable bus lock detection</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about bus lock detection.
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Notes about IRQ Affinity</title>
    <link href="http://liujunming.github.io/2022/01/16/Notes-about-IRQ-Affinity/"/>
    <id>http://liujunming.github.io/2022/01/16/Notes-about-IRQ-Affinity/</id>
    <published>2022-01-15T17:28:51.000Z</published>
    <updated>2022-01-16T11:25:09.226Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about IRQ Affinity.<a id="more"></a></p><h3 id="1-irqaffinity"><a href="#1-irqaffinity" class="headerlink" title="1. irqaffinity"></a>1. irqaffinity</h3><p>If <code>irqaffinity</code> is appended as described in <a href="https://github.com/intel-innersource/virtualization.hypervisors.client.idv.docs#kernel-parameters" target="_blank" rel="noopener">Kernel Parameters</a>, It’s used to set the default irq affinity mask.<br>The set value can be checked by:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/irq/default_smp_affinity</span><br></pre></td></tr></table></figure><h3 id="2-IRQ-Affinity"><a href="#2-IRQ-Affinity" class="headerlink" title="2. IRQ Affinity"></a>2. IRQ Affinity</h3><p>Binding IRQs to a group of CPUs is now a generic and independent kernel feature. Every IRQ source in Linux has an entry in <code>/proc/irq</code> directory. For example, the settings for IRQ 40 is stored in <code>/proc/irq/40</code>. IRQ affinity, or IRQ bindings, is configured though the <code>smp_affinity</code> setting in that directory. For example, the <code>smp_affinity</code> for IRQ 40 is in <code>/proc/irq/40/smp_affinity</code>. The value of the <code>smp_affinity</code> setting is a bitmask of all CPUs that are permitted as a resource for the given IRQ. The default value for <code>smp_affinity</code>is  <code>0xffffffff</code>. This means the processes for the IRQ are sent to all CPUs. You are not allowed to turn off all CPUs for an IRQ. If the IRQ controller does not support IRQ affinity, the value can not be changed from the default. If multiple CPUs are defined, then the IRQ source uses the least busy CPU. This is called <em>lowest priority APIC routing</em>. IRQ affinity is achieved by binding an IRQ to a specific CPU or group of CPUs by echoing a HEX value to <code>smp_affinity</code> for the IRQ.</p><h3 id="3-Example"><a href="#3-Example" class="headerlink" title="3. Example"></a>3. Example</h3><p>Here is an example of restricting IRQ44 (eth1) to CPU0-3 then restricting it to CPU4-7 (this is an 8-CPU SMP box):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@moon 44]# cd /proc/irq/44</span><br><span class="line">[root@moon 44]# cat smp_affinity</span><br><span class="line">ffffffff</span><br><span class="line"></span><br><span class="line">[root@moon 44]# echo 0f &gt; smp_affinity</span><br><span class="line">[root@moon 44]# cat smp_affinity</span><br><span class="line">0000000f</span><br><span class="line">[root@moon 44]# ping -f h</span><br><span class="line">PING hell (195.4.7.3): 56 data bytes</span><br><span class="line">...</span><br><span class="line">--- hell ping statistics ---</span><br><span class="line">6029 packets transmitted, 6027 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 0.1/0.1/0.4 ms</span><br><span class="line">[root@moon 44]# cat /proc/interrupts | grep &apos;CPU\|44:&apos;</span><br><span class="line">        CPU0       CPU1       CPU2       CPU3      CPU4       CPU5        CPU6       CPU7</span><br><span class="line">44:       1068       1785       1785       1783         0          0           0         0    IO-APIC-level  eth1</span><br></pre></td></tr></table></figure><p>As can be seen from the line above IRQ44 was delivered only to the first four processors (0-3). Now lets restrict that IRQ to CPU(4-7).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@moon 44]# echo f0 &gt; smp_affinity</span><br><span class="line">[root@moon 44]# cat smp_affinity</span><br><span class="line">000000f0</span><br><span class="line">[root@moon 44]# ping -f h</span><br><span class="line">PING hell (195.4.7.3): 56 data bytes</span><br><span class="line">..</span><br><span class="line">--- hell ping statistics ---</span><br><span class="line">2779 packets transmitted, 2777 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 0.1/0.5/585.4 ms</span><br><span class="line">[root@moon 44]# cat /proc/interrupts |  &apos;CPU\|44:&apos;</span><br><span class="line">        CPU0       CPU1       CPU2       CPU3      CPU4       CPU5        CPU6       CPU7</span><br><span class="line">44:       1068       1785       1785       1783      1784       1069        1070       1069   IO-APIC-level  eth1</span><br></pre></td></tr></table></figure><p>This time around IRQ44 was delivered only to the last four processors. i.e counters for the CPU0-3 did not change.</p><hr><p>参考资料:</p><ol><li><a href="https://www.kernel.org/doc/html/latest/core-api/irq/irq-affinity.html" target="_blank" rel="noopener">SMP IRQ affinity</a></li><li><a href="https://blog.csdn.net/shenhuxi_yu/article/details/77991535" target="_blank" rel="noopener">linux irq/affinity理解</a></li><li><a href="https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt" target="_blank" rel="noopener">kernel-parameters.txt</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about IRQ Affinity.
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Notes about force_emulation_prefix in KVM</title>
    <link href="http://liujunming.github.io/2022/01/14/Notes-about-force-emulation-prefix-in-KVM/"/>
    <id>http://liujunming.github.io/2022/01/14/Notes-about-force-emulation-prefix-in-KVM/</id>
    <published>2022-01-14T05:19:04.000Z</published>
    <updated>2022-01-14T15:34:20.420Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about force_emulation_prefix in KVM.<a id="more"></a></p><h3 id="1-Materials"><a href="#1-Materials" class="headerlink" title="1. Materials"></a>1. Materials</h3><p>commit id: 6c86eedc206dd1f9d37a2796faa8e6f2278215d2<br><a href="https://lore.kernel.org/kvm/1522798129-14588-1-git-send-email-wanpengli@tencent.com/" target="_blank" rel="noopener">https://lore.kernel.org/kvm/1522798129-14588-1-git-send-email-wanpengli@tencent.com/</a></p><h3 id="2-Motivation"><a href="#2-Motivation" class="headerlink" title="2. Motivation"></a>2. Motivation</h3><p>There is no easy way to force KVM to run an instruction through the emulator(by design as that will expose the x86 emulator as a significant attack-surface).</p><p>However, we do wish to expose the x86 emulator in case we are testing it(e.g. via kvm-unit-tests). Therefore, this patch adds a “force emulation prefix” that is designed to raise #UD which KVM will trap and it’s #UD exit-handler will match “force emulation prefix” to run instruction after prefix by the x86 emulator.</p><p>To not expose the x86 emulator by default, we add a module parameter that should be off by default.</p><p>The  x86 emulator is the function: <a href="https://elixir.bootlin.com/linux/v5.15-rc5/source/arch/x86/kvm/x86.c#L7988" target="_blank" rel="noopener">kvm_emulate_instruction</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kvm_emulate_instruction</span><br><span class="line">x86_emulate_instruction</span><br></pre></td></tr></table></figure><h3 id="3-Example"><a href="#3-Example" class="headerlink" title="3. Example"></a>3. Example</h3><ul><li>use <code>kvm.force_emulation_prefix=1</code> to enable</li></ul><p><a href="https://gitlab.com/kvm-unit-tests/kvm-unit-tests/-/blob/master/x86/emulator.c" target="_blank" rel="noopener">emulator.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Forced emulation prefix, used to invoke the emulator unconditionally.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEP <span class="meta-string">"ud2; .byte 'k', 'v', 'm';"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KVM_FEP_LENGTH 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fep_available = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">handle_exception(UD_VECTOR, record_no_fep);</span><br><span class="line"><span class="keyword">asm</span>(KVM_FEP <span class="string">"nop"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">record_no_fep</span><span class="params">(struct ex_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fep_available = <span class="number">0</span>;</span><br><span class="line">regs-&gt;rip += KVM_FEP_LENGTH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在guest中不会因为执行<code>asm(&quot;nop&quot;)</code>而发生VM Exit.</li><li>如果<code>kvm.force_emulation_prefix=1</code> ,那么在kvm unit test中，执行<code>asm(KVM_FEP &quot;nop&quot;)</code>的结果就是执行<code>asm(&quot;nop&quot;)</code>的结果，在guest中不会产生#UD.</li><li>如果<code>kvm.force_emulation_prefix=0</code> ,那么在kvm unit test中，执行<code>asm(KVM_FEP &quot;nop&quot;)</code>的结果就是在guest中产生#UD，那么#UD handler会被调用，全局变量<code>fep_available</code>就会被设置为0.</li></ul><p>Test cases:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://gitlab.com/kvm-unit-tests/kvm-unit-tests/-/blob/master/x86/emulator.c#L1185-1190</span></span><br><span class="line"><span class="keyword">if</span> (fep_available) &#123;</span><br><span class="line">...</span><br><span class="line">test_nop(mem);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>目的是测试<a href="https://elixir.bootlin.com/linux/v5.15-rc5/source/arch/x86/kvm/x86.c#L7988" target="_blank" rel="noopener">kvm_emulate_instruction</a>是否正确模拟了<code>nop</code>指令。</p><p>在guest中不会因为执行<code>asm(&quot;nop&quot;)</code>而发生VM Exit，就无法测试<a href="https://elixir.bootlin.com/linux/v5.15-rc5/source/arch/x86/kvm/x86.c#L7988" target="_blank" rel="noopener">kvm_emulate_instruction</a>是否正确模拟了<code>nop</code>指令。<code>force_emulation_prefix</code>就帮上了忙，细节请参考下节的内容。</p><h3 id="4-Source-code"><a href="#4-Source-code" class="headerlink" title="4. Source code"></a>4. Source code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v5.15-rc5/source/arch/x86/kvm/x86.c#L6541</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_ud</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> kvm_emulate_prefix[] = &#123; __KVM_EMULATE_PREFIX &#125;;</span><br><span class="line"><span class="keyword">int</span> emul_type = EMULTYPE_TRAP_UD;</span><br><span class="line"><span class="keyword">char</span> sig[<span class="number">5</span>]; <span class="comment">/* ud2; .ascii "kvm" */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x86_exception</span> <span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!static_call(kvm_x86_can_emulate_instruction)(vcpu, <span class="literal">NULL</span>, <span class="number">0</span>)))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (force_emulation_prefix &amp;&amp;</span><br><span class="line">    kvm_read_guest_virt(vcpu, kvm_get_linear_rip(vcpu),</span><br><span class="line">sig, <span class="keyword">sizeof</span>(sig), &amp;e) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">memcmp</span>(sig, kvm_emulate_prefix, <span class="keyword">sizeof</span>(sig)) == <span class="number">0</span>) &#123;</span><br><span class="line">kvm_rip_write(vcpu, kvm_rip_read(vcpu) + <span class="keyword">sizeof</span>(sig));</span><br><span class="line">emul_type = EMULTYPE_TRAP_UD_FORCED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kvm_emulate_instruction(vcpu, emul_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://elixir.bootlin.com/linux/v5.15-rc5/source/arch/x86/include/asm/emulate_prefix.h#L12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KVM_EMULATE_PREFIX  0x0f,0x0b,0x6b,0x76,0x6d<span class="comment">/* ud2 ; .ascii "kvm" */</span></span></span><br></pre></td></tr></table></figure><p>在上节的例子中，<code>handle_ud</code> 会执行<code>kvm_rip_write(vcpu, kvm_rip_read(vcpu) + sizeof(sig))</code>，<code>kvm_emulate_instruction</code>将模拟<code>nop</code>指令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about force_emulation_prefix in KVM.
    
    </summary>
    
      <category term="KVM" scheme="http://liujunming.github.io/categories/KVM/"/>
    
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>Notes about split lock detect</title>
    <link href="http://liujunming.github.io/2022/01/13/split-lock-and-its-virtualization/"/>
    <id>http://liujunming.github.io/2022/01/13/split-lock-and-its-virtualization/</id>
    <published>2022-01-13T00:04:29.000Z</published>
    <updated>2022-01-20T13:08:32.098Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about split lock detect.<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>A split lock is any atomic operation whose operand crosses two cache lines. Since the operand spans two cache lines and the operation must be atomic, the system locks the bus while the CPU accesses the two cache lines.</p><p>During bus locking, request from other CPUs or bus agents for control of the bus are blocked. Blocking bus access from other CPUs plus overhead of configuring bus locking protocol degrade not only performance on one CPU but also overall system performance.</p><p>If the operand is cacheable and completely contained in one cache line, the atomic operation is optimized by less expensive cache locking on Intel P6 and recent processors. If a split lock operation is detected and a developer fixes the issue so that the operand can be operated in one cache line, cache locking instead of more expensive bus locking will be used for the atomic operation. Removing the split lock can improve overall performance.</p><p>Intel-64 and IA32 multiple-processor systems support locked atomic operations on locations in system memory. For example, The LOCK instruction prefix can be prepended to the following instructions: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG, when these instructions use memory destination operand forms. </p><p>More information about split lock, bus locking, and cache locking can be found in the latest Intel 64 and IA-32 Architecture Software Developer’s Manual.</p><h3 id="2-Split-lock-detection"><a href="#2-Split-lock-detection" class="headerlink" title="2. Split lock detection"></a>2. Split lock detection</h3><p>Intel introduces a mechanism to detect split lock via Alignment Check(#AC) exception before badly aligned atomic instructions might impact whole system performance in Tremont and other future processors. </p><p>This capability is critical for real time system designers who build consolidated real time systems. These systems run hard real time code on some cores and run “untrusted” user processes on some other cores. The hard real time cannot afford to have any bus lock from the untrusted processes to hurt real time performance. To date the designers have been unable to deploy these solutions as they have no way to prevent the “untrusted” user code from generating split lock and bus lock to block the hard real time code to access memory during bus locking.</p><p>This capability may also find usage in cloud. A user process with split lock running in one guest can block other cores from accessing shared memory during its split locked memory access. That may cause overall<br>system performance degradation.</p><p>Split lock may open a security hole where malicious user code may slow down overall system by executing instructions with split lock.</p><h3 id="3-Feature-Enumeration-and-Control"><a href="#3-Feature-Enumeration-and-Control" class="headerlink" title="3. Feature Enumeration and Control"></a>3. Feature Enumeration and Control</h3><p>#AC for Split-locked Access feature is enumerated and controlled via CPUID and MSR registers.</p><ul><li>CPUID.(EAX=0x7, ECX=0):EDX[30], the 30th bit of output value in EDX indicates if the platform has IA32_CORE_CAPABILITIES MSR.</li><li>The 5th bit of IA32_CORE_CAPABILITIES MSR(0xcf), enumerates whether the CPU supports #AC for Split-locked Access (and has TEST_CTRL MSR).</li><li>The 29th bit of TEST_CTL MSR(0x33) controls enabling and disabling #AC for Split-locked Access.</li></ul><p><img src="/images/2022/01/24.png" alt></p><p><img src="/images/2022/01/25.png" alt></p><h3 id="4-Handle-split-lock"><a href="#4-Handle-split-lock" class="headerlink" title="4. Handle split lock"></a>4. Handle split lock</h3><p>Because #AC is a fault, the instruction is not executed, giving the #AC handler an opportunity to decide how to handle this instruction:</p><ul><li>It can allow the instruction to run with LOCK# bus signal potentially impacting performance of other CPUs.</li><li>It can terminate the software at this instruction.</li><li>and so on.</li></ul><h3 id="5-Interface"><a href="#5-Interface" class="headerlink" title="5. Interface"></a>5. Interface</h3><p><code>split_lock_detect</code> kernel parameter:<br><img src="/images/2022/01/23.png" alt></p><h3 id="6-Example"><a href="#6-Example" class="headerlink" title="6. Example"></a>6. Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//https://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Structure_002dPacking-Pragmas.html</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push,2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">counter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">62</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">counter</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(struct counter);</span><br><span class="line">    <span class="keyword">int</span> prot = PROT_READ | PROT_WRITE;</span><br><span class="line">    <span class="keyword">int</span> flags = MAP_PRIVATE | MAP_ANONYMOUS;</span><br><span class="line"></span><br><span class="line">    p = (struct counter *) mmap(<span class="number">0</span>, size, prot, flags, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    __sync_fetch_and_add(&amp;p-&gt;c, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Intel CPU中，一个cache line 只有64个字节，struct counter中的成员 c 占8个字节，buf填充了62个字节。因此，一旦访问成员c，就涉及两个cache lines的内容的拼接；执行原子操作 <code>__sync_fetch_and_add()</code>会触发split lock。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[124994.391805] x86/split lock detection: #AC: a.out/91418 took a split_lock trap at address: 0x556c2928819a</span><br></pre></td></tr></table></figure><h3 id="7-Implementation-in-Kernel"><a href="#7-Implementation-in-Kernel" class="headerlink" title="7. Implementation in Kernel"></a>7. Implementation in Kernel</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_FEATURE_SPLIT_LOCK_DETECT   (11*32+ 6) <span class="comment">/* #AC for split lock */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X86_FEATURE_BUS_LOCK_DETECT     (16*32+24) <span class="comment">/* Bus Lock detect */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Abbreviated from Intel SDM name IA32_CORE_CAPABILITIES */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_IA32_CORE_CAPS  0x000000cf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT_BIT  5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT  BIT(MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_TEST_CTRL0x00000033</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_TEST_CTRL_SPLIT_LOCK_DETECT_BIT29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_TEST_CTRL_SPLIT_LOCK_DETECTBIT(MSR_TEST_CTRL_SPLIT_LOCK_DETECT_BIT)</span></span><br></pre></td></tr></table></figure><p>If bit 5 is set in <code>MSR_IA32_CORE_CAPS</code>, the feature <code>X86_FEATURE_SPLIT_LOCK_DETECT</code> will be enabled and “split_lock_detect” will be displayed.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">early_cpu_init</span><br><span class="line">early_identify_cpu</span><br><span class="line">sld_setup</span><br><span class="line">split_lock_setup</span><br><span class="line">__split_lock_setup</span><br><span class="line">setup_force_cpu_cap(X86_FEATURE_SPLIT_LOCK_DETECT)</span><br><span class="line">sld_state_setup</span><br><span class="line">sld_state_show</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">split_lock_setup</span><span class="params">(struct cpuinfo_x86 *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">x86_cpu_id</span> *<span class="title">m</span>;</span></span><br><span class="line">u64 ia32_core_caps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (boot_cpu_has(X86_FEATURE_HYPERVISOR))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">m = x86_match_cpu(split_lock_cpu_ids);</span><br><span class="line"><span class="keyword">if</span> (!m)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (m-&gt;driver_data) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> (!cpu_has(c, X86_FEATURE_CORE_CAPABILITIES))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">rdmsrl(MSR_IA32_CORE_CAPS, ia32_core_caps);</span><br><span class="line"><span class="keyword">if</span> (!(ia32_core_caps &amp; MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpu_model_supports_sld = <span class="literal">true</span>;</span><br><span class="line">__split_lock_setup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">identify_cpu</span><br><span class="line">init_intel[this_cpu-&gt;c_init]</span><br><span class="line">split_lock_init</span><br><span class="line">split_lock_verify_msr</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://lwn.net/ml/linux-kernel/1556134382-58814-1-git-send-email-fenghua.yu%40intel.com/" target="_blank" rel="noopener">x86/split_lock: Enable split lock detection</a></li><li><a href="https://kernel.taobao.org/2019/07/Detecting-and-handling-split-locks/" target="_blank" rel="noopener">Detecting and handling split locks</a></li><li><a href="https://projectacrn.github.io/latest/developer-guides/hld/hld-splitlock.html" target="_blank" rel="noopener">Handling Split-Locked Access in ACRN</a></li><li><a href="https://drive.google.com/drive/folders/1MQLEV5samjExLukxFZ1A5GB1TaZS5ZSo" target="_blank" rel="noopener">TCC feature introduction - split lock</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about split lock detect.
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to VT-x FlexPriority</title>
    <link href="http://liujunming.github.io/2022/01/12/Introduction-to-VT-x-FlexPriority/"/>
    <id>http://liujunming.github.io/2022/01/12/Introduction-to-VT-x-FlexPriority/</id>
    <published>2022-01-12T04:36:09.000Z</published>
    <updated>2022-01-12T10:11:09.083Z</updated>
    
    <content type="html"><![CDATA[<p>VT-x FlexPriority是<a href="/2020/10/08/The-motivation-of-APICv/">APICv</a>之前的一个过渡性的技术，本文特意考古一下。<a id="more"></a></p><p>VT-x FlexPriority引入了Shadow TPR，即VTPR寄存器（Virtual-APIC Page也是此时引入的）。此时，Virtual-APIC Page中仅实现了VTPR一个寄存器，并且尚未发明<strong>APIC Write</strong> VM Exit，因此对VTPR寄存器的写入会起到类似APIC-Write Emulation的效果，不会引起VM Exit。</p><p><img src="/images/2022/01/22.png" alt></p><p>考古patch <a href="https://lore.kernel.org/kvm/DB3BD37E3533EE46BED2FBA80995557F87DA24@pdsmsx414.ccr.corp.intel.com/" target="_blank" rel="noopener">Memory mapped TPR shadow feature enabling</a>，读者若有兴趣，可以读一读。</p><hr><p>参考资料:</p><ol><li><a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/" target="_blank" rel="noopener">Intel SDM Chapter 29: APIC Virtualizaton &amp; Virtual Interrupts</a></li><li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/virtualization-enabling-intel-virtualization-technology-features-and-benefits-paper.pdf" target="_blank" rel="noopener">Enabling Intel® Virtualization Technology Features and Benefits</a></li><li><a href="https://lore.kernel.org/kvm/DB3BD37E3533EE46BED2FBA80995557F87DA24@pdsmsx414.ccr.corp.intel.com/" target="_blank" rel="noopener">Memory mapped TPR shadow feature enabling</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VT-x FlexPriority是&lt;a href=&quot;/2020/10/08/The-motivation-of-APICv/&quot;&gt;APICv&lt;/a&gt;之前的一个过渡性的技术，本文特意考古一下。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>How to verify the difference between posted interrupt and event injection</title>
    <link href="http://liujunming.github.io/2022/01/11/How-to-verify-the-difference-between-posted-interrupt-and-event-injection/"/>
    <id>http://liujunming.github.io/2022/01/11/How-to-verify-the-difference-between-posted-interrupt-and-event-injection/</id>
    <published>2022-01-11T06:38:25.000Z</published>
    <updated>2022-01-11T10:34:52.524Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍利用ftrace to verify the difference between posted interrupt and event injection.<a id="more"></a></p><h3 id="1-Posted-Interrupt-scenarios"><a href="#1-Posted-Interrupt-scenarios" class="headerlink" title="1. Posted Interrupt scenarios"></a>1. Posted Interrupt scenarios</h3><ul><li>Enable Posted Interrupt<ul><li>kernel parameter: <code>kvm_intel.enable_apicv=1</code></li><li><code>rmmod kvm-intel kvm &amp;&amp; modprobe kvm-intel enable_apicv=1</code></li></ul></li><li>Need to ensure <code>cat /sys/module/kvm_intel/parameters/enable_apicv</code> is <strong>Y</strong></li></ul><h3 id="2-Event-Injection-scenarios"><a href="#2-Event-Injection-scenarios" class="headerlink" title="2. Event Injection scenarios"></a>2. Event Injection scenarios</h3><ul><li><p>Disable Posted Interrupt</p><ul><li>kernel parameter: <code>kvm_intel.enable_apicv=0</code></li><li><code>rmmod kvm-intel kvm &amp;&amp; modprobe kvm-intel enable_apicv=0</code></li></ul></li><li><p>Need to ensure <code>cat /sys/module/kvm_intel/parameters/enable_apicv</code> is <strong>N</strong></p></li></ul><h3 id="3-Trace-verification"><a href="#3-Trace-verification" class="headerlink" title="3. Trace verification"></a>3. Trace verification</h3><ul><li>sudo trace-cmd record -e kvm_inj_virq</li><li>sudo trace-cmd report</li></ul><h4 id="3-1-trace-for-Posted-Interrupt"><a href="#3-1-trace-for-Posted-Interrupt" class="headerlink" title="3.1 trace for Posted Interrupt"></a>3.1 trace for Posted Interrupt</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86-930906 [173] 703091.577738: kvm_inj_virq:         irq 8</span><br><span class="line">qemu-system-x86-930906 [173] 703091.577741: kvm_inj_virq:         irq 8</span><br><span class="line">qemu-system-x86-930906 [173] 703091.581667: kvm_inj_virq:         irq 16</span><br><span class="line">qemu-system-x86-930906 [173] 703091.582496: kvm_inj_virq:         irq 16</span><br><span class="line">qemu-system-x86-930906 [173] 703091.592551: kvm_inj_virq:         irq 25</span><br></pre></td></tr></table></figure><h4 id="3-2-trace-for-Event-Injection"><a href="#3-2-trace-for-Event-Injection" class="headerlink" title="3.2 trace for Event Injection"></a>3.2 trace for Event Injection</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86-931437 [222] 703390.933279: kvm_inj_virq:         irq 8</span><br><span class="line">qemu-system-x86-931437 [222] 703390.933282: kvm_inj_virq:         irq 8</span><br><span class="line">qemu-system-x86-931437 [222] 703390.940684: kvm_inj_virq:         irq 16</span><br><span class="line">qemu-system-x86-931437 [222] 703390.941541: kvm_inj_virq:         irq 16</span><br><span class="line">qemu-system-x86-931437 [222] 703390.951859: kvm_inj_virq:         irq 25</span><br><span class="line">qemu-system-x86-931438 [223] 703391.322195: kvm_inj_virq:         irq 32</span><br><span class="line">qemu-system-x86-931437 [222] 703391.330941: kvm_inj_virq:         irq 236</span><br><span class="line">qemu-system-x86-931437 [222] 703391.331953: kvm_inj_virq:         irq 236</span><br><span class="line">qemu-system-x86-931437 [222] 703392.385846: kvm_inj_virq:         irq 236</span><br></pre></td></tr></table></figure><h4 id="3-3-summary"><a href="#3-3-summary" class="headerlink" title="3.3 summary"></a>3.3 summary</h4><p>Interrupts 32 to 255—User Defined Interrupts</p><p>相对于Event Injection，当enable Posted Interrupt之后，trace中没有出现User Defined Interrupts的kvm_inj_virq事件！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍利用ftrace to verify the difference between posted interrupt and event injection.
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>caller-saved registers and callee-saved registers</title>
    <link href="http://liujunming.github.io/2022/01/11/What-is-callee-saved-registers/"/>
    <id>http://liujunming.github.io/2022/01/11/What-is-callee-saved-registers/</id>
    <published>2022-01-11T00:42:56.000Z</published>
    <updated>2022-01-11T10:34:52.525Z</updated>
    
    <content type="html"><![CDATA[<p>The introduction to caller-saved registers and callee-saved registers.<a id="more"></a></p><h3 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h3><p><a href="/2020/04/11/Introduction-to-System-V-ABI/">Introduction to System V ABI</a></p><h3 id="2-Definition"><a href="#2-Definition" class="headerlink" title="2. Definition"></a>2. Definition</h3><h4 id="2-1-Caller-saved-registers"><a href="#2-1-Caller-saved-registers" class="headerlink" title="2.1 Caller-saved registers"></a>2.1 Caller-saved registers</h4><blockquote><p><strong>Caller-saved registers</strong> (AKA <strong>volatile</strong> registers, or <strong>call-clobbered</strong>) are used to hold temporary quantities that need not be preserved across calls.</p></blockquote><p>For that reason, it is the caller’s responsibility to push these registers onto the stack or copy them somewhere else if it wants to restore this value after a procedure call.</p><p>It’s normal to let a <code>call</code> destroy temporary values in these registers, though.</p><h4 id="2-2-Callee-saved-registers"><a href="#2-2-Callee-saved-registers" class="headerlink" title="2.2 Callee-saved registers"></a>2.2 Callee-saved registers</h4><blockquote><p><strong>Callee-saved registers</strong> (AKA <strong>non-volatile</strong> registers, or <strong>call-preserved</strong>) are used to hold long-lived values that should be preserved across calls.</p></blockquote><p>When the caller makes a procedure call, it can expect that those registers will hold the same value after the callee returns, making it the responsibility of the callee to save them and restore them before returning to the caller. Or to not touch them.</p><h3 id="3-Linux-x86-64-function-call"><a href="#3-Linux-x86-64-function-call" class="headerlink" title="3. Linux x86-64 function call"></a>3. Linux x86-64 function call</h3><p><a href="https://www.uclibc.org/docs/psABI-x86_64.pdf" target="_blank" rel="noopener">spec</a></p><h4 id="3-1-Callee-saved-registers"><a href="#3-1-Callee-saved-registers" class="headerlink" title="3.1 Callee-saved registers"></a>3.1 Callee-saved registers</h4><p><img src="/images/2022/01/20.png" alt></p><p><code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code>, <code>rbx</code>, <code>rsp</code>, <code>rbp</code> are the callee-saved registers - they have a “Yes” in the “Preserved across function calls” column.</p><h4 id="3-2-Caller-saved-registers"><a href="#3-2-Caller-saved-registers" class="headerlink" title="3.2 Caller-saved registers"></a>3.2 Caller-saved registers</h4><p><img src="/images/2022/01/21.png" alt></p><h3 id="4-Example"><a href="#4-Example" class="headerlink" title="4. Example"></a>4. Example</h3><h4 id="4-1-setjmp"><a href="#4-1-setjmp" class="headerlink" title="4.1 setjmp"></a>4.1 setjmp</h4><p><a href="https://gitlab.com/kvm-unit-tests/kvm-unit-tests/-/blob/master/lib/x86/setjmp64.S" target="_blank" rel="noopener">https://gitlab.com/kvm-unit-tests/kvm-unit-tests/-/blob/master/lib/x86/setjmp64.S</a></p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.globl setjmp</span><br><span class="line">setjmp:</span><br><span class="line">mov (%rsp), %rsi</span><br><span class="line">mov %rsi, (%rdi)</span><br><span class="line">mov %rsp, <span class="number">0x8</span>(%rdi)</span><br><span class="line">mov %rbp, <span class="number">0x10</span>(%rdi)</span><br><span class="line">mov %rbx, <span class="number">0x18</span>(%rdi)</span><br><span class="line">mov %r12, <span class="number">0x20</span>(%rdi)</span><br><span class="line">mov %r13, <span class="number">0x28</span>(%rdi)</span><br><span class="line">mov %r14, <span class="number">0x30</span>(%rdi)</span><br><span class="line">mov %r15, <span class="number">0x38</span>(%rdi)</span><br><span class="line">xor %eax, %eax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">.globl longjmp</span><br><span class="line">longjmp:</span><br><span class="line">mov %esi, %eax</span><br><span class="line">mov <span class="number">0x38</span>(%rdi), %r15</span><br><span class="line">mov <span class="number">0x30</span>(%rdi), %r14</span><br><span class="line">mov <span class="number">0x28</span>(%rdi), %r13</span><br><span class="line">mov <span class="number">0x20</span>(%rdi), %r12</span><br><span class="line">mov <span class="number">0x18</span>(%rdi), %rbx</span><br><span class="line">mov <span class="number">0x10</span>(%rdi), %rbp</span><br><span class="line">mov <span class="number">0x8</span>(%rdi), %rsp</span><br><span class="line">mov (%rdi), %rsi</span><br><span class="line">mov %rsi, (%rsp)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h4 id="4-2-arch-switch-to"><a href="#4-2-arch-switch-to" class="headerlink" title="4.2 arch_switch_to"></a>4.2 arch_switch_to</h4><p><a href="https://github.com/projectacrn/acrn-hypervisor/blob/release_2.7/hypervisor/arch/x86/sched.S" target="_blank" rel="noopener">https://github.com/projectacrn/acrn-hypervisor/blob/release_2.7/hypervisor/arch/x86/sched.S</a></p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    .text</span><br><span class="line"></span><br><span class="line">   .code64</span><br><span class="line">   .align       <span class="number">8</span></span><br><span class="line">   .global      arch_switch_to</span><br><span class="line">arch_switch_to:</span><br><span class="line">pushf</span><br><span class="line">pushq %rbx</span><br><span class="line">pushq %rbp</span><br><span class="line">pushq %r12</span><br><span class="line">pushq %r13</span><br><span class="line">pushq %r14</span><br><span class="line">pushq %r15</span><br><span class="line">pushq %rdi</span><br><span class="line">movq %rsp, (%rdi)</span><br><span class="line">movq (%rsi), %rsp</span><br><span class="line">popq %rdi</span><br><span class="line">popq %r15</span><br><span class="line">popq %r14</span><br><span class="line">popq %r13</span><br><span class="line">popq %r12</span><br><span class="line">popq %rbp</span><br><span class="line">popq %rbx</span><br><span class="line">popf</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://stackoverflow.com/questions/9268586/what-are-callee-and-caller-saved-registers" target="_blank" rel="noopener">What are callee and caller saved registers?</a></li><li><a href="https://stackoverflow.com/questions/18024672/what-registers-are-preserved-through-a-linux-x86-64-function-call" target="_blank" rel="noopener">What registers are preserved through a linux x86-64 function call</a></li><li><a href="https://www.cs.virginia.edu/~evans/cs216/guides/x86.html" target="_blank" rel="noopener">x86 Assembly Guide</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The introduction to caller-saved registers and callee-saved registers.
    
    </summary>
    
      <category term="计算机编程" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机编程" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LAPIC pass-thru in ACRN hypervisor</title>
    <link href="http://liujunming.github.io/2022/01/10/LAPIC-pass-thru-in-ACRN-hypervisor/"/>
    <id>http://liujunming.github.io/2022/01/10/LAPIC-pass-thru-in-ACRN-hypervisor/</id>
    <published>2022-01-10T01:17:14.000Z</published>
    <updated>2022-01-10T10:04:37.955Z</updated>
    
    <content type="html"><![CDATA[<p>How ACRN pass-thru LAPIC?<a id="more"></a></p><h3 id="LAPIC-Passthrough-Based-on-vLAPIC"><a href="#LAPIC-Passthrough-Based-on-vLAPIC" class="headerlink" title="LAPIC Passthrough Based on vLAPIC"></a>LAPIC Passthrough Based on vLAPIC</h3><p>LAPIC passthrough is supported based on vLAPIC, the guest OS first boots with vLAPIC in xAPIC mode and then switches to x2APIC mode to enable the LAPIC passthrough.</p><p>In case of LAPIC passthrough based on vLAPIC, the system will have the following characteristics.</p><ul><li>IRQs received by the LAPIC can be handled by the Guest VM without <code>vmexit</code></li><li>Guest VM always see virtual LAPIC IDs for security consideration</li><li>most MSRs are directly accessible from Guest VM except for <code>XAPICID</code>, <code>LDR</code> and <code>ICR</code>. Write operations to <code>ICR</code> will be trapped to avoid malicious IPIs. Read operations to <code>XAPIC</code> and <code>LDR</code> will be trapped in order to make the Guest VM always see the virtual LAPIC IDs instead of the physical ones.</li></ul><h3 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code"></a>Source code</h3><ul><li><a href="https://github.com/projectacrn/acrn-hypervisor/blob/release_2.7/hypervisor/arch/x86/guest/vmsr.c#L1168-L1187" target="_blank" rel="noopener">update_msr_bitmap_x2apic_passthru</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * After switch to x2apic mode, most MSRs are passthrough to guest, but vlapic is still valid</span></span><br><span class="line"><span class="comment"> * for virtualization of some MSRs for security consideration:</span></span><br><span class="line"><span class="comment"> * - XAPICID/LDR: Read to XAPICID/LDR need to be trapped to guarantee guest always see right vlapic_id.</span></span><br><span class="line"><span class="comment"> * - ICR: Write to ICR need to be trapped to avoid milicious IPI.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @pre vcpu != NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_msr_bitmap_x2apic_passthru</span><span class="params">(struct acrn_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint8_t</span> *msr_bitmap = vcpu-&gt;arch.msr_bitmap;</span><br><span class="line"></span><br><span class="line">intercept_x2apic_msrs(msr_bitmap, INTERCEPT_DISABLE);</span><br><span class="line">enable_msr_interception(msr_bitmap, MSR_IA32_EXT_XAPICID, INTERCEPT_READ);</span><br><span class="line">enable_msr_interception(msr_bitmap, MSR_IA32_EXT_APIC_LDR, INTERCEPT_READ);</span><br><span class="line">enable_msr_interception(msr_bitmap, MSR_IA32_EXT_APIC_ICR, INTERCEPT_WRITE);</span><br><span class="line">set_tsc_msr_interception(vcpu, exec_vmread64(VMX_TSC_OFFSET_FULL) != <span class="number">0U</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/projectacrn/acrn-hypervisor/blob/release_2.7/hypervisor/arch/x86/guest/vlapic.c#L2150-L2166" target="_blank" rel="noopener">vlapic_x2apic_write</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> vlapic_x2apic_write(struct acrn_vcpu *vcpu, <span class="keyword">uint32_t</span> msr, <span class="keyword">uint64_t</span> val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acrn_vlapic</span> *<span class="title">vlapic</span>;</span></span><br><span class="line"><span class="keyword">uint32_t</span> offset;</span><br><span class="line"><span class="keyword">int32_t</span> error = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If vLAPIC is in xAPIC mode and guest tries to access x2APIC MSRs</span></span><br><span class="line"><span class="comment"> * inject a GP to guest</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vlapic = vcpu_vlapic(vcpu);</span><br><span class="line"><span class="keyword">if</span> (is_x2apic_enabled(vlapic)) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_lapic_pt_configured(vcpu-&gt;vm)) &#123;</span><br><span class="line"><span class="keyword">switch</span> (msr) &#123;</span><br><span class="line"><span class="keyword">case</span> MSR_IA32_EXT_APIC_ICR:</span><br><span class="line">error = vlapic_x2apic_pt_icr_access(vcpu, val);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/projectacrn/acrn-hypervisor/blob/release_2.7/hypervisor/arch/x86/guest/vlapic.c#L2116-L2148" target="_blank" rel="noopener">vlapic_x2apic_read</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> vlapic_x2apic_read(struct acrn_vcpu *vcpu, <span class="keyword">uint32_t</span> msr, <span class="keyword">uint64_t</span> *val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acrn_vlapic</span> *<span class="title">vlapic</span>;</span></span><br><span class="line"><span class="keyword">uint32_t</span> offset;</span><br><span class="line"><span class="keyword">int32_t</span> error = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If vLAPIC is in xAPIC mode and guest tries to access x2APIC MSRs</span></span><br><span class="line"><span class="comment"> * inject a GP to guest</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vlapic = vcpu_vlapic(vcpu);</span><br><span class="line"><span class="keyword">if</span> (is_x2apic_enabled(vlapic)) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_lapic_pt_configured(vcpu-&gt;vm)) &#123;</span><br><span class="line"><span class="keyword">switch</span> (msr) &#123;</span><br><span class="line"><span class="keyword">case</span> MSR_IA32_EXT_APIC_LDR:</span><br><span class="line"><span class="keyword">case</span> MSR_IA32_EXT_XAPICID:</span><br><span class="line">offset = x2apic_msr_to_regoff(msr);</span><br><span class="line">error = vlapic_read(vlapic, offset, val);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">pr_err(<span class="string">"%s: unexpected MSR[0x%x] read with lapic_pt"</span>, __func__, msr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">offset = x2apic_msr_to_regoff(msr);</span><br><span class="line"><span class="keyword">if</span> (vlapic-&gt;ops-&gt;x2apic_read_msr_may_valid(offset)) &#123;</span><br><span class="line">error = vlapic_read(vlapic, offset, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://projectacrn.github.io/latest/developer-guides/hld/hv-virt-interrupt.html#lapic-passthrough-based-on-vlapic" target="_blank" rel="noopener">LAPIC Passthrough Based on vLAPIC</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;How ACRN pass-thru LAPIC?
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Segment protection:CPL,DPL and RPL</title>
    <link href="http://liujunming.github.io/2022/01/09/Segment-protection-CPL-DPL-and-RPL/"/>
    <id>http://liujunming.github.io/2022/01/09/Segment-protection-CPL-DPL-and-RPL/</id>
    <published>2022-01-09T06:33:15.000Z</published>
    <updated>2022-01-09T07:27:29.981Z</updated>
    
    <content type="html"><![CDATA[<p>本文将总结Segment protection:CPL,DPL and RPL相关知识点。<a id="more"></a></p><h3 id="1-CPL-DPL-and-RPL"><a href="#1-CPL-DPL-and-RPL" class="headerlink" title="1. CPL,DPL and RPL"></a>1. CPL,DPL and RPL</h3><h4 id="1-1-CPL"><a href="#1-1-CPL" class="headerlink" title="1.1 CPL"></a>1.1 CPL</h4><p><strong>Current privilege level (CPL) field</strong> — (Bits 0 and 1 of the CS segment register.) Indicates the privilege level of the currently executing program or procedure. The term current privilege level (CPL) refers to the setting of this field.<br><img src="/images/2022/01/15.png" alt></p><p>当前权限级别（Current Privilege Level，下简称 CPL） ： CPL 表示当前运行的代码的权限。 通过 CS 的 0~1 位两位记录代码的 CPL 值， CPL 可以有 0~3 供 4 个级别，这就是我们常说的 ring 级别（实际上， ring 级别有更广阔的含义）。其中 ring0对应 CPL=0，具有最高权限， 操作系统的内核运行在该权限； ring3 对应 CPL=3，用户程序运行在 ring3。 CPL 值越高权限越低。</p><h4 id="1-2-DPL"><a href="#1-2-DPL" class="headerlink" title="1.2 DPL"></a>1.2 DPL</h4><p><strong>Descriptor privilege level (DPL) field</strong> — (Bits 13 and 14 in the second doubleword of a segment descriptor.) Determines the privilege level of the segment.<br><img src="/images/2022/01/17.png" alt><br>描述符权限级别（Descriptor Privilege Level，下简称 DPL）： DPL 表示段和门所具有的权限。它表示代码访问某个段或通过某个门时所需要的最低权限。例如某个数据段描述符有 DPL=2，则只有 CPL=0、 1、2 的代码可以访问该数据段， CPL=3 的不能访问。</p><h4 id="1-3-RPL"><a href="#1-3-RPL" class="headerlink" title="1.3 RPL"></a>1.3 RPL</h4><p><strong>Requested privilege level (RPL) field</strong> — (Bits 0 and 1 of any segment selector.) Specifies the requested privilege level of a segment selector.<br><img src="/images/2022/01/16.png" alt><br>所要求权限级别（Requested Privilege Level，以下简称 RPL）： RPL 比较特殊，它存在于段寄存器的 0~1 位（注意， CS 寄存器的 0~1 位是 CPL），用于程序在访问段时增加一级检查。</p><h3 id="2-How-to-check"><a href="#2-How-to-check" class="headerlink" title="2. How to check"></a>2. How to check</h3><p>程序访问一个段，要通过段寄存器得到段描述符，这样会产生 2 次检查，参与检查的 3 个属性分别是：程序本身的 CPL、段寄存器的 RPL、段描述符的 DPL。 CPL、DPL、 RPL 组合起来的情况有很多种，但<u>只有当 CPL &lt;= DPL 且 RPL &lt;= DPL 时，访问才被允许</u>，其余情况均被拒绝。通常，可以把 RPL 设置成 0 来简化检查，此时，满足 CPL&lt;= DPL 访问即被允许。</p><p><img src="/images/2022/01/18.png" alt><br><img src="/images/2022/01/19.png" alt></p><h3 id="3-Materials"><a href="#3-Materials" class="headerlink" title="3. Materials"></a>3. Materials</h3><p>详情请参考SDM Vol3 CHAPTER 5 PROTECTION!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将总结Segment protection:CPL,DPL and RPL相关知识点。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Notes for SDM Vol2</title>
    <link href="http://liujunming.github.io/2022/01/09/Notes-for-SDM-Vol2/"/>
    <id>http://liujunming.github.io/2022/01/09/Notes-for-SDM-Vol2/</id>
    <published>2022-01-08T16:11:13.000Z</published>
    <updated>2022-01-08T16:48:09.767Z</updated>
    
    <content type="html"><![CDATA[<p>Notes for SDM Vol2.<a id="more"></a></p><h3 id="AND-NOT"><a href="#AND-NOT" class="headerlink" title="AND NOT"></a>AND NOT</h3><p><img src="/images/2022/01/12.png" alt></p><p>FORCE_INIT ← RFBM AND NOT FORMAT;<br>The expression in C language:<br>FORCE_INIT = RFBM &amp; ( ~FORMAT);</p><h3 id="Opcode-Column-in-the-Instruction-Summary-Table-Instructions-without-VEX-Prefix"><a href="#Opcode-Column-in-the-Instruction-Summary-Table-Instructions-without-VEX-Prefix" class="headerlink" title="Opcode Column in the Instruction Summary Table (Instructions without VEX Prefix)"></a>Opcode Column in the Instruction Summary Table (Instructions without VEX Prefix)</h3><ul><li><code>/digit</code> — A digit between 0 and 7 indicates that the ModR/M byte of the instruction uses only the r/m (register or memory) operand. The reg field contains the digit that provides an extension to the instruction’s opcode.<br><img src="/images/2022/01/13.png" alt><br><img src="/images/2022/01/14.png" alt></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes for SDM Vol2.
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Notes about FPU implementation in Linux kernel</title>
    <link href="http://liujunming.github.io/2022/01/08/Notes-about-FPU-implementation-in-Linux-kernel/"/>
    <id>http://liujunming.github.io/2022/01/08/Notes-about-FPU-implementation-in-Linux-kernel/</id>
    <published>2022-01-08T00:43:20.000Z</published>
    <updated>2022-01-08T09:49:32.476Z</updated>
    
    <content type="html"><![CDATA[<p>本文将结合kernel <a href="https://elixir.bootlin.com/linux/v5.15-rc6/source" target="_blank" rel="noopener">v5.15-rc6</a>，记录下FPU相关的笔记。<a id="more"></a></p><p>建议先阅读<a href="/2021/11/12/Notes-about-XSAVE-feature-set/">Notes about XSAVE feature set</a>。</p><h3 id="TIF-NEED-FPU-LOAD"><a href="#TIF-NEED-FPU-LOAD" class="headerlink" title="TIF_NEED_FPU_LOAD"></a>TIF_NEED_FPU_LOAD</h3><ul><li><p>If <code>TIF_NEED_FPU_LOAD</code> is cleared then the CPU’s FPU registers hold current thread’s FPU registers. </p></li><li><p>If <code>TIF_NEED_FPU_LOAD</code> is set then CPU’s FPU registers may not hold current()’s FPU registers. It is required to load the registers before returning to userland or using the content otherwise.</p></li></ul><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">schedule(kernel/sched/core.c)</span><br><span class="line">    __schedule(kernel/sched/core.c)</span><br><span class="line">    pick_next_task(kernel/sched/core.c)</span><br><span class="line">        context_switch(kernel/sched/core.c)</span><br><span class="line">            switch_to(arch/x86/include/<span class="keyword">asm</span>/switch_to.h)</span><br><span class="line">            __switch_to_asm(arch/x86/entry/entry_64.S)</span><br><span class="line">                    __switch_to(arch/x86/kernel/process_64.c)</span><br><span class="line">                        switch_fpu_prepare</span><br></pre></td></tr></table></figure><h3 id="Defer-FPU-state-load-until-return-to-userspace"><a href="#Defer-FPU-state-load-until-return-to-userspace" class="headerlink" title="Defer FPU state load until return to userspace"></a>Defer FPU state load until return to userspace</h3><p><a href="https://lore.kernel.org/lkml/20181107194858.9380-24-bigeasy@linutronix.de/" target="_blank" rel="noopener">https://lore.kernel.org/lkml/20181107194858.9380-24-bigeasy@linutronix.de/</a></p><p>Idea:Defer loading of FPU state until return to userspace. This gives the kernel the potential to skip loading FPU state for tasks that stay in kernel mode.</p><ul><li>save the FPU register into xsave area for the previous task when task switch occurs</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.15-rc6/source/arch/x86/kernel/process_64.c#L568</span></span><br><span class="line">__switch_to</span><br><span class="line">switch_fpu_prepare</span><br><span class="line">save_fpregs_to_fpstate</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!test_thread_flag(TIF_NEED_FPU_LOAD))</span><br><span class="line">switch_fpu_prepare(prev_fpu, cpu);</span><br></pre></td></tr></table></figure><p>为什么要加<code>!test_thread_flag(TIF_NEED_FPU_LOAD)</code>这一判断呢？<br>因为只有当前cpu fpu的寄存器状态属于previous task时，才能调用switch_fpu_prepare。</p><ul><li>set <code>TIF_NEED_FPU_LOAD</code> for the next task when task switch occurs</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.15-rc6/source/arch/x86/kernel/process_64.c#L623</span></span><br><span class="line">__switch_to</span><br><span class="line">switch_fpu_finish(next_fpu);</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.15-rc6/source/arch/x86/include/asm/fpu/internal.h#L534</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Delay loading of the complete FPU state until the return to userland.</span></span><br><span class="line"><span class="comment"> * PKRU is handled separately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">switch_fpu_finish</span><span class="params">(struct fpu *new_fpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cpu_feature_enabled(X86_FEATURE_FPU))</span><br><span class="line">set_thread_flag(TIF_NEED_FPU_LOAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch-fpu-prepare"><a href="#switch-fpu-prepare" class="headerlink" title="switch_fpu_prepare"></a>switch_fpu_prepare</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.15-rc6/source/arch/x86/include/asm/fpu/internal.h#L508</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * FPU state switching for scheduling.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is a two-stage process:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - switch_fpu_prepare() saves the old state.</span></span><br><span class="line"><span class="comment"> *    This is done within the context of the old process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - switch_fpu_finish() sets TIF_NEED_FPU_LOAD; the floating point state</span></span><br><span class="line"><span class="comment"> *    will get loaded on return to userspace, or when the kernel needs it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If TIF_NEED_FPU_LOAD is cleared then the CPU's FPU registers</span></span><br><span class="line"><span class="comment"> * are saved in the current thread's FPU register state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If TIF_NEED_FPU_LOAD is set then CPU's FPU registers may not</span></span><br><span class="line"><span class="comment"> * hold current()'s FPU registers. It is required to load the</span></span><br><span class="line"><span class="comment"> * registers before returning to userland or using the content</span></span><br><span class="line"><span class="comment"> * otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The FPU context is only stored/restored for a user task and</span></span><br><span class="line"><span class="comment"> * PF_KTHREAD is used to distinguish between kernel and user threads.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">switch_fpu_prepare</span><span class="params">(struct fpu *old_fpu, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (static_cpu_has(X86_FEATURE_FPU) &amp;&amp; !(current-&gt;flags &amp; PF_KTHREAD)) &#123;</span><br><span class="line">save_fpregs_to_fpstate(old_fpu);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The save operation preserved register state, so the</span></span><br><span class="line"><span class="comment"> * fpu_fpregs_owner_ctx is still @old_fpu. Store the</span></span><br><span class="line"><span class="comment"> * current CPU number in @old_fpu, so the next return</span></span><br><span class="line"><span class="comment"> * to user space can avoid the FPU register restore</span></span><br><span class="line"><span class="comment"> * when is returns on the same CPU and still owns the</span></span><br><span class="line"><span class="comment"> * context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">old_fpu-&gt;last_cpu = cpu;</span><br><span class="line"></span><br><span class="line">trace_x86_fpu_regs_deactivated(old_fpu);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exit-to-user-mode"><a href="#exit-to-user-mode" class="headerlink" title="exit to user mode"></a>exit to user mode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exit_to_user_mode_prepare</span><br><span class="line">    arch_exit_to_user_mode_prepare</span><br><span class="line">        switch_fpu_return</span><br><span class="line">        fpregs_restore_userregs</span><br><span class="line">        __restore_fpregs_from_fpstate</span><br><span class="line">        fpregs_activate</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syscall_exit_to_user_mode</span><br><span class="line">    __syscall_exit_to_user_mode_work</span><br><span class="line">        exit_to_user_mode_prepare</span><br><span class="line">            arch_exit_to_user_mode_prepare</span><br><span class="line">__exit_to_user_mode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">irqentry_exit_to_user_mode</span><br><span class="line">__exit_to_user_mode</span><br></pre></td></tr></table></figure><h3 id="fpregs-restore-userregs"><a href="#fpregs-restore-userregs" class="headerlink" title="fpregs_restore_userregs"></a>fpregs_restore_userregs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.15-rc6/source/arch/x86/include/asm/fpu/internal.h#L456</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fpregs_restore_userregs</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">fpu</span> = &amp;<span class="title">current</span>-&gt;<span class="title">thread</span>.<span class="title">fpu</span>;</span></span><br><span class="line"><span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(current-&gt;flags &amp; PF_KTHREAD))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fpregs_state_valid(fpu, cpu)) &#123;</span><br><span class="line">u64 mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This restores _all_ xstate which has not been</span></span><br><span class="line"><span class="comment"> * established yet.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If PKRU is enabled, then the PKRU value is already</span></span><br><span class="line"><span class="comment"> * correct because it was either set in switch_to() or in</span></span><br><span class="line"><span class="comment"> * flush_thread(). So it is excluded because it might be</span></span><br><span class="line"><span class="comment"> * not up to date in current-&gt;thread.fpu.xsave state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mask = xfeatures_mask_restore_user() |</span><br><span class="line">xfeatures_mask_supervisor();</span><br><span class="line">__restore_fpregs_from_fpstate(&amp;fpu-&gt;state, mask);</span><br><span class="line"></span><br><span class="line">fpregs_activate(fpu);</span><br><span class="line">fpu-&gt;last_cpu = cpu;</span><br><span class="line">&#125;</span><br><span class="line">clear_thread_flag(TIF_NEED_FPU_LOAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fpregs_state_valid</span><span class="params">(struct fpu *fpu, <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fpu == this_cpu_read(fpu_fpregs_owner_ctx) &amp;&amp; cpu == fpu-&gt;last_cpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Highest level per task FPU state data structure that</span></span><br><span class="line"><span class="comment"> * contains the FPU register state plus various FPU</span></span><br><span class="line"><span class="comment"> * state fields:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @last_cpu:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Records the last CPU on which this context was loaded into</span></span><br><span class="line"><span class="comment"> * FPU registers. (In the lazy-restore case we might be</span></span><br><span class="line"><span class="comment"> * able to reuse FPU registers across multiple context switches</span></span><br><span class="line"><span class="comment"> * this way, if no intermediate task used the FPU.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A value of -1 is used to indicate that the FPU state in context</span></span><br><span class="line"><span class="comment"> * memory is newer than the FPU state in registers, and that the</span></span><br><span class="line"><span class="comment"> * FPU state should be reloaded next time the task is run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>last_cpu;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @avx512_timestamp:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Records the timestamp of AVX512 use during last context switch.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>avx512_timestamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @state:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In-memory copy of all FPU registers that we save/restore</span></span><br><span class="line"><span class="comment"> * over context switches. If the task is using the FPU then</span></span><br><span class="line"><span class="comment"> * the registers in the FPU are more recent than this state</span></span><br><span class="line"><span class="comment"> * copy. If the task context-switches away then they get</span></span><br><span class="line"><span class="comment"> * saved here and represent the FPU state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">union</span> fpregs_statestate;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * WARNING: 'state' is dynamically-sized.  Do not put</span></span><br><span class="line"><span class="comment"> * anything after it here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fpregs_activate</span><br><span class="line">this_cpu_write(fpu_fpregs_owner_ctx, fpu)</span><br><span class="line"></span><br><span class="line">fpregs_deactivate</span><br><span class="line">this_cpu_write(fpu_fpregs_owner_ctx, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="kernel-fpu-begin-kernel-fpu-end"><a href="#kernel-fpu-begin-kernel-fpu-end" class="headerlink" title="kernel_fpu_begin/kernel_fpu_end"></a>kernel_fpu_begin/kernel_fpu_end</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">kernel_fpu_begin</span><br><span class="line">kernel_fpu_begin_mask(KFPU_MXCSR)</span><br><span class="line">__cpu_invalidate_fpregs_state</span><br><span class="line">__this_cpu_write(fpu_fpregs_owner_ctx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_KTHREAD0x00200000<span class="comment">/* I am a kernel thread */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kernel_fpu_begin_mask</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> kfpu_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">preempt_disable();</span><br><span class="line"></span><br><span class="line">WARN_ON_FPU(!irq_fpu_usable());</span><br><span class="line">WARN_ON_FPU(this_cpu_read(in_kernel_fpu));</span><br><span class="line"></span><br><span class="line">this_cpu_write(in_kernel_fpu, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(current-&gt;flags &amp; PF_KTHREAD) &amp;&amp;</span><br><span class="line">    !test_thread_flag(TIF_NEED_FPU_LOAD)) &#123;</span><br><span class="line">set_thread_flag(TIF_NEED_FPU_LOAD);</span><br><span class="line">save_fpregs_to_fpstate(&amp;current-&gt;thread.fpu);</span><br><span class="line">&#125;</span><br><span class="line">__cpu_invalidate_fpregs_state();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Put sane initial values into the control registers. */</span></span><br><span class="line"><span class="keyword">if</span> (likely(kfpu_mask &amp; KFPU_MXCSR) &amp;&amp; boot_cpu_has(X86_FEATURE_XMM))</span><br><span class="line">ldmxcsr(MXCSR_DEFAULT);</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kernel_fpu_end</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WARN_ON_FPU(!this_cpu_read(in_kernel_fpu));</span><br><span class="line"></span><br><span class="line">this_cpu_write(in_kernel_fpu, <span class="literal">false</span>);</span><br><span class="line">preempt_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将结合kernel &lt;a href=&quot;https://elixir.bootlin.com/linux/v5.15-rc6/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v5.15-rc6&lt;/a&gt;，记录下FPU相关的笔记。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>The usage of cpu hot(un)plug in QEMU</title>
    <link href="http://liujunming.github.io/2022/01/07/The-usage-of-cpu-hot-un-plug-in-QEMU/"/>
    <id>http://liujunming.github.io/2022/01/07/The-usage-of-cpu-hot-un-plug-in-QEMU/</id>
    <published>2022-01-07T06:48:33.000Z</published>
    <updated>2022-01-07T15:08:48.460Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍在QEMU KVM 环境下，cpu hot(un)plug的使用。<a id="more"></a></p><h3 id="1-Kernel-Configuration"><a href="#1-Kernel-Configuration" class="headerlink" title="1. Kernel Configuration"></a>1. Kernel Configuration</h3><p>To use the cpu hotplug feature,  need to select the following items:</p><ul><li>CONFIG_SMP</li><li>CONFIG_HOTPLUG_CPU</li><li>CONFIG_ACPI_HOTPLUG_CPU</li></ul><h3 id="2-QEMU-launch-script-setting"><a href="#2-QEMU-launch-script-setting" class="headerlink" title="2. QEMU launch script setting"></a>2. QEMU launch script setting</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu [...] -smp 1,maxcpus=4 -qmp unix:/tmp/qmp-sock,server=on,wait=off</span><br></pre></td></tr></table></figure><p>note that the “maxcpus” is mandatory to allow vCPU hotplug.</p><h3 id="3-Run-‘qmp-shell’"><a href="#3-Run-‘qmp-shell’" class="headerlink" title="3. Run ‘qmp-shell’"></a>3. Run ‘qmp-shell’</h3><p>Run ‘qmp-shell’ (located in the source tree, under: “scripts/qmp/“) to connect to the just-launched QEMU:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./qmp-shell -p -v /tmp/qmp-sock</span><br><span class="line">Welcome to the QMP low-level shell!</span><br><span class="line">Connected to QEMU 5.1.0</span><br><span class="line"></span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure></p><h3 id="4-Find-out-which-CPU-types-could-be-plugged-and-into-which-sockets"><a href="#4-Find-out-which-CPU-types-could-be-plugged-and-into-which-sockets" class="headerlink" title="4. Find out which CPU types could be plugged, and into which sockets:"></a>4. Find out which CPU types could be plugged, and into which sockets:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">(QEMU) query-hotpluggable-cpus</span><br><span class="line">&#123;</span><br><span class="line">    &quot;execute&quot;: &quot;query-hotpluggable-cpus&quot;,</span><br><span class="line">    &quot;arguments&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;return&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 3</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;vcpus-count&quot;: 1,</span><br><span class="line">            &quot;type&quot;: &quot;host-x86_64-cpu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 2</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;vcpus-count&quot;: 1,</span><br><span class="line">            &quot;type&quot;: &quot;host-x86_64-cpu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 1</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;vcpus-count&quot;: 1,</span><br><span class="line">            &quot;type&quot;: &quot;host-x86_64-cpu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;vcpus-count&quot;: 1,</span><br><span class="line">            &quot;qom-path&quot;: &quot;/machine/unattached/device[0]&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;host-x86_64-cpu&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure><p>The <code>query-hotpluggable-cpus</code> command returns an object for CPUs that are present (containing a “qom-path” member) or which may be hot-plugged (no “qom-path” member). From the output, we can see that <code>host-x86_64-cpu</code> is present in socket 0, while hot-plugging a CPU into socket 1 requires passing the listed properties to QMP <code>device_add</code>.</p><h3 id="5-Hotplug"><a href="#5-Hotplug" class="headerlink" title="5. Hotplug"></a>5. Hotplug</h3><p>Before  running <code>device_add</code>, run the following command lines.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /sys/devices/system/cpu</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">cpu0</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(QEMU) query-cpus-fast</span><br><span class="line">&#123;</span><br><span class="line">    &quot;execute&quot;: &quot;query-cpus-fast&quot;,</span><br><span class="line">    &quot;arguments&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;return&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;arch&quot;: &quot;x86&quot;,</span><br><span class="line">            &quot;thread-id&quot;: 20077,</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;qom-path&quot;: &quot;/machine/unattached/device[0]&quot;,</span><br><span class="line">            &quot;cpu-index&quot;: 0,</span><br><span class="line">            &quot;target&quot;: &quot;x86_64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure><p>CPU hot-add:<br><strong><em>{ ‘command’: ‘device_add’, ‘data’: {‘driver’: ‘str’, ‘id’: ‘str’, … }}</em></strong></p><ul><li>mandatory properties for every CPU<ul><li>driver: cpu model type name</li><li>id: unique device name</li></ul></li><li>target/configuration dependent properties<ul><li>socket-id: socket number in range [0..max sockets)</li><li>core-id: core number in range [0..max cores)</li><li>thread-id: thread-id in range [..max threads)</li><li>node-id: NUMA node ID the CPU belongs to</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(QEMU) device_add driver=host-x86_64-cpu socket-id=1 core-id=0 thread-id=0 id=cpu2</span><br><span class="line">&#123;</span><br><span class="line">    &quot;execute&quot;: &quot;device_add&quot;,</span><br><span class="line">    &quot;arguments&quot;: &#123;</span><br><span class="line">        &quot;driver&quot;: &quot;host-x86_64-cpu&quot;,</span><br><span class="line">        &quot;socket-id&quot;: 1,</span><br><span class="line">        &quot;core-id&quot;: 0,</span><br><span class="line">        &quot;thread-id&quot;: 0,</span><br><span class="line">        &quot;id&quot;: &quot;cpu2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;return&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure><p>After  running <code>device_add</code>, run the following command lines.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /sys/devices/system/cpu</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">cpu0</span><br><span class="line">cpu1</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(QEMU) query-cpus-fast</span><br><span class="line">&#123;</span><br><span class="line">    &quot;execute&quot;: &quot;query-cpus-fast&quot;,</span><br><span class="line">    &quot;arguments&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;return&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;arch&quot;: &quot;x86&quot;,</span><br><span class="line">            &quot;thread-id&quot;: 20077,</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;qom-path&quot;: &quot;/machine/unattached/device[0]&quot;,</span><br><span class="line">            &quot;cpu-index&quot;: 0,</span><br><span class="line">            &quot;target&quot;: &quot;x86_64&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;arch&quot;: &quot;x86&quot;,</span><br><span class="line">            &quot;thread-id&quot;: 20117,</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 1</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;qom-path&quot;: &quot;/machine/peripheral/cpu2&quot;,</span><br><span class="line">            &quot;cpu-index&quot;: 1,</span><br><span class="line">            &quot;target&quot;: &quot;x86_64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure><p><strong>Optionally online newly added CPU inside guest</strong><br>Linux kernel doesn’t online hot-added CPUs automatically. Once CPU is hot-added it should be onlined using an appropriate udev script or manually by issuing a following command:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/devices/system/cpu/cpu1/online</span><br></pre></td></tr></table></figure></p><h3 id="6-Hotunplug"><a href="#6-Hotunplug" class="headerlink" title="6. Hotunplug"></a>6. Hotunplug</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(QEMU) device_del id=cpu2</span><br><span class="line">&#123;</span><br><span class="line">    &quot;execute&quot;: &quot;device_del&quot;,</span><br><span class="line">    &quot;arguments&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;cpu2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;return&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure><p>After  running <code>device_del</code>, run the following command lines.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /sys/devices/system/cpu</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">cpu0</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(QEMU) query-cpus-fast</span><br><span class="line">&#123;</span><br><span class="line">    &quot;execute&quot;: &quot;query-cpus-fast&quot;,</span><br><span class="line">    &quot;arguments&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;return&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;arch&quot;: &quot;x86&quot;,</span><br><span class="line">            &quot;thread-id&quot;: 20077,</span><br><span class="line">            &quot;props&quot;: &#123;</span><br><span class="line">                &quot;core-id&quot;: 0,</span><br><span class="line">                &quot;thread-id&quot;: 0,</span><br><span class="line">                &quot;socket-id&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;qom-path&quot;: &quot;/machine/unattached/device[0]&quot;,</span><br><span class="line">            &quot;cpu-index&quot;: 0,</span><br><span class="line">            &quot;target&quot;: &quot;x86_64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">(QEMU)</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://qemu.readthedocs.io/en/latest/system/cpu-hotplug.html" target="_blank" rel="noopener">Virtual CPU hotplug</a></li><li><a href="https://wiki.qemu.org/Features/CPUHotplug" target="_blank" rel="noopener">Features/CPUHotplug</a></li><li><a href="http://events17.linuxfoundation.org/sites/events/files/slides/CPU%20Hot-plug%20support%20in%20QEMU.pdf" target="_blank" rel="noopener">QEMU CPU Hotplug</a></li><li><a href="https://github.com/esminc/qemu/blob/master/Source/device-qemu/android/android-goldfish-2.6.29/Documentation/cpu-hotplug.txt" target="_blank" rel="noopener">cpu-hotplug.txt</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍在QEMU KVM 环境下，cpu hot(un)plug的使用。
    
    </summary>
    
      <category term="QEMU" scheme="http://liujunming.github.io/categories/QEMU/"/>
    
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="hotplug" scheme="http://liujunming.github.io/tags/hotplug/"/>
    
  </entry>
  
  <entry>
    <title>The usage of memory hot(un)plug in QEMU</title>
    <link href="http://liujunming.github.io/2022/01/07/The-usage-of-memory-hotplug-under-QEMU-KVM/"/>
    <id>http://liujunming.github.io/2022/01/07/The-usage-of-memory-hotplug-under-QEMU-KVM/</id>
    <published>2022-01-06T16:27:39.000Z</published>
    <updated>2022-01-07T15:08:48.461Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍在QEMU KVM 环境下，memory hot(un)plug的使用。<a id="more"></a></p><h3 id="1-Kernel-Configuration"><a href="#1-Kernel-Configuration" class="headerlink" title="1. Kernel Configuration"></a>1. Kernel Configuration</h3><p>To use the memory hotplug feature, <code>CONFIG_ACPI_HOTPLUG_MEMORY</code> should be selected.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /boot/config-5.4.0-92-generic | grep CONFIG_ACPI_HOTPLUG_MEMORY</span><br><span class="line">CONFIG_ACPI_HOTPLUG_MEMORY=y</span><br></pre></td></tr></table></figure></p><h3 id="2-QEMU-launch-script-setting"><a href="#2-QEMU-launch-script-setting" class="headerlink" title="2. QEMU launch script setting"></a>2. QEMU launch script setting</h3><p>In order to be able to hotplug memory, QEMU has to be told how many hotpluggable memory slots to create and what is the maximum amount of memory the guest can grow. This is done at startup time by means of the <code>-m</code> command-line option, which has the following format:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-m [size=]megs[,slots=n,maxmem=size]</span><br></pre></td></tr></table></figure></p><p>Where,</p><ul><li>“megs” is the startup RAM. It is the RAM the guest will boot with</li><li>“slots” is the number of hotpluggable memory slots</li><li>“maxmem” is the maximum RAM size the guest can have</li></ul><p>For example, the following command-line:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu [...] -m 1G,slots=3,maxmem=4G</span><br></pre></td></tr></table></figure></p><p>Creates a guest with 1GB of memory and three hotpluggable memory slots. The hotpluggable memory slots are empty when the guest is booted, so all memory the guest will see after boot is 1GB. The maximum memory the guest can reach is 4GB. This means that three additional gigabytes can be hotplugged by using any combination of the available memory slots.</p><h3 id="3-Hotplug"><a href="#3-Hotplug" class="headerlink" title="3. Hotplug"></a>3. Hotplug</h3><p>Before  running <code>device_add</code>, run the following command lines.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/meminfo | head -2</span><br><span class="line">MemTotal:         727172 kB</span><br><span class="line">MemFree:           59700 kB</span><br><span class="line">$ ls /sys/devices/system/memory/ | grep memory</span><br><span class="line">memory0</span><br><span class="line">memory1</span><br><span class="line">memory2</span><br><span class="line">memory3</span><br><span class="line">memory4</span><br><span class="line">memory5</span><br><span class="line">memory6</span><br><span class="line">memory7</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(qemu) object_add memory-backend-ram,id=mem1,size=1G</span><br><span class="line">(qemu) device_add pc-dimm,id=dimm1,memdev=mem1</span><br></pre></td></tr></table></figure><p>After  running <code>device_add</code>, run the following command lines.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/meminfo | head -2</span><br><span class="line">MemTotal:        1785560 kB</span><br><span class="line">MemFree:         1115004 kB</span><br><span class="line">$ ls /sys/devices/system/memory/ | grep memory</span><br><span class="line">memory0</span><br><span class="line">memory1</span><br><span class="line">memory2</span><br><span class="line">memory3</span><br><span class="line">memory32</span><br><span class="line">memory33</span><br><span class="line">memory34</span><br><span class="line">memory35</span><br><span class="line">memory36</span><br><span class="line">memory37</span><br><span class="line">memory38</span><br><span class="line">memory39</span><br><span class="line">memory4</span><br><span class="line">memory5</span><br><span class="line">memory6</span><br><span class="line">memory7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ cat /sys/devices/system/memory/memory33/state</span><br><span class="line">online</span><br></pre></td></tr></table></figure></p><h3 id="4-Hotunplug"><a href="#4-Hotunplug" class="headerlink" title="4. Hotunplug"></a>4. Hotunplug</h3><p>You may need to add <code>movable_node</code> in guest kernel command line firstly!</p><p>In order to be able to hot unplug pc-dimm device, QEMU has to be told the ids of pc-dimm device and memory backend object. The ids were assigned when you hot plugged memory.</p><p>Two monitor commands are used to hot unplug memory:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- &quot;device_del&quot;: deletes a front-end pc-dimm device</span><br><span class="line">- &quot;object_del&quot;: deletes a memory backend object</span><br></pre></td></tr></table></figure></p><p>For example, assuming that the pc-dimm device with id “dimm1” exists, and its memory backend is “mem1”, the following commands tries to remove it.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(qemu) device_del dimm1</span><br><span class="line">(qemu) object_del mem1</span><br></pre></td></tr></table></figure></p><p>After  running <code>device_del</code>, run the following command lines.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/meminfo | head -2</span><br><span class="line">MemTotal:         736984 kB</span><br><span class="line">MemFree:           87368 kB</span><br><span class="line">$ ls /sys/devices/system/memory/ | grep memory</span><br><span class="line">memory0</span><br><span class="line">memory1</span><br><span class="line">memory2</span><br><span class="line">memory3</span><br><span class="line">memory4</span><br><span class="line">memory5</span><br><span class="line">memory6</span><br><span class="line">memory7</span><br></pre></td></tr></table></figure></p><hr><p>参考资料:</p><ol><li><a href="https://github.com/qemu/qemu/blob/master/docs/memory-hotplug.txt" target="_blank" rel="noopener">QEMU memory hotplug</a></li><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/memory-hotplug.html" target="_blank" rel="noopener">kernel doc Memory Hot(Un)Plug</a></li><li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1674497" target="_blank" rel="noopener">Memory Hot-unplug fails to remove DIMM</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍在QEMU KVM 环境下，memory hot(un)plug的使用。
    
    </summary>
    
      <category term="QEMU" scheme="http://liujunming.github.io/categories/QEMU/"/>
    
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="hotplug" scheme="http://liujunming.github.io/tags/hotplug/"/>
    
  </entry>
  
  <entry>
    <title>How to fetch mailing list patches</title>
    <link href="http://liujunming.github.io/2022/01/06/How-to-fetch-mailing-list-patches/"/>
    <id>http://liujunming.github.io/2022/01/06/How-to-fetch-mailing-list-patches/</id>
    <published>2022-01-06T06:17:43.000Z</published>
    <updated>2022-01-06T11:45:09.862Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍利用b4来获取mailing list中的patch。<a id="more"></a></p><h3 id="1-Motivation"><a href="#1-Motivation" class="headerlink" title="1. Motivation"></a>1. Motivation</h3><p>如何将mailing list中看到的patch <a href="https://lore.kernel.org/all/20210915095037.1149-1-shameerali.kolothum.thodi@huawei.com/" target="_blank" rel="noopener">https://lore.kernel.org/all/20210915095037.1149-1-shameerali.kolothum.thodi@huawei.com/</a> 下载下来呢？</p><p>b4正式登场！</p><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install b4</span><br></pre></td></tr></table></figure><h3 id="3-Usage"><a href="#3-Usage" class="headerlink" title="3. Usage"></a>3. Usage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ b4 am https://lore.kernel.org/all/20210915095037.1149-1-shameerali.kolothum.thodi@huawei.com</span><br><span class="line"></span><br><span class="line">Grabbing thread from lore.kernel.org/all/20210915095037.1149-1-shameerali.kolothum.thodi%40huawei.com/t.mbox.gz</span><br><span class="line">Analyzing 31 messages in the thread</span><br><span class="line">Checking attestation on all messages, may take a moment...</span><br><span class="line">---</span><br><span class="line">  [PATCH v3 1/6] crypto: hisilicon/qm: Move the QM header to include/linux</span><br><span class="line">  [PATCH v3 2/6] crypto: hisilicon/qm: Move few definitions to common header</span><br><span class="line">  [PATCH v3 3/6] hisi_acc_qm: Move PCI device IDs to common header</span><br><span class="line">  [PATCH v3 4/6] hisi-acc-vfio-pci: add new vfio_pci driver for HiSilicon ACC devices</span><br><span class="line">  [PATCH v3 5/6] hisi_acc_vfio_pci: Restrict access to VF dev BAR2 migration region</span><br><span class="line">  [PATCH v3 6/6] hisi_acc_vfio_pci: Add support for VFIO live migration</span><br><span class="line">---</span><br><span class="line">Total patches: 6</span><br><span class="line">---</span><br><span class="line">Cover: ./v3_20210915_shameerali_kolothum_thodi_vfio_hisilicon_add_acc_live_migration_driver.cover</span><br><span class="line"> Link: https://lore.kernel.org/r/20210915095037.1149-1-shameerali.kolothum.thodi@huawei.com</span><br><span class="line"> Base: not specified</span><br><span class="line">       git am ./v3_20210915_shameerali_kolothum_thodi_vfio_hisilicon_add_acc_live_migration_driver.mbx</span><br></pre></td></tr></table></figure><ul><li>grab the whole thread</li><li>find the latest revision of the series (v3)</li><li>save all patches into a <strong>mbox</strong> file</li><li>save the cover letter into a <strong>cover</strong> file</li><li>show example <code>git am</code> commands</li></ul><hr><p>参考资料:</p><ol><li><a href="https://people.kernel.org/monsieuricon/introducing-b4-and-patch-attestation" target="_blank" rel="noopener">Introducing b4 and patch attestation</a></li><li><a href="https://blog.csdn.net/Rong_Toa/article/details/109693210" target="_blank" rel="noopener">如何跟踪发现Linux内核补丁</a></li><li><a href="https://memcpy.io/applying-mailing-list-patches-with-git-b4.html" target="_blank" rel="noopener">Applying mailing list patches with ‘git b4’</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍利用b4来获取mailing list中的patch。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Dive into Intel int n instruction</title>
    <link href="http://liujunming.github.io/2022/01/06/Dive-into-Intel-int-n-instruction/"/>
    <id>http://liujunming.github.io/2022/01/06/Dive-into-Intel-int-n-instruction/</id>
    <published>2022-01-06T02:09:57.000Z</published>
    <updated>2022-01-07T15:08:48.459Z</updated>
    
    <content type="html"><![CDATA[<p>本文将深入解析Intel <code>int n</code> instruction。<a id="more"></a></p><h3 id="1-Theory"><a href="#1-Theory" class="headerlink" title="1. Theory"></a>1. Theory</h3><p>The <code>int n</code> instruction uses a vector as an argument, which allows a program to call any interrupt handler.<br><img src="/images/2022/01/08.png" alt><br><img src="/images/2022/01/09.png" alt></p><p><a href="/2022/01/06/Dive-into-Intel-iret-instruction/">Dive into Intel iret instruction</a></p><h3 id="2-Source-code-in-KVM-Unit-Tests"><a href="#2-Source-code-in-KVM-Unit-Tests" class="headerlink" title="2. Source code in KVM-Unit-Tests"></a>2. Source code in KVM-Unit-Tests</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USERMODE_STACK_SIZE0x2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RET_TO_KERNEL_IRQ0x20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> run_in_user(usermode_func func, <span class="keyword">unsigned</span> <span class="keyword">int</span> fault_vector,</span><br><span class="line"><span class="keyword">uint64_t</span> arg1, <span class="keyword">uint64_t</span> arg2, <span class="keyword">uint64_t</span> arg3,</span><br><span class="line"><span class="keyword">uint64_t</span> arg4, <span class="keyword">bool</span> *raised_vector)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> ret_to_kernel;</span><br><span class="line"><span class="keyword">uint64_t</span> rax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> user_stack[USERMODE_STACK_SIZE];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">set_idt_entry(RET_TO_KERNEL_IRQ, &amp;ret_to_kernel, <span class="number">3</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Prepare kernel SP for exception handlers */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %%rsp, %[rsp0]\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Load user_ds to DS and ES */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %[user_ds], %%ax\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %%ax, %%ds\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %%ax, %%es\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* IRET into user mode */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pushq %[user_ds]\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pushq %[user_stack_top]\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pushfq\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pushq %[user_cs]\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pushq $user_mode\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"iretq\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"user_mode:\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Back up registers before invoking func */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%rbx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%rcx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%rdx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%r8\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%r9\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%r10\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%r11\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%rdi\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"push %%rsi\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Call user mode function */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %[arg1], %%rdi\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %[arg2], %%rsi\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %[arg3], %%rdx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %[arg4], %%rcx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"call *%[func]\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Restore registers */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%rsi\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%rdi\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%r11\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%r10\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%r9\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%r8\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%rdx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%rcx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"pop %%rbx\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Return to kernel via system call */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"int %[kernel_entry_vector]\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* Kernel Mode */</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"ret_to_kernel:\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">"mov %[rsp0], %%rsp\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">:</span></span></span><br><span class="line">"+a"(rax),</span><br><span class="line">[rsp0]<span class="string">"=m"</span>(tss[<span class="number">0</span>].rsp0)</span><br><span class="line">:</span><br><span class="line">[arg1]<span class="string">"m"</span>(arg1),</span><br><span class="line">[arg2]<span class="string">"m"</span>(arg2),</span><br><span class="line">[arg3]<span class="string">"m"</span>(arg3),</span><br><span class="line">[arg4]<span class="string">"m"</span>(arg4),</span><br><span class="line">[func]<span class="string">"m"</span>(func),</span><br><span class="line">[user_ds]<span class="string">"i"</span>(USER_DS),</span><br><span class="line">[user_cs]<span class="string">"i"</span>(USER_CS),</span><br><span class="line">[user_stack_top]<span class="string">"r"</span>(user_stack +</span><br><span class="line"><span class="keyword">sizeof</span>(user_stack)),</span><br><span class="line">[kernel_entry_vector]<span class="string">"i"</span>(RET_TO_KERNEL_IRQ)</span><br><span class="line">:</span><br><span class="line"><span class="string">"rsi"</span>, <span class="string">"rdi"</span>, <span class="string">"rcx"</span>, <span class="string">"rdx"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-set-idt-entry"><a href="#2-1-set-idt-entry" class="headerlink" title="2.1 set_idt_entry"></a>2.1 set_idt_entry</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set_idt_entry(RET_TO_KERNEL_IRQ, &amp;ret_to_kernel, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_idt_entry</span><span class="params">(<span class="keyword">int</span> vec, <span class="keyword">void</span> *addr, <span class="keyword">int</span> dpl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">idt_entry_t</span> *e = &amp;boot_idt[vec];</span><br><span class="line">    <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span> *e);</span><br><span class="line">    e-&gt;offset0 = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr;</span><br><span class="line">    e-&gt;selector = read_cs();</span><br><span class="line">    e-&gt;ist = <span class="number">0</span>;</span><br><span class="line">    e-&gt;type = <span class="number">14</span>;</span><br><span class="line">    e-&gt;dpl = dpl;</span><br><span class="line">    e-&gt;p = <span class="number">1</span>;</span><br><span class="line">    e-&gt;offset1 = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    e-&gt;offset2 = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr &gt;&gt; <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2022/01/10.png" alt></p><h4 id="2-2-int-n"><a href="#2-2-int-n" class="headerlink" title="2.2 int n"></a>2.2 int n</h4><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return to kernel via system call */</span></span><br><span class="line"><span class="string">"int %[kernel_entry_vector]\n\t"</span></span><br><span class="line"><span class="comment">/* Kernel Mode */</span></span><br><span class="line"><span class="string">"ret_to_kernel:\n\t"</span></span><br><span class="line"><span class="string">"mov %[rsp0], %%rsp\n\t"</span></span><br><span class="line">:</span><br><span class="line"><span class="string">"+a"</span>(rax),</span><br><span class="line">[rsp0]<span class="string">"=m"</span>(tss[<span class="number">0</span>].rsp0)</span><br></pre></td></tr></table></figure><p>Why handler is <code>mov %[rsp0], %%rsp</code>?<br><img src="/images/2022/01/11.png" alt><br>processor会操作内核栈，rsp会发生变化，而handler则将rsp恢复到正确的状态。</p><h4 id="2-3-tss-0-rsp0"><a href="#2-3-tss-0-rsp0" class="headerlink" title="2.3 tss[0].rsp0"></a>2.3 tss[0].rsp0</h4><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"mov %%rsp, %[rsp0]\n\t"</span></span><br><span class="line">:: </span><br><span class="line">[rsp0]<span class="string">"=m"</span>(tss[<span class="number">0</span>].rsp0)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  __<span class="title">attribute__</span>((<span class="title">packed</span>)) &#123;</span></span><br><span class="line">u32 res1;</span><br><span class="line">u64 rsp0;</span><br><span class="line">u64 rsp1;</span><br><span class="line">u64 rsp2;</span><br><span class="line">u64 res2;</span><br><span class="line">u64 ist1;</span><br><span class="line">u64 ist2;</span><br><span class="line">u64 ist3;</span><br><span class="line">u64 ist4;</span><br><span class="line">u64 ist5;</span><br><span class="line">u64 ist6;</span><br><span class="line">u64 ist7;</span><br><span class="line">u64 res3;</span><br><span class="line">u16 res4;</span><br><span class="line">u16 iomap_base;</span><br><span class="line">&#125; <span class="keyword">tss64_t</span>;</span><br></pre></td></tr></table></figure><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>掌握住<code>int n</code> instruction的Operation即可！<br>详情当然是参考Intel SDM Vol2 INSTRUCTION SET REFERENCE!</p><p>要点：</p><ul><li>用户栈切换到内核栈</li><li>设置好IDT entry<ul><li>handler(rip)</li><li>dpl(is 3)</li><li>selector(kernel code segment)</li><li>…</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将深入解析Intel &lt;code&gt;int n&lt;/code&gt; instruction。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>Dive into Intel iret instruction</title>
    <link href="http://liujunming.github.io/2022/01/06/Dive-into-Intel-iret-instruction/"/>
    <id>http://liujunming.github.io/2022/01/06/Dive-into-Intel-iret-instruction/</id>
    <published>2022-01-06T02:08:41.000Z</published>
    <updated>2022-01-06T11:45:09.862Z</updated>
    
    <content type="html"><![CDATA[<p>本文将深入解析Intel <code>iret</code> instruction。<a id="more"></a></p><h3 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h3><p>建议读者阅读下<a href="/2020/01/16/浅谈栈/">浅谈栈</a> 与<a href="/2020/01/18/浅谈tss/">浅谈tss</a>。</p><h3 id="2-Materials"><a href="#2-Materials" class="headerlink" title="2. Materials"></a>2. Materials</h3><p>最权威的资料，值得读者细品。</p><ul><li>Intel SDM Vol1 CHAPTER 6 PROCEDURE CALLS, INTERRUPTS, AND EXCEPTIONS</li><li>Intel SDM Vol2 INSTRUCTION SET REFERENCE</li></ul><h3 id="3-Theory"><a href="#3-Theory" class="headerlink" title="3. Theory"></a>3. Theory</h3><p><img src="/images/2022/01/04.png" alt></p><p><img src="/images/2022/01/05.png" alt></p><p><img src="/images/2022/01/06.png" alt></p><h3 id="4-Example-in-kvm-unit-test"><a href="#4-Example-in-kvm-unit-test" class="headerlink" title="4. Example in kvm unit test"></a>4. Example in kvm unit test</h3><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">asm volatile (</span><br><span class="line"><span class="comment">/* Prepare kernel SP for exception handlers */</span></span><br><span class="line"><span class="string">"mov %%rsp, %[rsp0]\n\t"</span></span><br><span class="line"><span class="comment">/* Load user_ds to DS and ES */</span></span><br><span class="line"><span class="string">"mov %[user_ds], %%ax\n\t"</span></span><br><span class="line"><span class="string">"mov %%ax, %%ds\n\t"</span></span><br><span class="line"><span class="string">"mov %%ax, %%es\n\t"</span></span><br><span class="line"><span class="comment">/* IRET into user mode */</span></span><br><span class="line"><span class="string">"pushq %[user_ds]\n\t"</span></span><br><span class="line"><span class="string">"pushq %[user_stack_top]\n\t"</span></span><br><span class="line"><span class="string">"pushfq\n\t"</span></span><br><span class="line"><span class="string">"pushq %[user_cs]\n\t"</span></span><br><span class="line"><span class="string">"pushq $user_mode\n\t"</span></span><br><span class="line"><span class="string">"iretq\n"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"user_mode:\n\t"</span></span><br><span class="line"><span class="comment">/* Back up registers before invoking func */</span></span><br><span class="line"><span class="string">"push %%rbx\n\t"</span></span><br><span class="line"><span class="string">"push %%rcx\n\t"</span></span><br><span class="line"><span class="string">"push %%rdx\n\t"</span></span><br><span class="line"><span class="string">"push %%r8\n\t"</span></span><br><span class="line"><span class="string">"push %%r9\n\t"</span></span><br><span class="line"><span class="string">"push %%r10\n\t"</span></span><br><span class="line"><span class="string">"push %%r11\n\t"</span></span><br><span class="line"><span class="string">"push %%rdi\n\t"</span></span><br><span class="line"><span class="string">"push %%rsi\n\t"</span></span><br><span class="line"><span class="comment">/* Call user mode function */</span></span><br><span class="line"><span class="string">"mov %[arg1], %%rdi\n\t"</span></span><br><span class="line"><span class="string">"mov %[arg2], %%rsi\n\t"</span></span><br><span class="line"><span class="string">"mov %[arg3], %%rdx\n\t"</span></span><br><span class="line"><span class="string">"mov %[arg4], %%rcx\n\t"</span></span><br><span class="line"><span class="string">"call *%[func]\n\t"</span></span><br><span class="line"><span class="comment">/* Restore registers */</span></span><br><span class="line"><span class="string">"pop %%rsi\n\t"</span></span><br><span class="line"><span class="string">"pop %%rdi\n\t"</span></span><br><span class="line"><span class="string">"pop %%r11\n\t"</span></span><br><span class="line"><span class="string">"pop %%r10\n\t"</span></span><br><span class="line"><span class="string">"pop %%r9\n\t"</span></span><br><span class="line"><span class="string">"pop %%r8\n\t"</span></span><br><span class="line"><span class="string">"pop %%rdx\n\t"</span></span><br><span class="line"><span class="string">"pop %%rcx\n\t"</span></span><br><span class="line"><span class="string">"pop %%rbx\n\t"</span></span><br><span class="line"><span class="comment">/* Return to kernel via system call */</span></span><br><span class="line"><span class="string">"int %[kernel_entry_vector]\n\t"</span></span><br><span class="line"><span class="comment">/* Kernel Mode */</span></span><br><span class="line"><span class="string">"ret_to_kernel:\n\t"</span></span><br><span class="line"><span class="string">"mov %[rsp0], %%rsp\n\t"</span></span><br><span class="line">:</span><br><span class="line"><span class="string">"+a"</span>(rax),</span><br><span class="line">[rsp0]<span class="string">"=m"</span>(tss[<span class="number">0</span>].rsp0)</span><br><span class="line">:</span><br><span class="line">[arg1]<span class="string">"m"</span>(arg1),</span><br><span class="line">[arg2]<span class="string">"m"</span>(arg2),</span><br><span class="line">[arg3]<span class="string">"m"</span>(arg3),</span><br><span class="line">[arg4]<span class="string">"m"</span>(arg4),</span><br><span class="line">[func]<span class="string">"m"</span>(func),</span><br><span class="line">[user_ds]<span class="string">"i"</span>(USER_DS),</span><br><span class="line">[user_cs]<span class="string">"i"</span>(USER_CS),</span><br><span class="line">[user_stack_top]<span class="string">"r"</span>(user_stack +</span><br><span class="line">sizeof(user_stack)),</span><br><span class="line">[kernel_entry_vector]<span class="string">"i"</span>(RET_TO_KERNEL_IRQ)</span><br><span class="line">:</span><br><span class="line"><span class="string">"rsi"</span>, <span class="string">"rdi"</span>, <span class="string">"rcx"</span>, <span class="string">"rdx"</span>);</span><br></pre></td></tr></table></figure><p>为了能进入user mode，在内核态，进行了如下操作：<br><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Load user_ds to DS and ES */</span></span><br><span class="line"><span class="string">"mov %[user_ds], %%ax\n\t"</span></span><br><span class="line"><span class="string">"mov %%ax, %%ds\n\t"</span></span><br><span class="line"><span class="string">"mov %%ax, %%es\n\t"</span></span><br><span class="line"><span class="comment">/* IRET into user mode */</span></span><br><span class="line"><span class="string">"pushq %[user_ds]\n\t"</span></span><br><span class="line"><span class="string">"pushq %[user_stack_top]\n\t"</span></span><br><span class="line"><span class="string">"pushfq\n\t"</span></span><br><span class="line"><span class="string">"pushq %[user_cs]\n\t"</span></span><br><span class="line"><span class="string">"pushq $user_mode\n\t"</span></span><br><span class="line"><span class="string">"iretq\n"</span></span><br></pre></td></tr></table></figure></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>掌握住<code>iret</code> instruction的Operation即可！<br>详情当然是参考Intel SDM Vol2 INSTRUCTION SET REFERENCE!<br><img src="/images/2022/01/07.png" alt></p><p>建议详细阅读下<a href="https://stackoverflow.com/a/6892934/15530503" target="_blank" rel="noopener">Switching to User-mode using iret</a>！</p><hr><p>参考资料:</p><ol><li><a href="https://stackoverflow.com/questions/6892421/switching-to-user-mode-using-iret" target="_blank" rel="noopener">Switching to User-mode using iret</a></li><li><a href="https://stackoverflow.com/questions/13243958/cpu-switches-from-kernel-mode-to-user-mode-on-x86-when-and-how" target="_blank" rel="noopener">CPU Switches from Kernel mode to User Mode on X86 : When and How?</a></li><li><a href="http://www.jamesmolloy.co.uk/tutorial_html/10.-User%20Mode.html" target="_blank" rel="noopener">jamesmolloy.co.uk User mode</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将深入解析Intel &lt;code&gt;iret&lt;/code&gt; instruction。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>The usage of Intel GS segment</title>
    <link href="http://liujunming.github.io/2022/01/05/The-usage-of-Intel-GS-segment/"/>
    <id>http://liujunming.github.io/2022/01/05/The-usage-of-Intel-GS-segment/</id>
    <published>2022-01-05T07:48:22.000Z</published>
    <updated>2022-01-05T10:08:18.255Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读<a href="https://gitlab.com/kvm-unit-tests/kvm-unit-tests" target="_blank" rel="noopener">KVM-Unit-Tests</a>过程中，看到了<code>asm (&quot;mov %0, %%gs:0&quot; : : &quot;r&quot;(apic_id()) : &quot;memory&quot;);</code>，不是很明白，因此，特此写一篇文章记录下Intel GS segment的相关用法。<a id="more"></a></p><h3 id="1-Description-in-SDM"><a href="#1-Description-in-SDM" class="headerlink" title="1. Description in SDM"></a>1. Description in SDM</h3><p><img src="/images/2022/01/01.png" alt></p><h3 id="2-Usage"><a href="#2-Usage" class="headerlink" title="2. Usage"></a>2. Usage</h3><ul><li>The GS segment can be used for thread local storage.</li><li>The GS segment can be used for per-CPU data.</li></ul><h3 id="3-Source-code-in-KVM-Unit-Tests"><a href="#3-Source-code-in-KVM-Unit-Tests" class="headerlink" title="3. Source code in KVM-Unit-Tests"></a>3. Source code in KVM-Unit-Tests</h3><p>commit id: ca785dae0dd343b1de4b3f5d6c1223d41fbc39e7</p><p><img src="/images/2022/01/03.png" alt><br><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MSR_GS_BASE = <span class="number">0xc0000101</span></span><br><span class="line"></span><br><span class="line">.macro setup_percpu_area</span><br><span class="line">lea <span class="number">-4096</span>(%esp), %eax</span><br><span class="line">mov $<span class="number">0</span>, %edx</span><br><span class="line">mov $MSR_GS_BASE, %ecx</span><br><span class="line">wrmsr</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure></p><p><code>MSR_GS_BASE</code> MSR的描述如下：<br><img src="/images/2022/01/02.png" alt></p><p>stack的layout可以以<code>stacktop</code>为关键字，在<a href="https://gitlab.com/kvm-unit-tests/kvm-unit-tests/-/blob/master/x86/cstart64.S" target="_blank" rel="noopener">cstart64.S</a>中搜索。</p><p>Here’re the example to use GS segment to access per-CPU data:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smp_id</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> (<span class="string">"mov %%gs:0, %0"</span> : <span class="string">"=r"</span>(id));</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_smp_id</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span> (<span class="string">"mov %0, %%gs:0"</span> : : <span class="string">"r"</span>(apic_id()) : <span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>参考资料：</p><ol><li><a href="https://stackoverflow.com/questions/10810203/what-is-the-fs-gs-register-intended-for" target="_blank" rel="noopener">What is the “FS”/“GS” register intended for?</a></li><li><a href="https://stackoverflow.com/questions/9249315/what-is-gs-in-assembly" target="_blank" rel="noopener">What is %gs in Assembly</a></li><li><a href="https://stackoverflow.com/questions/12234817/what-does-this-instruction-do-mov-gs0x14-eax" target="_blank" rel="noopener">what does this instruction do?:- mov %gs:0x14,%eax</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在阅读&lt;a href=&quot;https://gitlab.com/kvm-unit-tests/kvm-unit-tests&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;KVM-Unit-Tests&lt;/a&gt;过程中，看到了&lt;code&gt;asm (&amp;quot;mov %0, %%gs:0&amp;quot; : : &amp;quot;r&amp;quot;(apic_id()) : &amp;quot;memory&amp;quot;);&lt;/code&gt;，不是很明白，因此，特此写一篇文章记录下Intel GS segment的相关用法。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
  <entry>
    <title>MSR management in QEMU/KVM</title>
    <link href="http://liujunming.github.io/2021/12/26/MSR-management-in-QEMU-KVM/"/>
    <id>http://liujunming.github.io/2021/12/26/MSR-management-in-QEMU-KVM/</id>
    <published>2021-12-26T05:37:17.000Z</published>
    <updated>2021-12-27T12:16:38.559Z</updated>
    
    <content type="html"><![CDATA[<p>本文将以<a href="https://gitlab.com/qemu-project/qemu/-/tree/v5.2.0" target="_blank" rel="noopener">QEMU V5.2.0</a>,<a href="https://elixir.bootlin.com/linux/v5.14/source" target="_blank" rel="noopener">kernel  v5.14</a>的源码与SDM的描述，介绍MSR management，具体细节不会一一介绍，但是会点出关键性的内容，读者可以以此为线索，深挖细节。<a id="more"></a></p><h2 id="1-理论基础"><a href="#1-理论基础" class="headerlink" title="1. 理论基础"></a>1. 理论基础</h2><h3 id="1-1-RDMSR-and-WRMSR-instruction"><a href="#1-1-RDMSR-and-WRMSR-instruction" class="headerlink" title="1.1 RDMSR and WRMSR instruction"></a>1.1 RDMSR and WRMSR instruction</h3><ul><li>RDMSR—Read from Model Specific Register<br>EDX:EAX ← MSR[ECX];</li><li>WRMSR—Write to Model Specific Register<br>MSR[ECX] ← EDX:EAX;</li></ul><p>WRMSR与RDMSR类似，受篇幅限制，接下来主要以RDMSR为主。</p><h3 id="1-2-VM-Exit"><a href="#1-2-VM-Exit" class="headerlink" title="1.2 VM Exit"></a>1.2 VM Exit</h3><p>The RDMSR instruction causes a VM exit if any of the following are true:</p><ul><li>The “use MSR bitmaps” VM-execution control is 0.</li><li>The value of ECX is not in the ranges 00000000H – 00001FFFH and C0000000H – C0001FFFH.</li><li>The value of ECX is in the range 00000000H – 00001FFFH and bit n in read bitmap for low MSRs is 1, where n is the value of ECX.</li><li>The value of ECX is in the range C0000000H – C0001FFFH and bit n in read bitmap for high MSRs is 1, where n is the value of ECX &amp; 00001FFFH.</li></ul><h3 id="1-3-MSR-bitmap"><a href="#1-3-MSR-bitmap" class="headerlink" title="1.3 MSR bitmap"></a>1.3 MSR bitmap</h3><p>On processors that support the 1-setting of the “use MSR bitmaps” VM-execution control, the VM-execution control fields include the 64-bit physical address of four contiguous <strong>MSR bitmaps</strong>, which are each 1-KByte in size. This field does not exist on processors that do not support the 1-setting of that control. The four bitmaps are:</p><ul><li><strong>Read bitmap for low MSRs</strong> (located at the MSR-bitmap address). This contains one bit for each MSR address in the range 00000000H to 00001FFFH. The bit determines whether an execution of RDMSR applied to that MSR causes a VM exit.</li><li><strong>Read bitmap for high MSRs</strong> (located at the MSR-bitmap address plus 1024). This contains one bit for each MSR address in the range C0000000H toC0001FFFH. The bit determines whether an execution of RDMSR applied to that MSR causes a VM exit.</li><li><strong>Write bitmap for low MSRs </strong>(located at the MSR-bitmap address plus 2048). This contains one bit for each MSR address in the range 00000000H to 00001FFFH. The bit determines whether an execution of WRMSR applied to that MSR causes a VM exit.</li><li><strong>Write bitmap for high MSRs</strong> (located at the MSR-bitmap address plus 3072). This contains one bit for each MSR address in the range C0000000H toC0001FFFH. The bit determines whether an execution of WRMSR applied to that MSR causes a VM exit.</li></ul><p>A logical processor uses these bitmaps if and only if the “use MSR bitmaps” control is 1. If the bitmaps are used, an execution of RDMSR or WRMSR causes a VM exit if the value of RCX is in neither of the ranges covered by the bitmaps or <u>if the appropriate bit in the MSR bitmaps (corresponding to the instruction and the RCX value) is 1</u>.</p><h3 id="1-4-VM-Exit-Controls-for-MSRs"><a href="#1-4-VM-Exit-Controls-for-MSRs" class="headerlink" title="1.4 VM-Exit Controls for MSRs"></a>1.4 VM-Exit Controls for MSRs</h3><p><img src="/images/2021/12/27.png" alt></p><h3 id="1-5-VM-Entry-Controls-for-MSRs"><a href="#1-5-VM-Entry-Controls-for-MSRs" class="headerlink" title="1.5 VM-Entry Controls for MSRs"></a>1.5 VM-Entry Controls for MSRs</h3><p><img src="/images/2021/12/28.png" alt></p><h2 id="2-Basic-VMX-related-source-code"><a href="#2-Basic-VMX-related-source-code" class="headerlink" title="2. Basic VMX-related source code"></a>2. Basic VMX-related source code</h2><h3 id="2-1-MSR-bitmap"><a href="#2-1-MSR-bitmap" class="headerlink" title="2.1 MSR bitmap"></a>2.1 MSR bitmap</h3><h4 id="2-1-1-空间分配与初始化"><a href="#2-1-1-空间分配与初始化" class="headerlink" title="2.1.1 空间分配与初始化"></a>2.1.1 空间分配与初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kvm_vm_ioct(KVM_CREATE_VCPU)</span><br><span class="line">    kvm_vm_ioctl_create_vcpu</span><br><span class="line">        kvm_arch_vcpu_create</span><br><span class="line">            vmx_create_vcpu[static_call(kvm_x86_vcpu_create)(vcpu)]</span><br><span class="line">                alloc_loaded_vmcs</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个page(4K)的空间给msr bitmap,并将该空间的内容初始化为全1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_loaded_vmcs</span><span class="params">(struct loaded_vmcs *loaded_vmcs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cpu_has_vmx_msr_bitmap()) &#123;</span><br><span class="line">loaded_vmcs-&gt;msr_bitmap = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)</span><br><span class="line">__get_free_page(GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (!loaded_vmcs-&gt;msr_bitmap)</span><br><span class="line"><span class="keyword">goto</span> out_vmcs;</span><br><span class="line"><span class="built_in">memset</span>(loaded_vmcs-&gt;msr_bitmap, <span class="number">0xff</span>, PAGE_SIZE);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-VMCS-field"><a href="#2-1-2-VMCS-field" class="headerlink" title="2.1.2 VMCS field"></a>2.1.2 VMCS field</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmx_create_vcpu</span><br><span class="line">alloc_loaded_vmcs</span><br><span class="line">init_vmcs</span><br><span class="line">vmcs_write64(MSR_BITMAP, __pa(vmx-&gt;vmcs01.msr_bitmap))</span><br></pre></td></tr></table></figure><h3 id="2-2-passthrough-MSR"><a href="#2-2-passthrough-MSR" class="headerlink" title="2.2 passthrough MSR"></a>2.2 passthrough MSR</h3><p><code>vmx_disable_intercept_for_msr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmx_disable_intercept_for_msr</span><span class="params">(struct kvm_vcpu *vcpu, u32 msr, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vcpu_vmx</span> *<span class="title">vmx</span> = <span class="title">to_vmx</span>(<span class="title">vcpu</span>);</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *msr_bitmap = vmx-&gt;vmcs01.msr_bitmap;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mark the desired intercept state in shadow bitmap, this is needed</span></span><br><span class="line"><span class="comment"> * for resync when the MSR filters change.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (is_valid_passthrough_msr(msr)) &#123;</span><br><span class="line"><span class="keyword">int</span> idx = possible_passthrough_msr_slot(msr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (idx != -ENOENT) &#123;</span><br><span class="line"><span class="keyword">if</span> (type &amp; MSR_TYPE_R)</span><br><span class="line">clear_bit(idx, vmx-&gt;shadow_msr_intercept.read);</span><br><span class="line"><span class="keyword">if</span> (type &amp; MSR_TYPE_W)</span><br><span class="line">clear_bit(idx, vmx-&gt;shadow_msr_intercept.write);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-MSR-area"><a href="#2-3-MSR-area" class="headerlink" title="2.3 MSR area"></a>2.3 MSR area</h3><p>建议学习下<a href="/2021/03/20/虚拟化学习心得-three-context/">虚拟化学习心得:three context</a> 中MSR area中的motivation。</p><p>以下内容为关键字，读者可去KVM中搜索源码学习。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VM_ENTRY_MSR_LOAD_COUNT</span><br><span class="line">VM_ENTRY_MSR_LOAD_ADDR</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VM_EXIT_MSR_STORE_COUNT</span><br><span class="line">VM_EXIT_MSR_LOAD_COUNT</span><br><span class="line">VM_EXIT_MSR_STORE_ADDR</span><br><span class="line">VM_EXIT_MSR_LOAD_ADDR</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vcpu_vmx</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msr_autoload</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vmx_msrs</span> <span class="title">guest</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vmx_msrs</span> <span class="title">host</span>;</span></span><br><span class="line">&#125; msr_autoload;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msr_autostore</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vmx_msrs</span> <span class="title">guest</span>;</span></span><br><span class="line">&#125; msr_autostore;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-How-KVM-handle-MSR-read"><a href="#3-How-KVM-handle-MSR-read" class="headerlink" title="3. How KVM handle MSR read"></a>3. How KVM handle MSR read</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msr_data</span> &#123;</span></span><br><span class="line"><span class="keyword">bool</span> host_initiated;</span><br><span class="line">u32 index;</span><br><span class="line">u64 data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>host_initiated</strong>:</p><ul><li>true: QEMU fired the call to operate on an MSR reg</li><li>false: guest fired the call to operate on an MSR reg</li></ul><h3 id="3-1-VM-Exit-when-guest-executing-RDMSR-instruction"><a href="#3-1-VM-Exit-when-guest-executing-RDMSR-instruction" class="headerlink" title="3.1 VM Exit when guest executing RDMSR instruction"></a>3.1 VM Exit when guest executing RDMSR instruction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kvm_emulate_rdmsr</span><br><span class="line">kvm_get_msr</span><br><span class="line">kvm_get_msr_ignored_check</span><br><span class="line">__kvm_get_msr</span><br><span class="line">vmx_get_msr[kvm_x86_get_msr]</span><br><span class="line">kvm_get_msr_common</span><br></pre></td></tr></table></figure><p><code>vmx_get_msr</code>处理一部分特殊MSR的读请求,<code>kvm_get_msr_common</code>处理普通MSR的读请求。</p><h3 id="3-2-QEMU-get-MSRs"><a href="#3-2-QEMU-get-MSRs" class="headerlink" title="3.2 QEMU get MSRs"></a>3.2 QEMU get MSRs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kvm_arch_dev_ioctl</span><br><span class="line">msr_io</span><br><span class="line">__msr_io(...,do_get_msr)</span><br><span class="line"></span><br><span class="line">kvm_arch_vcpu_ioctl</span><br><span class="line">msr_io</span><br><span class="line">__msr_io(...,do_get_msr)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do_get_msr</span><br><span class="line">    kvm_get_msr_ignored_check</span><br><span class="line">        __kvm_get_msr</span><br><span class="line">            vmx_get_msr</span><br></pre></td></tr></table></figure><h2 id="4-IOCTL"><a href="#4-IOCTL" class="headerlink" title="4. IOCTL"></a>4. IOCTL</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * List of msr numbers which we expose to userspace through KVM_GET_MSRS</span></span><br><span class="line"><span class="comment"> * and KVM_SET_MSRS, and KVM_GET_MSR_INDEX_LIST.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The three MSR lists(msrs_to_save, emulated_msrs, msr_based_features)</span></span><br><span class="line"><span class="comment"> * extract the supported MSRs from the related const lists.</span></span><br><span class="line"><span class="comment"> * msrs_to_save is selected from the msrs_to_save_all to reflect the</span></span><br><span class="line"><span class="comment"> * capabilities of the host cpu. This capabilities test skips MSRs that are</span></span><br><span class="line"><span class="comment"> * kvm-specific. Those are put in emulated_msrs_all; filtering of emulated_msrs</span></span><br><span class="line"><span class="comment"> * may depend on host virtualization features rather than host cpu features.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="4-1-KVM-GET-MSR-INDEX-LIST"><a href="#4-1-KVM-GET-MSR-INDEX-LIST" class="headerlink" title="4.1 KVM_GET_MSR_INDEX_LIST"></a>4.1 KVM_GET_MSR_INDEX_LIST</h3><p><code>KVM_GET_MSR_INDEX_LIST</code> returns the guest MSRs that are supported.  The list varies by kvm version and host processor, but does not change otherwise.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QEMU</span></span><br><span class="line">kvm_get_supported_msrs</span><br><span class="line">kvm_ioctl(KVM_GET_MSR_INDEX_LIST)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KVM</span></span><br><span class="line">kvm_arch_dev_ioctl(KVM_GET_MSR_INDEX_LIST)</span><br><span class="line">msrs_to_save</span><br><span class="line">emulated_msrs</span><br></pre></td></tr></table></figure><h3 id="4-2-KVM-GET-MSR-FEATURE-INDEX-LIST"><a href="#4-2-KVM-GET-MSR-FEATURE-INDEX-LIST" class="headerlink" title="4.2 KVM_GET_MSR_FEATURE_INDEX_LIST"></a>4.2 KVM_GET_MSR_FEATURE_INDEX_LIST</h3><p><code>KVM_GET_MSR_FEATURE_INDEX_LIST</code> returns the list of MSRs that can be passed to the <code>KVM_GET_MSRS</code> system ioctl.  This lets userspace probe host capabilities and processor features that are exposed via MSRs (e.g., VMX capabilities).<br>This list also varies by kvm version and host processor, but does not change otherwise.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QEMU</span></span><br><span class="line">kvm_get_supported_feature_msrs</span><br><span class="line">kvm_ioctl(KVM_GET_MSR_FEATURE_INDEX_LIST)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KVM</span></span><br><span class="line">kvm_arch_dev_ioctl(KVM_GET_MSR_INDEX_LIST)</span><br><span class="line">msr_based_features</span><br></pre></td></tr></table></figure><h3 id="4-3-KVM-GET-MSRS"><a href="#4-3-KVM-GET-MSRS" class="headerlink" title="4.3 KVM_GET_MSRS"></a>4.3 KVM_GET_MSRS</h3><p>When used as a system ioctl:<br>Reads the values of MSR-based features that are available for the VM.<br>The list of msr-based features can be obtained using <code>KVM_GET_MSR_FEATURE_INDEX_LIST</code> in a system ioctl.</p><p>When used as a vcpu ioctl:<br>Reads model-specific registers from the vcpu.  Supported msr indices can be obtained using <code>KVM_GET_MSR_INDEX_LIST</code> in a system ioctl.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_msrs</span> &#123;</span></span><br><span class="line">__u32 nmsrs; <span class="comment">/* number of msrs in entries */</span></span><br><span class="line">__u32 pad;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_msr_entry</span> <span class="title">entries</span>[0];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_msr_entry</span> &#123;</span></span><br><span class="line">__u32 index;</span><br><span class="line">__u32 reserved;</span><br><span class="line">__u64 data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Application code should set the <code>nmsrs</code> member (which indicates the size of the entries array) and the <code>index</code> member of each array entry. kvm will fill in the <code>data</code> member.</p><h3 id="4-4-KVM-SET-MSRS"><a href="#4-4-KVM-SET-MSRS" class="headerlink" title="4.4 KVM_SET_MSRS"></a>4.4 KVM_SET_MSRS</h3><p>Writes model-specific registers to the vcpu. </p><p>Application code should set the <code>nmsrs</code> member (which indicates the size of the entries array), and the <code>index</code> and <code>data</code> members of each array entry.</p><hr><p>参考资料:</p><ol><li><a href="https://www.cnblogs.com/haiyonghao/p/14440954.html" target="_blank" rel="noopener">READMSR和CPUID指令在Guest中的代码执行路径学习</a></li><li><a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt" target="_blank" rel="noopener">kvm/api.txt</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将以&lt;a href=&quot;https://gitlab.com/qemu-project/qemu/-/tree/v5.2.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QEMU V5.2.0&lt;/a&gt;,&lt;a href=&quot;https://elixir.bootlin.com/linux/v5.14/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kernel  v5.14&lt;/a&gt;的源码与SDM的描述，介绍MSR management，具体细节不会一一介绍，但是会点出关键性的内容，读者可以以此为线索，深挖细节。
    
    </summary>
    
      <category term="QEMU&amp;&amp;KVM" scheme="http://liujunming.github.io/categories/QEMU-KVM/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>Notes about magic SysRq key</title>
    <link href="http://liujunming.github.io/2021/12/25/Notes-about-magic-SysRq-key/"/>
    <id>http://liujunming.github.io/2021/12/25/Notes-about-magic-SysRq-key/</id>
    <published>2021-12-25T02:29:06.000Z</published>
    <updated>2021-12-25T03:08:54.637Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about magic SysRq key.<a id="more"></a></p><p><img src="/images/2021/12/26.png" alt></p><h3 id="1-What-is-magic-SysRq-key"><a href="#1-What-is-magic-SysRq-key" class="headerlink" title="1. What is magic SysRq key?"></a>1. What is magic SysRq key?</h3><p>It is a ‘magical’ key combo you can hit which the kernel will respond to regardless of whatever else it is doing, unless it is completely locked up.</p><p>Magic SysRq组合键是一串能直接与Linux 内核沟通的组合键，允许用户就算在系统进入死循环濒临崩溃时，直接调用系统底层将资料写入文件系统或重启，避免尚未写入文件系统与硬盘的数据在关机后消失。</p><p>此组合键提供一系列在系统崩溃时常用到的功能，比如上述的写入数据，或关闭 X Server 、Kill 进程、卸载 文件系统，也通常是死机时的最后手段。</p><h3 id="2-How-do-I-enable-the-magic-SysRq-key"><a href="#2-How-do-I-enable-the-magic-SysRq-key" class="headerlink" title="2. How do I enable the magic SysRq key?"></a>2. How do I enable the magic SysRq key?</h3><p>You need to say “yes” to ‘Magic SysRq key (<code>CONFIG_MAGIC_SYSRQ</code>)’ when configuring the kernel. When running a kernel with SysRq compiled in, <code>/proc/sys/kernel/sysrq</code> controls the functions allowed to be invoked via the SysRq key. The default value in this file is set by the <code>CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE</code> config symbol, which itself defaults to 1. Here is the list of possible values in <code>/proc/sys/kernel/sysrq</code>:</p><ul><li><p>0 - disable sysrq completely</p></li><li><p>1 - enable all functions of sysrq</p></li><li><p>>1 - bitmask of allowed sysrq functions (see below for detailed function description):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  2 =   0x2 - enable control of console logging level</span><br><span class="line">  4 =   0x4 - enable control of keyboard (SAK, unraw)</span><br><span class="line">  8 =   0x8 - enable debugging dumps of processes etc.</span><br><span class="line"> 16 =  0x10 - enable sync command</span><br><span class="line"> 32 =  0x20 - enable remount read-only</span><br><span class="line"> 64 =  0x40 - enable signalling of processes (term, kill, oom-kill)</span><br><span class="line">128 =  0x80 - allow reboot/poweroff</span><br><span class="line">256 = 0x100 - allow nicing of all RT tasks</span><br></pre></td></tr></table></figure></li></ul><p>Note that the value of <code>/proc/sys/kernel/sysrq</code> influences only the invocation via a keyboard. Invocation of any operation via <code>/proc/sysrq-trigger</code> is always allowed (by a user with admin privileges).</p><h3 id="3-How-do-I-use-the-magic-SysRq-key"><a href="#3-How-do-I-use-the-magic-SysRq-key" class="headerlink" title="3. How do I use the magic SysRq key?"></a>3. How do I use the magic SysRq key?</h3><ul><li><p>On x86<br>You press the key combo <code>ALT-SysRq-&lt;command key&gt;</code>.</p></li><li><p>On all<br>Write a character to <code>/proc/sysrq-trigger</code>. e.g.:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo t &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-What-are-the-‘command’-keys"><a href="#4-What-are-the-‘command’-keys" class="headerlink" title="4. What are the ‘command’ keys?"></a>4. What are the ‘command’ keys?</h3><p><a href="https://www.kernel.org/doc/html/latest/admin-guide/sysrq.html#what-are-the-command-keys" target="_blank" rel="noopener">kernel.org doc</a></p><h3 id="5-Usage-example"><a href="#5-Usage-example" class="headerlink" title="5. Usage example"></a>5. Usage example</h3><h4 id="5-1-perform-a-system-crash-and-a-crashdump-will-be-taken-if-configured"><a href="#5-1-perform-a-system-crash-and-a-crashdump-will-be-taken-if-configured" class="headerlink" title="5.1 perform a system crash and a crashdump will be taken if configured."></a>5.1 perform a system crash and a crashdump will be taken if configured.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/kernel/sysrq</span><br><span class="line">echo c &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/sysrq.html" target="_blank" rel="noopener">Linux Magic System Request Key Hacks</a></li><li><a href="https://zh.wikipedia.org/zh-cn/Magic_SysRq%E7%B5%84%E5%90%88%E9%8D%B5" target="_blank" rel="noopener">wikipedia Magic SysRq组合键</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about magic SysRq key.
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Intel CPU operating modes</title>
    <link href="http://liujunming.github.io/2021/12/24/Intel-CPU-operating-modes/"/>
    <id>http://liujunming.github.io/2021/12/24/Intel-CPU-operating-modes/</id>
    <published>2021-12-24T11:24:52.000Z</published>
    <updated>2021-12-24T13:08:07.571Z</updated>
    
    <content type="html"><![CDATA[<p>本文以Intel SDM为主，以<a href="https://github.com/projectacrn/acrn-hypervisor/tree/release_2.7" target="_blank" rel="noopener">ACRN</a>源码为辅来介绍Intel CPU operating modes。<a id="more"></a></p><h2 id="1-IA-32-architecture"><a href="#1-IA-32-architecture" class="headerlink" title="1. IA-32 architecture"></a>1. IA-32 architecture</h2><h3 id="1-1-Protected-mode"><a href="#1-1-Protected-mode" class="headerlink" title="1.1 Protected mode"></a>1.1 Protected mode</h3><p>This mode is the native state of the processor. Among the capabilities of protected mode is the ability to directly execute “real-address mode” 8086 software in a protected, multi-tasking environment. This feature is called <strong>virtual-8086 mode</strong>, although it is not actually a processor mode. Virtual-8086 mode is actually a protected mode attribute that can be enabled for any task.</p><h3 id="1-2-Real-address-mode"><a href="#1-2-Real-address-mode" class="headerlink" title="1.2 Real-address mode"></a>1.2 Real-address mode</h3><p>This mode implements the programming environment of the Intel 8086 processor with extensions (such as the ability to switch to protected or system management mode). The processor is placed in real-address mode following power-up or a reset.</p><h3 id="1-3-System-management-mode-SMM"><a href="#1-3-System-management-mode-SMM" class="headerlink" title="1.3 System management mode (SMM)"></a>1.3 System management mode (SMM)</h3><p> This mode provides an operating system or executive with a transparent mechanism for implementing platform-specific functions such as power management and system security. The processor enters SMM when the external SMM interrupt pin (SMI#) is activated or an SMI is received from the advanced programmable interrupt controller (APIC).</p><p>In SMM, the processor switches to a separate address space while saving the basic context of the currently running program or task. SMM-specific code may then be executed transparently. Upon returning from SMM, the processor is placed back into its state prior to the system management interrupt. </p><h2 id="2-Intel®-64-Architecture"><a href="#2-Intel®-64-Architecture" class="headerlink" title="2. Intel® 64 Architecture"></a>2. Intel® 64 Architecture</h2><p>Intel 64 architecture adds IA-32e mode. IA-32e mode has two sub-modes.</p><h3 id="2-1-Compatibility-mode-sub-mode-of-IA-32e-mode"><a href="#2-1-Compatibility-mode-sub-mode-of-IA-32e-mode" class="headerlink" title="2.1 Compatibility mode(sub-mode of IA-32e mode)"></a>2.1 Compatibility mode(sub-mode of IA-32e mode)</h3><p>Compatibility mode permits most legacy 16-bit and 32-bit applications to run without re-compilation under a 64-bit operating system. </p><h3 id="2-2-64-bit-mode-sub-mode-of-IA-32e-mode"><a href="#2-2-64-bit-mode-sub-mode-of-IA-32e-mode" class="headerlink" title="2.2 64-bit mode(sub-mode of IA-32e mode)"></a>2.2 64-bit mode(sub-mode of IA-32e mode)</h3><p>This mode enables a 64-bit operating system to run applications written to access 64-bit linear address space.</p><h2 id="3-状态机"><a href="#3-状态机" class="headerlink" title="3. 状态机"></a>3. 状态机</h2><p><img src="/images/2021/12/23.png" alt><br><img src="/images/2021/12/24.png" alt></p><h2 id="4-Code"><a href="#4-Code" class="headerlink" title="4. Code"></a>4. Code</h2><p><a href="https://github.com/projectacrn/acrn-hypervisor/blob/release_2.7/hypervisor/arch/x86/guest/vcpu.c#L301-#L317" target="_blank" rel="noopener">set_vcpu_mode</a></p><h3 id="4-1-How-to-determine-if-protect-mode"><a href="#4-1-How-to-determine-if-protect-mode" class="headerlink" title="4.1 How to determine if protect mode?"></a>4.1 How to determine if protect mode?</h3><p><img src="/images/2021/12/25.png" alt></p><h3 id="4-2-How-to-determine-if-IA-32e-mode"><a href="#4-2-How-to-determine-if-IA-32e-mode" class="headerlink" title="4.2 How to determine if IA-32e mode?"></a>4.2 How to determine if IA-32e mode?</h3><p>注意：IA-32e mode还有一个叫法:long mode。</p><p><img src="/images/2021/12/21.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_IA32_EFER_LME_BIT(1UL &lt;&lt; 8U)<span class="comment">/* IA32e mode enable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_IA32_EFER_LMA_BIT(1UL &lt;&lt; 10U)<span class="comment">/* IA32e mode active */</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> ((ia32_efer &amp; MSR_IA32_EFER_LMA_BIT) != <span class="number">0U</span>L)</span><br></pre></td></tr></table></figure><h3 id="4-3-How-to-determine-if-64-bit-mode"><a href="#4-3-How-to-determine-if-64-bit-mode" class="headerlink" title="4.3 How to determine if 64-bit mode?"></a>4.3 How to determine if 64-bit mode?</h3><p><img src="/images/2021/12/22.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ia32_efer &amp; MSR_IA32_EFER_LMA_BIT) != <span class="number">0U</span>L) &#123;</span><br><span class="line"><span class="keyword">if</span> ((cs_attr &amp; <span class="number">0x2000</span>U) != <span class="number">0U</span>) &#123;</span><br><span class="line"><span class="comment">/* CS.L = 1 */</span></span><br><span class="line">vcpu-&gt;arch.cpu_mode = CPU_MODE_64BIT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-How-to-determine-if-compatibility-mode"><a href="#4-4-How-to-determine-if-compatibility-mode" class="headerlink" title="4.4 How to determine if compatibility mode?"></a>4.4 How to determine if compatibility mode?</h3><p>IA32e mode active and CS.L = 0</p><hr><p>参考资料:</p><ol><li><a href="https://zhuanlan.zhihu.com/p/69334474" target="_blank" rel="noopener">x86-64处理器的几种运行模式</a></li><li><a href="https://zhuanlan.zhihu.com/p/298033676" target="_blank" rel="noopener">X86 CPU的工作模式</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文以Intel SDM为主，以&lt;a href=&quot;https://github.com/projectacrn/acrn-hypervisor/tree/release_2.7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ACRN&lt;/a&gt;源码为辅来介绍Intel CPU operating modes。
    
    </summary>
    
      <category term="SDM" scheme="http://liujunming.github.io/categories/SDM/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
  </entry>
  
</feed>
