<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2020-10-08T03:56:52.747Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Introduction to Posted-interrupt</title>
    <link href="http://liujunming.github.io/2020/10/07/Introduction-to-Posted-interrupt/"/>
    <id>http://liujunming.github.io/2020/10/07/Introduction-to-Posted-interrupt/</id>
    <published>2020-10-07T12:46:55.000Z</published>
    <updated>2020-10-08T03:56:52.747Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对SDM <a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/#posted-interrupt" target="_blank" rel="noopener">Posted Interrupt</a>做相关补充。对于VT-d的Posted-interrupt，本文并不涉及。</p><a id="more"></a><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>Virtual-Interrupt Delivery利用硬件功能解决了如下两个问题：第一个是需要Hypervisor手动模拟Interrupt Acknowledgement(要先从IRR中取出最高优先级的中断，设置ISR中对应位)、Interrupt Delivery(EOI)；第二个是有时需要产生<strong>Interrupt Window</strong> VM Exit以正确注入中断。</p><p>Posted Interrupt是对Virtual-Interrupt Delivery的进一步发展，让我们可以省略Interrupt Acceptance的过程，直接令正在运行的vCPU收到一个虚假中断，而不产生VM Exit。它可以向正在运行的vCPU注入中断，配合VT-d的Posted Interrupt功能，还可以实现Passthrough设备的中断直接发给vCPU而不引起VM Exit。</p><h3 id="Posted-Interrupt-Processing"><a href="#Posted-Interrupt-Processing" class="headerlink" title="Posted-Interrupt Processing"></a>Posted-Interrupt Processing</h3><p><img src="/images/2020/10/1.PNG" alt><br><img src="/images/2020/10/2.PNG" alt></p><h3 id="Usage-Examples-and-Enabling-Posted-Interrupt-Processing-in-KVM"><a href="#Usage-Examples-and-Enabling-Posted-Interrupt-Processing-in-KVM" class="headerlink" title="Usage Examples and Enabling Posted-Interrupt Processing in KVM"></a>Usage Examples and Enabling Posted-Interrupt Processing in KVM</h3><p><img src="/images/2020/10/3.PNG" alt><br>Send the event notification:给vCPU所在的CPU发送一个Notification Event，即中断向量号为Posted-Interrupt Notification Vector的中断。</p><blockquote><p>假设现在想给一个正在运行的vCPU注入中断，除非该vCPU正在处理中断，否则仅凭Virtual-Interrupt Delivery，仍需要令其VM Exit并设置RVI，以便在VM Entry时触发Virtual-Interrupt Delivery。若使用Posted Interrupt，则可以设置PIR中对应位，然后给vCPU所在的CPU发送一个Notification Event，即中断向量号为Posted-Interrupt Notification Vector的中断，这样vCPU无需VM Exit就可以被注入一个甚至多个中断。</p></blockquote><hr><p>参考链接：</p><ol><li><a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/" target="_blank" rel="noopener">Intel SDM Chapter 29: APIC Virtualizaton &amp; Virtual Interrupts</a></li><li><a href="https://www.linux-kvm.org/images/7/70/2012-forum-nakajima_apicv.pdf" target="_blank" rel="noopener">Enabling Optimized Interrupt/APIC Virtualization in KVM </a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是对SDM &lt;a href=&quot;https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/#posted-interrupt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Posted Interrupt&lt;/a&gt;做相关补充。对于VT-d的Posted-interrupt，本文并不涉及。&lt;/p&gt;
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about CVE-2016-5195</title>
    <link href="http://liujunming.github.io/2020/10/05/Some-notes-about-CVE-2016-5195/"/>
    <id>http://liujunming.github.io/2020/10/05/Some-notes-about-CVE-2016-5195/</id>
    <published>2020-10-05T05:51:00.000Z</published>
    <updated>2020-10-07T17:01:32.903Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对<a href="https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails" target="_blank" rel="noopener">CVE-2016-5195</a>做相关的notes。<a id="more"></a><br><a href="http://huntcve.github.io/2017/07/04/dirtycow/" target="_blank" rel="noopener">DirtyCow 漏洞分析2</a>分析的较好。</p><h3 id="detail"><a href="#detail" class="headerlink" title="detail"></a>detail</h3><ol><li>强行写入的内容被写到<strong>内核COW出来的拷贝页</strong>中，供进程使用。</li><li>If CR0.WP = 0, data may be written to any supervisor-mode address. <em>生成一个新的可写COW页面，并标记为脏页面，同时保留其只读属性</em></li></ol><h3 id="material"><a href="#material" class="headerlink" title="material"></a>material</h3><ol><li><a href="https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails" target="_blank" rel="noopener">VulnerabilityDetails</a></li><li><a href="http://huntcve.github.io/2017/07/04/dirtycow/" target="_blank" rel="noopener">DirtyCow 漏洞分析2</a></li><li><a href="https://www.anquanke.com/post/id/84851" target="_blank" rel="noopener">深入解读脏牛Linux本地提权漏洞</a></li><li><a href="http://pwn4.fun/2017/07/14/Dirty-COW%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Dirty COW（CVE-2016-5195）漏洞分析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是对&lt;a href=&quot;https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CVE-2016-5195&lt;/a&gt;做相关的notes。
    
    </summary>
    
      <category term="Security" scheme="http://liujunming.github.io/categories/Security/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Security" scheme="http://liujunming.github.io/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about CVE-2018-12207</title>
    <link href="http://liujunming.github.io/2020/09/30/Some-notes-about-CVE-2018-12207/"/>
    <id>http://liujunming.github.io/2020/09/30/Some-notes-about-CVE-2018-12207/</id>
    <published>2020-09-30T12:10:05.000Z</published>
    <updated>2020-10-07T17:01:32.903Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对<a href="https://software.intel.com/security-software-guidance/api-app/insights/deep-dive-machine-check-error-avoidance-page-size-change" target="_blank" rel="noopener">CVE-2018-12207</a>做相关的background补充。原文写的相当好，建议详读。<a id="more"></a></p><h3 id="Description-of-errata"><a href="#Description-of-errata" class="headerlink" title="Description of errata"></a>Description of errata</h3><p>Software sequences that may lead to machine check error code 0150H can be summarized as follows:</p><ol><li>Code is fetched from a linear address translated using a 4 KB translation cached in the ITLB.</li><li>Software modifies the paging structures so that the same linear address is translated using a large page (2 MB, 4 MB, or 1 GB) with a different physical address or memory type.</li><li>After the paging structure modification, but before software invalidates any ITLB entries for the linear address, code fetch happens again on the same linear address.</li><li>This may cause a machine-check error (IA32_MCi_STATUS.MCACOD=150H), which can result in a system hang or shutdown.</li></ol><h3 id="extension1"><a href="#extension1" class="headerlink" title="extension1"></a>extension1</h3><p>The VMM can use Extended Page Tables (EPT) to enforce that each guest physical address is 4 KB in size and that guest software cannot change the hardware page size for translations.</p><blockquote><p>For correctness, the TLB must consider the page size for a given translation to be the smaller of the nested and guest page sizes.</p></blockquote><p>From ASPLOS’08 《Accelerating Two-Dimensional Page Walks》2.4 Large Page Size。</p><h3 id="extension2"><a href="#extension2" class="headerlink" title="extension2"></a>extension2</h3><p>The sequence above requires bit 10 (Execute access for user-mode linear address) to be treated in the same manner as bit 2 when mode-based execution controls are active (the mode-based execute control for EPT feature is present and the VM execution control is set to 1).</p><ul><li><p>各级页表项的第2位为X (eXecute)，取1表示可执行</p><ul><li>若Secondary Processor-Based VM-Execution Controls.Mode-based execute control for EPT[bit 22]取1，则该位取1仅表示对于Guest的内核页可执行，不表示对于Guest的用户页可执行</li></ul></li><li><p>各级页表项的第10位为XU (eXecute for User)，取1表示对于Guest的用户页可执行</p><ul><li>仅当Secondary Processor-Based VM-Execution Controls.Mode-based execute control for EPT[bit 22]取1时有效，否则该位会被忽略</li></ul></li></ul><p>From <a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch28/" target="_blank" rel="noopener">Intel SDM Chapter 28: VMX Support for Address Translation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是对&lt;a href=&quot;https://software.intel.com/security-software-guidance/api-app/insights/deep-dive-machine-check-error-avoidance-page-size-change&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CVE-2018-12207&lt;/a&gt;做相关的background补充。原文写的相当好，建议详读。
    
    </summary>
    
      <category term="Security" scheme="http://liujunming.github.io/categories/Security/"/>
    
    
      <category term="内存管理" scheme="http://liujunming.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="Security" scheme="http://liujunming.github.io/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>Without EPT or SPT, guest still can access memory?</title>
    <link href="http://liujunming.github.io/2020/08/30/Without-EPT-or-SPT-guest-still-can-access-memory/"/>
    <id>http://liujunming.github.io/2020/08/30/Without-EPT-or-SPT-guest-still-can-access-memory/</id>
    <published>2020-08-30T01:28:10.000Z</published>
    <updated>2020-08-30T01:42:12.121Z</updated>
    
    <content type="html"><![CDATA[<p>Without EPT or SPT(shadow page table), guest can access memory?<br><a id="more"></a><br>在看kvm-unit-test时，发现：没有为guest创建EPT or SPT，但是，guest依然可以访问memory，这是怎么做到的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_vmcs_guest</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 26.3 CHECKING AND LOADING GUEST STATE */</span></span><br><span class="line">ulong guest_cr3;</span><br><span class="line"><span class="comment">/* 26.3.1.1 */</span></span><br><span class="line">guest_cr3 = read_cr3();</span><br><span class="line">...</span><br><span class="line">vmcs_write(GUEST_CR3, guest_cr3);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案便在上述代码片段中：将host的cr3赋值给guest的cr3。这样，直接将MMU pass-thru给guest，并且guest和host复用相同的页表。</p><p>这样比较tricky做法的缺点是:失去了隔离性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Without EPT or SPT(shadow page table), guest can access memory?&lt;br&gt;
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about Queued Invalidation in VT-d</title>
    <link href="http://liujunming.github.io/2020/08/29/Some-notes-about-Queued-Invalidaion-in-VT-d/"/>
    <id>http://liujunming.github.io/2020/08/29/Some-notes-about-Queued-Invalidaion-in-VT-d/</id>
    <published>2020-08-29T12:48:47.000Z</published>
    <updated>2020-08-30T01:17:15.248Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍VT-d中Queued Invalidation的相关知识点。<br><a id="more"></a></p><p>Queued Invalidation的详细内容请参考VT-d spc的6.5.2节。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>spec中的描述如下：</p><blockquote><p>The queued invalidation provides an advanced interface for software to submit invalidation requests to hardware and to synchronize invalidation completions with hardware.</p></blockquote><h2 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h2><blockquote><p>The queued invalidation interface uses IQ(Invalidation Queue), which is a circular buffer in system memory. Software submits commands by writing Invalidation Descriptors to the IQ. </p></blockquote><p><a href="https://github.com/projectacrn/acrn-hypervisor/blob/release_2.0/hypervisor/arch/x86/vtd.c#L546" target="_blank" rel="noopener">dmar_issue_qi_request</a>是研究Queued Invalidation的入口函数。</p><p>从源码中可以看到，acrn在invalid dmar context cache, invalid dmar iotlb, invalid dmar interrupt entry cache时，会使用到Queued Invalidation。</p><p>acrn向QI中submit 一个Invalidation Descriptor时，紧接着会submit Invalidation Wait Descriptor(VT-d spec 6.5.2.8)。</p><p><img src="/images/2020/05/6.PNG" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">invalidate_desc_ptr-&gt;hi_64 = hva2hpa(&amp;qi_status);</span><br><span class="line">invalidate_desc_ptr-&gt;lo_64 = DMAR_INV_WAIT_DESC_LOWER;</span><br><span class="line">dmar_unit-&gt;qi_tail = (dmar_unit-&gt;qi_tail + DMAR_QI_INV_ENTRY_SIZE) % DMAR_INVALIDATION_QUEUE_SIZE;</span><br><span class="line"></span><br><span class="line">qi_status = DMAR_INV_STATUS_INCOMPLETE;</span><br><span class="line">iommu_write32(dmar_unit, DMAR_IQT_REG, dmar_unit-&gt;qi_tail);</span><br><span class="line"></span><br><span class="line">start = rdtsc();</span><br><span class="line"><span class="keyword">while</span> (qi_status != DMAR_INV_STATUS_COMPLETED) &#123;</span><br><span class="line"><span class="keyword">if</span> ((rdtsc() - start) &gt; CYCLES_PER_MS) &#123;</span><br><span class="line">pr_err(<span class="string">"DMAR OP Timeout! @ %s"</span>, __func__);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">asm_pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>&amp;qi_status</code>写入Addr,将<code>DMAR_INV_STATUS_COMPLETED</code>写入Status Data(见上图)，这意味着：当硬件处理完invalidation requests 时，会将<code>qi_status</code>的值赋值为<code>DMAR_INV_STATUS_COMPLETED</code>。</p><p>软件先将<code>qi_status</code>赋值为<code>DMAR_INV_STATUS_INCOMPLETE</code>，然后loop，直至硬件将<code>qi_status</code>的值赋值为<code>DMAR_INV_STATUS_COMPLETED</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍VT-d中Queued Invalidation的相关知识点。&lt;br&gt;
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
      <category term="acrn" scheme="http://liujunming.github.io/tags/acrn/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to ept misconfig</title>
    <link href="http://liujunming.github.io/2020/07/12/Introduction-to-ept-misconfig/"/>
    <id>http://liujunming.github.io/2020/07/12/Introduction-to-ept-misconfig/</id>
    <published>2020-07-12T09:01:48.000Z</published>
    <updated>2020-08-30T01:17:15.245Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录ept misconfig的相关笔记。内容主要转载自<a href="http://happyseeker.github.io/kernel/2018/05/29/ept-misconfig.html" target="_blank" rel="noopener">EPT misconfig</a>。<br><a id="more"></a></p><h3 id="EPT-Voilation"><a href="#EPT-Voilation" class="headerlink" title="EPT Voilation"></a>EPT Voilation</h3><p>相当于EPT(扩展页表)的page fault，是一种特殊的硬件异常。当EPT中不存在指定GPA-&gt;HPA的映射时触发，硬件触发。</p><h3 id="EPT-misconfig"><a href="#EPT-misconfig" class="headerlink" title="EPT misconfig"></a>EPT misconfig</h3><p>本质上也是一种page fault，与EPT voilation不同(当page not present时触发)，EPT misconfig类似于 reserved bit set page fault，也就是说当页表项中的保留位设置时触发，也是硬件触发。</p><p>SDM中关于EPT misconfig的描述：</p><blockquote><p>An EPT misconfiguration occurs when, in the course of translating a guest-physical address, the logical processor encounters an EPT paging-structure entry that contains an unsupported value. An EPT violation occurs when there is no EPT misconfiguration but the EPT paging-structure entries disallow an access using the guest physical address.</p></blockquote><h3 id="EPT-misconfig用途"><a href="#EPT-misconfig用途" class="headerlink" title="EPT misconfig用途"></a>EPT misconfig用途</h3><p>EPT misconfig可以用来处理没有passed-through给Guest的mmio区域。</p><p>当首次访问某mmio page时，会触发EPT violation，KVM在EPT violation的处理过程中设置相应EPT entry中的保留位，然后在下一次再访问该page时，即会触发EPT misconfig。</p><p>详细步骤如下：</p><ol><li>QEMU declares a memory region(but not allocate ram or commit it to kvm)</li><li>Guest first access the MMIO address, cause a EPT violation VM-exit</li><li>KVM construct the EPT page table and marks the page table entry with special mark(110b)</li><li>Later the guest access these MMIO, it will be processed by EPT misconfig VM-exit handler</li></ol><hr><p>参考资料：</p><ol><li><a href="http://happyseeker.github.io/kernel/2018/05/29/ept-misconfig.html" target="_blank" rel="noopener">EPT misconfig</a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/09/03/kvm-mmio" target="_blank" rel="noopener">KVM MMIO implementation</a></li><li><a href="http://ningfxkvm.blogspot.com/2015/11/kvmept-exception.html" target="_blank" rel="noopener">KVM中的EPT Exception</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录ept misconfig的相关笔记。内容主要转载自&lt;a href=&quot;http://happyseeker.github.io/kernel/2018/05/29/ept-misconfig.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EPT misconfig&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第17期</title>
    <link href="http://liujunming.github.io/2020/07/12/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC17%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2020/07/12/每周分享第17期/</id>
    <published>2020-07-12T05:47:40.000Z</published>
    <updated>2020-08-30T01:17:15.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RPM包"><a href="#RPM包" class="headerlink" title="RPM包"></a>RPM包</h3><p>RPM(Redhat Linux Packet Manager)是Red Hat公司随Redhat Linux推出了一个软件包管理器，通过它能够更加轻松容易地实现软件的安装。</p><p><a href="https://blog.csdn.net/cuiyifang/article/details/7850703" target="_blank" rel="noopener">https://blog.csdn.net/cuiyifang/article/details/7850703</a><br><a href="https://zhuanlan.zhihu.com/p/27608663" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27608663</a></p><a id="more"></a><h3 id="bochs-vs-qemu"><a href="#bochs-vs-qemu" class="headerlink" title="bochs vs qemu"></a>bochs vs qemu</h3><p>Like bochs, QEMU emulates an x86 CPU. But QEMU is much faster than bochs as it uses dynamic compilation. Bochs is closely tied to x86 PC emulation while QEMU can emulate several processors. Like Valgrind, QEMU does user space emulation and dynamic translation.</p><p><a href="http://people.redhat.com/pbonzini/qemu-test-doc/_build/html/topics/QEMU-compared-to-other-emulators.html" target="_blank" rel="noopener">http://people.redhat.com/pbonzini/qemu-test-doc/_build/html/topics/QEMU-compared-to-other-emulators.html</a></p><h3 id="PCI-PCI-Express-Configuration-Space-Access"><a href="#PCI-PCI-Express-Configuration-Space-Access" class="headerlink" title="PCI/PCI Express Configuration Space Access"></a>PCI/PCI Express Configuration Space Access</h3><blockquote><p>Accesses made using either access mechanism are equivalent. The PCI Express Extended Configuration Space can only be accessed by using the ECAM.</p></blockquote><p>On x86 and x64 platforms, the address of each memory area is determined by the ACPI ‘MCFG’ table. </p><p><a href="http://developer.amd.com/wordpress/media/2012/10/pci%20-%20pci%20express%20configuration%20space%20access.pdf" target="_blank" rel="noopener">PCI/PCI Express Configuration Space Access</a><br><a href="https://stackoverflow.com/questions/57457283/how-to-access-pcie-configuration-space-ecam" target="_blank" rel="noopener">How to access PCIe configuration space</a></p><h3 id="何小龙"><a href="#何小龙" class="headerlink" title="何小龙"></a>何小龙</h3><p><a href="https://blog.csdn.net/hexiaolong2009" target="_blank" rel="noopener">https://blog.csdn.net/hexiaolong2009</a><br>有gpu相关的资料。</p><h3 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h3><p>chroot，即 change root directory (更改 root 目录)。在 linux 系统中，系统默认的目录结构都是以 /，即以根 (root) 开始的。而在使用 chroot 之后，系统的目录结构将以指定的位置作为 / 位置。</p><p><a href="https://www.cnblogs.com/sparkdev/p/8556075.html" target="_blank" rel="noopener">https://www.cnblogs.com/sparkdev/p/8556075.html</a></p><h3 id="nomodeset，quiet和splash内核参数是什么意思？"><a href="#nomodeset，quiet和splash内核参数是什么意思？" class="headerlink" title="nomodeset，quiet和splash内核参数是什么意思？"></a>nomodeset，quiet和splash内核参数是什么意思？</h3><ul><li><p>nomodeset</p><blockquote><p>The newest kernels have moved the video mode setting into the kernel. So all the programming of the hardware specific clock rates and registers on the video card happen in the kernel rather than in the X driver when the X server starts.. This makes it possible to have high resolution nice looking splash (boot) screens and flicker free transitions from boot splash to login screen. Unfortunately, on some cards this doesn’t work properly and you end up with a black screen. Adding the nomodeset parameter instructs the kernel to not load video drivers and use BIOS modes instead until X is loaded.</p></blockquote></li><li><p>quiet splash</p><blockquote><p>The splash (which eventually ends up in your /boot/grub/grub.cfg ) causes the splash screen to be shown.<br>At the same time you want the boot process to be quiet, as otherwise all kinds of messages would disrupt that splash screen.</p></blockquote></li></ul><p><a href="https://askubuntu.com/questions/716957/what-do-the-nomodeset-quiet-and-splash-kernel-parameters-mean" target="_blank" rel="noopener">What do the nomodeset, quiet and splash kernel parameters mean?</a></p><h3 id="GRUB-CMDLINE-LINUX-vs-GRUB-CMDLINE-LINUX-DEFAULT"><a href="#GRUB-CMDLINE-LINUX-vs-GRUB-CMDLINE-LINUX-DEFAULT" class="headerlink" title="GRUB_CMDLINE_LINUX vs GRUB_CMDLINE_LINUX_DEFAULT"></a>GRUB_CMDLINE_LINUX vs GRUB_CMDLINE_LINUX_DEFAULT</h3><ul><li>Options in <code>GRUB_CMDLINE_LINUX</code> are <strong>always effective</strong>.</li><li>Options in <code>GRUB_CMDLINE_LINUX_DEFAULT</code> are <strong>effective ONLY during normal boot</strong> (NOT during recovery mode).</li></ul><p><a href="https://askubuntu.com/questions/575651/what-is-the-difference-between-grub-cmdline-linux-and-grub-cmdline-linux-default" target="_blank" rel="noopener">What is the difference between GRUB_CMDLINE_LINUX and GRUB_CMDLINE_LINUX_DEFAULT in /etc/default/grub</a></p><h3 id="Intro-to-Time-Sensitive-Networking-and-Intel®-Time-Coordinated-Computing-Intel®-TCC"><a href="#Intro-to-Time-Sensitive-Networking-and-Intel®-Time-Coordinated-Computing-Intel®-TCC" class="headerlink" title="Intro to Time-Sensitive Networking and Intel® Time Coordinated Computing (Intel® TCC)"></a>Intro to Time-Sensitive Networking and Intel® Time Coordinated Computing (Intel® TCC)</h3><p>TCC makes sure each device executes its operations exactly when it supposed to.<br><a href="https://www.intel.com/content/www/us/en/now/inside-iot/concept-of-time-video.html" target="_blank" rel="noopener">https://www.intel.com/content/www/us/en/now/inside-iot/concept-of-time-video.html</a></p><h3 id="hurley-x86架构操作系统内核的实现"><a href="#hurley-x86架构操作系统内核的实现" class="headerlink" title="hurley x86架构操作系统内核的实现"></a>hurley x86架构操作系统内核的实现</h3><p><a href="http://wiki.0xffffff.org/" target="_blank" rel="noopener">http://wiki.0xffffff.org/</a><br><a href="https://github.com/hurley25/hurlex-doc/blob/master/doc/hurlex-index.pdf" target="_blank" rel="noopener">https://github.com/hurley25/hurlex-doc/blob/master/doc/hurlex-index.pdf</a></p><h3 id="Lockstep"><a href="#Lockstep" class="headerlink" title="Lockstep"></a>Lockstep</h3><p>Lockstep systems are fault-tolerant computer systems that run the same set of operations at the same time in parallel.<br><a href="https://en.wikipedia.org/wiki/Lockstep_(computing)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Lockstep_(computing)</a></p><h3 id="COLO"><a href="#COLO" class="headerlink" title="COLO"></a>COLO</h3><p>COLO (COarse-grained LOck-stepping)是一种虚拟机的高可用解决方案。当启用的COLO功能后, 主虚拟机(PVM)和备虚拟机(SVM)都会同时处于running 状态。PVM和SVM都可以接收到来自client的网络数据包, 并对数据包做出回应。当PVM和SVM回复的数据包的内容相同, 则PVM回复的数据包会返回给client, 否则会触发checkpoint对PVM和SVM进行同步，然后再将数据包返回给client。当PVM所在的物理机发生宕机时候, SVM可以立即接管, 为client提供服务。</p><p><a href="https://cloud.tencent.com/developer/article/1087097" target="_blank" rel="noopener">kvm虚拟机的FT（容错）方案</a><br><a href="https://wiki.qemu.org/Features/COLO" target="_blank" rel="noopener">Features/COLO</a><br><a href="https://blog.csdn.net/zhongbeida_xue/article/details/70759266" target="_blank" rel="noopener">QEMU COLO (Fault Tolerance) 容错功能总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RPM包&quot;&gt;&lt;a href=&quot;#RPM包&quot; class=&quot;headerlink&quot; title=&quot;RPM包&quot;&gt;&lt;/a&gt;RPM包&lt;/h3&gt;&lt;p&gt;RPM(Redhat Linux Packet Manager)是Red Hat公司随Redhat Linux推出了一个软件包管理器，通过它能够更加轻松容易地实现软件的安装。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/cuiyifang/article/details/7850703&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/cuiyifang/article/details/7850703&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27608663&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/27608663&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第16期</title>
    <link href="http://liujunming.github.io/2020/07/05/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC16%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2020/07/05/每周分享第16期/</id>
    <published>2020-07-05T04:07:02.000Z</published>
    <updated>2020-08-30T01:17:15.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fzf"><a href="#fzf" class="headerlink" title="fzf"></a>fzf</h3><p>命令行文本增强工具</p><p><a href="https://www.jianshu.com/p/8acfc103fa2f" target="_blank" rel="noopener">https://www.jianshu.com/p/8acfc103fa2f</a></p><a id="more"></a><h3 id="Intel-CPU-security-features"><a href="#Intel-CPU-security-features" class="headerlink" title="Intel CPU security features"></a>Intel CPU security features</h3><p><a href="https://github.com/huku-/research/wiki/Intel-CPU-security-features" target="_blank" rel="noopener">https://github.com/huku-/research/wiki/Intel-CPU-security-features</a></p><h3 id="How-to-use-sed-to-find-and-replace-text-in-files"><a href="#How-to-use-sed-to-find-and-replace-text-in-files" class="headerlink" title="How to use sed to find and replace text in files"></a>How to use sed to find and replace text in files</h3><p><a href="https://www.cyberciti.biz/faq/how-to-use-sed-to-find-and-replace-text-in-files-in-linux-unix-shell/" target="_blank" rel="noopener">https://www.cyberciti.biz/faq/how-to-use-sed-to-find-and-replace-text-in-files-in-linux-unix-shell/</a></p><h3 id="Board-Support-Package"><a href="#Board-Support-Package" class="headerlink" title="Board Support Package"></a>Board Support Package</h3><p>In embedded systems, a board support package (BSP) is the layer of software containing hardware-specific drivers and other routines that allow a particular operating system (traditionally a real-time operating system, or RTOS) to function in a particular hardware environment (a computer or CPU card), integrated with the RTOS itself. Third-party hardware developers who wish to support a particular RTOS must create a BSP that allows that RTOS to run on their platform. In most cases the RTOS image and license, the BSP containing it, and the hardware are bundled together by the hardware vendor.</p><p><a href="https://en.wikipedia.org/wiki/Board_support_package" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Board_support_package</a></p><p><a href="https://www.microcontrollertips.com/board-support-package/" target="_blank" rel="noopener">https://www.microcontrollertips.com/board-support-package/</a></p><h3 id="为什么要清除BSS段"><a href="#为什么要清除BSS段" class="headerlink" title="为什么要清除BSS段"></a>为什么要清除BSS段</h3><p><a href="https://www.cnblogs.com/cainiaoaixuexi/p/3276444.html" target="_blank" rel="noopener">https://www.cnblogs.com/cainiaoaixuexi/p/3276444.html</a></p><h3 id="ELF中的-bss-section和COMMON-section"><a href="#ELF中的-bss-section和COMMON-section" class="headerlink" title="ELF中的.bss section和COMMON section"></a>ELF中的.bss section和COMMON section</h3><p><a href="https://stackoverflow.com/questions/16835716/bss-vs-common-what-goes-where" target="_blank" rel="noopener">https://stackoverflow.com/questions/16835716/bss-vs-common-what-goes-where</a></p><p><a href="http://swaywang.blogspot.com/2012/06/elfbss-sectioncommon-section.html" target="_blank" rel="noopener">http://swaywang.blogspot.com/2012/06/elfbss-sectioncommon-section.html</a></p><h3 id="How-To-Create-View-Extract-Modify-C-Archive-Files"><a href="#How-To-Create-View-Extract-Modify-C-Archive-Files" class="headerlink" title="How To Create, View, Extract, Modify C Archive Files"></a>How To Create, View, Extract, Modify C Archive Files</h3><p><a href="https://www.thegeekstuff.com/2010/08/ar-command-examples/" target="_blank" rel="noopener">https://www.thegeekstuff.com/2010/08/ar-command-examples/</a></p><h3 id="gcc-linker-map-files"><a href="#gcc-linker-map-files" class="headerlink" title="gcc linker map files"></a>gcc linker map files</h3><p><a href="https://blog.csdn.net/szullc/article/details/84946863" target="_blank" rel="noopener">https://blog.csdn.net/szullc/article/details/84946863</a></p><p><a href="https://stackoverflow.com/questions/22199844/what-are-gcc-linker-map-files-used-for" target="_blank" rel="noopener">https://stackoverflow.com/questions/22199844/what-are-gcc-linker-map-files-used-for</a></p><p>Experience: map file比objdump更精确</p><h3 id="nm-命令显示关于指定-File-中符号的信息"><a href="#nm-命令显示关于指定-File-中符号的信息" class="headerlink" title="nm 命令显示关于指定 File 中符号的信息"></a>nm 命令显示关于指定 File 中符号的信息</h3><p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/nm.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/nm.html</a></p><h3 id="Alder-Lake"><a href="#Alder-Lake" class="headerlink" title="Alder Lake"></a>Alder Lake</h3><p><a href="https://en.wikichip.org/wiki/intel/microarchitectures/alder_lake" target="_blank" rel="noopener">https://en.wikichip.org/wiki/intel/microarchitectures/alder_lake</a></p><h3 id="Windows-10X"><a href="#Windows-10X" class="headerlink" title="Windows 10X"></a>Windows 10X</h3><p><a href="https://www.youtube.com/watch?v=dIz0WDwBonc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=dIz0WDwBonc</a></p><h3 id="windows-core-os"><a href="#windows-core-os" class="headerlink" title="windows core os"></a>windows core os</h3><p><a href="https://www.windowscentral.com/windows-core-os" target="_blank" rel="noopener">https://www.windowscentral.com/windows-core-os</a></p><h3 id="Intel-Hardware-Accelerated-Execution-Manager-HAXM"><a href="#Intel-Hardware-Accelerated-Execution-Manager-HAXM" class="headerlink" title="Intel Hardware Accelerated Execution Manager (HAXM)"></a>Intel Hardware Accelerated Execution Manager (HAXM)</h3><p>HAXM is a cross-platform hardware-assisted virtualization engine (hypervisor), widely used as an accelerator for <a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">Android Emulator</a> and <a href="https://www.qemu.org/" target="_blank" rel="noopener">QEMU</a>. It has always supported running on Windows and macOS, and has been ported to other host operating systems as well, such as Linux and NetBSD.</p><p>HAXM runs as a kernel-mode driver on the host operating system, and provides a KVM-like interface to user space, thereby enabling applications like QEMU to utilize the hardware virtualization capabilities built into modern Intel CPUs, namely <a href="https://www.intel.com/content/www/us/en/virtualization/virtualization-technology/intel-virtualization-technology.html" target="_blank" rel="noopener">Intel Virtualization Technology</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;fzf&quot;&gt;&lt;a href=&quot;#fzf&quot; class=&quot;headerlink&quot; title=&quot;fzf&quot;&gt;&lt;/a&gt;fzf&lt;/h3&gt;&lt;p&gt;命令行文本增强工具&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/8acfc103fa2f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/8acfc103fa2f&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第15期</title>
    <link href="http://liujunming.github.io/2020/06/14/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC15%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2020/06/14/每周分享第15期/</id>
    <published>2020-06-14T06:35:42.000Z</published>
    <updated>2020-08-30T01:17:15.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Burn-the-Clear-Linux-to-the-USB-driver"><a href="#Burn-the-Clear-Linux-to-the-USB-driver" class="headerlink" title="Burn the Clear Linux to the USB driver"></a>Burn the Clear Linux to the USB driver</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/sdaX</span><br><span class="line"></span><br><span class="line">dd if=clear-2xxxx-installer.img of=/dev/sdb bs=4M status=progress</span><br><span class="line">sync</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="ACRN-腾讯云大学"><a href="#ACRN-腾讯云大学" class="headerlink" title="ACRN  腾讯云大学"></a>ACRN  腾讯云大学</h3><p><a href="https://cloud.tencent.com/edu/learning/course-2675-51869" target="_blank" rel="noopener">https://cloud.tencent.com/edu/learning/course-2675-51869</a></p><h3 id="gitmemory"><a href="#gitmemory" class="headerlink" title="gitmemory"></a>gitmemory</h3><p><a href="https://www.gitmemory.com/liujunming" target="_blank" rel="noopener">https://www.gitmemory.com/liujunming</a></p><h3 id="通过表情符号为您的电子邮件增添风格"><a href="#通过表情符号为您的电子邮件增添风格" class="headerlink" title="通过表情符号为您的电子邮件增添风格"></a>通过表情符号为您的电子邮件增添风格</h3><p><a href="https://support.microsoft.com/zh-cn/office/%e9%80%9a%e8%bf%87%e8%a1%a8%e6%83%85%e7%ac%a6%e5%8f%b7%e4%b8%ba%e6%82%a8%e7%9a%84%e7%94%b5%e5%ad%90%e9%82%ae%e4%bb%b6%e5%a2%9e%e6%b7%bb%e9%a3%8e%e6%a0%bc-b7ffd919-6749-4f07-a998-c0fa1bc0a4d6?ui=zh-cn&amp;rs=zh-cn&amp;ad=cn" target="_blank" rel="noopener">通过表情符号为您的电子邮件增添风格</a><br>若要访问 Windows 10 表情符号选取器，请按 Windows 键和句点（.） 键。</p><h3 id="DediProg"><a href="#DediProg" class="headerlink" title="DediProg"></a>DediProg</h3><p><a href="https://www.dediprog.com/page/companyinformationch" target="_blank" rel="noopener">https://www.dediprog.com/page/companyinformationch</a><br>烧录器</p><h3 id="pkill-f"><a href="#pkill-f" class="headerlink" title="pkill -f"></a>pkill -f</h3><p><code>pkill -f abc</code> 杀掉进程名包含<code>abc</code>的所有进程。</p><h3 id="基于-Docker-Qemu-快速构建-Linux-内核实验环境"><a href="#基于-Docker-Qemu-快速构建-Linux-内核实验环境" class="headerlink" title="基于 Docker/Qemu 快速构建 Linux 内核实验环境"></a>基于 Docker/Qemu 快速构建 Linux 内核实验环境</h3><p><a href="http://tinylab.org/docker-qemu-linux-lab/" target="_blank" rel="noopener">http://tinylab.org/docker-qemu-linux-lab/</a></p><h3 id="SMRAM"><a href="#SMRAM" class="headerlink" title="SMRAM"></a>SMRAM</h3><p>Short for System Management RAM, SMRAM is a portion of the systems memory used by the processor to store code used with SMM.</p><p><a href="https://www.computerhope.com/jargon/s/smram.htm" target="_blank" rel="noopener">https://www.computerhope.com/jargon/s/smram.htm</a></p><h3 id="System-Management-Mode"><a href="#System-Management-Mode" class="headerlink" title="System Management Mode"></a>System Management Mode</h3><p>System Management Mode is an operating mode of x86 central processor units (CPUs) in which all normal execution, including the operating system, is suspended. An alternate software system which usually resides in the computer’s firmware, or a hardware-assisted debugger, is then executed with high privileges.</p><p>System Management Mode (SMM) is intended to be used for advanced power-management features and other operating-system-independent functions. The chipset is programmed to recognize many types of events and timeouts. When such an event occurs, the chipset asserts the SMI# input pin. At the next instruction boundary, the microprocessor saves its entire state and enters SMM.</p><p>只有SMI才会引起进入SMM，处理器保护现场，切换到SMRAM里的一个独立地址空间执行SMM代码，RSM指令会使系统返回到原来的正常模式。SMM相当于实模式，没有特权级和地址映射，可寻址4GB，可执行所有I/O和可用系统指令。</p><p><a href="https://en.wikipedia.org/wiki/System_Management_Mode" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/System_Management_Mode</a><br><a href="https://www.rdzhijia.com/thread-29-1-1.html" target="_blank" rel="noopener">https://www.rdzhijia.com/thread-29-1-1.html</a><br><a href="https://blog.csdn.net/lightseed/article/details/4627069" target="_blank" rel="noopener">https://blog.csdn.net/lightseed/article/details/4627069</a></p><h3 id="Windows-Imaging-Format"><a href="#Windows-Imaging-Format" class="headerlink" title="Windows Imaging Format"></a>Windows Imaging Format</h3><p>The Windows IMaging Format (WIM) is a file-based disk image format.</p><p>Like other disk image formats, a WIM file contains a set of files and associated filesystem metadata. However, unlike sector-based formats (such as ISO or VHD), WIM is file-based: The fundamental unit of information in a WIM is a file.</p><p><a href="https://en.wikipedia.org/wiki/Windows_Imaging_Format" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Windows_Imaging_Format</a></p><h3 id="CSE-481A"><a href="#CSE-481A" class="headerlink" title="CSE 481A"></a>CSE 481A</h3><p>CSE 481A is a capstone course on operating systems, with an emphasis on virtualization.<br><a href="https://courses.cs.washington.edu/courses/cse481a/18wi/index.html" target="_blank" rel="noopener">https://courses.cs.washington.edu/courses/cse481a/18wi/index.html</a></p><h3 id="Capstone-project"><a href="#Capstone-project" class="headerlink" title="Capstone project"></a>Capstone project</h3><p>Capstone project叫顶点课程<br>顶点课程是美国高校为高年级学生，特别是临近毕业的学生开设的一种综合性课程。<br>顶点课程最显著的两个特点：<br>1）是为学生提供整合已得的知识、技能和态度等的机会<br>2）是为学生进入真实世界做准备，即通过要求学生完成一些应用性的项目，如服务性实习、实习等，为学生提供参与真实世界的机会，让学生把先前所学知识和技能应用于解决实际问题，为学生进入职业领域做准备。</p><h3 id="虚拟化从VirtIO-without-Virt到DPU"><a href="#虚拟化从VirtIO-without-Virt到DPU" class="headerlink" title="虚拟化从VirtIO without Virt到DPU"></a>虚拟化从VirtIO without Virt到DPU</h3><p><a href="https://mp.weixin.qq.com/s/vGOGuh1-8aeEU3QwoKDzcA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vGOGuh1-8aeEU3QwoKDzcA</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Burn-the-Clear-Linux-to-the-USB-driver&quot;&gt;&lt;a href=&quot;#Burn-the-Clear-Linux-to-the-USB-driver&quot; class=&quot;headerlink&quot; title=&quot;Burn the Clear Linux to the USB driver&quot;&gt;&lt;/a&gt;Burn the Clear Linux to the USB driver&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;umount /dev/sdaX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dd if=clear-2xxxx-installer.img of=/dev/sdb bs=4M status=progress&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sync&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第14期</title>
    <link href="http://liujunming.github.io/2020/05/24/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC14%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2020/05/24/每周分享第14期/</id>
    <published>2020-05-24T07:20:49.000Z</published>
    <updated>2020-08-30T01:17:15.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h3><p>ANSI是一种字符代码，为使计算机支持更多语言，通常使用 0x00~0x7f 范围的1 个字节来表示 1 个英文字符。超出此范围的使用0x80~0xFFFF来编码，即扩展的ASCII编码。<br><a id="more"></a><br>在实际应用中接触比较多的文本编码有3种：ASCII、ANSI和UNICODE，其中ASCII码是后两种编码的基础。</p><h3 id="zGlue"><a href="#zGlue" class="headerlink" title="zGlue"></a>zGlue</h3><p><a href="http://www.sigmaintell.com/news.php?cid=27&amp;id=5305" target="_blank" rel="noopener">http://www.sigmaintell.com/news.php?cid=27&amp;id=5305</a></p><h3 id="suse-linux"><a href="#suse-linux" class="headerlink" title="suse linux"></a>suse linux</h3><p><a href="https://baike.baidu.com/item/SUSE/60409?fromtitle=suse%20linux&amp;fromid=649234&amp;fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/SUSE/60409?fromtitle=suse%20linux&amp;fromid=649234&amp;fr=aladdin</a></p><h3 id="diffinity"><a href="#diffinity" class="headerlink" title="diffinity"></a>diffinity</h3><p>Diffinity is a free diff and merging tool for Windows with focus on accurate and easy to read source code diffs. </p><p><a href="http://truehumandesign.se/s_diffinity.php" target="_blank" rel="noopener">http://truehumandesign.se/s_diffinity.php</a></p><h3 id="中国神剧推荐"><a href="#中国神剧推荐" class="headerlink" title="中国神剧推荐"></a>中国神剧推荐</h3><ol><li>《大明王朝1566》</li><li>《天道》</li><li>《走向共和》</li><li>《生存之民工》</li></ol><h3 id="pagemap"><a href="#pagemap" class="headerlink" title="pagemap"></a>pagemap</h3><p><a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/vm/pagemap.txt</a><br><a href="https://www.cnblogs.com/pengdonglin137/p/6802108.html" target="_blank" rel="noopener">https://www.cnblogs.com/pengdonglin137/p/6802108.html</a></p><h3 id="华为自动驾驶操作系统内核-ISO-26262-ASIL-D"><a href="#华为自动驾驶操作系统内核-ISO-26262-ASIL-D" class="headerlink" title="华为自动驾驶操作系统内核 ISO 26262 ASIL-D"></a>华为自动驾驶操作系统内核 ISO 26262 ASIL-D</h3><p><a href="https://www.huawei.com/cn/press-events/news/2020/5/aos-core-asil-d-certificate" target="_blank" rel="noopener">https://www.huawei.com/cn/press-events/news/2020/5/aos-core-asil-d-certificate</a></p><h3 id="华东师范大学-何积丰"><a href="#华东师范大学-何积丰" class="headerlink" title="华东师范大学 何积丰"></a>华东师范大学 何积丰</h3><p><a href="http://www.sei.ecnu.edu.cn/Data/View/4487" target="_blank" rel="noopener">http://www.sei.ecnu.edu.cn/Data/View/4487</a></p><h3 id="阿里巴巴正式开源-Inclavare-Containers"><a href="#阿里巴巴正式开源-Inclavare-Containers" class="headerlink" title="阿里巴巴正式开源 Inclavare Containers"></a>阿里巴巴正式开源 Inclavare Containers</h3><p><a href="https://kernel.taobao.org/2020/05/Inclavare-Containers/" target="_blank" rel="noopener">https://kernel.taobao.org/2020/05/Inclavare-Containers/</a></p><h3 id="Difference-between-DPL-and-RPL-in-x86"><a href="#Difference-between-DPL-and-RPL-in-x86" class="headerlink" title="Difference between DPL and RPL in x86"></a>Difference between DPL and RPL in x86</h3><p>Segment protection was introduced with the 286, before paging existed in the x86 family of processors. Back then, segmentation was the only way to restrict access to kernel memory from a user-mode context. RPL provided a convenient way to enforce this restriction when passing pointers across different privilege levels.</p><p>Modern operating systems use paging to restrict access to memory, which removes the need for segmentation. So RPL is mostly an unused leftover from older times.</p><p><a href="https://stackoverflow.com/questions/36617718/difference-between-dpl-and-rpl-in-x86" target="_blank" rel="noopener">https://stackoverflow.com/questions/36617718/difference-between-dpl-and-rpl-in-x86</a><br><a href="http://blog.chinaunix.net/uid-21736802-id-1817645.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-21736802-id-1817645.html</a><br><a href="http://qcd.phys.cmu.edu/QCDcluster/intel/vtune/reference/vc17a.htm" target="_blank" rel="noopener">http://qcd.phys.cmu.edu/QCDcluster/intel/vtune/reference/vc17a.htm</a></p><h3 id="stabs"><a href="#stabs" class="headerlink" title="stabs"></a>stabs</h3><p>Stabs (Symbol Table String) refers to a format for information that describes a program to a debugger.</p><p><a href="https://blog.csdn.net/hfyinsdu/article/details/104359578" target="_blank" rel="noopener">https://blog.csdn.net/hfyinsdu/article/details/104359578</a><br><a href="http://blog.sina.com.cn/s/blog_ba1e7c860102wrsz.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_ba1e7c860102wrsz.html</a><br><a href="https://sourceware.org/gdb/onlinedocs/stabs.html" target="_blank" rel="noopener">https://sourceware.org/gdb/onlinedocs/stabs.html</a></p><h3 id="DWARF"><a href="#DWARF" class="headerlink" title="DWARF"></a>DWARF</h3><p>stabs 已经被 DWARF 替代<br><a href="https://www.ibm.com/developerworks/cn/aix/library/au-dwarf-debug-format/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/aix/library/au-dwarf-debug-format/index.html</a></p><h3 id="MISRA-C编程规范标准"><a href="#MISRA-C编程规范标准" class="headerlink" title="MISRA C编程规范标准"></a>MISRA C编程规范标准</h3><p><a href="https://blog.csdn.net/qq_20553613/article/details/81989570" target="_blank" rel="noopener">https://blog.csdn.net/qq_20553613/article/details/81989570</a></p><h3 id="LDRA-Testbed"><a href="#LDRA-Testbed" class="headerlink" title="LDRA Testbed"></a>LDRA Testbed</h3><p>LDRA Testbed provides the core static and dynamic analysis engines for both host and embedded software. LDRA Testbed provides the means to enforce compliance with coding standards such as MISRA, JSF++ AV, CERT C, CWE and provides visibility of software flaws that might typically pass through the standard build and test process to become latent problems.<br><a href="https://en.wikipedia.org/wiki/LDRA_Testbed" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/LDRA_Testbed</a></p><h3 id="rst"><a href="#rst" class="headerlink" title="rst"></a>rst</h3><p><a href="https://www.jianshu.com/p/1885d5570b37" target="_blank" rel="noopener">https://www.jianshu.com/p/1885d5570b37</a></p><h3 id="printf-quot-s-quot-length-string"><a href="#printf-quot-s-quot-length-string" class="headerlink" title="printf(&quot;%.*s&quot;, length, string)"></a><code>printf(&quot;%.*s&quot;, length, string)</code></h3><p><code>printf(&quot;%.*s&quot;, length, string)</code> prints at most <code>length</code> characters of <code>string</code>. </p><h3 id="Long-mode"><a href="#Long-mode" class="headerlink" title="Long mode"></a>Long mode</h3><p>In the x86-64 computer architecture, long mode is the mode where a 64-bit operating system can access 64-bit instructions and registers.</p><h3 id="Bao-a-lightweight-static-partitioning-hypervisor"><a href="#Bao-a-lightweight-static-partitioning-hypervisor" class="headerlink" title="Bao - a lightweight static partitioning hypervisor"></a>Bao - a lightweight static partitioning hypervisor</h3><p><a href="https://github.com/bao-project/bao-hypervisor" target="_blank" rel="noopener">https://github.com/bao-project/bao-hypervisor</a><br><a href="https://drops.dagstuhl.de/opus/volltexte/2020/11779/pdf/OASIcs-NG-RES-2020-3.pdf" target="_blank" rel="noopener">https://drops.dagstuhl.de/opus/volltexte/2020/11779/pdf/OASIcs-NG-RES-2020-3.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ANSI&quot;&gt;&lt;a href=&quot;#ANSI&quot; class=&quot;headerlink&quot; title=&quot;ANSI&quot;&gt;&lt;/a&gt;ANSI&lt;/h3&gt;&lt;p&gt;ANSI是一种字符代码，为使计算机支持更多语言，通常使用 0x00~0x7f 范围的1 个字节来表示 1 个英文字符。超出此范围的使用0x80~0xFFFF来编码，即扩展的ASCII编码。&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>xv6 lab1 notes</title>
    <link href="http://liujunming.github.io/2020/05/18/xv6-lab1-notes/"/>
    <id>http://liujunming.github.io/2020/05/18/xv6-lab1-notes/</id>
    <published>2020-05-18T06:48:52.000Z</published>
    <updated>2020-08-30T01:17:15.255Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录xv6 lab1的相关笔记。</p><a id="more"></a><h2 id="1-Part-1-PC-Bootstrap"><a href="#1-Part-1-PC-Bootstrap" class="headerlink" title="1. Part 1: PC Bootstrap"></a>1. Part 1: PC Bootstrap</h2><h3 id="1-1-Getting-Started-with-x86-assembly"><a href="#1-1-Getting-Started-with-x86-assembly" class="headerlink" title="1.1 Getting Started with x86 assembly"></a>1.1 Getting Started with x86 assembly</h3><p>recommend some learning materials</p><h3 id="1-2-Simulating-the-x86"><a href="#1-2-Simulating-the-x86" class="headerlink" title="1.2 Simulating the x86"></a>1.2 Simulating the x86</h3><p><code>make qemu-nox</code> </p><p>you’re ready to run QEMU, supplying the file <code>obj/kern/kernel.img</code> as the contents of the emulated PC’s “virtual hard disk.” This hard disk image contains both our boot loader (<code>obj/boot/boot</code>) and our kernel (<code>obj/kernel</code>).</p><p>To quit qemu, type <code>Ctrl+a x</code>.</p><h3 id="1-3-The-PC’s-Physical-Address-Space"><a href="#1-3-The-PC’s-Physical-Address-Space" class="headerlink" title="1.3 The PC’s Physical Address Space"></a>1.3 The PC’s Physical Address Space</h3><p> A PC’s physical address space is hard-wired to have the following general layout:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure></p><p>The first PCs, which were based on the 16-bit Intel 8088 processor, were only capable of addressing 1MB of physical memory. The physical address space of an early PC would therefore start at 0x00000000 but end at 0x000FFFFF. The 640KB area marked “Low Memory” was the only random-access memory (RAM) that an early PC could use.</p><p>The 384KB area from 0x000A0000 through 0x000FFFFF was reserved by the hardware for special uses such as video display buffers and firmware held in non-volatile memory. The most important part of this reserved area is the Basic Input/Output System (BIOS), which occupies the 64KB region from 0x000F0000 through 0x000FFFFF. In early PCs the BIOS was held in true read-only memory (ROM), but current PCs store the BIOS in updateable flash memory. The BIOS is responsible for performing basic system initialization such as activating the video card and checking the amount of memory installed. After performing this initialization, the BIOS loads the operating system from some appropriate location such as floppy disk, hard disk, CD-ROM, or the network, and passes control of the machine to the operating system.</p><p>When Intel finally “broke the one megabyte barrier” with the 80286 and 80386 processors, which supported 16MB and 4GB physical address spaces respectively, the PC architects nevertheless preserved the original layout for the low 1MB of physical address space in order to ensure backward compatibility with existing software. Modern PCs therefore have a “hole” in physical memory from 0x000A0000 to 0x00100000, dividing RAM into “low” or “conventional memory” (the first 640KB) and “extended memory” (everything else). In addition, some space at the very top of the PC’s 32-bit physical address space, above all physical RAM, is now commonly reserved by the BIOS for use by 32-bit PCI devices.</p><h3 id="1-4-The-ROM-BIOS"><a href="#1-4-The-ROM-BIOS" class="headerlink" title="1.4 The ROM BIOS"></a>1.4 The ROM BIOS</h3><p>Open two terminal windows and <code>cd</code> both shells into your lab directory. In one, enter <code>make qemu-nox-gdb</code>). This starts up QEMU, but QEMU stops just before the processor executes the first instruction and waits for a debugging connection from GDB. In the second terminal, from the same directory you can run <code>make gdb</code>. You should see something like this,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">athena% make gdb</span><br><span class="line">GNU gdb (GDB) 6.8-debian</span><br><span class="line">Copyright (C) 2008 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;i486-linux-gnu&quot;.</span><br><span class="line">+ target remote localhost:26000</span><br><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0] 0xffff0:ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p><p>The following line:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f000:fff0] 0xffff0:ljmp   $0xf000,$0xe05b</span><br></pre></td></tr></table></figure></p><p>is GDB’s disassembly of the first instruction to be executed. From this output you can conclude a few things:</p><ul><li>The IBM PC starts executing at physical address 0x000ffff0, which is at the very top of the 64KB area reserved for the ROM BIOS.</li><li>The PC starts executing with <code>CS = 0xf000</code> and <code>IP = 0xfff0</code>.</li><li>The first instruction to be executed is a <code>jmp</code> instruction, which jumps to the segmented address <code>CS = 0xf000</code> and <code>IP = 0xe05b</code>.</li></ul><p>Why does QEMU start like this? This is how Intel designed the 8088 processor, which IBM used in their original PC. Because the BIOS in a PC is “hard-wired” to the physical address range 0x000f0000-0x000fffff, this design ensures that the BIOS always gets control of the machine first after power-up or any system restart - which is crucial because on power-up there is no other software anywhere in the machine’s RAM that the processor could execute. The QEMU emulator comes with its own BIOS, which it places at this location in the processor’s simulated physical address space. On processor reset, the (simulated) processor enters real mode and sets CS to 0xf000 and the IP to 0xfff0, so that execution begins at that (CS:IP) segment address. How does the segmented address 0xf000:fff0 turn into a physical address?</p><p>To answer that we need to know a bit about real mode addressing. In real mode (the mode that PC starts off in), address translation works according to the formula: <em>physical address</em> = 16 * <em>segment</em> + <em>offset</em>. So, when the PC sets CS to 0xf000 and IP to 0xfff0, the physical address referenced is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16 * 0xf000 + 0xfff0   # in hex multiplication by 16 is</span><br><span class="line">= 0xf0000 + 0xfff0     # easy--just append a 0.</span><br><span class="line">= 0xffff0</span><br></pre></td></tr></table></figure></p><p>When the BIOS runs, it sets up an interrupt descriptor table and initializes various devices such as the VGA display. This is where the “<strong>Starting SeaBIOS</strong>“ message you see in the QEMU window comes from.</p><p>After initializing the PCI bus and all the important devices the BIOS knows about, it searches for a bootable device such as a floppy, hard drive, or CD-ROM. Eventually, when it finds a bootable disk, the BIOS reads the <em>boot loader</em> from the disk and transfers control to it.</p><h2 id="2-Part-2-The-Boot-Loader"><a href="#2-Part-2-The-Boot-Loader" class="headerlink" title="2. Part 2: The Boot Loader"></a>2. Part 2: The Boot Loader</h2><p>If the disk is bootable, the first sector is called the <em>boot sector</em>, since this is where the boot loader code resides. When the BIOS finds a bootable floppy or hard disk, it loads the 512-byte boot sector into memory at physical addresses 0x7c00 through 0x7dff, and then uses a <code>jmp</code> instruction to set the CS:IP to <code>0000:7c00</code>, passing control to the boot loader.</p><p>The boot loader consists of one assembly language source file, <code>boot/boot.S</code>, and one C source file, <code>boot/main.c</code></p><p>The boot loader must perform two main functions:</p><ol><li>First, the boot loader switches the processor from real mode to <em>32-bit protected mode</em></li><li>Second, the boot loader reads the kernel from the hard disk by directly accessing the IDE disk device registers via the x86’s special I/O instructions. </li></ol><h3 id="2-1-debug"><a href="#2-1-debug" class="headerlink" title="2.1 debug"></a>2.1 debug</h3><p>After you understand the boot loader source code, look at the file <code>obj/boot/boot.asm</code>. This file is a disassembly of the boot loader that our GNUmakefile creates <em>after</em> compiling the boot loader. This disassembly file makes it easy to see exactly where in physical memory all of the boot loader’s code resides, and makes it easier to track what’s happening while stepping through the boot loader in GDB. Likewise, <code>obj/kern/kernel.asm</code> contains a disassembly of the JOS kernel, which can often be useful for debugging.</p><p>You can set address breakpoints in GDB with the <code>b</code> command. For example, <code>b *0x7c00</code>sets a breakpoint at address 0x7C00. Once at a breakpoint, you can continue execution using the <code>c</code> and <code>si</code> commands: <code>c</code> causes QEMU to continue execution until the next breakpoint (or until you press <code>Ctrl-C</code> in GDB), and <code>si N</code> steps through the instructions <em>N</em> at a time.</p><p>To examine instructions in memory (besides the immediate next one to be executed, which GDB prints automatically), you use the <code>x/i</code> command. This command has the syntax <code>x/Ni ADDR</code>, where <em>N</em> is the number of consecutive instructions to disassemble and <em>ADDR</em> is the memory address at which to start disassembling.</p><h3 id="2-2-Loading-the-Kernel"><a href="#2-2-Loading-the-Kernel" class="headerlink" title="2.2 Loading the Kernel"></a>2.2 Loading the Kernel</h3><p>Full information about this format is available in <a href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf" target="_blank" rel="noopener">the ELF specification</a>.</p><p>Examine the full list of the names, sizes, and link addresses of all the sections in the kernel executable by typing:</p><p><code>objdump -h obj/kern/kernel</code></p><p> You can inspect the program headers by typing:</p><p> <code>objdump -x obj/kern/kernel</code></p><p> You can see the entry point:</p><p> <code>objdump -f obj/kern/kernel</code></p><h2 id="3-Part-3-The-Kernel"><a href="#3-Part-3-The-Kernel" class="headerlink" title="3. Part 3: The Kernel"></a>3. Part 3: The Kernel</h2><h3 id="3-1-The-Stack"><a href="#3-1-The-Stack" class="headerlink" title="3.1 The Stack"></a>3.1 The Stack</h3><p>The x86 stack pointer (<code>esp</code> register) points to the lowest location on the stack that is currently in use. Everything <em>below</em> that location in the region reserved for the stack is free. Pushing a value onto the stack involves decreasing the stack pointer and then writing the value to the place the stack pointer points to. Popping a value from the stack involves reading the value the stack pointer points to and then increasing the stack pointer. In 32-bit mode, the stack can only hold 32-bit values, and esp is always divisible by four. Various x86 instructions, such as <code>call</code>, are “hard-wired” to use the stack pointer register.</p><p>The <code>ebp</code> (base pointer) register is associated with the stack primarily by software convention. On entry to a C function, the function’s <em>prologue</em> code normally saves the previous function’s base pointer by pushing it onto the stack, and then copies the current <code>esp</code> value into <code>ebp</code> for the duration of the function. If all the functions in a program obey this convention, then at any given point during the program’s execution, it is possible to trace back through the stack by following the chain of saved <code>ebp</code> pointers and determining exactly what nested sequence of function calls caused this particular point in the program to be reached. This capability can be particularly useful, for example, when a particular function causes an <code>assert</code> failure or <code>panic</code> because bad arguments were passed to it, but you aren’t sure <em>who</em> passed the bad arguments. A stack backtrace lets you find the offending function.</p><hr><p>参考资料：</p><ol><li><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/" target="_blank" rel="noopener">Lab 1: Booting a PC</a></li><li><a href="https://github.com/hehao98/MIT6.828Labs-JOS/blob/master/reports/Lab1.md" target="_blank" rel="noopener">https://github.com/hehao98/MIT6.828Labs-JOS/blob/master/reports/Lab1.md</a></li><li><a href="https://hehao98.github.io/posts/2019/03/xv6-1/" target="_blank" rel="noopener">XV6操作系统代码阅读心得</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录xv6 lab1的相关笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://liujunming.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://liujunming.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="xv6" scheme="http://liujunming.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第13期</title>
    <link href="http://liujunming.github.io/2020/05/17/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC13%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2020/05/17/每周分享第13期/</id>
    <published>2020-05-17T00:31:14.000Z</published>
    <updated>2020-08-30T01:17:15.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="The-motivation-of-ebp-register"><a href="#The-motivation-of-ebp-register" class="headerlink" title="The motivation of ebp register"></a>The motivation of ebp register</h3><p>The <code>ebp</code> (base pointer) register is associated with the stack primarily by software convention. On entry to a C function, the function’s <em>prologue</em> code normally saves the previous function’s base pointer by pushing it onto the stack, and then copies the current <code>esp</code> value into <code>ebp</code> for the duration of the function. If all the functions in a program obey this convention, then at any given point during the program’s execution, it is possible to trace back through the stack by following the chain of saved <code>ebp</code> pointers and determining exactly what nested sequence of function calls caused this particular point in the program to be reached. This capability can be particularly useful, for example, when a particular function causes an <code>assert</code> failure or <code>panic</code> because bad arguments were passed to it, but you aren’t sure <em>who</em> passed the bad arguments. A stack backtrace lets you find the offending function.<br><a id="more"></a><br><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/#The-Stack" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2018/labs/lab1/#The-Stack</a></p><h3 id="ANSI-escape-code"><a href="#ANSI-escape-code" class="headerlink" title="ANSI escape code"></a>ANSI escape code</h3><p>在linux console显示各种颜色的信息可以使用特殊的符号串：escape  sequence code.通过使用escape sequence code可以在linux终端以高亮，粗体，闪烁、多种颜色等方式展示消息。</p><p><a href="https://blog.csdn.net/lano2088/article/details/51985563" target="_blank" rel="noopener">https://blog.csdn.net/lano2088/article/details/51985563</a><br><a href="https://en.wikipedia.org/wiki/ANSI_escape_code" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/ANSI_escape_code</a><br><a href="http://rrbrandt.dee.ufcg.edu.br/en/docs/ansi/" target="_blank" rel="noopener">http://rrbrandt.dee.ufcg.edu.br/en/docs/ansi/</a></p><h3 id="Carbon-Create-and-share-beautiful-images-of-your-source-code"><a href="#Carbon-Create-and-share-beautiful-images-of-your-source-code" class="headerlink" title="Carbon: Create and share beautiful images of your source code"></a>Carbon: Create and share beautiful images of your source code</h3><p><a href="https://github.com/carbon-app/carbon" target="_blank" rel="noopener">https://github.com/carbon-app/carbon</a></p><h3 id="silicon"><a href="#silicon" class="headerlink" title="silicon"></a>silicon</h3><p><a href="https://github.com/Aloxaf/silicon" target="_blank" rel="noopener">https://github.com/Aloxaf/silicon</a><br>功能和Carbon基本一致，无需浏览器和网络</p><h3 id="openAPI"><a href="#openAPI" class="headerlink" title="openAPI"></a>openAPI</h3><p>举个例子：<br>现在的互联网充满了一个又一个信息孤岛和大量的碎片化的数据，用户想知道一些资讯，必须在不同的网站上跑来跑去.比如看电影，首先去google map查看周围的电影院，然后去大众点评网查看对这家电影院的评论，然后去电影院的网站上看看今天有什么电影上映。然后支付网站进行电子购票.整个过程非常繁琐，数据之间没有关联.充斥着大量的异构系统.<br>为了解决这些问题.我们引入了openapi的概念.通过openapi,数据提供商开放了自己的数据，通过mashup将信息孤岛连接起来.整合这些信息碎片. </p><p>如果google,大众点评网，电影院，支付宝均开放自己的openapi.然后有一个mashup程序将他们整合起来.那么用户就能体验一站式购物.进这个网站，找到电影院，查看电影院评价，如果评价好，查看电影院上映什么节目。电子订票.然后就能直接杀过去了。省时省力 。</p><p><a href="https://blog.csdn.net/sinat_37529938/article/details/89098454" target="_blank" rel="noopener">https://blog.csdn.net/sinat_37529938/article/details/89098454</a><br><a href="https://www.youtube.com/watch?v=s9u3mXQZbXI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=s9u3mXQZbXI</a></p><h3 id="Linux-containers-in-a-few-lines-of-code"><a href="#Linux-containers-in-a-few-lines-of-code" class="headerlink" title="Linux containers in a few lines of code"></a>Linux containers in a few lines of code</h3><p><a href="https://zserge.com/posts/containers/" target="_blank" rel="noopener">https://zserge.com/posts/containers/</a></p><h3 id="《如何阅读一本书》"><a href="#《如何阅读一本书》" class="headerlink" title="《如何阅读一本书》"></a>《如何阅读一本书》</h3><p>作者：莫提默•J•艾德勒/查尔斯•范多伦<br><a href="http://t.cn/A6AUGPrb?m=4503332151139449&amp;u=6610719877" target="_blank" rel="noopener">http://t.cn/A6AUGPrb?m=4503332151139449&amp;u=6610719877</a></p><h3 id="platuml"><a href="#platuml" class="headerlink" title="platuml"></a>platuml</h3><p><a href="https://plantuml.com/zh/" target="_blank" rel="noopener">https://plantuml.com/zh/</a></p><h3 id="multiboot"><a href="#multiboot" class="headerlink" title="multiboot"></a>multiboot</h3><p>Every operating system ever created tends to have its own boot loader. Installing a new operating system on a machine generally involves installing a whole new set of boot mechanisms, each with completely different install-time and boot-time user interfaces. Getting multiple operating systems to coexist reliably on one machine through typical chaining mechanisms can be a nightmare. There is little or no choice of boot loaders for a particular operating system — if the one that comes with the operating system doesn’t do exactly what you want, or doesn’t work on your machine, you’re screwed.</p><p>While we may not be able to fix this problem in existing proprietary operating systems, it shouldn’t be too difficult for a few people in the free operating system communities to put their heads together and solve this problem for the popular free operating systems. That’s what this specification aims for. Basically, it specifies an interface between a boot loader and a operating system, such that any complying boot loader should be able to load any complying operating system. This specification does not specify how boot loaders should work — only how they must interface with the operating system being loaded.</p><p><a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/multiboot/multiboot.html</a></p><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p><a href="https://www.youtube.com/watch?v=LFDrDnKPOTg" target="_blank" rel="noopener">https://www.youtube.com/watch?v=LFDrDnKPOTg</a></p><h3 id="OAuth-2-0-的一个简单解释"><a href="#OAuth-2-0-的一个简单解释" class="headerlink" title="OAuth 2.0 的一个简单解释"></a>OAuth 2.0 的一个简单解释</h3><p><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/04/oauth_design.html</a></p><h3 id="EDA工具"><a href="#EDA工具" class="headerlink" title="EDA工具"></a>EDA工具</h3><p>EDA技术就是以计算机为工具，设计者在EDA软件平台上，用硬件描述语言VerilogHDL完成设计文件，然后由计算机自动地完成逻辑编译、化简、分割、综合、优化、布局、布线和仿真，直至对于特定目标芯片的适配编译、逻辑映射和编程下载等工作。EDA技术的出现，极大地提高了电路设计的效率和可操作性，减轻了设计者的劳动强度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;The-motivation-of-ebp-register&quot;&gt;&lt;a href=&quot;#The-motivation-of-ebp-register&quot; class=&quot;headerlink&quot; title=&quot;The motivation of ebp register&quot;&gt;&lt;/a&gt;The motivation of ebp register&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;ebp&lt;/code&gt; (base pointer) register is associated with the stack primarily by software convention. On entry to a C function, the function’s &lt;em&gt;prologue&lt;/em&gt; code normally saves the previous function’s base pointer by pushing it onto the stack, and then copies the current &lt;code&gt;esp&lt;/code&gt; value into &lt;code&gt;ebp&lt;/code&gt; for the duration of the function. If all the functions in a program obey this convention, then at any given point during the program’s execution, it is possible to trace back through the stack by following the chain of saved &lt;code&gt;ebp&lt;/code&gt; pointers and determining exactly what nested sequence of function calls caused this particular point in the program to be reached. This capability can be particularly useful, for example, when a particular function causes an &lt;code&gt;assert&lt;/code&gt; failure or &lt;code&gt;panic&lt;/code&gt; because bad arguments were passed to it, but you aren’t sure &lt;em&gt;who&lt;/em&gt; passed the bad arguments. A stack backtrace lets you find the offending function.&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第12期</title>
    <link href="http://liujunming.github.io/2020/05/10/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC12%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2020/05/10/每周分享第12期/</id>
    <published>2020-05-10T12:29:18.000Z</published>
    <updated>2020-08-30T01:17:15.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Computer-Science-Map"><a href="#Computer-Science-Map" class="headerlink" title="Computer Science Map"></a>Computer Science Map</h3><p><a href="https://abhinavmarwaha.com/tech-notes/2020-02-02-Computer-Science-Map/" target="_blank" rel="noopener">https://abhinavmarwaha.com/tech-notes/2020-02-02-Computer-Science-Map/</a><br><a id="more"></a></p><h3 id="Alibaba-Cloud-Linux-2-LTS-OS-启动优化实践"><a href="#Alibaba-Cloud-Linux-2-LTS-OS-启动优化实践" class="headerlink" title="Alibaba Cloud Linux 2 LTS OS 启动优化实践"></a>Alibaba Cloud Linux 2 LTS OS 启动优化实践</h3><p><a href="https://www.infoq.cn/article/yIQKuBgO4JluGCYTv6a3" target="_blank" rel="noopener">https://www.infoq.cn/article/yIQKuBgO4JluGCYTv6a3</a></p><h3 id="EPT-Based-Sub-page-Write-Protection"><a href="#EPT-Based-Sub-page-Write-Protection" class="headerlink" title="EPT-Based Sub-page Write Protection"></a>EPT-Based Sub-page Write Protection</h3><p><a href="https://www.slideshare.net/xen_com_mgr/xpdds18-eptbased-subpage-write-protection-on-xenc-yi-zhang-intel" target="_blank" rel="noopener">https://www.slideshare.net/xen_com_mgr/xpdds18-eptbased-subpage-write-protection-on-xenc-yi-zhang-intel</a></p><h3 id="GUTS-channel"><a href="#GUTS-channel" class="headerlink" title="GUTS channel"></a>GUTS channel</h3><p><a href="https://www.youtube.com/channel/UCIm-u7l65hp5jboSJrB7U5w" target="_blank" rel="noopener">https://www.youtube.com/channel/UCIm-u7l65hp5jboSJrB7U5w</a></p><p>jserv<br><a href="http://wiki.csie.ncku.edu.tw/User/jserv" target="_blank" rel="noopener">http://wiki.csie.ncku.edu.tw/User/jserv</a><br><a href="http://wiki.csie.ncku.edu.tw/embedded/schedule" target="_blank" rel="noopener">http://wiki.csie.ncku.edu.tw/embedded/schedule</a></p><h3 id="Memory-protection-unit"><a href="#Memory-protection-unit" class="headerlink" title="Memory protection unit"></a>Memory protection unit</h3><p>A memory protection unit (MPU), is a computer hardware unit that provides memory protection. It is usually implemented as part of the central processing unit (CPU). MPU is a trimmed down version of memory management unit (MMU) providing only memory protection support. It is usually implemented in low power processors that require only memory protection and do not need the full fledged feature of a memory management unit like virtual memory management.</p><p><a href="https://en.wikipedia.org/wiki/Memory_protection_unit" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Memory_protection_unit</a></p><h3 id="GAS"><a href="#GAS" class="headerlink" title="GAS"></a>GAS</h3><p>GNU Assembler</p><p><a href="https://www.tldp.org/HOWTO/Assembly-HOWTO/gas.html" target="_blank" rel="noopener">https://www.tldp.org/HOWTO/Assembly-HOWTO/gas.html</a><br><a href="https://cs.lmu.edu/~ray/notes/gasexamples/" target="_blank" rel="noopener">https://cs.lmu.edu/~ray/notes/gasexamples/</a></p><h3 id="CGA"><a href="#CGA" class="headerlink" title="CGA"></a>CGA</h3><p>Short for Color Graphics Adapter, CGA was an early IBM video adapter.CGA has the highest resolution of 640 x 200, color depth of 4-bit, and supports 16 colors (24 = 16).</p><p><a href="https://www.computerhope.com/jargon/c/cga.htm" target="_blank" rel="noopener">https://www.computerhope.com/jargon/c/cga.htm</a></p><h3 id="Scratch-space"><a href="#Scratch-space" class="headerlink" title="Scratch space"></a>Scratch space</h3><p>Scratch space is space on the hard disk drive that is dedicated for storage of temporary user data. It is unreliable by intention and has no back up. Scratch disks may occasionally be set to erase all data at regular intervals so that the disk space is left free for future use. The management of scratch disk space is typically dynamic, occurring when needed. Its advantage is that it is faster than e.g. network filesystems.</p><p>Scratch space is commonly used scientific computing workstations, and in graphic design programs such as Adobe Photoshop. It is used when programs need to use more data than can be stored in system RAM.<br><a href="https://en.wikipedia.org/wiki/Scratch_space" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Scratch_space</a><br><a href="https://www.computerhope.com/jargon/s/scratch-space.htm" target="_blank" rel="noopener">https://www.computerhope.com/jargon/s/scratch-space.htm</a></p><h3 id="DIMM-dual-in-line-memory-module"><a href="#DIMM-dual-in-line-memory-module" class="headerlink" title="DIMM(dual in-line memory module)"></a>DIMM(dual in-line memory module)</h3><p>DIMM (dual in-line memory module) is a type of computer memory that is natively 64 bits, enabling fast data transfer.<br>DIMM is a module that contains one or several random access memory (RAM) chips on a small circuit board with pins that connect it to the computer motherboard.</p><p><a href="https://searchstorage.techtarget.com/definition/DIMM" target="_blank" rel="noopener">https://searchstorage.techtarget.com/definition/DIMM</a></p><p><img src="/images/2020/05/2.jpg" alt></p><center>Three SDRAM DIMM slots on a computer motherboard</center>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Computer-Science-Map&quot;&gt;&lt;a href=&quot;#Computer-Science-Map&quot; class=&quot;headerlink&quot; title=&quot;Computer Science Map&quot;&gt;&lt;/a&gt;Computer Science Map&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://abhinavmarwaha.com/tech-notes/2020-02-02-Computer-Science-Map/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://abhinavmarwaha.com/tech-notes/2020-02-02-Computer-Science-Map/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>variable argument function in c</title>
    <link href="http://liujunming.github.io/2020/05/07/variable-argument-function-in-c/"/>
    <id>http://liujunming.github.io/2020/05/07/variable-argument-function-in-c/</id>
    <published>2020-05-07T01:22:38.000Z</published>
    <updated>2020-08-30T01:17:15.255Z</updated>
    
    <content type="html"><![CDATA[<p>C语言的可变参数函数主要用到了一个类型<code>va_list</code>和三个宏——<code>va_start</code>、<code>va_arg</code>和<code>va_end</code>。<a id="more"></a></p><p>本文转载自：</p><ol><li><a href="http://blog.sina.com.cn/s/blog_3fe961ae0100nf1l.html" target="_blank" rel="noopener">C语言实现可变参数函数</a></li><li><a href="https://mudongliang.github.io/2017/02/20/cva_argva_listva_startva_end.html" target="_blank" rel="noopener">深入C语言可变参数</a></li></ol><h3 id="1-什么是可变参数"><a href="#1-什么是可变参数" class="headerlink" title="1. 什么是可变参数"></a>1. 什么是可变参数</h3><p>在C语言编程中有时会遇到一些参数个数可变的函数，例如<code>printf()</code>,<code>scanf()</code>函数，其函数原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format,…)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,…)</span></span></span><br></pre></td></tr></table></figure></p><p>它除了有一个参数format固定以外，后面跟着的参数的个数和类型是可变的(用三个点“…”做参数占位符)</p><h3 id="2-简单的可变参数例子"><a href="#2-简单的可变参数例子" class="headerlink" title="2. 简单的可变参数例子"></a>2. 简单的可变参数例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_args</span><span class="params">(<span class="keyword">int</span> count, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">print_args(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_args</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, value;</span><br><span class="line">va_list arg_ptr;</span><br><span class="line">va_start(arg_ptr, count);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">value = va_arg(arg_ptr,<span class="keyword">int</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"position %d = %d\n"</span>, i+<span class="number">1</span>, value);</span><br><span class="line">&#125;</span><br><span class="line">va_end(arg_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言的可变参数函数主要用到了一个类型&lt;code&gt;va_list&lt;/code&gt;和三个宏——&lt;code&gt;va_start&lt;/code&gt;、&lt;code&gt;va_arg&lt;/code&gt;和&lt;code&gt;va_end&lt;/code&gt;。
    
    </summary>
    
      <category term="计算机编程" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机编程" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>QEMU usage notes</title>
    <link href="http://liujunming.github.io/2020/05/06/QEMU-usage-notes/"/>
    <id>http://liujunming.github.io/2020/05/06/QEMU-usage-notes/</id>
    <published>2020-05-06T14:00:54.000Z</published>
    <updated>2020-08-30T01:17:15.248Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录qemu的使用经验。<br><a id="more"></a></p><h3 id="behavior-of-serial-stdio-vs-serial-mon-stdio"><a href="#behavior-of-serial-stdio-vs-serial-mon-stdio" class="headerlink" title="behavior of -serial stdio vs. -serial mon:stdio"></a>behavior of <code>-serial stdio</code> vs. <code>-serial mon:stdio</code></h3><p>To avoid QEMU being terminated on SIGINT (Ctrl+c), instead of just <code>stdio</code>, supply the special parameter <code>mon:stdio</code> to<code>-serial</code> option. </p><p><a href="https://kashyapc.wordpress.com/2016/02/11/qemu-command-line-behavior-of-serial-stdio-vs-serial-monstdio/" target="_blank" rel="noopener">https://kashyapc.wordpress.com/2016/02/11/qemu-command-line-behavior-of-serial-stdio-vs-serial-monstdio/</a></p><h3 id="quit-the-QEMU-monitor-when-not-using-a-GUI"><a href="#quit-the-QEMU-monitor-when-not-using-a-GUI" class="headerlink" title="quit the QEMU monitor when not using a GUI"></a>quit the QEMU monitor when not using a GUI</h3><p><code>Ctrl-A X</code><br><a href="https://superuser.com/questions/1087859/how-to-quit-the-qemu-monitor-when-not-using-a-gui" target="_blank" rel="noopener">https://superuser.com/questions/1087859/how-to-quit-the-qemu-monitor-when-not-using-a-gui</a></p><h3 id="built-in-monitor-mode"><a href="#built-in-monitor-mode" class="headerlink" title="built-in monitor mode"></a>built-in monitor mode</h3><p><a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2018/labguide.html</a></p><p>QEMU includes a built-in monitor that can inspect and modify the machine state in useful ways. To enter the monitor, press <code>Ctrl-a c</code> in the terminal running QEMU. Press <code>Ctrl-a c</code> again to switch back to the serial console.</p><p>For a complete reference to the monitor commands, see the <a href="http://wiki.qemu.org/download/qemu-doc.html#pcsys_005fmonitor" target="_blank" rel="noopener">QEMU manual</a>. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录qemu的使用经验。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Dive into paging mechanism</title>
    <link href="http://liujunming.github.io/2020/05/04/Dive-into-paging-mechanism/"/>
    <id>http://liujunming.github.io/2020/05/04/Dive-into-paging-mechanism/</id>
    <published>2020-05-04T05:57:24.000Z</published>
    <updated>2020-08-30T01:17:15.239Z</updated>
    
    <content type="html"><![CDATA[<p>本文将结合<a href="https://github.com/cirosantilli/x86-bare-metal-examples#536-paging" target="_blank" rel="noopener">x86-bare-metal-examples</a>与SDM，展示Intel IA32架构下paging的具体用法。<a id="more"></a></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>MMU使用页表，将虚拟地址转为物理地址。</p><p><img src="/images/2020/05/3.PNG" alt><br><img src="/images/2020/05/4.PNG" alt></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">    CLEAR</span><br><span class="line">    STAGE2</span><br><span class="line">    PROTECTED_MODE</span><br><span class="line">    SETUP_PAGING_4M</span><br><span class="line"></span><br><span class="line">    /* Setup a test canary value. */</span><br><span class="line">    movl $0x1234, 0x1000</span><br><span class="line"></span><br><span class="line">    /* Print the canary to make sure it is really there. */</span><br><span class="line">    VGA_PRINT_HEX_4 0x1000</span><br><span class="line"></span><br><span class="line">    /* Make page 0 point to page frame 1(i.e. virtual address 0 points to physical address 4KB)</span><br><span class="line">     * by setting bit 12 of the Page Table Entry structure.</span><br><span class="line">     *</span><br><span class="line">     * At SETUP_PAGING_4M, page_table has been setup to</span><br><span class="line">     * point page frame 0(i.e. page 0 point to page frame 0).</span><br><span class="line">     * Bit 12 is the lowest bit of the &quot;Address of 4KB page frame&quot; field,</span><br><span class="line">     * By setting it, can relocate page 0 point to page frame 1.</span><br><span class="line">     */</span><br><span class="line">    orw $0x1000, page_table</span><br><span class="line"></span><br><span class="line">    PAGING_ON</span><br><span class="line"></span><br><span class="line">    /* THIS is what we&apos;ve been working for!!!</span><br><span class="line">     * Even though we mov to 0, the paging circuit reads that as physical address 0x1000,</span><br><span class="line">     * so the canary value 0x1234 should be modified to 0x5678.</span><br><span class="line">     **/</span><br><span class="line">    movl $0x5678, 0</span><br><span class="line"></span><br><span class="line">    /* Turn paging back off to prevent it from messing with us. */</span><br><span class="line">    PAGING_OFF</span><br><span class="line"></span><br><span class="line">    /* Print the (hopefully) modified value 0x5678. */</span><br><span class="line">    VGA_PRINT_HEX_4 0x1000</span><br></pre></td></tr></table></figure><p>第5行代码调用宏<code>SETUP_PAGING_4M</code>来建立4MB 内存区域的页表，后面会详细分析该宏。</p><p>第8行代码往物理地址4KB处写入0x1234。</p><p>第21行代码让page 0指向page frame 1(即：virtual address 0 points to physical address 4KB)。</p><p>第23行代码调用宏<code>PAGING_ON</code>来开启分页，后面会详细分析该宏。</p><p>第29行代码是往虚拟地址0写入0x5678，此时，物理地址4KB处的内容被更改为0x5678。</p><p>第32行代码调用宏<code>PAGING_OFF</code>来关闭分页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/* Setup the first Page Directory entry, which gives us a 4MB(2^10 * 2^12) memory region.</span><br><span class="line"> * The memory region starts at 0, and the virtual address and physical address are identical.</span><br><span class="line"> * </span><br><span class="line"> * The currently executing code is inside that range, or else we&apos;d jump somewhere and die.</span><br><span class="line"> */</span><br><span class="line">.equ page_directory, __end_align_4k</span><br><span class="line">.equ page_table, __end_align_4k + 0x1000</span><br><span class="line">.macro SETUP_PAGING_4M</span><br><span class="line">    LOCAL page_setup_start page_setup_end</span><br><span class="line">    PUSH_EADX</span><br><span class="line"></span><br><span class="line">    /* Page Directory setup. */</span><br><span class="line">    mov $page_table, %eax</span><br><span class="line">    /* Clear the low 12 bits of the first Page Directory entry. */</span><br><span class="line">    and $0xF000, %ax</span><br><span class="line">    /* Set the P, R/W, U/S, and A bits of the first Page Directory entry. */</span><br><span class="line">    orb $0b00100111, %al</span><br><span class="line">    /* Setup the first Page Directory entry. */</span><br><span class="line">    mov %eax, page_directory</span><br><span class="line"></span><br><span class="line">    /* Page table setup. */</span><br><span class="line">    mov $0, %eax</span><br><span class="line">    mov $page_table, %ebx</span><br><span class="line">page_setup_start:</span><br><span class="line">    cmp $0x400, %eax</span><br><span class="line">    je page_setup_end</span><br><span class="line">    /* Top 20 address bits. */</span><br><span class="line">    mov %eax, %edx</span><br><span class="line">    shl $12, %edx</span><br><span class="line">    /* For flag bits 0-7. We only set bit 0 and bit 1:</span><br><span class="line">     * - bit 0: Page present</span><br><span class="line">     * - bit 1: Page is writable.</span><br><span class="line">     *  Might work without this as the permission also depends on CR0.WP.</span><br><span class="line">     */</span><br><span class="line">    mov $0b00000011, %dl</span><br><span class="line">    /* Zero flag bits 8-11 */</span><br><span class="line">    and $0xF0, %dh</span><br><span class="line">    /* Setup the PTE(Page Table Entry). */</span><br><span class="line">    mov %edx, (%ebx)</span><br><span class="line">    inc %eax</span><br><span class="line">    add $4, %ebx</span><br><span class="line">    jmp page_setup_start</span><br><span class="line">page_setup_end:</span><br><span class="line">    POP_EDAX</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p><code>page_directory</code>是Page Directory的物理地址。</p><p><code>page_table</code>是Page Directory第一个entry指向的Page Table的物理地址。</p><p>该宏只置Page Directory第一个entry的present位为1。同时，设置Page Table，使得page 0指向page frame 0， page 1指向page frame 1…，page 1023指向page frame 1023。这样，就配置好了4MB(2^10 * 2^12)大小的内存区域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* * Turn paging on.</span><br><span class="line"> * The cr3 register does have a format, it is not simply the address of the page directory:</span><br><span class="line"> *</span><br><span class="line"> * Many tutorials simply ignore bits 3 and 4, and do a direct address mov to `cr3`.</span><br><span class="line"> *</span><br><span class="line"> * This sets the 20 top address bits to their correct value, and puts trash in bits 3 and 4,</span><br><span class="line"> * but it generally works.</span><br><span class="line"> */</span><br><span class="line">.macro PAGING_ON</span><br><span class="line">    /* Tell the CPU where the page directory is. */</span><br><span class="line">    mov $page_directory, %eax</span><br><span class="line">    mov %eax, %cr3</span><br><span class="line"></span><br><span class="line">    /* Turn paging on. */</span><br><span class="line">    mov %cr0, %eax</span><br><span class="line">    or $0x80000000, %eax</span><br><span class="line">    mov %eax, %cr0</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">/* Turn paging off. */</span><br><span class="line">.macro PAGING_OFF</span><br><span class="line">    mov %cr0, %eax</span><br><span class="line">    and $0x7FFFFFFF, %eax</span><br><span class="line">    mov  %eax, %cr0</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p><img src="/images/2020/05/5.PNG" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将结合&lt;a href=&quot;https://github.com/cirosantilli/x86-bare-metal-examples#536-paging&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;x86-bare-metal-examples&lt;/a&gt;与SDM，展示Intel IA32架构下paging的具体用法。
    
    </summary>
    
      <category term="内存管理" scheme="http://liujunming.github.io/categories/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="内存管理" scheme="http://liujunming.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第11期</title>
    <link href="http://liujunming.github.io/2020/05/03/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC11%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2020/05/03/每周分享第11期/</id>
    <published>2020-05-03T09:06:42.000Z</published>
    <updated>2020-08-30T01:17:15.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统安装心得"><a href="#系统安装心得" class="headerlink" title="系统安装心得"></a>系统安装心得</h3><ol><li>查看硬盘分区表格式是MBR还是GPT</li><li>利用rufus制作系统盘<a id="more"></a></li></ol><p>1.MBR or GPT<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure></p><p>dos mode is mbr<br><a href="https://unix.stackexchange.com/questions/61142/remove-gpt-default-back-to-mbr" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/61142/remove-gpt-default-back-to-mbr</a></p><p>2.rufus<br><a href="https://www.jianshu.com/p/c23ac08421bc" target="_blank" rel="noopener">https://www.jianshu.com/p/c23ac08421bc</a></p><h3 id="Intel-Compute-Stick"><a href="#Intel-Compute-Stick" class="headerlink" title="Intel Compute Stick"></a>Intel Compute Stick</h3><p><a href="https://www.intel.com/content/www/us/en/compute-stick/intel-compute-stick-core-video.html" target="_blank" rel="noopener">https://www.intel.com/content/www/us/en/compute-stick/intel-compute-stick-core-video.html</a><br>Convert Your TV to PC with Intel Compute Stick</p><h3 id="PS-2-vs-USB"><a href="#PS-2-vs-USB" class="headerlink" title="PS/2 vs USB"></a>PS/2 vs USB</h3><p><img src="/images/2020/05/1.jpg" alt><br>PS/2 is a “port” while USB is a “bus” .<br>The difference is a port is designed to connect a single device, while a bus is designed to connect many devices together. They can all be connected to a single USB host controller using a hub. With PS/2 I’d need a separate connector for each device.</p><p><a href="https://www.quora.com/PS-2-vs-USB-what-are-the-advantages-and-disadvantages-of-each" target="_blank" rel="noopener">https://www.quora.com/PS-2-vs-USB-what-are-the-advantages-and-disadvantages-of-each</a></p><h3 id="canary-test"><a href="#canary-test" class="headerlink" title="canary test"></a>canary test</h3><p>In software testing, a canary is a push of programming code changes to a small group of end users who are unaware that they are receiving new code. Because the canary is only distributed to a small number of users, its impact is relatively small and changes can be reversed quickly should the new code prove to be buggy.</p><p><a href="https://whatis.techtarget.com/definition/canary-canary-testing" target="_blank" rel="noopener">https://whatis.techtarget.com/definition/canary-canary-testing</a></p><h3 id="资源合集"><a href="#资源合集" class="headerlink" title="资源合集"></a>资源合集</h3><p>《资本的故事》<br><a href="https://www.bilibili.com/video/BV1mW411J7ED" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1mW411J7ED</a></p><p>Manager’s Playbook: Heuristics for effective management<br><a href="https://github.com/ksindi/managers-playbook" target="_blank" rel="noopener">https://github.com/ksindi/managers-playbook</a></p><p>Teleforking a Process onto a Different Computer<br><a href="https://thume.ca/2020/04/18/telefork-forking-a-process-onto-a-different-computer/" target="_blank" rel="noopener">https://thume.ca/2020/04/18/telefork-forking-a-process-onto-a-different-computer/</a></p><p>Beginners guide to gateways and proxies<br><a href="https://dev.to/peterj/beginners-guide-to-gateways-and-proxies-1npn" target="_blank" rel="noopener">https://dev.to/peterj/beginners-guide-to-gateways-and-proxies-1npn</a></p><h3 id="Orbital-Edge-Computing-Nanosatellite-Constellations-as-a-New-Class-of-Computer-System"><a href="#Orbital-Edge-Computing-Nanosatellite-Constellations-as-a-New-Class-of-Computer-System" class="headerlink" title="Orbital Edge Computing: Nanosatellite Constellations as a New Class of Computer System"></a>Orbital Edge Computing: Nanosatellite Constellations as a New Class of Computer System</h3><p>From:包云岗</p><blockquote><p>2020年度计算机体系结构/操作系统/编译编程三个领域综合的国际顶会ASPLOS最佳论文奖之一是来自CMU的一项关于卫星集群的工作：《Orbital Edge Computing: Nanosatellite Constellations as a New Class of Computer System》。作者认为卫星集群将会是一种新的计算机系统。<br>我们组里研讨过这篇论文，其实技术上并没有特别大的突破和新的洞察力，实验也还只是在模拟器进行。获得最佳论文奖主要还是因为给大家畅想了一个未来愿景。</p></blockquote><h3 id="x86-64-canonical-address"><a href="#x86-64-canonical-address" class="headerlink" title="x86-64 canonical address"></a>x86-64 canonical address</h3><p><a href="https://stackoverflow.com/questions/25852367/x86-64-canonical-address" target="_blank" rel="noopener">https://stackoverflow.com/questions/25852367/x86-64-canonical-address</a></p><blockquote><p>In 64-bit mode, an address is considered to be in canonical form if address bits 63 through to the most-significant implemented bit by the microarchitecture are set to either all ones or all zeros.</p></blockquote><p>I.e. a canonical virtual address is 48 bits correctly sign-extended to 64. If the high bits don’t match, it’s non-canonical and will fault if you attempt to dereference it.</p><h3 id="“-”-colon-in-C-struct"><a href="#“-”-colon-in-C-struct" class="headerlink" title="“:” (colon) in C struct"></a>“:” (colon) in C struct</h3><p><a href="https://stackoverflow.com/questions/8564532/colon-in-c-struct-what-does-it-mean" target="_blank" rel="noopener">https://stackoverflow.com/questions/8564532/colon-in-c-struct-what-does-it-mean</a><br><a href="https://stackoverflow.com/questions/824295/what-does-c-struct-syntax-a-b-mean" target="_blank" rel="noopener">https://stackoverflow.com/questions/824295/what-does-c-struct-syntax-a-b-mean</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> a : <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">char</span> b : <span class="number">3</span>;</span><br><span class="line">&#125; test3;</span><br></pre></td></tr></table></figure><p><code>sizeof(test3) = 1</code></p><p>Keywords: Bitfields</p><h3 id="acrn-vm-type"><a href="#acrn-vm-type" class="headerlink" title="acrn vm type"></a>acrn vm type</h3><ul><li><p>Pre-launched VM(launched before the Service VM is started)</p></li><li><p>Service VM</p></li><li><p>Post-launched VM(launched by the Service VM)</p></li></ul><p>  <a href="https://projectacrn.org/acrn-project-releases-version-1-0/" target="_blank" rel="noopener">https://projectacrn.org/acrn-project-releases-version-1-0/</a></p><h3 id="Xenomai"><a href="#Xenomai" class="headerlink" title="Xenomai"></a>Xenomai</h3><p><a href="https://gitlab.denx.de/Xenomai/xenomai/-/wikis/home" target="_blank" rel="noopener">https://gitlab.denx.de/Xenomai/xenomai/-/wikis/home</a></p><p>Xenomai is about making various real-time operating system APIs available to Linux-based platforms. When the target Linux kernel cannot meet the requirements with respect to response time constraints, Xenomai can also supplement it for delivering stringent real-time guarantees.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;系统安装心得&quot;&gt;&lt;a href=&quot;#系统安装心得&quot; class=&quot;headerlink&quot; title=&quot;系统安装心得&quot;&gt;&lt;/a&gt;系统安装心得&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;查看硬盘分区表格式是MBR还是GPT&lt;/li&gt;
&lt;li&gt;利用rufus制作系统盘
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解RTC</title>
    <link href="http://liujunming.github.io/2020/05/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RTC/"/>
    <id>http://liujunming.github.io/2020/05/02/深入理解RTC/</id>
    <published>2020-05-02T08:31:24.000Z</published>
    <updated>2020-08-30T01:17:15.263Z</updated>
    
    <content type="html"><![CDATA[<p>本文将深入介绍RTC(Real Time Clock)，并结合代码进行解析。<a id="more"></a></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>A real-time clock (RTC) is a computer clock (most often in the form of an integrated circuit) that keeps track of the current time.</p><p>RTC can only be accessed through IO Ports 0x70 and 0x71.</p><h3 id="Shortage"><a href="#Shortage" class="headerlink" title="Shortage"></a>Shortage</h3><p>The RTC cannot give accuracy greater than seconds. For that, consider the PIT, or the HPET.</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>代码源于<a href="/2020/05/02/x86-bare-metal-examples-Project/">x86-bare-metal-examples</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Reference: https://wiki.osdev.org/CMOS</span><br><span class="line">Register  Contents            Range</span><br><span class="line">0x00      Seconds             0–59</span><br><span class="line">0x02      Minutes             0–59</span><br><span class="line">0x04      Hours               0–23 in 24-hour mode, </span><br><span class="line">      1–12 in 12-hour mode, highest bit set if pm</span><br><span class="line">0x07      Day of Month        1–31</span><br><span class="line">0x08      Month               1–12</span><br><span class="line">0x09      Year                0–99</span><br><span class="line"></span><br><span class="line">0x0A      Status Register A</span><br><span class="line">RTC has an &quot;Update in progress&quot; flag (bit 7 of Status Register A). </span><br><span class="line">To read the time and date properly you have to wait until </span><br><span class="line">the &quot;Update in progress&quot; flag goes from &quot;set&quot; to &quot;clear&quot;. </span><br><span class="line">*/ </span><br><span class="line">.equ RTCaddress, 0x70</span><br><span class="line">.equ RTCdata, 0x71</span><br><span class="line"></span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line">BEGIN</span><br><span class="line">update_in_progress:</span><br><span class="line">    mov $0x0A, %al</span><br><span class="line">    out %al, $RTCaddress</span><br><span class="line">    in $RTCdata, %al</span><br><span class="line">    testb $0x80, %al</span><br><span class="line">    jne update_in_progress</span><br><span class="line"></span><br><span class="line">    /* Second. */</span><br><span class="line">    mov $0x00, %al</span><br><span class="line">    out %al, $RTCaddress</span><br><span class="line">    in $RTCdata, %al</span><br><span class="line"></span><br><span class="line">    /* Only print if second changed. */</span><br><span class="line">    cmp %al, %cl</span><br><span class="line">    je update_in_progress</span><br><span class="line">    mov %al, %cl</span><br><span class="line"></span><br><span class="line">    PRINT_HEX &lt;%al&gt;</span><br><span class="line">    PUTC</span><br><span class="line"></span><br><span class="line">    /* Minute. */</span><br><span class="line">    mov $0x02, %al</span><br><span class="line">    out %al, $RTCaddress</span><br><span class="line">    in $RTCdata, %al</span><br><span class="line">    PRINT_HEX &lt;%al&gt;</span><br><span class="line">    PUTC</span><br><span class="line"></span><br><span class="line">    /* Hour. */</span><br><span class="line">    mov $0x04, %al</span><br><span class="line">    out %al, $RTCaddress</span><br><span class="line">    in $RTCdata, %al</span><br><span class="line">    PRINT_HEX &lt;%al&gt;</span><br><span class="line">    PUTC</span><br><span class="line"></span><br><span class="line">    /* Day. */</span><br><span class="line">    mov $0x07, %al</span><br><span class="line">    out %al, $RTCaddress</span><br><span class="line">    in $RTCdata, %al</span><br><span class="line">    PRINT_HEX &lt;%al&gt;</span><br><span class="line">    PUTC</span><br><span class="line"></span><br><span class="line">    /* Month. */</span><br><span class="line">    mov $0x08, %al</span><br><span class="line">    out %al, $RTCaddress</span><br><span class="line">    in $RTCdata, %al</span><br><span class="line">    PRINT_HEX &lt;%al&gt;</span><br><span class="line">    PUTC</span><br><span class="line"></span><br><span class="line">    /* Year. */</span><br><span class="line">    mov $0x09, %al</span><br><span class="line">    out %al, $RTCaddress</span><br><span class="line">    in $RTCdata, %al</span><br><span class="line">    PRINT_HEX &lt;%al&gt;</span><br><span class="line">    PRINT_NEWLINE</span><br><span class="line"></span><br><span class="line">    jmp update_in_progress</span><br></pre></td></tr></table></figure><p>第23~27行代码解析：<br>When the chip updates the time and date (once per second) it increases “seconds” and checks if it rolled over. If “seconds” did roll over it increases “minutes” and checks if that rolled over. This can continue through all the time and date registers (e.g. all the way up to “if year rolled over, increase century”). However, it’s entirely possible to read the time and date while an update is in progress and get inconsistent values (for example, at 9:00 o’clock you might read 8:59, or 8:60, or 8:00, or 9:00).</p><p>To help guard against this problem the RTC has an “Update in progress” flag (bit 7 of Status Register A). To read the time and date properly you have to wait until the “Update in progress” flag goes from “set” to “clear”. </p><p>剩余代码比较容易理解。<br>往PIO 0x70写入0x00后，从PIO 0x71寄存器中读到的就是当前的秒数。<br>往PIO 0x70写入0x02后，从PIO 0x71寄存器中读到的就是当前的分钟数。<br>往PIO 0x70写入0x04后，从PIO 0x71寄存器中读到的就是当前的小时数。<br>…</p><hr><p>参考资料：</p><ol><li><a href="https://wiki.osdev.org/CMOS" target="_blank" rel="noopener">CMOS</a></li><li><a href="https://en.wikipedia.org/wiki/Real-time_clock" target="_blank" rel="noopener">Real-time clock</a></li><li><a href="https://wiki.osdev.org/RTC" target="_blank" rel="noopener">RTC</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将深入介绍RTC(Real Time Clock)，并结合代码进行解析。
    
    </summary>
    
      <category term="I/O系统" scheme="http://liujunming.github.io/categories/I-O%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="I/O系统" scheme="http://liujunming.github.io/tags/I-O%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>x86-bare-metal-examples 环境搭建</title>
    <link href="http://liujunming.github.io/2020/05/02/x86-bare-metal-examples-Project/"/>
    <id>http://liujunming.github.io/2020/05/02/x86-bare-metal-examples-Project/</id>
    <published>2020-05-02T02:55:40.000Z</published>
    <updated>2020-08-30T01:17:15.255Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍<a href="https://github.com/cirosantilli/x86-bare-metal-examples" target="_blank" rel="noopener">x86-bare-metal-examples</a>的环境搭建。<a id="more"></a><br>远程主机环境：Ubuntu。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>首先在主机中<code>sudo apt-get install vinagre</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run rtc</span><br></pre></td></tr></table></figure><p>另一个session：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vinagre localhost:5900</span><br></pre></td></tr></table></figure></p><p><img src="/images/2020/05/2.PNG" alt></p><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run rtc debug</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍&lt;a href=&quot;https://github.com/cirosantilli/x86-bare-metal-examples&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;x86-bare-metal-examples&lt;/a&gt;的环境搭建。
    
    </summary>
    
      <category term="计算机系统" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机系统" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to hlt/pause/monitor/mwait instruction</title>
    <link href="http://liujunming.github.io/2020/05/01/Introduction-to-halt-pause-monitor-mwait-instruction/"/>
    <id>http://liujunming.github.io/2020/05/01/Introduction-to-halt-pause-monitor-mwait-instruction/</id>
    <published>2020-05-01T13:16:50.000Z</published>
    <updated>2020-08-30T01:17:15.245Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍<code>hlt</code>、<code>pause</code>、<code>monitor</code>和<code>mwait</code> 这四个指令的相关知识点。<a id="more"></a></p><h3 id="hlt"><a href="#hlt" class="headerlink" title="hlt"></a>hlt</h3><p>X86架构中，<code>hlt</code>指令使CPU进入HALT状态，在Linux的进程调度模块中，当某CPU处于idle状态时，可能会执行<code>hlt</code>命令使其进入HALT状态，目的显而易见，是为了节能。</p><p>那CPU进入HALT状态后，如何Resume呢？谁来将其唤醒？<br>答案是：中断(包括NMI和SMI)，debug exception，BINIT# signal，INIT# signal，或者RESET# signal。</p><h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><p>先阅读<a href="https://stackoverflow.com/a/12904645" target="_blank" rel="noopener">What is the purpose of the “PAUSE” instruction in x86?</a></p><blockquote><p>Improves the performance of spin-wait loops. When executing a “spin-wait loop,” processors will suffer a severe performance penalty when exiting the loop because it detects a possible memory order violation. The PAUSE instruction provides a hint to the processor that the code sequence is a spin-wait loop. The processor uses this hint to avoid the memory order violation in most situations, which greatly improves processor performance. For this reason, it is recommended that a PAUSE instruction be placed in all spin-wait loops.<br>An additional function of the PAUSE instruction is to reduce the power consumed by a processor while executing a spin loop. A processor can execute a spin-wait loop extremely quickly, causing the processor to consume a lot of power while it waits for the resource it is spinning on to become available. Inserting a pause instruction in a spinwait loop greatly reduces the processor’s power consumption.</p></blockquote><h3 id="monitor-and-mwait"><a href="#monitor-and-mwait" class="headerlink" title="monitor and mwait"></a>monitor and mwait</h3><p>Executing the HLT instruction on a idle logical processor puts the  targeted processor in a non-execution state. This requires another processor (when posting work for the halted  logical processor) to wake up the halted processor using an inter-processor interrupt. The posting and servicing of  such an interrupt introduces a delay in the servicing of new work requests. </p><p>MONITOR sets up an effective address  range that is monitored for write-to-memory activities; MWAIT places the processor in an optimized state (this may vary between different implementations) until a write to the monitored address range occurs. </p><p>引入了<code>monitor</code> 和 <code>mwait</code>指令后，避免了<code>hlt</code>导致的<strong>the posting and servicing of  such an interrupt introduces a delay in the servicing of new work requests</strong>. </p><p><a href="https://github.com/projectacrn/acrn-hypervisor/blob/v1.6/hypervisor/arch/x86/cpu.c#L468" target="_blank" rel="noopener">acrn-hypervisor</a>中的用法如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* wait until *sync == wake_sync */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_sync_change</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">uint64_t</span> *sync, <span class="keyword">uint64_t</span> wake_sync)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (has_monitor_cap()) &#123;</span><br><span class="line"><span class="comment">/* Wait for the event to be set using monitor/mwait */</span></span><br><span class="line"><span class="keyword">while</span> ((*sync) != wake_sync) &#123;</span><br><span class="line">asm_monitor(sync, <span class="number">0U</span>L, <span class="number">0U</span>L);</span><br><span class="line"><span class="keyword">if</span> ((*sync) != wake_sync) &#123;</span><br><span class="line">asm_mwait(<span class="number">0U</span>L, <span class="number">0U</span>L);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> asm_monitor(<span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">uint64_t</span> *addr, <span class="keyword">uint64_t</span> ecx, <span class="keyword">uint64_t</span> edx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="string">"monitor\n"</span> : : <span class="string">"a"</span> (addr), <span class="string">"c"</span> (ecx), <span class="string">"d"</span> (edx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">asm_mwait</span><span class="params">(<span class="keyword">uint64_t</span> eax, <span class="keyword">uint64_t</span> ecx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">asm volatile("mwait\n" : : "a" (eax), "c" (ecx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Uses of <code>monitor</code>/<code>mwait</code> in the Linux kernel请参考<a href="https://stackoverflow.com/a/57485714" target="_blank" rel="noopener">Uses of the monitor/mwait instructions</a>。</p><hr><p>参考资料：</p><ol><li>Intel SDM</li><li><a href="http://blog.chinaunix.net/uid-14528823-id-4444611.html" target="_blank" rel="noopener">X86 HLT指令相关</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍&lt;code&gt;hlt&lt;/code&gt;、&lt;code&gt;pause&lt;/code&gt;、&lt;code&gt;monitor&lt;/code&gt;和&lt;code&gt;mwait&lt;/code&gt; 这四个指令的相关知识点。
    
    </summary>
    
      <category term="体系结构" scheme="http://liujunming.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="体系结构" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
  </entry>
  
</feed>
