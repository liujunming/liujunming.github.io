<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2022-08-28T11:48:59.835Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RTC virtualization in QEMU</title>
    <link href="http://liujunming.github.io/2022/08/27/RTC-virtualization-in-QEMU/"/>
    <id>http://liujunming.github.io/2022/08/27/RTC-virtualization-in-QEMU/</id>
    <published>2022-08-27T12:05:29.000Z</published>
    <updated>2022-08-28T11:48:59.835Z</updated>
    
    <content type="html"><![CDATA[<p>本文将结合<a href="https://github.com/qemu/qemu/commits/stable-5.0" target="_blank" rel="noopener">QEMU</a>代码，解析RTC虚拟化。<a id="more"></a>一些细节作者也没有捋清楚，待日后更新吧。</p><h2 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h2><ul><li>读者需对<a href="/2020/05/02/深入理解RTC/">RTC</a>有一定的了解<ul><li>往PIO 0x70写入0x00后，从PIO 0x71寄存器中读到的就是当前的秒数</li><li>往PIO 0x70写入0x02后，从PIO 0x71寄存器中读到的就是当前的分钟数</li><li>往PIO 0x70写入0x04后，从PIO 0x71寄存器中读到的就是当前的小时数<br><img src="/images/2022/07/12.jpg" alt></li></ul></li><li><a href="/2021/10/19/PIO-virtualization-in-QEMU-KVM/">PIO virtualization in QEMU/KVM</a></li></ul><h2 id="2-How-to-use-RTC-in-QEMU"><a href="#2-How-to-use-RTC-in-QEMU" class="headerlink" title="2. How to use RTC in QEMU"></a>2. How to use RTC in QEMU</h2><h3 id="2-1-QEMU-document"><a href="#2-1-QEMU-document" class="headerlink" title="2.1 QEMU document"></a>2.1 QEMU document</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">``-rtc [base=utc|localtime|datetime][,clock=host|rt|vm][,driftfix=none|slew]``</span><br><span class="line">    Specify ``base`` as ``utc`` or ``localtime`` to let the RTC start at</span><br><span class="line">    the current UTC or local time, respectively. ``localtime`` is</span><br><span class="line">    required for correct date in MS-DOS or Windows. To start at a</span><br><span class="line">    specific point in time, provide datetime in the format</span><br><span class="line">    ``2006-06-17T16:01:21`` or ``2006-06-17``. The default base is UTC.</span><br><span class="line"></span><br><span class="line">    By default the RTC is driven by the host system time. This allows</span><br><span class="line">    using of the RTC as accurate reference clock inside the guest,</span><br><span class="line">    specifically if the host time is smoothly following an accurate</span><br><span class="line">    external reference clock, e.g. via NTP. If you want to isolate the</span><br><span class="line">    guest time from the host, you can set ``clock`` to ``rt`` instead,</span><br><span class="line">    which provides a host monotonic clock if host support it. To even</span><br><span class="line">    prevent the RTC from progressing during suspension, you can set</span><br><span class="line">    ``clock`` to ``vm`` (virtual clock). &apos;\ ``clock=vm``\ &apos; is</span><br><span class="line">    recommended especially in icount mode in order to preserve</span><br><span class="line">    determinism; however, note that in icount mode the speed of the</span><br><span class="line">    virtual clock is variable and can in general differ from the host</span><br><span class="line">    clock.</span><br><span class="line"></span><br><span class="line">    Enable ``driftfix`` (i386 targets only) if you experience time drift</span><br><span class="line">    problems, specifically with Windows&apos; ACPI HAL. This option will try</span><br><span class="line">    to figure out how many timer interrupts were not processed by the</span><br><span class="line">    Windows guest and will re-inject them.</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time" target="_blank" rel="noopener">UTC</a> is the primary time standard by which the world regulates clocks and time.</p></li><li><p><strong>system time</strong> vs <strong>monotonic clock</strong><br><a href="https://stackoverflow.com/questions/3523442/difference-between-clock-realtime-and-clock-monotonic" target="_blank" rel="noopener">https://stackoverflow.com/questions/3523442/difference-between-clock-realtime-and-clock-monotonic</a><br>system time is affected by <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol" target="_blank" rel="noopener">NTP</a>, and can move forwards and backwards. monotonic clock is not, and advances at one tick per tick.</p></li><li><p>与<code>clock=rt</code>相比，<code>clock=vm</code>增加了一个新的特性:当guest suspend的时候，RTC暂停计时</p></li><li><p>icount: instruction counter</p></li><li><p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/windows-kernel-mode-hal-library" target="_blank" rel="noopener">HAL(Hardware Abstraction Layers)</a></p></li></ul><h3 id="2-2-QEMUClockType"><a href="#2-2-QEMUClockType" class="headerlink" title="2.2 QEMUClockType"></a>2.2 QEMUClockType</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * QEMUClockType:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following clock types are available:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @QEMU_CLOCK_REALTIME: Real time clock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The real time clock should be used only for stuff which does not</span></span><br><span class="line"><span class="comment"> * change the virtual machine state, as it runs even if the virtual</span></span><br><span class="line"><span class="comment"> * machine is stopped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @QEMU_CLOCK_VIRTUAL: virtual clock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The virtual clock only runs during the emulation. It stops</span></span><br><span class="line"><span class="comment"> * when the virtual machine is stopped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @QEMU_CLOCK_HOST: host clock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The host clock should be used for device models that emulate accurate</span></span><br><span class="line"><span class="comment"> * real time sources. It will continue to run when the virtual machine</span></span><br><span class="line"><span class="comment"> * is suspended, and it will reflect system time changes the host may</span></span><br><span class="line"><span class="comment"> * undergo (e.g. due to NTP).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @QEMU_CLOCK_VIRTUAL_RT: realtime clock used for icount warp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Outside icount mode, this clock is the same as @QEMU_CLOCK_VIRTUAL.</span></span><br><span class="line"><span class="comment"> * In icount mode, this clock counts nanoseconds while the virtual</span></span><br><span class="line"><span class="comment"> * machine is running.  It is used to increase @QEMU_CLOCK_VIRTUAL</span></span><br><span class="line"><span class="comment"> * while the CPUs are sleeping and thus not executing instructions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    QEMU_CLOCK_REALTIME = <span class="number">0</span>,</span><br><span class="line">    QEMU_CLOCK_VIRTUAL = <span class="number">1</span>,</span><br><span class="line">    QEMU_CLOCK_HOST = <span class="number">2</span>,</span><br><span class="line">    QEMU_CLOCK_VIRTUAL_RT = <span class="number">3</span>,</span><br><span class="line">    QEMU_CLOCK_MAX</span><br><span class="line">&#125; QEMUClockType;</span><br></pre></td></tr></table></figure><h3 id="2-3-QEMU参数解析"><a href="#2-3-QEMU参数解析" class="headerlink" title="2.3 QEMU参数解析"></a>2.3 QEMU参数解析</h3><p>至于QEMU是如何解析<code>base</code>、<code>clock</code>和<code>driftfix</code>这些参数的呢？请参考<code>configure_rtc</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">configure_rtc</span><span class="params">(QemuOpts *opts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set defaults */</span></span><br><span class="line">    rtc_clock = QEMU_CLOCK_HOST;</span><br><span class="line">    rtc_ref_start_datetime = qemu_clock_get_ms(QEMU_CLOCK_HOST) / <span class="number">1000</span>;</span><br><span class="line">    rtc_realtime_clock_offset = qemu_clock_get_ms(QEMU_CLOCK_REALTIME) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    value = qemu_opt_get(opts, <span class="string">"base"</span>);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(value, <span class="string">"utc"</span>)) &#123;</span><br><span class="line">            rtc_base_type = RTC_BASE_UTC;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(value, <span class="string">"localtime"</span>)) &#123;</span><br><span class="line">            Error *blocker = <span class="literal">NULL</span>;</span><br><span class="line">            rtc_base_type = RTC_BASE_LOCALTIME;</span><br><span class="line">            error_setg(&amp;blocker, QERR_REPLAY_NOT_SUPPORTED,</span><br><span class="line">                      <span class="string">"-rtc base=localtime"</span>);</span><br><span class="line">            replay_add_blocker(blocker);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rtc_base_type = RTC_BASE_DATETIME;</span><br><span class="line">            configure_rtc_base_datetime(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-Full-picture"><a href="#3-Full-picture" class="headerlink" title="3. Full picture"></a>3. Full picture</h2><p>往PIO 0x70写入0x00后，从PIO 0x71寄存器中读到的就是当前的秒数。本节以该操作为例，介绍下整个流程。</p><h3 id="3-1-Guest写PIO-0x70"><a href="#3-1-Guest写PIO-0x70" class="headerlink" title="3.1 Guest写PIO 0x70"></a>3.1 Guest写PIO 0x70</h3><ol><li>Guest在Non-root mode下执行了OUT指令</li><li>PIO VM Exit</li><li>KVM发现自己处理不了这个PIO，就将这个IO请求forward给QEMU</li><li>QEMU处理这个IO请求</li></ol><p>至于QEMU如何处理这个IO请求，请参考<a href="/2022/08/27/RTC-virtualization-in-QEMU/#4-3-cmos-ioport-write">cmos_ioport_write</a>。</p><h3 id="3-2-Guest读PIO-0x71"><a href="#3-2-Guest读PIO-0x71" class="headerlink" title="3.2 Guest读PIO 0x71"></a>3.2 Guest读PIO 0x71</h3><ol><li>Guest在Non-root mode下执行了IN指令</li><li>PIO VM Exit</li><li>KVM发现自己处理不了这个PIO，就将这个IO请求forward给QEMU</li><li>QEMU处理这个IO请求</li></ol><p>至于QEMU如何处理这个IO请求，请参考<a href="/2022/08/27/RTC-virtualization-in-QEMU/#4-4-cmos-ioport-read">cmos_ioport_read</a>。</p><h2 id="4-模拟mc146818时钟芯片"><a href="#4-模拟mc146818时钟芯片" class="headerlink" title="4. 模拟mc146818时钟芯片"></a>4. 模拟mc146818时钟芯片</h2><h3 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RTCState</span> &#123;</span></span><br><span class="line">    ISADevice parent_obj;</span><br><span class="line"></span><br><span class="line">    MemoryRegion io;</span><br><span class="line">    MemoryRegion coalesced_io;</span><br><span class="line">    <span class="keyword">uint8_t</span> cmos_data[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> cmos_index;</span><br><span class="line">    <span class="keyword">int32_t</span> base_year;</span><br><span class="line">    <span class="keyword">uint64_t</span> base_rtc;</span><br><span class="line">    <span class="keyword">uint64_t</span> last_update;</span><br><span class="line">    <span class="keyword">int64_t</span> offset;</span><br><span class="line">    qemu_irq irq;</span><br><span class="line">    <span class="keyword">int</span> it_shift;</span><br><span class="line">    <span class="comment">/* periodic timer */</span></span><br><span class="line">    QEMUTimer *periodic_timer;</span><br><span class="line">    <span class="keyword">int64_t</span> next_periodic_time;</span><br><span class="line">    <span class="comment">/* update-ended timer */</span></span><br><span class="line">    QEMUTimer *update_timer;</span><br><span class="line">    <span class="keyword">uint64_t</span> next_alarm_time;</span><br><span class="line">    <span class="keyword">uint16_t</span> irq_reinject_on_ack_count;</span><br><span class="line">    <span class="keyword">uint32_t</span> irq_coalesced;</span><br><span class="line">    <span class="keyword">uint32_t</span> period;</span><br><span class="line">    QEMUTimer *coalesced_timer;</span><br><span class="line">    Notifier clock_reset_notifier;</span><br><span class="line">    LostTickPolicy lost_tick_policy;</span><br><span class="line">    Notifier suspend_notifier;</span><br><span class="line">    QLIST_ENTRY(RTCState) link;</span><br><span class="line">&#125; RTCState;</span><br></pre></td></tr></table></figure><ul><li><code>cmos_data</code>存放128字节的数据</li><li><code>base_rtc</code> is the RTC value when the RTC was last updated</li><li><code>last_update</code> is the guest time when the RTC was last updated</li></ul><h3 id="4-2-初始化"><a href="#4-2-初始化" class="headerlink" title="4.2 初始化"></a>4.2 初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps cmos_ops = &#123;</span><br><span class="line">    .read = cmos_ioport_read,</span><br><span class="line">    .write = cmos_ioport_write,</span><br><span class="line">    .impl = &#123;</span><br><span class="line">        .min_access_size = <span class="number">1</span>,</span><br><span class="line">        .max_access_size = <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_realizefn</span><span class="params">(DeviceState *dev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">0x70</span>;</span><br><span class="line"></span><br><span class="line">        s-&gt;cmos_data[RTC_REG_A] = <span class="number">0x26</span>;</span><br><span class="line">        s-&gt;cmos_data[RTC_REG_B] = <span class="number">0x02</span>;</span><br><span class="line">        s-&gt;cmos_data[RTC_REG_C] = <span class="number">0x00</span>;</span><br><span class="line">        s-&gt;cmos_data[RTC_REG_D] = <span class="number">0x80</span>;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        memory_region_init_io(&amp;s-&gt;io, OBJECT(s), &amp;cmos_ops, s, <span class="string">"rtc"</span>, <span class="number">2</span>);</span><br><span class="line">        isa_register_ioport(isadev, &amp;s-&gt;io, base);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h3 id="4-3-cmos-ioport-write"><a href="#4-3-cmos-ioport-write" class="headerlink" title="4.3 cmos_ioport_write"></a>4.3 cmos_ioport_write</h3><p>Guest往PIO 0x70写入0x00后，QEMU中的处理:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmos_ioport_write</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">uint64_t</span> data, <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTCState *s = opaque;</span><br><span class="line">    <span class="keyword">uint32_t</span> old_period;</span><br><span class="line">    <span class="keyword">bool</span> update_periodic_timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((addr &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        s-&gt;cmos_index = data &amp; <span class="number">0x7f</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><p>此时，<code>addr &amp; 1</code>为0(0x70)，因此会执行<code>s-&gt;cmos_index = data &amp; 0x7f</code>，设置<code>cmos_index</code>为0。</p><h3 id="4-4-cmos-ioport-read"><a href="#4-4-cmos-ioport-read" class="headerlink" title="4.4 cmos_ioport_read"></a>4.4 cmos_ioport_read</h3><p>Guest从PIO 0x71寄存器中读到的就是当前的秒数，QEMU中的处理:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint64_t <span class="title">cmos_ioport_read</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTCState *s = opaque;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((addr &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xff</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(s-&gt;cmos_index) &#123;</span><br><span class="line">        <span class="keyword">case</span> RTC_IBM_PS2_CENTURY_BYTE:</span><br><span class="line">            s-&gt;cmos_index = RTC_CENTURY;</span><br><span class="line">            <span class="comment">/* fall through */</span></span><br><span class="line">        <span class="keyword">case</span> RTC_CENTURY:</span><br><span class="line">        <span class="keyword">case</span> RTC_SECONDS:</span><br><span class="line">        <span class="keyword">case</span> RTC_MINUTES:</span><br><span class="line">        <span class="keyword">case</span> RTC_HOURS:</span><br><span class="line">        <span class="keyword">case</span> RTC_DAY_OF_WEEK:</span><br><span class="line">        <span class="keyword">case</span> RTC_DAY_OF_MONTH:</span><br><span class="line">        <span class="keyword">case</span> RTC_MONTH:</span><br><span class="line">        <span class="keyword">case</span> RTC_YEAR:</span><br><span class="line">            <span class="comment">/* if not in set mode, calibrate cmos before</span></span><br><span class="line"><span class="comment">             * reading*/</span></span><br><span class="line">            <span class="keyword">if</span> (rtc_running(s)) &#123;</span><br><span class="line">                rtc_update_time(s);</span><br><span class="line">            &#125;</span><br><span class="line">            ret = s-&gt;cmos_data[s-&gt;cmos_index];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure></p><p>此时，<code>addr &amp; 1</code>为1(0x71)，因此会执行<code>rtc_update_time</code>，然后返回<code>s-&gt;cmos_data[s-&gt;cmos_index]</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_update_time</span><span class="params">(RTCState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">ret</span>;</span></span><br><span class="line">    <span class="keyword">time_t</span> guest_sec;</span><br><span class="line">    <span class="keyword">int64_t</span> guest_nsec;</span><br><span class="line"></span><br><span class="line">    guest_nsec = get_guest_rtc_ns(s);</span><br><span class="line">    guest_sec = guest_nsec / NANOSECONDS_PER_SECOND;</span><br><span class="line">    gmtime_r(&amp;guest_sec, &amp;ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is SET flag of Register B disabled? */</span></span><br><span class="line">    <span class="keyword">if</span> ((s-&gt;cmos_data[RTC_REG_B] &amp; REG_B_SET) == <span class="number">0</span>) &#123;</span><br><span class="line">        rtc_set_cmos(s, &amp;ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rtc_set_cmos</code>会设置<code>cmos_data</code>中的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint64_t <span class="title">get_guest_rtc_ns</span><span class="params">(RTCState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> guest_clock = qemu_clock_get_ns(rtc_clock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s-&gt;base_rtc * NANOSECONDS_PER_SECOND +</span><br><span class="line">        guest_clock - s-&gt;last_update + s-&gt;offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://lore.kernel.org/qemu-devel/1342781633-7288-5-git-send-email-pbonzini@redhat.com/" target="_blank" rel="noopener">https://lore.kernel.org/qemu-devel/1342781633-7288-5-git-send-email-pbonzini@redhat.com/</a></p><p>Calculate guest RTC based on the time of the last update.The formula is:<br><code>(base_rtc + guest_time_now - guest_time_last_update + offset)</code></p><ul><li>base_rtc is the RTC value when the RTC was last updated</li><li>guest_time_now is the guest time when the access happens</li><li>guest_time_last_update is the guest time when the RTC was last updated</li><li>offset is used when divider reset happens or the set bit is toggled(可以暂时忽略，若想深入研究，需仔细阅读RTC的spec)</li></ul><h3 id="4-5-Update-guest-RTC"><a href="#4-5-Update-guest-RTC" class="headerlink" title="4.5 Update guest RTC"></a>4.5 Update guest RTC</h3><p>什么时候会更新guest的RTC呢？<br>一旦更新guest的RTC，就会更新<code>base_rtc</code>和<code>last_update</code>。</p><h4 id="4-5-1-base-rtc和last-update的初始化"><a href="#4-5-1-base-rtc和last-update的初始化" class="headerlink" title="4.5.1 base_rtc和last_update的初始化"></a>4.5.1 <code>base_rtc</code>和<code>last_update</code>的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_set_date_from_host</span><span class="params">(ISADevice *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTCState *s = MC146818_RTC(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span>;</span></span><br><span class="line"></span><br><span class="line">    qemu_get_timedate(&amp;tm, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    s-&gt;base_rtc = mktimegm(&amp;tm);</span><br><span class="line">    s-&gt;last_update = qemu_clock_get_ns(rtc_clock);</span><br><span class="line">    s-&gt;offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the CMOS date */</span></span><br><span class="line">    rtc_set_cmos(s, &amp;tm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_realizefn</span><span class="params">(DeviceState *dev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        rtc_set_date_from_host(isadev);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-2-base-rtc和last-update的更新"><a href="#4-5-2-base-rtc和last-update的更新" class="headerlink" title="4.5.2 base_rtc和last_update的更新"></a>4.5.2 <code>base_rtc</code>和<code>last_update</code>的更新</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_set_time</span><span class="params">(RTCState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span>;</span></span><br><span class="line"></span><br><span class="line">    rtc_get_time(s, &amp;tm);</span><br><span class="line">    s-&gt;base_rtc = mktimegm(&amp;tm);</span><br><span class="line">    s-&gt;last_update = qemu_clock_get_ns(rtc_clock);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rtc_set_time</code>会更新<code>base_rtc</code>和<code>last_update</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmos_ioport_write</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">uint64_t</span> data, <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTCState *s = opaque;</span><br><span class="line">    <span class="keyword">uint32_t</span> old_period;</span><br><span class="line">    <span class="keyword">bool</span> update_periodic_timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((addr &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        s-&gt;cmos_index = data &amp; <span class="number">0x7f</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CMOS_DPRINTF(<span class="string">"cmos: write index=0x%02x val=0x%02"</span> PRIx64 <span class="string">"\n"</span>,</span><br><span class="line">                     s-&gt;cmos_index, data);</span><br><span class="line">        <span class="keyword">switch</span>(s-&gt;cmos_index) &#123;</span><br><span class="line">        <span class="keyword">case</span> RTC_SECONDS_ALARM:</span><br><span class="line">        <span class="keyword">case</span> RTC_MINUTES_ALARM:</span><br><span class="line">        <span class="keyword">case</span> RTC_HOURS_ALARM:</span><br><span class="line">            s-&gt;cmos_data[s-&gt;cmos_index] = data;</span><br><span class="line">            check_update_timer(s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RTC_IBM_PS2_CENTURY_BYTE:</span><br><span class="line">            s-&gt;cmos_index = RTC_CENTURY;</span><br><span class="line">            <span class="comment">/* fall through */</span></span><br><span class="line">        <span class="keyword">case</span> RTC_CENTURY:</span><br><span class="line">        <span class="keyword">case</span> RTC_SECONDS:</span><br><span class="line">        <span class="keyword">case</span> RTC_MINUTES:</span><br><span class="line">        <span class="keyword">case</span> RTC_HOURS:</span><br><span class="line">        <span class="keyword">case</span> RTC_DAY_OF_WEEK:</span><br><span class="line">        <span class="keyword">case</span> RTC_DAY_OF_MONTH:</span><br><span class="line">        <span class="keyword">case</span> RTC_MONTH:</span><br><span class="line">        <span class="keyword">case</span> RTC_YEAR:</span><br><span class="line">            s-&gt;cmos_data[s-&gt;cmos_index] = data;</span><br><span class="line">            <span class="comment">/* if in set mode, do not update the time */</span></span><br><span class="line">            <span class="keyword">if</span> (rtc_running(s)) &#123;</span><br><span class="line">                rtc_set_time(s);</span><br><span class="line">                check_update_timer(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RTC_REG_A:</span><br><span class="line">            update_periodic_timer = (s-&gt;cmos_data[RTC_REG_A] ^ data) &amp; <span class="number">0x0f</span>;</span><br><span class="line">            old_period = rtc_periodic_clock_ticks(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((data &amp; <span class="number">0x60</span>) == <span class="number">0x60</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rtc_running(s)) &#123;</span><br><span class="line">                    rtc_update_time(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* What happens to UIP when divider reset is enabled is</span></span><br><span class="line"><span class="comment">                 * unclear from the datasheet.  Shouldn't matter much</span></span><br><span class="line"><span class="comment">                 * though.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                s-&gt;cmos_data[RTC_REG_A] &amp;= ~REG_A_UIP;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((s-&gt;cmos_data[RTC_REG_A] &amp; <span class="number">0x60</span>) == <span class="number">0x60</span>) &amp;&amp;</span><br><span class="line">                    (data &amp; <span class="number">0x70</span>)  &lt;= <span class="number">0x20</span>) &#123;</span><br><span class="line">                <span class="comment">/* when the divider reset is removed, the first update cycle</span></span><br><span class="line"><span class="comment">                 * begins one-half second later*/</span></span><br><span class="line">                <span class="keyword">if</span> (!(s-&gt;cmos_data[RTC_REG_B] &amp; REG_B_SET)) &#123;</span><br><span class="line">                    s-&gt;offset = <span class="number">500000000</span>;</span><br><span class="line">                    rtc_set_time(s);</span><br><span class="line">                &#125;</span><br><span class="line">                s-&gt;cmos_data[RTC_REG_A] &amp;= ~REG_A_UIP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* UIP bit is read only */</span></span><br><span class="line">            s-&gt;cmos_data[RTC_REG_A] = (data &amp; ~REG_A_UIP) |</span><br><span class="line">                (s-&gt;cmos_data[RTC_REG_A] &amp; REG_A_UIP);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (update_periodic_timer) &#123;</span><br><span class="line">                periodic_timer_update(s, qemu_clock_get_ns(rtc_clock),</span><br><span class="line">                                      old_period, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            check_update_timer(s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RTC_REG_B:</span><br><span class="line">            update_periodic_timer = (s-&gt;cmos_data[RTC_REG_B] ^ data)</span><br><span class="line">                                       &amp; REG_B_PIE;</span><br><span class="line">            old_period = rtc_periodic_clock_ticks(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data &amp; REG_B_SET) &#123;</span><br><span class="line">                <span class="comment">/* update cmos to when the rtc was stopping */</span></span><br><span class="line">                <span class="keyword">if</span> (rtc_running(s)) &#123;</span><br><span class="line">                    rtc_update_time(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* set mode: reset UIP mode */</span></span><br><span class="line">                s-&gt;cmos_data[RTC_REG_A] &amp;= ~REG_A_UIP;</span><br><span class="line">                data &amp;= ~REG_B_UIE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* if disabling set mode, update the time */</span></span><br><span class="line">                <span class="keyword">if</span> ((s-&gt;cmos_data[RTC_REG_B] &amp; REG_B_SET) &amp;&amp;</span><br><span class="line">                    (s-&gt;cmos_data[RTC_REG_A] &amp; <span class="number">0x70</span>) &lt;= <span class="number">0x20</span>) &#123;</span><br><span class="line">                    s-&gt;offset = get_guest_rtc_ns(s) % NANOSECONDS_PER_SECOND;</span><br><span class="line">                    rtc_set_time(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>从第34、57和90行可知，当guest往PIO 0x71设置值的时候，就可能会调用<code>rtc_set_time</code>。<br>比如在guest中，当前为2022年，如果guest想设置为2021年，此时就会触发<code>base_rtc</code>和<code>last_update</code>的更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtc_post_load</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">int</span> version_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTCState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (version_id &lt;= <span class="number">2</span> || rtc_clock == QEMU_CLOCK_REALTIME) &#123;</span><br><span class="line">        rtc_set_time(s);</span><br><span class="line">        s-&gt;offset = <span class="number">0</span>;</span><br><span class="line">        check_update_timer(s);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当live migration时，在目的端，也可能会调用<code>rtc_set_time</code>。</p><h3 id="4-6-MISC"><a href="#4-6-MISC" class="headerlink" title="4.6 MISC"></a>4.6 MISC</h3><ul><li><code>rtc_policy_slew_deliver_irq</code>是<code>driftfix=slew</code>参数对应的操作，细节未研究，待日后更新。</li><li>rtc作为定时器的用法，本文也没有阐述，待日后更新。<br><img src="/images/2022/07/13.jpg" alt></li></ul><hr><p>参考资料:</p><ol><li><a href="https://blog.csdn.net/u014022631/article/details/122429251" target="_blank" rel="noopener">qemu时钟虚拟化</a></li><li><a href="https://martin.uy/blog/bios-execution-in-qemu-first-io-interaction/" target="_blank" rel="noopener">BIOS execution in QEMU: first I/O interaction</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将结合&lt;a href=&quot;https://github.com/qemu/qemu/commits/stable-5.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QEMU&lt;/a&gt;代码，解析RTC虚拟化。
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>Notes about KVM steal time</title>
    <link href="http://liujunming.github.io/2022/08/20/Notes-about-KVM-steal-time/"/>
    <id>http://liujunming.github.io/2022/08/20/Notes-about-KVM-steal-time/</id>
    <published>2022-08-20T14:31:40.000Z</published>
    <updated>2022-08-21T03:36:05.968Z</updated>
    
    <content type="html"><![CDATA[<p>本文将参考<a href="https://cloud.tencent.com/developer/article/1087403" target="_blank" rel="noopener">steal time技术分析</a>，并结合<a href="https://elixir.bootlin.com/linux/v4.19/source" target="_blank" rel="noopener">v4.19 kernel</a>来解析steal time。<a id="more"></a></p><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><p>当前Host的墙上时间是HWT1，此时Guest中的墙上时间GWT1，如果是同一个时区的话，此时HWT1和GWT1是相等的。</p><p>如果此时Host中发生了调度，Guest所在的qemu进程不执行了，那么HWT1将继续增长，GWT1是否应该增长呢？</p><ul><li><p>如果GWT1不增长，那么等到Guest继续执行的时候，就会继续在原来的GWT1基础上增长，那么HWT2到HWT1之间的时间就发生了丢失；现象就是Guest中的时间变慢了。</p></li><li><p>如果GWT1同时增长，那么就会在Guest进程切回来继续执行的时候，Guest中的时间会瞬间增大了HWT2减掉HWT1的差值。现象就是Guest的墙上时间是对的。可是新的问题又来了：在Guest的qemu进程被Host切换之前，Guest中刚刚切换走redis，开始执行Nginx；等到Guest继续执行的时候，因为Guest中的时钟跳变增大了很多，Guest会认为Nginx执行了大量的CPU时间。如果Linux Guest中采用的是cfs调度算法，那么Nginx下次被调度会隔比较长的时间。可是实际上呢，Nginx根本没有得到执行！</p></li></ul><h3 id="2-Motivation"><a href="#2-Motivation" class="headerlink" title="2. Motivation"></a>2. Motivation</h3><p>为了解决上述Guest中的调度问题，就引入了steal time。<br>Steal time的原理就是：告诉Guest，哪些时间被Host给steal了，调度的时候，忽略这部分时间，就可以正确调度了。<br>所以，基本就是两个部分：</p><ol><li>在Host中通知Guest具体的steal time是多少</li><li>在Guest中处理这些时间，修正因时间跳变引起的调度错误</li></ol><h3 id="3-Identify-steal-time-in-Guest"><a href="#3-Identify-steal-time-in-Guest" class="headerlink" title="3. Identify steal time in Guest"></a>3. Identify steal time in Guest</h3><p><img src="/images/2022/07/11.jpg" alt><br>可以在<code>/proc/stat</code>中的第八项看到steal time(<code>top</code>就是从<code>/proc/stat</code>获取的数据)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v4.19/source/fs/proc/stat.c</span></span><br><span class="line">steal = kcpustat_cpu(i).cpustat[CPUTIME_STEAL];</span><br></pre></td></tr></table></figure></p><h3 id="4-Guest-register-steal-time"><a href="#4-Guest-register-steal-time" class="headerlink" title="4. Guest register steal time"></a>4. Guest register steal time</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_register_steal_time</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_steal_time</span> *<span class="title">st</span> = &amp;<span class="title">per_cpu</span>(<span class="title">steal_time</span>, <span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!has_steal_clock)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">wrmsrl(MSR_KVM_STEAL_TIME, (slow_virt_to_phys(st) | KVM_MSR_ENABLED));</span><br><span class="line">pr_info(<span class="string">"kvm-stealtime: cpu %d, msr %llx\n"</span>,</span><br><span class="line">cpu, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) slow_virt_to_phys(st));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>guest通过写MSR MSR_KVM_STEAL_TIME，把per_cpu变量steal_time的物理地址（Guest Physical Address）告诉Host。</p><p>MSR_KVM_STEAL_TIME MSR的描述:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">MSR_KVM_STEAL_TIME: <span class="number">0x4b564d03</span></span><br><span class="line"></span><br><span class="line">data: <span class="number">64</span>-byte alignment physical address of a memory area which must be</span><br><span class="line">in guest RAM, plus an enable bit in bit <span class="number">0.</span> This memory is expected to</span><br><span class="line">hold a copy of the following structure:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_steal_time</span> &#123;</span></span><br><span class="line">__u64 steal;</span><br><span class="line">__u32 version;</span><br><span class="line">__u32 flags;</span><br><span class="line">__u8  preempted;</span><br><span class="line">__u8  u8_pad[<span class="number">3</span>];</span><br><span class="line">__u32 pad[<span class="number">11</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">whose data will be filled in by the hypervisor periodically. Only one</span><br><span class="line">write, <span class="keyword">or</span> registration, is needed <span class="keyword">for</span> each VCPU. The interval between</span><br><span class="line">updates of <span class="keyword">this</span> structure is arbitrary <span class="keyword">and</span> implementation-dependent.</span><br><span class="line">The hypervisor may update <span class="keyword">this</span> structure at any time it sees fit until</span><br><span class="line">anything with bit0 == <span class="number">0</span> is written to it. Guest is required to make sure</span><br><span class="line"><span class="keyword">this</span> structure is initialized to zero.</span><br><span class="line"></span><br><span class="line">Fields have the following meanings:</span><br><span class="line"></span><br><span class="line">version: a sequence counter. In other words, guest has to check</span><br><span class="line"><span class="keyword">this</span> field before <span class="keyword">and</span> after grabbing time information <span class="keyword">and</span> make</span><br><span class="line">sure they are both equal <span class="keyword">and</span> even. An odd version indicates an</span><br><span class="line">in-progress update.</span><br><span class="line"></span><br><span class="line">flags: At <span class="keyword">this</span> point, always zero. May be used to indicate</span><br><span class="line">changes in <span class="keyword">this</span> structure in the future.</span><br><span class="line"></span><br><span class="line">steal: the amount of time in which <span class="keyword">this</span> vCPU did <span class="keyword">not</span> run, in</span><br><span class="line">nanoseconds. Time during which the vcpu is idle, will <span class="keyword">not</span> be</span><br><span class="line">reported as steal time.</span><br><span class="line"></span><br><span class="line">preempted: indicate the vCPU who owns <span class="keyword">this</span> struct is running <span class="keyword">or</span></span><br><span class="line"><span class="keyword">not</span>. Non-zero values mean the vCPU has been preempted. Zero</span><br><span class="line">means the vCPU is <span class="keyword">not</span> preempted. NOTE, it is always zero <span class="keyword">if</span> the</span><br><span class="line">the hypervisor doesn't support <span class="keyword">this</span> field.</span><br></pre></td></tr></table></figure></p><h3 id="5-Host-calculate-steal-time"><a href="#5-Host-calculate-steal-time" class="headerlink" title="5. Host calculate steal time"></a>5. Host calculate steal time</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v4.19/source/include/linux/sched.h#L290</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span> &#123;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* Time spent waiting on a runqueue: */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>run_delay;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意看<code>run_delay</code>，如注释，就是task等待的时间，也就是没有执行的时间（例子中Guest的qemu被切换走的时间）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v4.19/source/arch/x86/kvm/x86.c#L2292</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">record_steal_time</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">vcpu-&gt;arch.st.steal.version += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">kvm_write_guest_cached(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.st.stime,</span><br><span class="line">&amp;vcpu-&gt;arch.st.steal, <span class="keyword">sizeof</span>(struct kvm_steal_time));</span><br><span class="line"></span><br><span class="line">smp_wmb();</span><br><span class="line"></span><br><span class="line">vcpu-&gt;arch.st.steal.steal += current-&gt;sched_info.run_delay -</span><br><span class="line">vcpu-&gt;arch.st.last_steal;</span><br><span class="line">vcpu-&gt;arch.st.last_steal = current-&gt;sched_info.run_delay;</span><br><span class="line"></span><br><span class="line">kvm_write_guest_cached(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.st.stime,</span><br><span class="line">&amp;vcpu-&gt;arch.st.steal, <span class="keyword">sizeof</span>(struct kvm_steal_time));</span><br><span class="line"></span><br><span class="line">smp_wmb();</span><br><span class="line"></span><br><span class="line">vcpu-&gt;arch.st.steal.version += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">kvm_write_guest_cached(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.st.stime,</span><br><span class="line">&amp;vcpu-&gt;arch.st.steal, <span class="keyword">sizeof</span>(struct kvm_steal_time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Host中，用<code>run_delay</code>计算出Guest的steal time，并通过<code>kvm_write_guest_cached</code>告诉Guest（前文中Guest向Host注册的地址，Host直接修改）。<br>这样，在Guest恢复执行的时候，就可以知道steal time的具体大小了。</p><h3 id="6-Guest-scheduler处理steal-time"><a href="#6-Guest-scheduler处理steal-time" class="headerlink" title="6. Guest scheduler处理steal time"></a>6. Guest scheduler处理steal time</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v4.19/source/kernel/sched/core.c#L132</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RQ-clock updating methods:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_rq_clock_task</span><span class="params">(struct rq *rq, s64 delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PARAVIRT_TIME_ACCOUNTING</span></span><br><span class="line"><span class="keyword">if</span> (static_key_false((&amp;paravirt_steal_rq_enabled))) &#123;</span><br><span class="line">steal = paravirt_steal_clock(cpu_of(rq));</span><br><span class="line">steal -= rq-&gt;prev_steal_time_rq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(steal &gt; delta))</span><br><span class="line">steal = delta;</span><br><span class="line"></span><br><span class="line">rq-&gt;prev_steal_time_rq += steal;</span><br><span class="line">delta -= steal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">rq-&gt;clock_task += delta;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clock_task</code>记录的是队列中任务执行的时间，其由函数<code>update_rq_clock_task()</code>负责更新。steal time是guest可以意识到的时间，这个时间不被计算到具体的调度队列的运行时间，因而虚拟化下guest中的task调度正常，不会出现时间跳变引起的调度错误。</p><hr><p>参考资料:</p><ol><li><a href="https://cloud.tencent.com/developer/article/1087403" target="_blank" rel="noopener">steal time技术分析</a></li><li><a href="https://lore.kernel.org/kvm/1309793548-16714-1-git-send-email-glommer@redhat.com/" target="_blank" rel="noopener">Steal time for KVM</a></li><li><a href="https://oenhan.com/kvm-steal-time" target="_blank" rel="noopener">KVM下STEAL_TIME源代码分析</a></li><li><a href="https://blog.csdn.net/wu7244582/article/details/111366245" target="_blank" rel="noopener">kvm steal 溯源</a></li><li><a href="https://www.site24x7.com/learn/linux/cpu-steal-time.html" target="_blank" rel="noopener">What is CPU steal time?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将参考&lt;a href=&quot;https://cloud.tencent.com/developer/article/1087403&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;steal time技术分析&lt;/a&gt;，并结合&lt;a href=&quot;https://elixir.bootlin.com/linux/v4.19/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v4.19 kernel&lt;/a&gt;来解析steal time。
    
    </summary>
    
      <category term="KVM" scheme="http://liujunming.github.io/categories/KVM/"/>
    
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>Notes about KVM async page fault</title>
    <link href="http://liujunming.github.io/2022/08/18/Notes-about-KVM-async-page-fault/"/>
    <id>http://liujunming.github.io/2022/08/18/Notes-about-KVM-async-page-fault/</id>
    <published>2022-08-18T12:59:06.000Z</published>
    <updated>2022-08-18T13:43:09.348Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about KVM apf(async page fault)。<a id="more"></a>转载自:<a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2019/03/24/kvm-async-page-fault" target="_blank" rel="noopener">KVM async page fault</a>。</p><p>The qemu/kvm VM’s physical memory is the virtual memory of qemu process. When the virtual memory of qemu has been commit and is setup with physical memory the host can swap out this physical memory. When the guest vcpu access memory swapped out by host, its execution is suspended until memory is swapped back. Asynchronous page fault is a way to try and use guest vcpu more efficiently by allowing it to execute other tasks while page is brought back into memory. Following give a summary of these processes.</p><ol><li><p>page fault when the EPT page table is not setup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. VMEXIT</span><br><span class="line">2. kvm_mmu_page_fault()</span><br><span class="line">3. gfn_to_pfn()</span><br><span class="line">4. get_user_pages_unlocked()</span><br><span class="line">     no previously mapped page and no swap entry found</span><br><span class="line">     empty page is allocated</span><br><span class="line">5. page is added into shadow/nested page table</span><br></pre></td></tr></table></figure></li><li><p>page fault when the physical memory is swapped out(without apf)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. VMEXIT</span><br><span class="line">2. kvm_mmu_page_fault()</span><br><span class="line">3. gfn_to_pfn()</span><br><span class="line">4. get_user_pages_unlocked()</span><br><span class="line">    swap entry is found</span><br><span class="line">    page swap-in process is initiated</span><br><span class="line">    vcpu thread goes to sleep until page is swapped in</span><br></pre></td></tr></table></figure></li><li><p>page fault when the phycial memory is swapped out(with apf)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. VMEXIT</span><br><span class="line">2. kvm_mmu_page_fault()</span><br><span class="line">3. gfn_to_pfn()</span><br><span class="line">4. get_user_pages_nowait()</span><br><span class="line">5. gup(get_user_pages) is done by dedicated thread, inject &apos;page not present&apos; exception to guest</span><br><span class="line">6. guest puts process A(which caused this page fault) to sleep and schedule another process</span><br><span class="line">7. page is swapped in, inject &apos;page ready&apos; exception to guest</span><br><span class="line">8. guest can schedule process A back to run on vcpu</span><br></pre></td></tr></table></figure></li></ol><p>Following shows the process of kvm async page fault process.<br><img src="/images/2022/07/10.jpeg" alt><br>From description we know that kvm apf need the guest do something, such as recognize the apf ‘page not present’ and ‘page ready’ exception, and also the pv guest should hook the exception to process these two new exception. apf contains following steps.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. the guest should be initialized to process the new exception</span><br><span class="line">2. kvm page fault handler should recognize the swapped out case and initialize a work to swap in the page, inject a &apos;page not present&apos; to guest</span><br><span class="line">3. the guest receive this exception and schedule another process to run </span><br><span class="line">4. when the page caused page fault in step 2 has been swapped in, the kvm inject a &apos;page ready&apos; exception to guest</span><br><span class="line">5. the guest can do schedule to run process that was blocked by page fault in step 2</span><br></pre></td></tr></table></figure></p><hr><p>参考资料:</p><ol><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2019/03/24/kvm-async-page-fault" target="_blank" rel="noopener">KVM async page fault</a></li><li><a href="https://www.linux-kvm.org/images/a/ac/2010-forum-Async-page-faults.pdf" target="_blank" rel="noopener">2010-forum-Async-page-faults</a></li><li><a href="https://lore.kernel.org/lkml/20091108164706.GB3286@elte.hu/T/" target="_blank" rel="noopener">Add shared memory hypercall to PV Linux guest</a></li><li><a href="https://xingguotian.github.io/2019/08/23/qemu-kvm%20%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" target="_blank" rel="noopener">Qemu-kvm memory 虚拟化</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about KVM apf(async page fault)。
    
    </summary>
    
      <category term="KVM" scheme="http://liujunming.github.io/categories/KVM/"/>
    
    
      <category term="内存管理" scheme="http://liujunming.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="KVM" scheme="http://liujunming.github.io/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>Linux/x86中断处理：中断号</title>
    <link href="http://liujunming.github.io/2022/08/15/Linux-x86%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%AD%E6%96%AD%E5%8F%B7/"/>
    <id>http://liujunming.github.io/2022/08/15/Linux-x86中断处理：中断号/</id>
    <published>2022-08-15T08:32:27.000Z</published>
    <updated>2022-08-15T13:45:39.587Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自:<a href="https://github.com/eternalNight/blog-pages/blob/master/_posts/linux-intr-irq.md" target="_blank" rel="noopener">Linux/x86中断处理：中断号</a>。<a id="more"></a></p><h2 id="1-架构相关部分（x86）"><a href="#1-架构相关部分（x86）" class="headerlink" title="1. 架构相关部分（x86）"></a>1. 架构相关部分（x86）</h2><p>特别要注意的是，架构无关部分所用的中断号纯粹是个逻辑值，和硬件上所用的中断号没有必然联系！换句话说，只要和架构相关的代码串通好了，我们就完全可以说时钟的中断号是0xbeef，串口的中断号是0xdead，硬盘的中断号是0xbaddad，尽管硬件使用的中断号可能都没超过256。区别起见，以下把架构无关部分用的中断号叫做“逻辑中断号”，硬件使用的中断号（具体到x86上就是用哪个IDT表项）叫做“物理中断号”。对于x86架构来说，物理中断号的范围就是0-255，0号是除0错，14号是缺页等等。</p><h3 id="1-1-物理中断号到逻辑中断号的映射"><a href="#1-1-物理中断号到逻辑中断号的映射" class="headerlink" title="1.1 物理中断号到逻辑中断号的映射"></a>1.1 物理中断号到逻辑中断号的映射</h3><p>建立物理中断号到逻辑中断号的映射，是架构相关的中断处理例程需要完成的主要任务之一。对于x86_64来说，汇编部分的IDT表项入口是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(irq_entries_start)</span><br><span class="line">        INTR_FRAME</span><br><span class="line">    vector=FIRST_EXTERNAL_VECTOR</span><br><span class="line">    .rept (FIRST_SYSTEM_VECTOR - FIRST_EXTERNAL_VECTOR)</span><br><span class="line">        pushq_cfi $(~vector+0x80)    /* Note: always in signed byte range */</span><br><span class="line">    vector=vector+1</span><br><span class="line">        jmp     common_interrupt</span><br><span class="line">        CFI_ADJUST_CFA_OFFSET -8</span><br><span class="line">        .align  8</span><br><span class="line">    .endr</span><br><span class="line">        CFI_ENDPROC</span><br><span class="line">END(irq_entries_start)</span><br></pre></td></tr></table></figure></p><p>C部分的IDT建立是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for_each_clear_bit_from(i, used_vectors, first_system_vector) &#123;</span><br><span class="line">        <span class="comment">/* IA32_SYSCALL_VECTOR could be used in trap_init already. */</span></span><br><span class="line">        set_intr_gate(i, irq_entries_start +</span><br><span class="line">                        <span class="number">8</span> * (i - FIRST_EXTERNAL_VECTOR));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FIRST_EXTERNAL_VECTOR是0x20（和Intel手册上的内容一致）。进入中断后的一系列操作包括汇编里的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">common_interrupt:</span><br><span class="line">        XCPT_FRAME</span><br><span class="line">        ASM_CLAC</span><br><span class="line">        addq $-0x80,(%rsp)              /* Adjust vector to [-256,-1] range */</span><br><span class="line">        interrupt do_IRQ</span><br></pre></td></tr></table></figure></p><p>和C里的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __<span class="function">irq_entry <span class="title">do_IRQ</span><span class="params">(struct pt_regs *regs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="built_in">vector</span> = ~regs-&gt;orig_ax;</span><br><span class="line">        <span class="keyword">unsigned</span> irq;</span><br><span class="line">...</span><br><span class="line">irq = __this_cpu_read(vector_irq[<span class="built_in">vector</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handle_irq(irq, regs))</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中regs-&gt;orig_ax就是irq_entries_start里那些IDT入口push到栈上的值。那么，do_IRQ里的vector（记作v’）和IDT入口里的vector（记作v）的关系就应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v&apos; = ~((~v + 0x80) + (-0x80)) = v</span><br></pre></td></tr></table></figure></p><p>不就是一样的嘛……</p><p>拿到vector之后，接下去还有一个per_cpu的vector_irq，把vector映射成irq，这个才是麻烦的部分，因为对于x86平台上大部分中断，无论是物理中断号还是发给哪个CPU都是可配置的，所以静态没办法决定物理中断号、CPU号和逻辑中断号间的关系，只好弄一个per_cpu的vector_irq，遇到一个存一个。</p><h2 id="2-架构无关部分"><a href="#2-架构无关部分" class="headerlink" title="2. 架构无关部分"></a>2. 架构无关部分</h2><p>在架构无关部分，中断处理的大致流程很直观：handle_irq（架构无关部分的中断处理入口）拿到一个中断号，找先前在这个中断号上注册过的中断处理例程，每个例程调一遍，完事。所谓“在这个中断号上注册”，指的就是以这个中断号为参数，调用request_irq。</p><p>数据结构也很直接：一个中断号对应一个irq_desc，irq_desc里面记录了所有先前注册了这个中断号的中断处理例程（irqaction）。irq_desc里的handle_irq是一级的处理入口，由它一边处理一些通用的细节问题（比如边沿/电平触发的分别处理），一边一个一个地调action链表里注册过的例程。irq_chip是对应中断控制器的结构，里面存放的是一系列函数指针，实现像开关中断这样的由中断控制器提供的中断管理服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                       irq_desc</span><br><span class="line">      irq == ?? ==&gt; +------------+</span><br><span class="line">                    | handle_irq |</span><br><span class="line">   irq_chip      +--|    chip    |        irqaction</span><br><span class="line">+------------+&lt;--+  |   action   | ---&gt; +-----------+  +-&gt;+-----------+  +-&gt; ...</span><br><span class="line">|  irq_mask  |      |    name    |      |  handler  |  |  |  handler  |  |</span><br><span class="line">| irq_unmask |      .            .      | thread_fn |  |  | thread_fn |  |</span><br><span class="line">.            .      .            .      |   next    |--+  |   next    |--+</span><br><span class="line">.            .                          .           .     .           .</span><br></pre></td></tr></table></figure></p><p>对于从中断号（上图中的irq）到irq_desc的映射，Linux里默认是用了一个NR_IRQS个单元的irq_desc数组做的，也就是说中断号仅限于0到NR_IRQS-1之间。如果配置选项CONFIG_SPARSE_IRQ开启，那么中断号到irq_desc的映射就会用一个radix tree来维护，那样的话中断号多大都无所谓了。</p><p>irq_desc有几个设置函数，用来设置handle_irq、name、chip（严格来说是irq_desc里的irq_data的chip）等，包括：</p><ul><li>irq_set_chip：设置chip</li><li>__irq_set_handler：设置handle_irq和name</li><li>irq_set_chip_and_handler_name：handle_irq、name、chip全包</li></ul><h2 id="3-procfs-amp-sysfs里的中断相关文件"><a href="#3-procfs-amp-sysfs里的中断相关文件" class="headerlink" title="3. procfs &amp; sysfs里的中断相关文件"></a>3. procfs &amp; sysfs里的中断相关文件</h2><h3 id="3-1-proc-interrupts"><a href="#3-1-proc-interrupts" class="headerlink" title="3.1 /proc/interrupts"></a>3.1 /proc/interrupts</h3><p>这大概是最著名的一个了。文件的创建位置是proc_interrupts_init，内容由show_interrupts函数提供，主要流程是遍历一遍所有有效的逻辑中断号，对于带了action（也就是被注册过的）的中断，打印的域包括：</p><ul><li>逻辑中断号；</li><li>每个CPU上中断次数的统计；</li><li>对应chip的名称，诸如IO-APIC、PCI-MSI之类；</li><li>中断的名称，即irq_desc里的name，通常是空的；</li><li>每个action的名称，也就是request_irq时给的name，多个action的话用逗号分隔。</li></ul><p>遍历了所有逻辑中断号之后，还会调用arch_show_interrupts获得体系结构相关部分的中断信息，在x86上所有第一列不是数字的部分就是x86的arch_show_interrupts捣腾出来的内容，主要的信息包括中断类型和每个CPU上的中断计数。</p><h4 id="3-1-1-proc-interrupts有中断看不到？！"><a href="#3-1-1-proc-interrupts有中断看不到？！" class="headerlink" title="3.1.1 /proc/interrupts有中断看不到？！"></a>3.1.1 /proc/interrupts有中断看不到？！</h4><p>这个可以有，因为首先处理中断的总是内核的架构相关部分，如果它默默地自己处理了某些中断，既不用handle_irq（架构无关部分的中断处理入口），也不request_irq，还不在arch_show_interrupts里给你看，那/proc/interrupts里自然就找不到这些中断的痕迹。</p><p>x86就有架构相关部分默默处理掉的中断，比如LAPIC时钟。虽说LAPIC时钟中断默认是0x20，但在__setup_APIC_LVTT里就把它改成0xEF了，而0xEF的IDT表项又在apic_intr_init中专门设成了apic_timer_interrupt，而不是irq_entries_start那张表里的通用入口。所以要是在/proc/interrupts里看到这么一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">         CPU0       CPU1       CPU2       CPU3</span><br><span class="line">0:        134          0          0          0   IO-APIC-edge      timer</span><br></pre></td></tr></table></figure></p><p>这货才不是运行时的时钟（不排除系统启动的时候暂时用过它）！真正的时钟应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOC:  919608278  869138540  868188298  901247206   Local timer interrupts</span><br></pre></td></tr></table></figure></p><h3 id="3-2-proc-irq"><a href="#3-2-proc-irq" class="headerlink" title="3.2 /proc/irq/*"></a>3.2 /proc/irq/*</h3><p>这个目录主要是用来控制中断亲和性的，目录下面每个被注册过的逻辑中断号有一个目录，用得比较多的是下面两个文件：</p><ul><li>smp_affinity：bitmap形式的亲和性设置；</li><li>smp_affinity_list：CPU id列表形式的亲和性设置；</li></ul><p>其它几个文件只读，其内容的含义待考。</p><h3 id="3-3-sys-…-irq-和-sys-…-msi-irqs"><a href="#3-3-sys-…-irq-和-sys-…-msi-irqs" class="headerlink" title="3.3 /sys/…/irq 和 /sys/…/msi_irqs"></a>3.3 /sys/…/irq 和 /sys/…/msi_irqs</h3><p>基本每个device的目录下面都有，irq是每个设备所使用的逻辑中断号，不过奇怪的是有些逻辑中断号没有在/proc/interrupts里出现，原因不明。msi_irqs目录下面是一些以逻辑中断号命名的文件，每个都是这个设备所申请的msi或msix中断，没有申请过msi和msix中断的设备没有这个目录。</p><h2 id="4-总结：怎么知道设备的中断号？"><a href="#4-总结：怎么知道设备的中断号？" class="headerlink" title="4. 总结：怎么知道设备的中断号？"></a>4. 总结：怎么知道设备的中断号？</h2><p>绕了这么一大圈下来，可以明显感觉到x86平台为了让一套中断系统适应各种各样奇奇怪怪的环境，在“可配置”这一点上下了多大功夫。这也让搞内核开发的有点头疼：找个中断号怎么就那么麻烦？！</p><p>根据x86中断系统的结构，在Linux里找一个设备的中断号大概分这么几步：</p><ol><li>确定逻辑中断号：先看/proc/interrupts，有名字跟设备直接对应的最好，看不出的话就去sysfs这个符号链接的迷宫，从总线、功能、驱动模块……等等角度，找那个device对应的目录，看文件irq和目录msi_irqs的内容；</li><li>确定物理中断号：插printk，在适当的位置（比如arch_show_interrupts）把vector_irq这个数组打出来，找哪个物理中断号对应了上面确定的逻辑中断号；</li><li>确定物理中断号的配置情况：先从/proc/interrupts搞清楚管理这个中断的chip，然后：</li></ol><ul><li>如果是IOAPIC，找调用ioapic_write_entry和__ioapic_write_entry（更新I/O Redirection Table的函数）的地方；</li><li>如果是MSI，找驱动初始化时申请msi的地方；</li><li>如果是其它东西，那一般是一个级联的中断控制器，先翻翻这个中断控制器的驱动，看看有没有设置中断号之类的API再做商榷；</li><li>对于中断号用字母缩写的中断，在apic.h里找对应的寄存器，然后找apic_write这个寄存器的地方。</li></ul><hr><p>参考资料:</p><ol><li><a href="https://github.com/eternalNight/blog-pages/blob/master/_posts/linux-intr-irq.md" target="_blank" rel="noopener">Linux/x86中断处理：中断号</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA5NTM3MjIxMw==&amp;mid=2247490602&amp;idx=2&amp;sn=4d973784bb61cb1b422b122f6b5239c4&amp;chksm=90410af0a73683e64af7c2593a3bd3c4be04729204548fc8b530c0bbdad01211e0bfb8c8de73&amp;mpshare=1&amp;scene=1&amp;srcid=0322dXqrZHc4i5osgoZomhKG&amp;sharer_sharetime=1616389873996&amp;sharer_shareid=a9a36119fdda2f083962ae6839e2e602&amp;key=fafdc124f4ee647bb0faa403b80208ef8ac0b1661dc3c5bb4ce4a39ce07c8824fcfab78d3a4e7dcb7aee0bcd1713edcf83928a51e956654938343cbb08310d4ae50c7e217888e430e52004715065e53d2226cfa0aecb6a428ae73be4b31649adc006c2c55f79b93a2ab0f85174ed62f92cb81cc30c46fb3d2d4c1d83720fbc3a&amp;ascene=1&amp;uin=MTcwOTQ4NzA0MQ%3D%3D&amp;devicetype=Windows+7&amp;version=6206014b&amp;lang=zh_CN&amp;exportkey=AU79XKScyoT9GEt1KS9SgHU%3D&amp;pass_ticket=DvZ2hOy2IlirucyQl09vTYciz0pynAY1RZ7s06iR710rBFtKcFVvIrOPi9vbGDkO&amp;wx_header=0&amp;winzoom=1#" target="_blank" rel="noopener">Linux中断子系统-通用框架处理</a></li><li><a href="http://www.wowotech.net/irq_subsystem/irq-domain.html" target="_blank" rel="noopener">IRQ Domain介绍</a></li><li><a href="http://www.wowotech.net/irq_subsystem/interrupt_descriptor.html" target="_blank" rel="noopener">IRQ number和中断描述符</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自:&lt;a href=&quot;https://github.com/eternalNight/blog-pages/blob/master/_posts/linux-intr-irq.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux/x86中断处理：中断号&lt;/a&gt;。
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="SDM" scheme="http://liujunming.github.io/tags/SDM/"/>
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>IOMMU的探测</title>
    <link href="http://liujunming.github.io/2022/08/15/IOMMU%E7%9A%84%E6%8E%A2%E6%B5%8B/"/>
    <id>http://liujunming.github.io/2022/08/15/IOMMU的探测/</id>
    <published>2022-08-15T03:04:44.000Z</published>
    <updated>2022-08-15T05:21:45.624Z</updated>
    
    <content type="html"><![CDATA[<p>如果机器上存在多个IOMMU，怎么知道某设备使用哪个IOMMU呢？以这个问题为索引，引出本文。<a id="more"></a></p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="https://projectacrn.github.io/3.0/_images/vt-d-image90.png" alt></p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>先看一个典型的x86物理服务器：<br><img src="https://kernelgo.org/images/iommu-platform.png" alt><br>服务器上可以有多个DMAR Unit（这里可以直接理解为多个IOMMU硬件）， 每个DMAR会负责处理其下挂载设备的DMA请求。 例如上图中， PCIE Root Port (dev:fun) (14:0)下面挂载的所有设备的DMA请求由DMAR #1负责处理， PCIE Root Port (dev:fun) (14:1)下面挂载的所有设备的DMA请求由DMAR #2负责处理， 而DMAR #3下挂载的是一个Root-Complex集成设备[29:0]，这个设备的DMA请求被DMAR #3承包， DMAR #4的情况比较复杂，它负责处理Root-Complex集成设备[30:0]以及I/OxAPIC设备的DMA请求。 这些和IOMMU相关的硬件拓扑信息需要BIOS通过ACPI表呈现给OS，这样OS才能正确驱动IOMMU硬件工作。</p><p>BIOS通过在ACPI表中提供一套DMA Remapping Reporting Structure 信息来表述物理服务器上的IOMMU拓扑信息， 这样OS在加载IOMMU驱动的时候就知道如何建立映射关系了。</p><p>VT-d spec描述的更为详细！<br><img src="/images/2022/07/09.jpg" alt></p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>查看主机上的DMAR信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acpidump -n DMAR -b</span><br><span class="line">iasl -d dmar.dat</span><br><span class="line">cat dmar.dsl</span><br></pre></td></tr></table></figure></p><p>结合<a href="https://software.intel.com/content/dam/develop/external/us/en/documents-tps/vt-directed-io-spec.pdf" target="_blank" rel="noopener">Intel VT-d spec</a>的”BIOS Considerations”一节与<a href="https://github.com/projectacrn/acrn-hypervisor/blob/v3.0/hypervisor/acpi_parser/dmar_parse.c" target="_blank" rel="noopener">ACRN hypervisor</a>，慢慢去解析相关field。</p><p>蓝皮书中也有相关描述:<br><img src="/images/2022/07/08.jpg" alt></p><hr><p>参考资料:</p><ol><li><a href="https://projectacrn.github.io/3.0/developer-guides/hld/hv-vt-d.html#dma-remapping-report-acpi-table" target="_blank" rel="noopener">DMA Remapping Report ACPI Table</a></li><li><a href="https://kernelgo.org/intel_iommu.html" target="_blank" rel="noopener">Intel IOMMU Introduction</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果机器上存在多个IOMMU，怎么知道某设备使用哪个IOMMU呢？以这个问题为索引，引出本文。
    
    </summary>
    
      <category term="ACPI" scheme="http://liujunming.github.io/categories/ACPI/"/>
    
    
      <category term="ACPI" scheme="http://liujunming.github.io/tags/ACPI/"/>
    
      <category term="IOMMU" scheme="http://liujunming.github.io/tags/IOMMU/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel hrtimers</title>
    <link href="http://liujunming.github.io/2022/08/14/Linux-kernel-hrtimers/"/>
    <id>http://liujunming.github.io/2022/08/14/Linux-kernel-hrtimers/</id>
    <published>2022-08-14T08:22:54.000Z</published>
    <updated>2022-08-14T13:47:09.028Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about hrtimers in Linux kernel.<a id="more"></a>本文内容主要转载自<a href="https://blog.csdn.net/qq_37858386/article/details/85784994" target="_blank" rel="noopener">Linux内核高精度定时器hrtimer 使用实例</a>。</p><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><p>One might ask the question: we already have a timer subsystem (kernel/timers.c), why do we need two timer subsystems? After a lot of back and forth trying to integrate high-resolution and high-precision features into the existing timer framework, and after testing various such high-resolution timer implementations in practice, we came to the conclusion that the timer wheel code is fundamentally not suitable for such an approach. We initially didn’t believe this (‘there must be a way to solve this’), and spent a considerable effort trying to integrate things into the timer wheel, but we failed. </p><p>内核为高精度定时器重新设计了一套软件架构，它可以为我们提供<strong>纳秒级的定时精度</strong>，以满足对精确时间有迫切需求的应用程序或内核驱动，以下学习使用hrtimer(high resolution timer)高精度定时器。</p><h3 id="2-Interface"><a href="#2-Interface" class="headerlink" title="2. Interface"></a>2. Interface</h3><h4 id="2-1-hrtimer-init"><a href="#2-1-hrtimer-init" class="headerlink" title="2.1 hrtimer_init"></a>2.1 hrtimer_init</h4><p>hrtimer_init函数初始化定时器工作模式。which_clock可以是CLOCK_REALTIME、CLOCK_MONOTONIC、CLOCK_BOOTTIME中的一种，mode则可以是相对时间HRTIMER_MODE_REL，也可以是绝对时间HRTIMER_MODE_ABS。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hrtimer_init</span><span class="params">(struct hrtimer *timer, <span class="keyword">clockid_t</span> which_clock,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">enum</span> hrtimer_mode mode)</span></span>;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-设定超时回调函数"><a href="#2-2-设定超时回调函数" class="headerlink" title="2.2 设定超时回调函数"></a>2.2 设定超时回调函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer.function = hr_callback;</span><br></pre></td></tr></table></figure><h4 id="2-3-hrtimer-start"><a href="#2-3-hrtimer-start" class="headerlink" title="2.3 hrtimer_start"></a>2.3 hrtimer_start</h4><p>使用hrtimer_start激活该定时器。根据tim和mode参数的值计算hrtimer的超时时间，并设置到timer-&gt;expire域。 expire设置的是绝对时间，所以如果参数mode的值为HRTIMER_MODE_REL（即参数tim的值为相对时间），那么需要将tim的值修正为绝对时间：expire = tim + timer-&gt;base-&gt;get_time()，调用enqueue_hrtimer，将hrtimer加入到红黑树中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hrtimer_start</span><span class="params">(struct hrtimer *timer, <span class="keyword">ktime_t</span> tim,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">const</span> <span class="keyword">enum</span> hrtimer_mode mode)</span></span>;</span><br></pre></td></tr></table></figure></p><h4 id="2-4-hrtimer-cancel"><a href="#2-4-hrtimer-cancel" class="headerlink" title="2.4 hrtimer_cancel"></a>2.4 hrtimer_cancel</h4><p>使用hrtimer_cancel取消一个hrtimer。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hrtimer_cancel</span><span class="params">(struct hrtimer *timer)</span></span>;</span><br></pre></td></tr></table></figure></p><h4 id="2-5-function字段指定的回调函数返回值"><a href="#2-5-function字段指定的回调函数返回值" class="headerlink" title="2.5 function字段指定的回调函数返回值"></a>2.5 function字段指定的回调函数返回值</h4><p>定时器一旦到期，function字段指定的回调函数会被调用，该函数的返回值为一个枚举值，它决定了该hrtimer是否需要被重新激活。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> hrtimer_restart &#123;</span><br><span class="line">HRTIMER_NORESTART,<span class="comment">/* Timer is not restarted */</span></span><br><span class="line">HRTIMER_RESTART,<span class="comment">/* Timer must be restarted */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="2-6-hrtimer-forward"><a href="#2-6-hrtimer-forward" class="headerlink" title="2.6 hrtimer_forward"></a>2.6 hrtimer_forward</h4><p>把hrtimer的到期时间推进一个tick周期，返回HRTIMER_RESTART表明该hrtimer需要再次启动，以便产生下一个tick事件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hrtimer_forward(timer, now, tick_period);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> HRTIMER_RESTART;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-Example"><a href="#3-Example" class="headerlink" title="3. Example"></a>3. Example</h3><p>Simple example, callback every 100ms:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/hrtimer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ktime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> <span class="title">test_hrtimer</span>;</span></span><br><span class="line"><span class="keyword">static</span> u64 sampling_period_ms = <span class="number">100</span>; <span class="comment">// 100ms</span></span><br><span class="line"><span class="keyword">static</span> u32 loop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> hrtimer_restart <span class="title">test_hrtimer_handler</span><span class="params">(struct hrtimer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">"test_hrtimer_handler: %u\n"</span>, ++loop);</span><br><span class="line">    hrtimer_forward_now(&amp;test_hrtimer, ms_to_ktime(sampling_period_ms));</span><br><span class="line">    <span class="keyword">return</span> HRTIMER_RESTART;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_hrtimer_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hrtimer_init(&amp;test_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span><br><span class="line">    test_hrtimer.function = &amp;test_hrtimer_handler;</span><br><span class="line">    hrtimer_start(&amp;test_hrtimer, ms_to_ktime(sampling_period_ms), HRTIMER_MODE_REL);</span><br><span class="line">    pr_info(<span class="string">"init test_hrtimer.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_hrtimer_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hrtimer_cancel(&amp;test_hrtimer );</span><br><span class="line">    pr_info(<span class="string">"exit test_hrtimer.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(test_hrtimer_init);</span><br><span class="line">module_exit(test_hrtimer_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg</span><br><span class="line">[1213154.564771] init test_hrtimer.</span><br><span class="line">[1213154.664771] test_hrtimer_handler: 1</span><br><span class="line">[1213154.764769] test_hrtimer_handler: 2</span><br><span class="line">[1213154.864768] test_hrtimer_handler: 3</span><br><span class="line">[1213154.964766] test_hrtimer_handler: 4</span><br><span class="line">[1213155.064765] test_hrtimer_handler: 5</span><br><span class="line">[1213155.164763] test_hrtimer_handler: 6</span><br><span class="line">[1213155.264761] test_hrtimer_handler: 7</span><br><span class="line">[1213155.364759] test_hrtimer_handler: 8</span><br><span class="line">[1213155.464758] test_hrtimer_handler: 9</span><br><span class="line">[1213155.564756] test_hrtimer_handler: 10</span><br><span class="line">[1213155.664755] test_hrtimer_handler: 11</span><br><span class="line">[1213155.764753] test_hrtimer_handler: 12</span><br><span class="line">[1213155.864752] test_hrtimer_handler: 13</span><br><span class="line">[1213155.964750] test_hrtimer_handler: 14</span><br><span class="line">[1213156.064749] test_hrtimer_handler: 15</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://blog.csdn.net/qq_37858386/article/details/85784994" target="_blank" rel="noopener">Linux内核高精度定时器hrtimer 使用实例</a></li><li><a href="https://docs.kernel.org/timers/hrtimers.html" target="_blank" rel="noopener">hrtimers - subsystem for high-resolution kernel timers</a></li><li><a href="https://stackoverflow.com/questions/54777424/using-hrtimers-in-the-linux-kernel" target="_blank" rel="noopener">Using hrtimers in the Linux Kernel</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about hrtimers in Linux kernel.
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel timer example</title>
    <link href="http://liujunming.github.io/2022/08/14/Linux-kernel-timer-example/"/>
    <id>http://liujunming.github.io/2022/08/14/Linux-kernel-timer-example/</id>
    <published>2022-08-14T07:15:35.000Z</published>
    <updated>2022-08-14T13:47:09.029Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about timer in Linux kernel.<a id="more"></a>内容主要转载自<a href="http://yannik520.github.io/linux_driver_code/timer/timer_example.html" target="_blank" rel="noopener">Timer Example</a>。</p><h3 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h3><p>jiffies记录了系统启动以来，经过了多少tick。<br>一个tick代表多长时间，在内核的CONFIG_HZ中定义。比如CONFIG_HZ=200，则一个jiffies对应5ms时间。所以内核基于jiffies的定时器精度也是5ms。</p><h3 id="2-Timer-API"><a href="#2-Timer-API" class="headerlink" title="2. Timer API"></a>2. Timer API</h3><p>A timer is represented in the kernel as an instance of timer_list:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * All fields that change during normal runtime grouped to the</span></span><br><span class="line"><span class="comment"> * same cacheline</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span><span class="title">entry</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>expires;</span><br><span class="line"><span class="keyword">void</span>(*function)(struct timer_list *);</span><br><span class="line">u32flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span><span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>expires is an absolute value in jiffies. entry is a doubley linked list, and a callback function.</p><h3 id="3-Timer-setup-initialization"><a href="#3-Timer-setup-initialization" class="headerlink" title="3. Timer setup initialization"></a>3. Timer setup initialization</h3><p>The following are steps to initialize timers:</p><ul><li><p><strong>Setting up the timer</strong>: Set up the timer, feeding the user-defined callback function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timer_setup - prepare a timer for first use</span></span><br><span class="line"><span class="comment"> * @timer: the timer in question</span></span><br><span class="line"><span class="comment"> * @callback: the function to call when timer expires</span></span><br><span class="line"><span class="comment"> * @flags: any TIMER_* flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Regular timer initialization should use either DEFINE_TIMER() above,</span></span><br><span class="line"><span class="comment"> * or timer_setup(). For timers on the stack, timer_setup_on_stack() must</span></span><br><span class="line"><span class="comment"> * be used and must be balanced with a call to destroy_timer_on_stack().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> timer_setup(timer, callback, flags)\</span></span><br><span class="line">__init_timer((timer), (callback), (flags))</span><br></pre></td></tr></table></figure></li><li><p><strong>Setting the expiration time</strong>: When the timer is initialized, we need to set its expiration before the callback gets fired:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_timer</span><span class="params">(struct timer_list *timer, <span class="keyword">unsigned</span> <span class="keyword">long</span> expires)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>Releasing the timer</strong>: When you are done with the timer, it needs to be released:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_timer</span><span class="params">(struct timer_list * timer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_timer_sync</span><span class="params">(struct timer_list *timer)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>del_timer() return 0 on an inactive timer, and return 1 on an active timer, del_timer_sync waits for the handler to finish its execution, even those that may happen on another CPU. You should not hold a lock preventing the handler’s completion, otherwise it will result in a dead lock. You should release the timer in the module cleanup routine. You can independently check whether the timer is running or not:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timer_pending</span><span class="params">(<span class="keyword">const</span> struct timer_list * timer)</span></span>;</span><br></pre></td></tr></table></figure></p><h3 id="4-Example"><a href="#4-Example" class="headerlink" title="4. Example"></a>4. Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">my_timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_timer_callback</span><span class="params">(struct timer_list *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(<span class="string">"%s called (%ld)\n"</span>, __func__, jiffies);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">my_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">"%s: Timer module loaded\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">timer_setup(&amp;my_timer, my_timer_callback, <span class="number">0</span>);</span><br><span class="line">pr_info(<span class="string">"%s: Setup timer to fire in 2s (%ld)\n"</span>, __func__, jiffies);</span><br><span class="line"></span><br><span class="line">ret = mod_timer(&amp;my_timer, jiffies + msecs_to_jiffies(<span class="number">2000</span>));</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">pr_err(<span class="string">"%s: Timer firing failed\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">my_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = del_timer(&amp;my_timer);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">pr_err(<span class="string">"%s: The timer is still is use ...\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">"%s: Timer module unloaded\n"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Yannik Li &lt;yannik520@gmail.com&gt;"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Timer example"</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg</span><br><span class="line">[1208385.932488] my_init: Timer module loaded</span><br><span class="line">[1208385.932581] my_init: Setup timer to fire in 2s (5503072803)</span><br><span class="line">[1208387.945145] my_timer_callback called (5503074816)</span><br><span class="line">[1208425.037823] my_exit: Timer module unloaded</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="http://yannik520.github.io/linux_driver_code/timer/timer_example.html" target="_blank" rel="noopener">Timer Example</a></li><li><a href="https://www.cnblogs.com/arnoldlu/p/7234443.html" target="_blank" rel="noopener">jiffies背景介绍</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about timer in Linux kernel.
    
    </summary>
    
      <category term="Time" scheme="http://liujunming.github.io/categories/Time/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
      <category term="Time" scheme="http://liujunming.github.io/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>How to dump ACPI table</title>
    <link href="http://liujunming.github.io/2022/08/13/How-to-dump-ACPI-table/"/>
    <id>http://liujunming.github.io/2022/08/13/How-to-dump-ACPI-table/</id>
    <published>2022-08-13T13:00:24.000Z</published>
    <updated>2022-08-13T14:16:32.716Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ acpidump -h</span><br><span class="line">Usage: acpidump [options]</span><br><span class="line">Options:</span><br><span class="line">  -b                  Dump tables to binary files</span><br><span class="line">  -h -?               This help message</span><br><span class="line">  -o &lt;File&gt;           Redirect output to file</span><br><span class="line">  -r &lt;Address&gt;        Dump tables from specified RSDP</span><br><span class="line">  -s                  Print table summaries only</span><br><span class="line">  -v                  Display version information</span><br><span class="line">  -z                  Verbose mode</span><br><span class="line"></span><br><span class="line">Table Options:</span><br><span class="line">  -a &lt;Address&gt;        Get table via a physical address</span><br><span class="line">  -c &lt;on|off&gt;         Turning on/off customized table dumping</span><br><span class="line">  -f &lt;BinaryFile&gt;     Get table via a binary file</span><br><span class="line">  -n &lt;Signature&gt;      Get table via a name/signature</span><br><span class="line">  -x                  Do not use but dump XSDT</span><br><span class="line">  -x -x               Do not use or dump XSDT</span><br><span class="line"></span><br><span class="line">Invocation without parameters dumps all available tables</span><br><span class="line">Multiple mixed instances of -a, -f, and -n are supported</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><strong>How to dump apic table</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ acpidump -n APIC -b</span><br><span class="line">$ ls</span><br><span class="line">apic.dat</span><br><span class="line">$ iasl -d apic.dat</span><br><span class="line">Intel ACPI Component Architecture</span><br><span class="line">ASL+ Optimizing Compiler version 20160527-64</span><br><span class="line">Copyright (c) 2000 - 2016 Intel Corporation</span><br><span class="line"></span><br><span class="line">Input file apic.dat, Length 0xB0 (176) bytes</span><br><span class="line">ACPI: APIC 0x0000000000000000 0000B0 (v01 BOCHS  BXPCAPIC 00000001 BXPC 00000001)</span><br><span class="line">Acpi Data Table [APIC] decoded</span><br><span class="line">Formatted output:  apic.dsl - 7376 bytes</span><br><span class="line">$ ls</span><br><span class="line">apic.dat  apic.dsl</span><br><span class="line">$ vim apic.dsl</span><br></pre></td></tr></table></figure><p>apic.dsl文件格式为文本文件，可以直接查看其中的内容了。</p><h3 id="acpidump-source-code"><a href="#acpidump-source-code" class="headerlink" title="acpidump source code"></a>acpidump source code</h3><p><a href="https://elixir.bootlin.com/linux/v3.14.34/source/tools/power/acpi/tools/acpidump/acpidump.c" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v3.14.34/source/tools/power/acpi/tools/acpidump/acpidump.c</a><br><a href="https://elixir.bootlin.com/linux/v4.19/source/tools/power/acpi/tools/acpidump" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v4.19/source/tools/power/acpi/tools/acpidump</a><br>研究acpidump的实现有助于理解acpi。</p><hr><p>参考资料:</p><ol><li><a href="https://ilinuxkernel.com/?p=2001" target="_blank" rel="noopener">Linux系统中ACPI Table读取与解析</a></li><li><a href="https://www.acpica.org/" target="_blank" rel="noopener">acpica.org</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Tools&quot;&gt;&lt;a href=&quot;#Tools&quot; class=&quot;headerlink&quot; title=&quot;Tools&quot;&gt;&lt;/a&gt;Tools&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ acpidump -h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Usage: acpidump [options]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Options:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -b                  Dump tables to binary files&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -h -?               This help message&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -o &amp;lt;File&amp;gt;           Redirect output to file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -r &amp;lt;Address&amp;gt;        Dump tables from specified RSDP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -s                  Print table summaries only&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -v                  Display version information&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -z                  Verbose mode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Table Options:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -a &amp;lt;Address&amp;gt;        Get table via a physical address&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -c &amp;lt;on|off&amp;gt;         Turning on/off customized table dumping&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -f &amp;lt;BinaryFile&amp;gt;     Get table via a binary file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -n &amp;lt;Signature&amp;gt;      Get table via a name/signature&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -x                  Do not use but dump XSDT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  -x -x               Do not use or dump XSDT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Invocation without parameters dumps all available tables&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Multiple mixed instances of -a, -f, and -n are supported&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="ACPI" scheme="http://liujunming.github.io/categories/ACPI/"/>
    
    
      <category term="ACPI" scheme="http://liujunming.github.io/tags/ACPI/"/>
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Post-Copy Live Migration</title>
    <link href="http://liujunming.github.io/2022/08/13/Notes-about-Post-Copy-Live-Migration/"/>
    <id>http://liujunming.github.io/2022/08/13/Notes-about-Post-Copy-Live-Migration/</id>
    <published>2022-08-13T08:46:11.000Z</published>
    <updated>2022-08-18T13:43:09.348Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Post-Copy-steps"><a href="#Post-Copy-steps" class="headerlink" title="Post-Copy steps"></a>Post-Copy steps</h3><ol><li>suspends the migrating VM at the source node</li><li>copies minimal processor state to the target node</li><li>resumes the virtual machine</li><li>begins fetching memory pages over the network from the source.<br>The manner in which pages are fetched gives rise to different variants<a id="more"></a></li></ol><h3 id="trade-off"><a href="#trade-off" class="headerlink" title="trade-off"></a>trade-off</h3><ul><li>For VMs with read-intensive workloads, pre-copy would be the better approach</li><li>For large-memory or write-intensive workloads, post-copy would better suited.</li></ul><p>Pre-copy是为了能够尽量地减少downtime，并且不影响服务的运作;而post-copy则是为了减少total migration time且让程序能够持续的执行。</p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ul><li><a href="https://github.com/liujunming/paper_reading_notes/issues/12" target="_blank" rel="noopener">Post-Copy Live Migration of Virtual Machines</a></li><li><a href="https://www.iteye.com/blog/cloudtech-1614643" target="_blank" rel="noopener">[论文笔记]Post-copy based live virtual machine migration</a></li><li><a href="http://cshuo.top/2016/09/10/live_migration/" target="_blank" rel="noopener">VM 热迁移详解</a></li><li><a href="https://www.linux-kvm.org/images/f/f7/2012-forum-postcopy.pdf" target="_blank" rel="noopener">Postcopy Live migration for QEmu/KVM</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Post-Copy-steps&quot;&gt;&lt;a href=&quot;#Post-Copy-steps&quot; class=&quot;headerlink&quot; title=&quot;Post-Copy steps&quot;&gt;&lt;/a&gt;Post-Copy steps&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;suspends the migrating VM at the source node&lt;/li&gt;
&lt;li&gt;copies minimal processor state to the target node&lt;/li&gt;
&lt;li&gt;resumes the virtual machine&lt;/li&gt;
&lt;li&gt;begins fetching memory pages over the network from the source.&lt;br&gt;The manner in which pages are fetched gives rise to different variants
    
    </summary>
    
      <category term="live migration" scheme="http://liujunming.github.io/categories/live-migration/"/>
    
    
      <category term="live migration" scheme="http://liujunming.github.io/tags/live-migration/"/>
    
  </entry>
  
  <entry>
    <title>Notes about netlink</title>
    <link href="http://liujunming.github.io/2022/08/12/Notes-about-netlink/"/>
    <id>http://liujunming.github.io/2022/08/12/Notes-about-netlink/</id>
    <published>2022-08-12T13:58:11.000Z</published>
    <updated>2022-08-12T12:44:27.129Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从What、Why和How这三个角度去介绍netlink。</p><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>netlink is used to transfer information between the kernel and user-space processes.  It consists of a standard sockets-based interface for user space processes and an internal kernel API for kernel modules.<a id="more"></a></p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>How can kernel code and user-space code communicate with each other?</p><p>The answer is the various IPC methods that exist between kernel and user space, such as system call, ioctl, proc filesystem or netlink socket. This article discusses netlink socket and reveals its advantages as a network feature-friendly IPC.</p><p>Netlink socket is a special IPC used for transferring information between kernel and user-space processes. It provides a full-duplex communication link between the two by way of standard socket APIs for user-space processes and a special kernel API for kernel modules. Netlink socket uses the address family AF_NETLINK, as compared to AF_INET used by TCP/IP socket. Each netlink socket feature defines its own protocol type.</p><p>Why do some features use netlink instead of system calls, ioctls or proc filesystems for communication between user and kernel worlds? It is a nontrivial task to add system calls, ioctls or proc files for new features; we risk polluting the kernel and damaging the stability of the system. Netlink socket is simple, though: only a constant, the protocol type, needs to be added. Then, the kernel module and application can talk using socket-style APIs immediately.</p><p>Netlink is asynchronous because, as with any other socket API, it provides a socket queue to smooth the burst of messages. The system call for sending a netlink message queues the message to the receiver’s netlink queue and then invokes the receiver’s reception handler. The receiver, within the reception handler’s context, can decide whether to process the message immediately or leave the message in the queue and process it later in a different context. Unlike netlink, system calls require synchronous processing. Therefore, if we use a system call to pass a message from user space to the kernel, the kernel scheduling granularity may be affected if the time to process that message is long.</p><p>The code implementing a system call in the kernel is linked statically to the kernel in compilation time; thus, it is not appropriate to include system call code in a loadable module, which is the case for most device drivers. With netlink socket, no compilation time dependency exists between the netlink core of Linux kernel and the netlink application living in loadable kernel modules.</p><p>Netlink socket supports multicast, which is another benefit over system calls, ioctls and proc. One process can multicast a message to a netlink group address, and any number of other processes can listen to that group address. This provides a near-perfect mechanism for event distribution from kernel to user space.</p><p>System call and ioctl are simplex IPCs in the sense that a session for these IPCs can be initiated only by user-space applications. But, what if a kernel module has an urgent message for a user-space application? There is no way of doing that directly using these IPCs. Normally, applications periodically need to poll the kernel to get the state changes, although intensive polling is expensive. Netlink solves this problem gracefully by allowing the kernel to initiate sessions too. We call it the duplex characteristic of the netlink socket.</p><p>Finally, netlink socket provides a BSD socket-style API that is well understood by the software development community. Therefore, training costs are less as compared to using the rather cryptic system call APIs and ioctls.</p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>运行<a href="https://github.com/mwarning/netlink-examples/tree/master/unicast_example" target="_blank" rel="noopener">unicast_example</a>，并结合以下链接，仔细阅读代码，会有不少收获。</p><ul><li><a href="https://man7.org/linux/man-pages/man7/address_families.7.html" target="_blank" rel="noopener">man address_families</a></li><li><a href="https://man7.org/linux/man-pages/man2/socket.2.html" target="_blank" rel="noopener">man socket</a></li><li><a href="https://man7.org/linux/man-pages/man7/netlink.7.html" target="_blank" rel="noopener">man netlink</a></li><li><a href="https://elixir.bootlin.com/linux/v4.9/source/include/uapi/linux/netlink.h" target="_blank" rel="noopener">include/uapi/linux/netlink.h</a></li><li><a href="https://elixir.bootlin.com/linux/v4.9/source/include/linux/netlink.h" target="_blank" rel="noopener">include/linux/netlink.h</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./nl_recv &quot;Hello you!&quot;</span><br><span class="line">Send to kernel: Hello you!</span><br><span class="line">Received from kernel: Hello you!</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[946021.892960] netlink_test: Received from pid 1322: Hello you!</span><br><span class="line">[946021.893074] netlink_test: Send Hello you!</span><br></pre></td></tr></table></figure><p>如果想要进一步的了解，可以运行<a href="https://github.com/mwarning/netlink-examples" target="_blank" rel="noopener">mwarning/netlink-examples</a>上的所有示例。</p><hr><p>参考资料:</p><ol><li><a href="https://www.linuxjournal.com/article/7356" target="_blank" rel="noopener">Kernel Korner - Why and How to Use Netlink Socket</a></li><li><a href="https://github.com/xgfone/snippet/blob/master/snippet/docs/linux/netlink/netlink-note.md" target="_blank" rel="noopener">Linux Netlink 详解</a></li><li><a href="https://github.com/mwarning/netlink-examples" target="_blank" rel="noopener">mwarning/netlink-examples</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将从What、Why和How这三个角度去介绍netlink。&lt;/p&gt;
&lt;h3 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What&quot;&gt;&lt;/a&gt;What&lt;/h3&gt;&lt;p&gt;netlink is used to transfer information between the kernel and user-space processes.  It consists of a standard sockets-based interface for user space processes and an internal kernel API for kernel modules.
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Notes about /proc/self/</title>
    <link href="http://liujunming.github.io/2022/08/11/Notes-about-proc-self/"/>
    <id>http://liujunming.github.io/2022/08/11/Notes-about-proc-self/</id>
    <published>2022-08-11T07:09:38.000Z</published>
    <updated>2022-08-11T13:36:02.682Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/dillanzhou/article/details/82876575" target="_blank" rel="noopener">/proc/self/目录的意义</a>和<a href="https://unix.stackexchange.com/questions/333225/which-process-is-proc-self-for" target="_blank" rel="noopener">Which process is <code>/proc/self/</code> for?</a>。<a id="more"></a></p><p>可以通过/proc/$pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/$pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。为了更方便的获取本进程的信息，linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。</p><p>When the kernel has to answer the question “What does <code>/proc/self</code> point to?”, it simply <a href="https://elixir.bootlin.com/linux/latest/source/fs/proc/self.c" target="_blank" rel="noopener">picks the currently-scheduled pid</a>, i.e. the currently running process (on the current logical CPU). The effect is that <code>/proc/self</code> always points to the asking program’s pid; if you run<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /proc/self</span><br></pre></td></tr></table></figure></p><p>you’ll see <code>ls</code>‘s pid; if you write code which uses <code>/proc/self</code> then code will see its own pid, etc.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/dillanzhou/article/details/82876575&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;/proc/self/目录的意义&lt;/a&gt;和&lt;a href=&quot;https://unix.stackexchange.com/questions/333225/which-process-is-proc-self-for&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Which process is &lt;code&gt;/proc/self/&lt;/code&gt; for?&lt;/a&gt;。
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>MSI/MSI-x及其虚拟化</title>
    <link href="http://liujunming.github.io/2022/08/07/MSI-MSI-x%E5%8F%8A%E5%85%B6%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>http://liujunming.github.io/2022/08/07/MSI-MSI-x及其虚拟化/</id>
    <published>2022-08-07T09:11:47.000Z</published>
    <updated>2022-08-13T09:25:21.265Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/pdf/深入理解MSI-X中断和中断虚拟化.pdf">深入理解 MSI/MSI-X 中断和中断虚拟化</a><br><a href="/pdf/MSI-x及其虚拟化.pdf">MSI/MSI-x及其虚拟化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;/pdf/深入理解MSI-X中断和中断虚拟化.pdf&quot;&gt;深入理解 MSI/MSI-X 中断和中断虚拟化&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/pdf/MSI-x及其虚拟化.pdf&quot;&gt;MSI/MSI-x及其虚拟化&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="中断" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
      <category term="中断" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Notes about TUN/TAP Interface</title>
    <link href="http://liujunming.github.io/2022/07/31/Notes-about-TUN-TAP-Interface/"/>
    <id>http://liujunming.github.io/2022/07/31/Notes-about-TUN-TAP-Interface/</id>
    <published>2022-07-31T10:30:57.000Z</published>
    <updated>2022-07-31T13:38:29.709Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about TUN/TAP Interface。内容主要转载自:<a href="https://hechao.li/2018/05/21/Tun-Tap-Interface/" target="_blank" rel="noopener">TUN/TAP Interface</a>。<a id="more"></a></p><h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h3><p>From the Linux kernel <a href="https://www.kernel.org/doc/html/latest/networking/tuntap.html" target="_blank" rel="noopener">documentation</a>:</p><blockquote><p>TUN/TAP provides packet reception and transmission for user space programs. It can be seen as a simple Point-to-Point or Ethernet device, which, instead of receiving packets from physical media, receives them from user space program and instead of sending packets via physical media writes them to the user space program.</p></blockquote><p>In other words, TUN/TAP interfaces are virtual interfaces that does not have physical devices associated. A user space program can attach to a TUN/TAP interface and handle the traffic sent to the interface.</p><h3 id="Difference"><a href="#Difference" class="headerlink" title="Difference"></a>Difference</h3><p>There are two types of virtual network interfaces managed by <code>/dev/net/tun</code>:</p><ul><li>TUN interfaces transport IP packets (layer 3);</li><li>TAP interfaces transport Ethernet frames (layer 2).</li></ul><p>A TUN interface is a virtual IP Point-to-Point interface(L3) and a TAP interface is a virtual Ethernet interface(L2). That means the user program can only read/write IP packets from/to a TUN interface and Ethernet frames from/to a TAP interface.</p><h3 id="Use-Cases"><a href="#Use-Cases" class="headerlink" title="Use Cases"></a>Use Cases</h3><p>The typical use case of a TUN interface is IP tunneling. For example, <a href="https://openvpn.net/" target="_blank" rel="noopener">OpenVPN</a> receives packets from a TUN interface such as <code>tun0</code> and encrypts it before sending to the real ethernet interface <code>eth0</code>. Then the OpenVPN client on the peer receives the packet from <code>eth0</code> and decrypts it before sending it to <code>tun0</code>. In other words, OpenVPN works as a proxy between <code>tun0</code> and <code>eth0</code> and creates a encrypted UDP connection over the internet between two hosts.<br><img src="/images/2022/07/03.png" alt></p><p>The typical use case of a TAP interface is virtual networking. For example, in <a href="https://hechao.li/2017/12/13/linux-bridge-part1" target="_blank" rel="noopener">Linux Bridge Part 1</a>, we’ve seen that when we create a VM in the KVM with bridged network, it creates a TAP interface like <code>vnet0</code> and adds it to the Linux bridge. In this case, KVM is the userspace program which reads from and writes to the TAP interfaces. When VM0 sends a packet to its <code>eth0</code>, KVM sends it to TAP interface <code>vnet0</code> so that the bridge will forward it to <code>vnet1</code>. Then KVM receives it and sends it to VM1’s <code>eth0</code>.<br><img src="/images/2022/07/04.png" alt></p><h3 id="Managing-TUN-TAP-interfaces"><a href="#Managing-TUN-TAP-interfaces" class="headerlink" title="Managing TUN/TAP interfaces"></a>Managing TUN/TAP interfaces</h3><p><code>ip tuntap</code> can be used to manage TUN/TAP interfaces. For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ip tuntap help</span><br><span class="line">Usage: ip tuntap &#123; add | del | show | list | lst | help &#125; [ dev PHYS_DEV ]</span><br><span class="line">          [ mode &#123; tun | tap &#125; ] [ user USER ] [ group GROUP ]</span><br><span class="line">          [ one_queue ] [ pi ] [ vnet_hdr ] [ multi_queue ]</span><br><span class="line"></span><br><span class="line">Where: USER  := &#123; STRING | NUMBER &#125;</span><br><span class="line">       GROUP := &#123; STRING | NUMBER &#125;</span><br></pre></td></tr></table></figure></p><h3 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h3><p>精读<a href="/images/2022/07/Linux 虚拟网络设备之 TUN_TAP 设备 - 知乎.pdf">Linux 虚拟网络设备之 TUN/TAP 设备</a>，会收获颇丰。</p><p><img src="/images/2022/07/05.jpeg" alt></p><hr><p><img src="/images/2022/07/06.jpeg" alt></p><hr><p><img src="/images/2022/07/07.jpeg" alt></p><hr><p>参考资料:</p><ol><li><a href="https://hechao.li/2018/05/21/Tun-Tap-Interface/" target="_blank" rel="noopener">TUN/TAP Interface</a></li><li><a href="https://www.gabriel.urdhr.fr/2021/05/08/tuntap/" target="_blank" rel="noopener">TUN/TAP interface (on Linux)</a></li><li><a href="https://zhuanlan.zhihu.com/p/388742230" target="_blank" rel="noopener">Linux 虚拟网络设备之 TUN/TAP 设备</a></li><li><a href="https://www.kernel.org/doc/html/latest/networking/tuntap.html" target="_blank" rel="noopener">kernel document Universal TUN/TAP device driver</a></li><li><a href="https://backreference.org/2010/03/26/tuntap-interface-tutorial/" target="_blank" rel="noopener">Tun/Tap interface tutorial</a></li><li><a href="https://man7.org/linux/man-pages/man7/netdevice.7.html" target="_blank" rel="noopener">man netdevice</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about TUN/TAP Interface。内容主要转载自:&lt;a href=&quot;https://hechao.li/2018/05/21/Tun-Tap-Interface/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TUN/TAP Interface&lt;/a&gt;。
    
    </summary>
    
      <category term="计算机网络" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux network tun interface示例</title>
    <link href="http://liujunming.github.io/2022/07/31/Example-of-linux-network-tun-interface/"/>
    <id>http://liujunming.github.io/2022/07/31/Example-of-linux-network-tun-interface/</id>
    <published>2022-07-31T09:38:38.000Z</published>
    <updated>2022-07-31T13:38:29.708Z</updated>
    
    <content type="html"><![CDATA[<p>示例源于<a href="https://segmentfault.com/a/1190000009249039" target="_blank" rel="noopener">Linux虚拟网络设备之tun/tap</a>。<a id="more"></a></p><h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><p>收到tun设备的数据包之后，只打印出收到了多少字节的数据包，其它的什么都不做<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_tun.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tun_alloc</span><span class="params">(<span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fd, err;</span><br><span class="line">    <span class="keyword">char</span> *clonedev = <span class="string">"/dev/net/tun"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(clonedev, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">    ifr.ifr_flags = flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = ioctl(fd, TUNSETIFF, (<span class="keyword">void</span> *) &amp;ifr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Open tun/tap device: %s for reading...\n"</span>, ifr.ifr_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tun_fd, nread;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1500</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags: IFF_TUN   - TUN device (no Ethernet headers)</span></span><br><span class="line"><span class="comment">     *        IFF_TAP   - TAP device</span></span><br><span class="line"><span class="comment">     *        IFF_NO_PI - Do not provide packet information</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tun_fd = tun_alloc(IFF_TUN | IFF_NO_PI);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tun_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Allocating interface"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        nread = read(tun_fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (nread &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"Reading from interface"</span>);</span><br><span class="line">            close(tun_fd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Read %d bytes from tun/tap device\n"</span>, nread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://man7.org/linux/man-pages/man7/netdevice.7.html" target="_blank" rel="noopener">man netdevice</a></p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#--------------------------第一个shell窗口----------------------</span><br><span class="line">#将上面的程序保存成tun.c，然后编译</span><br><span class="line">dev@debian:~$ gcc tun.c -o tun</span><br><span class="line"></span><br><span class="line">#启动tun程序，程序会创建一个新的tun设备，</span><br><span class="line">#程序会阻塞在这里，等着数据包过来</span><br><span class="line">dev@debian:~$ sudo ./tun</span><br><span class="line">Open tun/tap device tun1 for reading...</span><br><span class="line">Read 84 bytes from tun/tap device</span><br><span class="line">Read 84 bytes from tun/tap device</span><br><span class="line">Read 84 bytes from tun/tap device</span><br><span class="line">Read 84 bytes from tun/tap device</span><br><span class="line"></span><br><span class="line">#--------------------------第二个shell窗口----------------------</span><br><span class="line">#启动抓包程序，抓经过tun1的包</span><br><span class="line"># tcpdump -i tun1</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on tun1, link-type RAW (Raw IP), capture size 262144 bytes</span><br><span class="line">19:57:13.473101 IP 192.168.3.11 &gt; 192.168.3.12: ICMP echo request, id 24028, seq 1, length 64</span><br><span class="line">19:57:14.480362 IP 192.168.3.11 &gt; 192.168.3.12: ICMP echo request, id 24028, seq 2, length 64</span><br><span class="line">19:57:15.488246 IP 192.168.3.11 &gt; 192.168.3.12: ICMP echo request, id 24028, seq 3, length 64</span><br><span class="line">19:57:16.496241 IP 192.168.3.11 &gt; 192.168.3.12: ICMP echo request, id 24028, seq 4, length 64</span><br><span class="line"></span><br><span class="line">#--------------------------第三个shell窗口----------------------</span><br><span class="line">#./tun启动之后，通过ip link命令就会发现系统多了一个tun设备，</span><br><span class="line">#在我的测试环境中，多出来的设备名称叫tun1，在你的环境中可能叫tun0</span><br><span class="line">#新的设备没有ip，我们先给tun1配上IP地址</span><br><span class="line">dev@debian:~$ sudo ip addr add 192.168.3.11/24 dev tun1</span><br><span class="line"></span><br><span class="line">#默认情况下，tun1没有起来，用下面的命令将tun1启动起来</span><br><span class="line">dev@debian:~$ sudo ip link set tun1 up</span><br><span class="line"></span><br><span class="line">#尝试ping一下192.168.3.0/24网段的IP，</span><br><span class="line">#根据默认路由，该数据包会走tun1设备，</span><br><span class="line">#由于我们的程序中收到数据包后，啥都没干，相当于把数据包丢弃了，</span><br><span class="line">#所以这里的ping根本收不到返回包，</span><br><span class="line">#但在前两个窗口中可以看到这里发出去的四个icmp echo请求包，</span><br><span class="line">#说明数据包正确的发送到了应用程序里面，只是应用程序没有处理该包</span><br><span class="line">dev@debian:~$ ping -c 4 192.168.3.12</span><br><span class="line">PING 192.168.3.12 (192.168.3.12) 56(84) bytes of data.</span><br><span class="line"></span><br><span class="line">--- 192.168.3.12 ping statistics ---</span><br><span class="line">4 packets transmitted, 0 received, 100% packet loss, time 3023ms</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;示例源于&lt;a href=&quot;https://segmentfault.com/a/1190000009249039&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux虚拟网络设备之tun/tap&lt;/a&gt;。
    
    </summary>
    
      <category term="计算机网络" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Notes about PV TLB Shootdown</title>
    <link href="http://liujunming.github.io/2022/07/30/Notes-about-PV-TLB-Shootdown/"/>
    <id>http://liujunming.github.io/2022/07/30/Notes-about-PV-TLB-Shootdown/</id>
    <published>2022-07-30T14:28:28.000Z</published>
    <updated>2022-07-31T05:37:43.940Z</updated>
    
    <content type="html"><![CDATA[<p>Notes about PV TLB Shootdown.<a id="more"></a></p><p>A TLB is a cache of translation from memory virtual address to physical address. When a CPU changes virtual to physical mapping of an address, it needs to invalidate other CPUs’ stale mapping in their respective caches. This process is called TLB shootdown.</p><p>Modern operating systems consider TLB shootdown operations to be performance critical and so optimize them to exhibit very low latency.The implementation of these operations is therefore architected to ensure that shootdowns can be completed with very low latencies through the use of IPI based signalling.</p><p>Remote TLB flush does a busy wait which is fine in bare-metal scenario.But within the guest, the vCPUs might have been preempted or blocked. In this scenario, the initiator vCPU would end up busy-waiting for a long amount of time; it also consumes CPU unnecessarily to wake up the target of the shootdown.</p><p><strong>Idea:</strong><br>In PV TLB shootdown, the TLB flush initiator vCPU will not wait the sleeping vCPU, instead it just set a flag in the guest-vmm shared area and then kvm will check this flag and do the TLB flush when the sleeping vCPU come to run.</p><p><img src="/images/2022/07/02.jpg" alt></p><p>实现细节也很有意思，感兴趣的读者可以去仔细阅读代码+文末的参考资料，本文就不赘述了。</p><hr><p>参考资料:</p><ol><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/09/10/kvm-performance-1" target="_blank" rel="noopener">kvm performance optimization technologies, part one</a></li><li><a href="https://lwn.net/Articles/740363/" target="_blank" rel="noopener">KVM: X86: Add Paravirt TLB Shootdown</a></li><li><a href="https://events19.linuxfoundation.org/wp-content/uploads/2017/12/Update_Wanpeng-LI_Torwards-a-more-Scalable-KVM-Hypervisor.pdf" target="_blank" rel="noopener">Torwards a more Scalable KVM Hypervisor</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes about PV TLB Shootdown.
    
    </summary>
    
      <category term="虚拟化" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Notes about multiqueue virtio-net</title>
    <link href="http://liujunming.github.io/2022/07/29/Notes-about-multiqueue-virtio-net/"/>
    <id>http://liujunming.github.io/2022/07/29/Notes-about-multiqueue-virtio-net/</id>
    <published>2022-07-29T13:41:23.000Z</published>
    <updated>2022-07-29T14:47:17.669Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录multiqueue virtio-net相关笔记。<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>Multi-queue virtio-net provides an approach that scales the network performance as the number of vCPUs increases, by allowing them to transfer packets through more than one virtqueue pair at a time.</p><p>Today’s high-end servers have more processors, and guests running on them often have an increasing number of vCPUs. In single queue virtio-net, the scale of the protocol stack in a guest is restricted, as the network performance does not scale as the number of vCPUs increases. Guests cannot transmit or retrieve packets in parallel, as virtio-net has only one TX and RX queue.</p><p>Multi-queue support removes these bottlenecks by allowing paralleled packet processing.</p><p>Multi-queue virtio-net provides the greatest performance benefit when:</p><ul><li>Traffic packets are relatively large.</li><li>The guest is active on many connections at the same time, with traffic running between guests, guest to host, or guest to an external system.</li><li>The number of queues is equal to the number of vCPUs. This is because multi-queue support optimizes RX interrupt affinity and TX queue selection in order to make a specific queue private to a specific vCPU.</li></ul><h3 id="2-Parallel-send-receive-processing"><a href="#2-Parallel-send-receive-processing" class="headerlink" title="2. Parallel send/receive processing"></a>2. Parallel send/receive processing</h3><p>To make sure the whole stack could be worked in parallel, the parallelism of not only the front-end (guest driver) but also the back-end (vhost and tap/macvtap) must be explored. This is done by:</p><ul><li>Allowing multiple sockets to be attached to tap/macvtap</li><li>Using multiple threaded vhost to serve as the backend of a multiqueue capable virtio-net adapter</li><li>Use a multi-queue awared virtio-net driver to send and receive packets to/from each queue</li></ul><p><img src="https://www.linux-kvm.org/images/e/e3/Ver1.jpg" alt></p><h3 id="3-Configuration"><a href="#3-Configuration" class="headerlink" title="3. Configuration"></a>3. Configuration</h3><h3 id="3-1-If-using-qemu"><a href="#3-1-If-using-qemu" class="headerlink" title="3.1 If using qemu"></a>3.1 If using qemu</h3><ul><li>create tap device with multiple queues, please reference<br><code>Documentation/networking/tuntap.txt:(3.3 Multiqueue tuntap interface)</code></li><li>enable mq for tap (suppose N queue pairs) -netdev tap,vhost=on,queues=N</li><li>enable mq and specify msix vectors in qemu cmdline (2N+2 vectors, N for tx queues, N for rx queues, 1 for config, and one for possible control vq): -device virtio-net-pci,mq=on,vectors=2N+2…</li></ul><h3 id="3-2-If-using-libvirt"><a href="#3-2-If-using-libvirt" class="headerlink" title="3.2 If using libvirt"></a>3.2 If using libvirt</h3><p>To use multi-queue virtio-net, enable support in the guest by adding the following to the guest XML configuration (where the value of N is from 1 to 256, as the kernel supports up to 256 queues for a multi-queue tap device):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;interface type=&apos;network&apos;&gt;</span><br><span class="line">      &lt;source network=&apos;default&apos;/&gt;</span><br><span class="line">      &lt;model type=&apos;virtio&apos;/&gt;</span><br><span class="line">      &lt;driver name=&apos;vhost&apos; queues=&apos;N&apos;/&gt;</span><br><span class="line">&lt;/interface&gt;</span><br></pre></td></tr></table></figure></p><h3 id="3-3-In-guest"><a href="#3-3-In-guest" class="headerlink" title="3.3 In guest"></a>3.3 In guest</h3><p>When running a virtual machine with N virtio-net queues in the guest, enable the multi-queue support with the following command (where the value of M is from 1 to N):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -L eth0 combined M</span><br></pre></td></tr></table></figure></p><h3 id="4-Verification"><a href="#4-Verification" class="headerlink" title="4. Verification"></a>4. Verification</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -l eth0</span><br><span class="line">Channel parameters for eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:        0</span><br><span class="line">TX:        0</span><br><span class="line">Other:        0</span><br><span class="line">Combined:    4</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:        0</span><br><span class="line">TX:        0</span><br><span class="line">Other:        0</span><br><span class="line">Combined:    4</span><br></pre></td></tr></table></figure><p>验证多队列生效的方法是观察中断，即<code>cat /proc/interrupts</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/interrupts</span><br><span class="line">           CPU0       CPU1</span><br><span class="line">...</span><br><span class="line"> 27:       1352          0   PCI-MSI-edge      virtio0-input.0</span><br><span class="line"> 28:          1          0   PCI-MSI-edge      virtio0-output.0</span><br><span class="line"> 29:        378          0   PCI-MSI-edge      virtio0-input.1</span><br><span class="line"> 30:          1          0   PCI-MSI-edge      virtio0-output.1</span><br><span class="line"> 31:        151          0   PCI-MSI-edge      virtio0-input.2</span><br><span class="line"> 32:          1          0   PCI-MSI-edge      virtio0-output.2</span><br><span class="line"> 33:        268          0   PCI-MSI-edge      virtio0-input.3</span><br><span class="line"> 34:          0          0   PCI-MSI-edge      virtio0-output.3</span><br></pre></td></tr></table></figure><p>可以观察到中断分布在4个<code>virtio0</code>队列设备上。</p><hr><p>参考资料:</p><ol><li><a href="https://www.linux-kvm.org/page/Multiqueue" target="_blank" rel="noopener">Multiqueue virtio-net</a></li><li><a href="https://huataihuang.gitbooks.io/cloud-atlas/content/virtual/kvm/performance/kvm_performance_tunning_in_action/multi_queue-virtio-net.html" target="_blank" rel="noopener">多队列 virtio-net</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_tuning_and_optimization_guide/sect-virtualization_tuning_optimization_guide-networking-techniques" target="_blank" rel="noopener">Network Tuning Techniques</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录multiqueue virtio-net相关笔记。
    
    </summary>
    
      <category term="virtio" scheme="http://liujunming.github.io/categories/virtio/"/>
    
    
      <category term="virtio" scheme="http://liujunming.github.io/tags/virtio/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to userfaultfd mechanism</title>
    <link href="http://liujunming.github.io/2022/07/24/Introduction-to-userfaultfd-mechanism/"/>
    <id>http://liujunming.github.io/2022/07/24/Introduction-to-userfaultfd-mechanism/</id>
    <published>2022-07-24T05:13:22.000Z</published>
    <updated>2022-07-24T08:22:39.582Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容主要转载自<a href="http://brieflyx.me/2020/linux-tools/userfaultfd-internals/" target="_blank" rel="noopener">Linux Kernel Userfaultfd 内部机制探究</a>，看代码的时候结合<a href="https://man7.org/linux/man-pages/man2/userfaultfd.2.html" target="_blank" rel="noopener">man userfaultfd</a>和<a href="https://man7.org/linux/man-pages/man2/ioctl_userfaultfd.2.html" target="_blank" rel="noopener">man ioctl_userfaultfd</a>，方便查询。<br><a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>Userfaults allow the implementation of on-demand paging from userland and more generally they allow userland to take control of various memory page faults, something otherwise only the kernel code could do.</p><p>userfaultfd是kernel中提供的一种特殊的处理page fault的机制，能够让用户态程序自行处理自己的page fault。</p><p>它的调用方式是通过一个userfaultfd的syscall新建一个 fd，然后用ioctl等syscall来调用相关的API。该机制的初衷是为了方便虚拟机的post-copy live migration。</p><h3 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h3><p><img src="/images/2022/07/01.png" alt><br>左侧的 Faulting thread，mm core，userfaultfd 是属于同一个（内核）线程，右边的 uffd monitor 是属于另一（内核）线程，它们在用户态应该表现为共享地址空间的2个线程。</p><p>在开始时，faulting 线程读取了一块未分配物理页的内存，触发了page fault，此时进到内核中进行处理，内核调用了 <code>handle_userfault</code> 交给 userfaultfd 相关的代码进行处理，此时该线程将被挂起进入阻塞状态。同时一个待处理的消息 <code>uffd_msg</code> 结构通过该 fd 发送到了另一个 monitor 线程，该线程可以调用相关 API 进行处理 （ <code>UFFDIO_COPY</code> 或 <code>UFFDIO_ZEROPAGE</code>）并告知内核唤醒 faulting 线程。</p><p>从这个例子中我们能看出这里面涉及到2个线程之间的交互，我们也不能免俗地要介绍一下具体用法，阅读 <code>userfaultfd</code> man page 里给出的例子，里面大概分为5步。</p><h3 id="3-用法"><a href="#3-用法" class="headerlink" title="3. 用法"></a>3. 用法</h3><h4 id="3-1-分配一个-userfault-fd-并检查-API"><a href="#3-1-分配一个-userfault-fd-并检查-API" class="headerlink" title="3.1 分配一个 userfault fd 并检查 API"></a>3.1 分配一个 userfault fd 并检查 API</h4><p>由于 glibc 没有对应的 syscall wrapper，直接使用 syscall 函数分配。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Create and enable userfaultfd object */</span></span><br><span class="line"></span><br><span class="line">uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"userfaultfd"</span>);</span><br><span class="line"></span><br><span class="line">uffdio_api.api = UFFD_API;</span><br><span class="line">uffdio_api.features = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"ioctl-UFFDIO_API"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="3-2-注册需要进行-userfault-的内存区域"><a href="#3-2-注册需要进行-userfault-的内存区域" class="headerlink" title="3.2 注册需要进行 userfault 的内存区域"></a>3.2 注册需要进行 userfault 的内存区域</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register the memory range of the mapping we just created for</span></span><br><span class="line"><span class="comment">          handling by the userfaultfd object. In mode, we request to track</span></span><br><span class="line"><span class="comment">          missing pages (i.e., pages that have not yet been faulted in). */</span></span><br><span class="line"></span><br><span class="line">uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">uffdio_register.range.len = len;</span><br><span class="line">uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line"><span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"ioctl-UFFDIO_REGISTER"</span>);</span><br></pre></td></tr></table></figure><h4 id="3-3-创建-monitor-线程，（子线程）监听-fd-的事件"><a href="#3-3-创建-monitor-线程，（子线程）监听-fd-的事件" class="headerlink" title="3.3 创建 monitor 线程，（子线程）监听 fd 的事件"></a>3.3 创建 monitor 线程，（子线程）监听 fd 的事件</h4><p>在一个 for 循环中，不断使用 pool 来等待这个 fd ，然后读取一个 msg，这里读取的 msg 就是 <code>uffd_msg</code> 结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* See what poll() tells us about the userfaultfd */</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">   <span class="keyword">int</span> nready;</span><br><span class="line">   pollfd.fd = uffd;</span><br><span class="line">   pollfd.events = POLLIN;</span><br><span class="line">   nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">   <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">       errExit(<span class="string">"poll"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\nfault_handler_thread():\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"    poll() returns: nready = %d; "</span></span><br><span class="line">           <span class="string">"POLLIN = %d; POLLERR = %d\n"</span>, nready,</span><br><span class="line">           (pollfd.revents &amp; POLLIN) != <span class="number">0</span>,</span><br><span class="line">           (pollfd.revents &amp; POLLERR) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Read an event from the userfaultfd */</span></span><br><span class="line"></span><br><span class="line">   nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">   <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"EOF on userfaultfd!\n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">       errExit(<span class="string">"read"</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h4 id="3-4-主线程触发指定区域的-page-fault"><a href="#3-4-主线程触发指定区域的-page-fault" class="headerlink" title="3.4 主线程触发指定区域的 page fault"></a>3.4 主线程触发指定区域的 page fault</h4><p>读一下该区域的内存即可</p><h4 id="3-5（子线程）处理-fault"><a href="#3-5（子线程）处理-fault" class="headerlink" title="3.5（子线程）处理 fault"></a>3.5（子线程）处理 fault</h4><p>调用 <code>UFFDIO_COPY</code>为新映射的页提供数据，并唤醒主线程，子线程自身会进入到下一轮循环中继续 poll 等待输入。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Copy the page pointed to by 'page' into the faulting</span></span><br><span class="line"><span class="comment">  region. Vary the contents that are copied in, so that it</span></span><br><span class="line"><span class="comment">  is more obvious that each fault is handled separately. */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(page, <span class="string">'A'</span> + fault_cnt % <span class="number">20</span>, page_size);</span><br><span class="line">fault_cnt++;</span><br><span class="line"></span><br><span class="line">uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We need to handle page faults in units of pages(!).</span></span><br><span class="line"><span class="comment">  So, round faulting address down to page boundary */</span></span><br><span class="line"></span><br><span class="line">uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                  ~(page_size - <span class="number">1</span>);</span><br><span class="line">uffdio_copy.len = page_size;</span><br><span class="line">uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"ioctl-UFFDIO_COPY"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="4-Example"><a href="#4-Example" class="headerlink" title="4. Example"></a>4. Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* userfaultfd_demo.c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Licensed under the GNU General Public License version 2 or later.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> errExit(msg)    do &#123; perror(msg); exit(EXIT_FAILURE); \</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">fault_handler_thread(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span>   <span class="comment">/* Data read from userfaultfd */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;     <span class="comment">/* Number of faults so far handled */</span></span><br><span class="line">    <span class="keyword">long</span> uffd;                    <span class="comment">/* userfaultfd file descriptor */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *page = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a page that will be copied into the faulting region. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        page = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE,</span><br><span class="line">                    MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">            errExit(<span class="string">"mmap"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop, handling incoming events on the userfaultfd</span></span><br><span class="line"><span class="comment">       file descriptor. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* See what poll() tells us about the userfaultfd. */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"poll"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nfault_handler_thread():\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"    poll() returns: nready = %d; "</span></span><br><span class="line">                <span class="string">"POLLIN = %d; POLLERR = %d\n"</span>, nready,</span><br><span class="line">                (pollfd.revents &amp; POLLIN) != <span class="number">0</span>,</span><br><span class="line">                (pollfd.revents &amp; POLLERR) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read an event from the userfaultfd. */</span></span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"EOF on userfaultfd!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"read"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We expect only one kind of event; verify that assumption. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Unexpected event on userfaultfd\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Display info about the page-fault event. */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"    UFFD_EVENT_PAGEFAULT event: "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"flags = %"</span>PRIx64<span class="string">"; "</span>, msg.arg.pagefault.flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"address = %"</span>PRIx64<span class="string">"\n"</span>, msg.arg.pagefault.address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Copy the page pointed to by 'page' into the faulting</span></span><br><span class="line"><span class="comment">           region. Vary the contents that are copied in, so that it</span></span><br><span class="line"><span class="comment">           is more obvious that each fault is handled separately. */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="string">'A'</span> + fault_cnt % <span class="number">20</span>, page_size);</span><br><span class="line">        fault_cnt++;</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We need to handle page faults in units of pages(!).</span></span><br><span class="line"><span class="comment">           So, round faulting address down to page boundary. */</span></span><br><span class="line"></span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                           ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">"ioctl-UFFDIO_COPY"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"        (uffdio_copy.copy returned %"</span>PRId64<span class="string">")\n"</span>,</span><br><span class="line">                uffdio_copy.copy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> uffd;          <span class="comment">/* userfaultfd file descriptor */</span></span><br><span class="line">    <span class="keyword">char</span> *addr;         <span class="comment">/* Start of region handled by userfaultfd */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len;       <span class="comment">/* Length of region handled by userfaultfd */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thr;      <span class="comment">/* ID of thread that handles page faults */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">uffdio_api</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">uffdio_register</span>;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s num-pages\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line">    len = strtoull(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>) * page_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create and enable userfaultfd object. */</span></span><br><span class="line"></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (uffd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"userfaultfd"</span>);</span><br><span class="line"></span><br><span class="line">    uffdio_api.api = UFFD_API;</span><br><span class="line">    uffdio_api.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"ioctl-UFFDIO_API"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a private anonymous mapping. The memory will be</span></span><br><span class="line"><span class="comment">       demand-zero paged--that is, not yet allocated. When we</span></span><br><span class="line"><span class="comment">       actually touch the memory, it will be allocated via</span></span><br><span class="line"><span class="comment">       the userfaultfd. */</span></span><br><span class="line"></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE,</span><br><span class="line">                MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)</span><br><span class="line">        errExit(<span class="string">"mmap"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address returned by mmap() = %p\n"</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register the memory range of the mapping we just created for</span></span><br><span class="line"><span class="comment">       handling by the userfaultfd object. In mode, we request to track</span></span><br><span class="line"><span class="comment">       missing pages (i.e., pages that have not yet been faulted in). */</span></span><br><span class="line"></span><br><span class="line">    uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">    uffdio_register.range.len = len;</span><br><span class="line">    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"ioctl-UFFDIO_REGISTER"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a thread that will process the userfaultfd events. */</span></span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;thr, <span class="literal">NULL</span>, fault_handler_thread, (<span class="keyword">void</span> *) uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">        errno = s;</span><br><span class="line">        errExit(<span class="string">"pthread_create"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Main thread now touches memory in the mapping, touching</span></span><br><span class="line"><span class="comment">       locations 1024 bytes apart. This will trigger userfaultfd</span></span><br><span class="line"><span class="comment">       events for all pages in the region. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    l = <span class="number">0xf</span>;    <span class="comment">/* Ensure that faulting address is not on a page</span></span><br><span class="line"><span class="comment">                   boundary, in order to test that we correctly</span></span><br><span class="line"><span class="comment">                   handle that case in fault_handling_thread(). */</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; len) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = addr[l];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Read address %p in main(): "</span>, addr + l);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, c);</span><br><span class="line">        l += <span class="number">1024</span>;</span><br><span class="line">        usleep(<span class="number">100000</span>);         <span class="comment">/* Slow things down a little */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ ./userfaultfd_demo 3</span><br><span class="line">Address returned by mmap() = 0x7fd30106c000</span><br><span class="line"></span><br><span class="line">fault_handler_thread():</span><br><span class="line">    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0</span><br><span class="line">    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106c00f</span><br><span class="line">        (uffdio_copy.copy returned 4096)</span><br><span class="line">Read address 0x7fd30106c00f in main(): A</span><br><span class="line">Read address 0x7fd30106c40f in main(): A</span><br><span class="line">Read address 0x7fd30106c80f in main(): A</span><br><span class="line">Read address 0x7fd30106cc0f in main(): A</span><br><span class="line"></span><br><span class="line">fault_handler_thread():</span><br><span class="line">    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0</span><br><span class="line">    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106d00f</span><br><span class="line">        (uffdio_copy.copy returned 4096)</span><br><span class="line">Read address 0x7fd30106d00f in main(): B</span><br><span class="line">Read address 0x7fd30106d40f in main(): B</span><br><span class="line">Read address 0x7fd30106d80f in main(): B</span><br><span class="line">Read address 0x7fd30106dc0f in main(): B</span><br><span class="line"></span><br><span class="line">fault_handler_thread():</span><br><span class="line">    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0</span><br><span class="line">    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106e00f</span><br><span class="line">        (uffdio_copy.copy returned 4096)</span><br><span class="line">Read address 0x7fd30106e00f in main(): C</span><br><span class="line">Read address 0x7fd30106e40f in main(): C</span><br><span class="line">Read address 0x7fd30106e80f in main(): C</span><br><span class="line">Read address 0x7fd30106ec0f in main(): C</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="http://brieflyx.me/2020/linux-tools/userfaultfd-internals/" target="_blank" rel="noopener">Linux Kernel Userfaultfd 内部机制探究</a></li><li><a href="https://man7.org/linux/man-pages/man2/userfaultfd.2.html" target="_blank" rel="noopener">man userfaultfd</a></li><li><a href="https://man7.org/linux/man-pages/man2/ioctl_userfaultfd.2.html" target="_blank" rel="noopener">man ioctl_userfaultfd</a></li><li><a href="https://www.slideshare.net/kerneltlv/userfaultfd-current-features-limitations-and-future-development" target="_blank" rel="noopener">Userfaultfd: Current Features, Limitations and Future Development</a></li><li><a href="https://www.kernel.org/doc/Documentation/vm/userfaultfd.txt" target="_blank" rel="noopener">kernel userfaultfd.txt</a></li><li><a href="http://lastweek.io/notes/userfaultfd/" target="_blank" rel="noopener">shanyizhou:Linux Userfaultfd</a></li><li><a href="https://blog.linuxplumbersconf.org/2017/ocw/system/presentations/4699/original/userfaultfd_%20post-copy%20VM%20migration%20and%20beyond.pdf" target="_blank" rel="noopener">userfaultfd_ post-copy VM migration and beyond.pdf</a></li><li><a href="https://noahdesu.github.io/2016/10/10/userfaultfd-hello-world.html" target="_blank" rel="noopener">userfaultfd hello world</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容主要转载自&lt;a href=&quot;http://brieflyx.me/2020/linux-tools/userfaultfd-internals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux Kernel Userfaultfd 内部机制探究&lt;/a&gt;，看代码的时候结合&lt;a href=&quot;https://man7.org/linux/man-pages/man2/userfaultfd.2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;man userfaultfd&lt;/a&gt;和&lt;a href=&quot;https://man7.org/linux/man-pages/man2/ioctl_userfaultfd.2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;man ioctl_userfaultfd&lt;/a&gt;，方便查询。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://liujunming.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liujunming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>eBPF资料合集</title>
    <link href="http://liujunming.github.io/2022/07/10/eBPF%E8%B5%84%E6%96%99%E5%90%88%E9%9B%86/"/>
    <id>http://liujunming.github.io/2022/07/10/eBPF资料合集/</id>
    <published>2022-07-10T04:10:12.000Z</published>
    <updated>2022-07-24T08:22:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>个人整理的eBPF资料合集。<a id="more"></a></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><a href="https://blog.csdn.net/hjkfcz/article/details/104916719" target="_blank" rel="noopener">ebpf原理分析</a></li><li><a href="https://tinylab.org/ebpf-part2/" target="_blank" rel="noopener">eBPF 程序装载、翻译与运行过程详解</a></li><li><a href="https://mp.weixin.qq.com/s/pKDn9DrvKYwDlu88Ojg5Pg" target="_blank" rel="noopener">揭秘 BPF map 前生今世</a></li><li><a href="https://mp.weixin.qq.com/s/afDcXoh0YfRlics22kucQw" target="_blank" rel="noopener">高效入门eBPF</a></li></ul><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ul><li><a href="https://mp.weixin.qq.com/s/9NtEmY0K861v9tHvmTOvWw" target="_blank" rel="noopener">eBPF Tracing 入门教程与实例</a></li><li><a href="https://mp.weixin.qq.com/s/LaoNpE5MNMrEeKzOFb_lYA" target="_blank" rel="noopener">深入浅出 eBPF｜你要了解的 7 个核心问题</a></li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li><a href="https://mp.weixin.qq.com/s/wn_hdcGPXOnzEZNj_-baJw" target="_blank" rel="noopener">宋宝华：用eBPF/bcc分析系统性能的一个简单案例</a></li><li><a href="https://mp.weixin.qq.com/s/6vw_HepdR76w_6vSmHuIVA" target="_blank" rel="noopener">基于eBPF监控和排查云原生环境中的磁盘IO性能问题</a></li><li><a href="https://mp.weixin.qq.com/s/meHBnFphRi9Kz-bf5QrONg" target="_blank" rel="noopener">高性能BPF内存分析工具解析</a></li><li><a href="https://www.ebpf.top/post/no_space_left_on_devices/" target="_blank" rel="noopener">eBPF+Ftrace 合璧剑指：no space left on device</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人整理的eBPF资料合集。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>bpftrace资料合集</title>
    <link href="http://liujunming.github.io/2022/07/10/bpftrace%E8%B5%84%E6%96%99%E5%90%88%E9%9B%86/"/>
    <id>http://liujunming.github.io/2022/07/10/bpftrace资料合集/</id>
    <published>2022-07-10T03:12:54.000Z</published>
    <updated>2022-07-24T08:22:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>个人整理的bpftrace资料合集。<a id="more"></a></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ul><li><a href="https://opensource.com/article/19/8/introduction-bpftrace" target="_blank" rel="noopener">An introduction to bpftrace for Linux</a></li><li><a href="https://www.brendangregg.com/ebpf.html#bpftrace" target="_blank" rel="noopener">Linux Extended BPF (eBPF) Tracing Tools:bpftrace</a></li><li><a href="https://github.com/iovisor/bpftrace/blob/master/man/adoc/bpftrace.adoc" target="_blank" rel="noopener">Manual</a></li><li><a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md" target="_blank" rel="noopener">Reference Guide</a></li><li><a href="https://github.com/iovisor/bpftrace/blob/master/docs/tutorial_one_liners.md" target="_blank" rel="noopener">One-Liner Tutorial</a></li><li><a href="https://github.com/iovisor/bpftrace" target="_blank" rel="noopener">github bpftrace</a></li></ul><h2 id="精读"><a href="#精读" class="headerlink" title="精读"></a>精读</h2><ul><li><a href="https://mp.weixin.qq.com/s/eZySfbqwOzG5EW7YL6enSw" target="_blank" rel="noopener">从bpftrace看如何利用eBPF实现内核追踪</a><ul><li><a href="/pdf/bpftrace_tutorial.pdf">archive</a></li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/476264071" target="_blank" rel="noopener">Linux - 如何测量函数的执行时间</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人整理的bpftrace资料合集。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Notes about eBPF</title>
    <link href="http://liujunming.github.io/2022/07/09/Notes-about-eBPF/"/>
    <id>http://liujunming.github.io/2022/07/09/Notes-about-eBPF/</id>
    <published>2022-07-09T07:53:10.000Z</published>
    <updated>2022-07-24T08:22:39.584Z</updated>
    
    <content type="html"><![CDATA[<p>eBPF does to Linux what JavaScript does to HTML. (Sort of.) So instead of a static HTML website, JavaScript lets you define mini programs that run on events like mouse clicks, which are run in a safe virtual machine in the browser. And with eBPF, instead of a fixed kernel, you can now write mini programs that run on events like disk I/O, which are run in a safe virtual machine in the kernel. In reality, eBPF is more like the v8 virtual machine that runs JavaScript, rather than JavaScript itself. eBPF is part of the Linux kernel.</p><p>Programming in eBPF directly is incredibly hard, the same as coding in v8 bytecode. But no one codes in v8: they code in JavaScript, or often a framework on top of JavaScript (jQuery, Angular, React, etc). It’s the same with eBPF. People will use it and code in it via frameworks. For tracing, the main ones are bcc and bpftrace. These don’t live in the kernel code base, they live in a Linux Foundation project on github called iovisor.[1]<a id="more"></a></p><p>本文内容转载自：<a href="https://www.brendangregg.com/ebpf.html" target="_blank" rel="noopener">Linux Extended BPF (eBPF) Tracing Tools</a></p><h2 id="1-History"><a href="#1-History" class="headerlink" title="1. History"></a>1. History</h2><p>BPF originated as a technology for optimizing packet filters. If you run tcpdump with an expression (matching on a host or port), it gets compiled into optimal BPF bytecode which is executed by an in-kernel sandboxed virtual machine. Extended BPF extended what this BPF virtual machine could do: allowing it to run on events other than packets, and do actions other than filtering.</p><h2 id="2-Introduction"><a href="#2-Introduction" class="headerlink" title="2. Introduction"></a>2. Introduction</h2><p>eBPF can be used to for software defined networks, DDoS mitigation (early packet drop), improving network performance (eXpress Data Path), intrusion detection, and more. It is used as shown in the following workflow:<br><img src="https://www.brendangregg.com/eBPF/linux_ebpf_internals.png" alt></p><p>Our observability tool has BPF code to perform certain actions: measure latency, summarize as a histogram, grab stack traces, etc. That BPF code is compiled to BPF byte code and then sent to the kernel, where a verifier may reject it if it is deemed unsafe (which includes not allowing loops or backwards branches). If the BPF bytecode is accepted, it can then be attached to different event sources:</p><ul><li><strong>kprobes</strong>: kernel dynamic tracing.</li><li><strong>uprobes</strong>: user level dynamic tracing.</li><li><strong>tracepoints</strong>: kernel static tracing.</li><li><strong>perf_events</strong>: timed sampling and PMCs.</li></ul><p>The BPF program has two ways to pass measured data back to user space: either per-event details, or via a BPF map. BPF maps can implement arrays, associative arrays, and histograms, and are suited for passing summary statistics.</p><h2 id="3-Prerequisites"><a href="#3-Prerequisites" class="headerlink" title="3. Prerequisites"></a>3. Prerequisites</h2><p>A Linux kernel compiled with CONFIG_BPF_SYSCALL (eg, Ubuntu does this), and at least the 4.4 kernel (eg, Ubuntu Xenial) so that histogram, statistic, and per-event tracing is supported. The following diagram shows other features with the Linux version eBPF supported arrived in green:<br><img src="https://www.brendangregg.com/eBPF/linux_ebpf_support.png" alt></p><h2 id="4-Front-Ends"><a href="#4-Front-Ends" class="headerlink" title="4. Front Ends"></a>4. Front Ends</h2><p>There are multiple different front-ends for eBPF. Here’s a summary, I’d recommend trying out bcc and bpftrace (highlighted).<br><img src="/images/2022/06/06.jpg" alt><br>I’ve previously summarized these on three dimensions: ease of use, scope &amp; capability, and stage of development. Here are the BPF front-ends vs the standard built-in Linux tracers (ftrace and perf):<br><img src="https://www.brendangregg.com/eBPF/ebpf_tracing_landscape_jan2019.png" alt></p><hr><p>Reference:<br>[1] <a href="https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html" target="_blank" rel="noopener">https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;eBPF does to Linux what JavaScript does to HTML. (Sort of.) So instead of a static HTML website, JavaScript lets you define mini programs that run on events like mouse clicks, which are run in a safe virtual machine in the browser. And with eBPF, instead of a fixed kernel, you can now write mini programs that run on events like disk I/O, which are run in a safe virtual machine in the kernel. In reality, eBPF is more like the v8 virtual machine that runs JavaScript, rather than JavaScript itself. eBPF is part of the Linux kernel.&lt;/p&gt;
&lt;p&gt;Programming in eBPF directly is incredibly hard, the same as coding in v8 bytecode. But no one codes in v8: they code in JavaScript, or often a framework on top of JavaScript (jQuery, Angular, React, etc). It’s the same with eBPF. People will use it and code in it via frameworks. For tracing, the main ones are bcc and bpftrace. These don’t live in the kernel code base, they live in a Linux Foundation project on github called iovisor.[1]
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
</feed>
