<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2021-02-06T14:30:50.061Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>è™šæ‹ŸåŒ–å­¦ä¹ å¿ƒå¾—:learn from native</title>
    <link href="http://liujunming.github.io/2021/02/04/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97-learn-from-native/"/>
    <id>http://liujunming.github.io/2021/02/04/è™šæ‹ŸåŒ–å­¦ä¹ å¿ƒå¾—-learn-from-native/</id>
    <published>2021-02-04T15:35:28.000Z</published>
    <updated>2021-02-06T14:30:50.061Z</updated>
    
    <content type="html"><![CDATA[<p>åœ¨è™šæ‹ŸåŒ–åœºæ™¯ä¸‹ï¼Œé‡åˆ°å¤æ‚çš„caseï¼Œå¯èƒ½ä¸çŸ¥é“å¦‚ä½•å¤„ç†ã€‚learn from nativeå¯èƒ½æ˜¯ä¸€ä¸ªçªç ´å£ã€‚ä½•ä¸ºnativeå‘¢ï¼Ÿæœ¬æ–‡æŒ‡çš„æ˜¯éè™šæ‹ŸåŒ–åœºæ™¯ä¸‹ï¼Œè¯¥caseçš„è¡Œä¸ºï¼ˆè¯»è€…éœ€è¦æ¸…æ¥šï¼šä»€ä¹ˆoperationç”±ç¡¬ä»¶å®Œæˆï¼Œä»€ä¹ˆoperationç”±è½¯ä»¶å®Œæˆï¼‰ã€‚<a id="more"></a></p><p>è¯»è€…å¯èƒ½ä¼šè§‰å¾—ä¸Šé¢çš„è¯å¾ˆæŠ½è±¡ï¼Œæœ¬æ–‡å°†ä»¥ä¸€ä¸ªä¾‹å­é˜è¿°è¯¥æ€æƒ³ã€‚</p><h3 id="1-Background-behavior-in-native"><a href="#1-Background-behavior-in-native" class="headerlink" title="1. Background(behavior in native)"></a>1. Background(behavior in native)</h3><p>è¯»è€…éœ€è¦é˜…è¯»<a href="/2021/02/03/Notes-about-instruction-boundaries/">Notes about instruction boundaries</a>ã€‚</p><blockquote><p>If more than one exception or interrupt is pending at an instruction boundary, the processor services them in a predictable order. Table 6-2 shows the priority among classes of exception and interrupt sources. </p></blockquote><p><img src="/images/2021/01/2.PNG" alt></p><p><img src="/images/2021/01/3.PNG" alt></p><blockquote><p>The processor first services a pending exception or interrupt from the class which has the highest priority, transferring execution to the first instruction of the handler. Lower priority exceptions are discarded; lower priority interrupts are held pending. Discarded exceptions are re-generated when the interrupt handler returns execution to the point in the program or task where the exceptions and/or interrupts occurred. </p></blockquote><p>SDMå¯¹äºSimultaneous Exceptions and Interrupts ç»™å‡ºäº†æè¿°ã€‚æ¥ä¸‹æ¥å°†ä»¥ä¸€ä¸ªå…·ä½“çš„ä¾‹å­é˜è¿°ç›¸å…³çŸ¥è¯†ç‚¹ã€‚</p><p>åœ¨nativeç¯å¢ƒä¸‹ï¼Œå‡è®¾å½“å‰CPUä¼šæ‰§è¡Œ<code>rdmsr</code>æŒ‡ä»¤ï¼Œ<code>rdmsr</code>æŒ‡ä»¤çš„æ‰§è¡Œæ—¶é—´ä¸º5ä¸ªcycleï¼Œå¹¶ä¸”<code>rdsmr</code>æŒ‡ä»¤ä¼šäº§ç”Ÿ#GPã€‚å½“CPUæ‰§è¡Œ<code>rdmsr</code>åˆ°ç¬¬3ä¸ªcycleæ—¶ï¼Œå¤–éƒ¨è®¾å¤‡å‘è¯¥CPUå‘é€äº†ä¸€ä¸ªMaskable Hardware Interruptã€‚é‚£ä¹ˆï¼Œæ¥ä¸‹æ¥çš„ç¡¬ä»¶è¡Œä¸ºæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ</p><p>å½“CPUæ‰§è¡Œå®Œ<code>rdmsr</code>æŒ‡ä»¤åï¼Œç”±äºMaskable Hardware Interruptçš„ä¼˜å…ˆçº§é«˜äº#GPï¼Œå› æ­¤CPUä¼šä¸¢å¼ƒ#GP,ä¼˜å…ˆå¤„ç†Maskable Hardware Interruptã€‚å½“Maskable Hardware Interruptå¤„ç†å®Œä¹‹åï¼Œç¡¬ä»¶ä¼šre-generate  #GPã€‚</p><h3 id="2-Is-Simultaneous-Exceptions-and-Interrupts-behavior-in-virtualization"><a href="#2-Is-Simultaneous-Exceptions-and-Interrupts-behavior-in-virtualization" class="headerlink" title="2. Is Simultaneous Exceptions and Interrupts?(behavior  in virtualization)"></a>2. Is Simultaneous Exceptions and Interrupts?(behavior  in virtualization)</h3><p>å‡è®¾åœ¨è™šæ‹ŸåŒ–åœºæ™¯ä¸‹ï¼š</p><ol><li>å½“å‰CPUåªè¿è¡Œä¸€ä¸ªvCPU thread</li><li>å½“å‰CPUçš„LAPIC pass-thruç»™vCPU</li><li>åœ¨root modeä¸‹ï¼Œhvä¼šå…³ä¸­æ–­</li><li>åœ¨non-root modeä¸‹ï¼Œå½“vCPUæ‰§è¡Œ<code>rdmsr</code>æ—¶ï¼Œä¼šå‘ç”ŸVM Exitï¼Œhvå°†ä¸ºvCPUæ³¨å…¥#GP</li><li>åœ¨rootä¸‹ï¼Œå½“hvä¸ºvCPUæ³¨å…¥#GPæ—¶ï¼Œå¤–éƒ¨è®¾å¤‡å‘è¯¥CPUå‘é€äº†ä¸€ä¸ªMaskable Hardware Interrupt</li></ol><p>é‚£ä¹ˆï¼Œè¯»è€…å¯ä»¥å°è¯•å›ç­”å¦‚ä¸‹é—®é¢˜ï¼š</p><p>åœ¨guestçœ‹æ¥ï¼ŒMaskable Hardware Interruptå’Œ#GPæ˜¯Simultaneous Exceptions and Interruptså—ï¼Ÿ</p><p>å®éªŒç»“æœå¦‚ä¸‹ï¼šå½“è¿›å…¥non-root modeåï¼ŒvCPUä¼šå…ˆå¤„ç†#GPï¼Œç„¶åå¤„ç†Maskable Hardware Interruptã€‚ç”±æ­¤å¯è§ï¼Œåœ¨guestçœ‹æ¥ï¼ŒMaskable Hardware Interruptå’Œ#GP<strong>ä¸æ˜¯</strong>Simultaneous Exceptions and Interruptsã€‚</p><p>ä¸ºä»€ä¹ˆï¼Ÿæ­¤æ—¶ï¼Œlearn from nativeçš„æ–¹æ¡ˆå°±æ´¾ä¸Šç”¨åœºäº†ã€‚åœ¨nativeç¯å¢ƒä¸‹ï¼ŒMaskable Hardware Interruptå’Œ#GP pending at an instruction boundaryæ—¶ï¼Œç¡¬ä»¶æ‰ä¼šå°†Maskable Hardware Interruptå’Œ#GPå½“ä½œSimultaneous Exceptions and Interruptsã€‚åœ¨æˆ‘ä»¬çš„è¿™ä¸ªä¾‹å­ä¸­ï¼Œå½“guestæ‰§è¡Œå®Œ<code>rdmsr</code>æŒ‡ä»¤åï¼Œæ ¹æ®instruction boundaryï¼Œä»¥guestçš„è§†è§’æ¥çœ‹ï¼Œç¡¬ä»¶ä¼šç«‹åˆ»ä¸ºå…¶æ³¨å…¥#GPï¼Œè€ŒMaskable Hardware Interruptæ˜¯åœ¨guestæ‰§è¡Œå®Œ<code>rdmsr</code>æŒ‡ä»¤åäº§ç”Ÿçš„ï¼Œå› æ­¤ï¼Œåœ¨guestçœ‹æ¥ï¼ŒMaskable Hardware Interruptå’Œ#GP<strong>ä¸æ˜¯</strong>Simultaneous Exceptions and Interruptsã€‚</p><h3 id="3-Rethinking"><a href="#3-Rethinking" class="headerlink" title="3. Rethinking"></a>3. Rethinking</h3><p>å‡è®¾åœ¨è™šæ‹ŸåŒ–åœºæ™¯ä¸‹ï¼š</p><ol><li>å½“å‰CPUåªè¿è¡Œä¸€ä¸ªvCPU thread</li><li>å½“å‰CPUçš„LAPIC pass-thruç»™vCPU</li><li>åœ¨non-root modeä¸‹ï¼Œå½“vCPUæ‰§è¡Œ<code>rdmsr</code>æ—¶ï¼ˆæ‰§è¡Œæ—¶é—´ä¸º5ä¸ªcycleï¼‰ï¼Œä¼šå‘ç”ŸVM Exitï¼Œhvå°†ä¸ºvCPUæ³¨å…¥#GP</li><li>åœ¨non-root modeä¸‹ï¼Œå½“vCPUæ‰§è¡Œ<code>rdmsr</code>åˆ°ç¬¬3ä¸ªcycleæ—¶æ—¶ï¼Œå¤–éƒ¨è®¾å¤‡å‘è¯¥CPUå‘é€äº†ä¸€ä¸ªMaskable Hardware Interrupt</li></ol><p>é‚£ä¹ˆï¼Œè¯»è€…å¯ä»¥å°è¯•å›ç­”å¦‚ä¸‹é—®é¢˜ï¼š</p><p>åœ¨guestçœ‹æ¥ï¼ŒMaskable Hardware Interruptå’Œ#GPæ˜¯Simultaneous Exceptions and Interruptså—ï¼Ÿ</p><p>åˆ©ç”¨learn from nativeçš„æ–¹æ¡ˆå¯çŸ¥ï¼Œåœ¨guestçœ‹æ¥ï¼ŒMaskable Hardware Interruptå’Œ#GPæ˜¯Simultaneous Exceptions and Interruptsã€‚</p><p>é—®é¢˜åˆæ¥äº†ï¼Œåœ¨è™šæ‹ŸåŒ–ç¯å¢ƒä¸‹ï¼Œæ˜¯å¦‚ä½•ä¿è¯Discarded exceptions are re-generated when the interrupt handler returns execution to the point in the program or task where the exceptions and/or interrupts occurredï¼Ÿ</p><p>åœ¨non-root modeä¸‹ï¼Œå½“vCPUå¤„ç†å®ŒMaskable Hardware Interruptåï¼ŒRIPå¯„å­˜å™¨ä¼šä¿è¯vCPUå†æ‰§è¡Œä¸€æ¬¡<code>rdmsr</code>æŒ‡ä»¤ï¼Œé‚£ä¹ˆï¼Œå°±ä¼šå‘ç”ŸVM Exitï¼Œhvä¼šç»™vCPU æ³¨å…¥#GPã€‚</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;åœ¨è™šæ‹ŸåŒ–åœºæ™¯ä¸‹ï¼Œé‡åˆ°å¤æ‚çš„caseï¼Œå¯èƒ½ä¸çŸ¥é“å¦‚ä½•å¤„ç†ã€‚learn from nativeå¯èƒ½æ˜¯ä¸€ä¸ªçªç ´å£ã€‚ä½•ä¸ºnativeå‘¢ï¼Ÿæœ¬æ–‡æŒ‡çš„æ˜¯éè™šæ‹ŸåŒ–åœºæ™¯ä¸‹ï¼Œè¯¥caseçš„è¡Œä¸ºï¼ˆè¯»è€…éœ€è¦æ¸…æ¥šï¼šä»€ä¹ˆoperationç”±ç¡¬ä»¶å®Œæˆï¼Œä»€ä¹ˆoperationç”±è½¯ä»¶å®Œæˆï¼‰ã€‚
    
    </summary>
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Notes about instruction boundaries</title>
    <link href="http://liujunming.github.io/2021/02/03/Notes-about-instruction-boundaries/"/>
    <id>http://liujunming.github.io/2021/02/03/Notes-about-instruction-boundaries/</id>
    <published>2021-02-03T06:47:53.000Z</published>
    <updated>2021-02-06T14:30:50.060Z</updated>
    
    <content type="html"><![CDATA[<p>è½¬è½½è‡ªï¼š<a href="https://blog.csdn.net/leoufung/article/details/48828197" target="_blank" rel="noopener">Intelçš„instruction boundariesæ˜¯ä»€ä¹ˆ</a><br><a id="more"></a></p><p>SDMä¸­<code>instruction boundaries</code>ä¸€è¯ç»å¸¸å‡ºç°ã€‚å¦‚<code>All interrupts are guaranteed to be taken on an instruction boundary</code>ã€‚ é‚£ä¹ˆä»€ä¹ˆæ˜¯æŒ‡ä»¤çš„è¾¹ç•Œå‘¢?ä¸€ä¸ªæŒ‡ä»¤ä¼šæœ‰è¾¹ç•Œå—? </p><p>åœ¨X86ä¸­, ä½¿ç”¨çš„æ˜¯éç²¾ç®€æŒ‡ä»¤,ä¼šå ç”¨å¾ˆå¤šçš„cycleæ‰å¯ä»¥å®Œæˆä¸€æ¡æŒ‡ä»¤,è€Œä¸”ä¸åŒçš„æŒ‡ä»¤å ç”¨çš„cycleæ•°æ˜¯ä¸åŒçš„,å¤æ‚çš„æŒ‡ä»¤ä¼šå ç”¨å¾ˆå¤šçš„cycleæ‰å¯ä»¥å®Œæˆ; è€ŒARMæŒ‡ä»¤çš„æ‰§è¡Œå ç”¨å›ºå®šçš„cycleã€‚</p><p>è¿™é‡Œè¯´çš„æ˜¯ä¸­æ–­ä¼šå‘ç”Ÿåœ¨æŒ‡ä»¤çš„è¾¹ç•Œä¸Šã€‚ä¹Ÿå°±æ˜¯è¯´, å‡å¦‚ä¸€ä¸ªå¤æ‚çš„æŒ‡ä»¤éœ€è¦100ä¸ªcycleæ‰å¯ä»¥å®Œæˆé€»è¾‘, ä½†æ˜¯åœ¨ç¬¬50ä¸ªcycleå‘ç”Ÿäº†ä¸­æ–­, é‚£ä¹ˆä¸­æ–­ä¹Ÿä¼šåœ¨æ‰§è¡Œå®Œæ•´ä¸ªé€»è¾‘, åœ¨ç¬¬100cycleçš„åœ°æ–¹æ‰å‘ç”Ÿ, è€Œä¸ä¼šåœ¨ç¬¬50cycleçš„åœ°æ–¹ç«‹å³å‘ç”Ÿã€‚</p><p>OK,ç†è§£äº†ä¹‹å,çœ‹ä¸‹é¢è¿™å¥è¯, <code>Interrupts are taken at instruction boundaries located during the retirement phase of instruction execution;</code>  è¿™ä¸‹å°±å¥½ç†è§£äº†, ä¸­æ–­å‘ç”Ÿåœ¨æŒ‡ä»¤è¾¹ç•Œä¸Š, ä¹Ÿå°±æ˜¯å‘ç”Ÿåœ¨æŒ‡ä»¤çš„â€å®Œæˆé˜¶æ®µâ€, å®Œæˆé˜¶æ®µå°±æ˜¯ä¸Šé¢æŒ‡çš„ç¬¬100ä¸ªcycleå¤„ã€‚</p><h3 id="VM-Exitå‘ç”Ÿåœ¨æŒ‡ä»¤è¾¹ç•Œä¸Šå—ï¼Ÿ"><a href="#VM-Exitå‘ç”Ÿåœ¨æŒ‡ä»¤è¾¹ç•Œä¸Šå—ï¼Ÿ" class="headerlink" title="VM Exitå‘ç”Ÿåœ¨æŒ‡ä»¤è¾¹ç•Œä¸Šå—ï¼Ÿ"></a>VM Exitå‘ç”Ÿåœ¨æŒ‡ä»¤è¾¹ç•Œä¸Šå—ï¼Ÿ</h3><p>ä¸ªäººè®¤ä¸ºVM Exitå‘ç”Ÿåœ¨æŒ‡ä»¤è¾¹ç•Œä¸Šã€‚<br><a href="https://revers.engineering/day-5-vmexits-interrupts-cpuid-emulation/" target="_blank" rel="noopener">https://revers.engineering/day-5-vmexits-interrupts-cpuid-emulation/</a></p><p><img src="/images/2021/01/4.PNG" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;è½¬è½½è‡ªï¼š&lt;a href=&quot;https://blog.csdn.net/leoufung/article/details/48828197&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Intelçš„instruction boundariesæ˜¯ä»€ä¹ˆ&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ä½“ç³»ç»“æ„" scheme="http://liujunming.github.io/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="ä½“ç³»ç»“æ„" scheme="http://liujunming.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>æ¯å‘¨åˆ†äº«ç¬¬19æœŸ</title>
    <link href="http://liujunming.github.io/2021/01/28/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC19%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/01/28/æ¯å‘¨åˆ†äº«ç¬¬19æœŸ/</id>
    <published>2021-01-28T01:33:39.000Z</published>
    <updated>2021-02-03T14:12:58.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Intel-Appoints-Sunil-Shenoy-as-Senior-Vice-President-of-Design-Engineering-Group"><a href="#Intel-Appoints-Sunil-Shenoy-as-Senior-Vice-President-of-Design-Engineering-Group" class="headerlink" title="Intel Appoints Sunil Shenoy as Senior Vice President of Design Engineering Group"></a>Intel Appoints Sunil Shenoy as Senior Vice President of Design Engineering Group</h3><p><a href="https://newsroom.intel.com/news-releases/intel-appoints-sunil-shenoy-senior-vice-president-design-engineering-group/" target="_blank" rel="noopener">https://newsroom.intel.com/news-releases/intel-appoints-sunil-shenoy-senior-vice-president-design-engineering-group/</a><br><a id="more"></a></p><h3 id="ACRN-TCM"><a href="#ACRN-TCM" class="headerlink" title="ACRN TCM"></a>ACRN TCM</h3><p><a href="https://drive.google.com/drive/folders/1_XTGu6re3BOQAjtPx636Mz1T5lOy2UWC" target="_blank" rel="noopener">https://drive.google.com/drive/folders/1_XTGu6re3BOQAjtPx636Mz1T5lOy2UWC</a></p><h3 id="Zhenyuan-Ruan"><a href="#Zhenyuan-Ruan" class="headerlink" title="Zhenyuan Ruan"></a>Zhenyuan Ruan</h3><p><a href="https://zainryan.github.io/" target="_blank" rel="noopener">https://zainryan.github.io/</a></p><h3 id="Accessing-PCI-Express-Configuration-Registers-Using-IntelÂ®-Chipsets"><a href="#Accessing-PCI-Express-Configuration-Registers-Using-IntelÂ®-Chipsets" class="headerlink" title="Accessing PCI Express Configuration Registers Using IntelÂ® Chipsets"></a>Accessing PCI Express Configuration Registers Using IntelÂ® Chipsets</h3><p><a href="http://www.csit-sun.pub.ro/~cpop/Documentatie_SMP/Intel_Microprocessor_Systems/Intel_ProcessorNew/Intel%20White%20Paper/Accessing%20PCI%20Express%20Configuration%20Registers%20Using%20Intel%20Chipsets.pdf" target="_blank" rel="noopener">http://www.csit-sun.pub.ro/~cpop/Documentatie_SMP/Intel_Microprocessor_Systems/Intel_ProcessorNew/Intel%20White%20Paper/Accessing%20PCI%20Express%20Configuration%20Registers%20Using%20Intel%20Chipsets.pdf</a></p><h3 id="IntelÂ®-5100-Memory-Controller-Hub-Chipset-Datasheet"><a href="#IntelÂ®-5100-Memory-Controller-Hub-Chipset-Datasheet" class="headerlink" title="IntelÂ® 5100 Memory Controller Hub Chipset Datasheet"></a>IntelÂ® 5100 Memory Controller Hub Chipset Datasheet</h3><p><a href="https://www.intel.com/content/dam/doc/datasheet/5100-memory-controller-hub-chipset-datasheet.pdf" target="_blank" rel="noopener">https://www.intel.com/content/dam/doc/datasheet/5100-memory-controller-hub-chipset-datasheet.pdf</a><br>Includes details for I/O Address: CF8h &amp; CFCh</p><h3 id="Windows-10-X"><a href="#Windows-10-X" class="headerlink" title="Windows 10 X"></a>Windows 10 X</h3><p>Windows 10 X ï¼ˆå¾®è½¯å…¨æ–°æ“ä½œç³»ç»Ÿï¼‰å®‰è£…æ•™ç¨‹ä¸ä½“éªŒï¼<br><a href="https://www.youtube.com/watch?v=N9aRsV_2uRE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=N9aRsV_2uRE</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Intel-Appoints-Sunil-Shenoy-as-Senior-Vice-President-of-Design-Engineering-Group&quot;&gt;&lt;a href=&quot;#Intel-Appoints-Sunil-Shenoy-as-Senior-Vice-President-of-Design-Engineering-Group&quot; class=&quot;headerlink&quot; title=&quot;Intel Appoints Sunil Shenoy as Senior Vice President of Design Engineering Group&quot;&gt;&lt;/a&gt;Intel Appoints Sunil Shenoy as Senior Vice President of Design Engineering Group&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://newsroom.intel.com/news-releases/intel-appoints-sunil-shenoy-senior-vice-president-design-engineering-group/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://newsroom.intel.com/news-releases/intel-appoints-sunil-shenoy-senior-vice-president-design-engineering-group/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ç»éªŒ" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="ç»éªŒ" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>æ¯å‘¨åˆ†äº«ç¬¬18æœŸ</title>
    <link href="http://liujunming.github.io/2021/01/21/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC18%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/01/21/æ¯å‘¨åˆ†äº«ç¬¬18æœŸ/</id>
    <published>2021-01-21T08:02:20.000Z</published>
    <updated>2021-01-24T07:38:51.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nvidiaä¸ºä»€ä¹ˆæ”¶è´­Mellanoxï¼Ÿ"><a href="#Nvidiaä¸ºä»€ä¹ˆæ”¶è´­Mellanoxï¼Ÿ" class="headerlink" title="Nvidiaä¸ºä»€ä¹ˆæ”¶è´­Mellanoxï¼Ÿ"></a>Nvidiaä¸ºä»€ä¹ˆæ”¶è´­Mellanoxï¼Ÿ</h3><p><a href="https://www.jiqizhixin.com/articles/2019-03-15-13" target="_blank" rel="noopener">https://www.jiqizhixin.com/articles/2019-03-15-13</a></p><a id="more"></a><h3 id="AMDæ”¶è´­èµ›çµæ€ï¼ˆXilinxï¼‰"><a href="#AMDæ”¶è´­èµ›çµæ€ï¼ˆXilinxï¼‰" class="headerlink" title="AMDæ”¶è´­èµ›çµæ€ï¼ˆXilinxï¼‰"></a>AMDæ”¶è´­èµ›çµæ€ï¼ˆXilinxï¼‰</h3><p><a href="https://www.sdnlab.com/24506.html" target="_blank" rel="noopener">https://www.sdnlab.com/24506.html</a></p><h3 id="xilinx-å’Œ-altera-ä¸¤å®¶å…¬å¸çš„ä¸»è¦åŒºåˆ«å’Œå„è‡ªä¼˜åŠ¿åˆ†åˆ«æ˜¯ä»€ä¹ˆï¼Ÿ"><a href="#xilinx-å’Œ-altera-ä¸¤å®¶å…¬å¸çš„ä¸»è¦åŒºåˆ«å’Œå„è‡ªä¼˜åŠ¿åˆ†åˆ«æ˜¯ä»€ä¹ˆï¼Ÿ" class="headerlink" title="xilinx å’Œ altera ä¸¤å®¶å…¬å¸çš„ä¸»è¦åŒºåˆ«å’Œå„è‡ªä¼˜åŠ¿åˆ†åˆ«æ˜¯ä»€ä¹ˆï¼Ÿ"></a>xilinx å’Œ altera ä¸¤å®¶å…¬å¸çš„ä¸»è¦åŒºåˆ«å’Œå„è‡ªä¼˜åŠ¿åˆ†åˆ«æ˜¯ä»€ä¹ˆï¼Ÿ</h3><p><a href="https://www.zhihu.com/question/31440109" target="_blank" rel="noopener">https://www.zhihu.com/question/31440109</a></p><h3 id="HW-hardware-accelerator"><a href="#HW-hardware-accelerator" class="headerlink" title="HW(hardware) accelerator"></a>HW(hardware) accelerator</h3><p><a href="https://blog.mellanox.com/2018/08/defining-smartnic/" target="_blank" rel="noopener">https://blog.mellanox.com/2018/08/defining-smartnic/</a></p><p>Mellanox,Huawei,Xilinx,Intel</p><h3 id="Chrome-tracing"><a href="#Chrome-tracing" class="headerlink" title="Chrome tracing"></a>Chrome tracing</h3><p><a href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool" target="_blank" rel="noopener">https://www.chromium.org/developers/how-tos/trace-event-profiling-tool</a></p><h3 id="specVirt"><a href="#specVirt" class="headerlink" title="specVirt"></a>specVirt</h3><p><a href="https://www.spec.org/virt_sc2013/" target="_blank" rel="noopener">https://www.spec.org/virt_sc2013/</a><br>The SPEC virt_sc Â® 2013 benchmark suites are used to measure performance of virtualized platforms. </p><h3 id="self-contained-meaning"><a href="#self-contained-meaning" class="headerlink" title="self-contained meaning"></a>self-contained meaning</h3><p><a href="https://www.yourdictionary.com/self-contained" target="_blank" rel="noopener">https://www.yourdictionary.com/self-contained</a><br>The definition of self contained refers to something or someone that is complete on its own and that doesnâ€™t need anything else.</p><h3 id="Zhaorong-Hou-Intelå…¬å¸èµ„æ·±å·¥ç¨‹ç»ç†"><a href="#Zhaorong-Hou-Intelå…¬å¸èµ„æ·±å·¥ç¨‹ç»ç†" class="headerlink" title="Zhaorong Hou, Intelå…¬å¸èµ„æ·±å·¥ç¨‹ç»ç†"></a>Zhaorong Hou, Intelå…¬å¸èµ„æ·±å·¥ç¨‹ç»ç†</h3><p><a href="https://www.youtube.com/watch?v=yKVG9jYOwz8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=yKVG9jYOwz8</a></p><h3 id="ç»æµæœºå™¨æ˜¯æ€æ ·è¿è¡Œçš„"><a href="#ç»æµæœºå™¨æ˜¯æ€æ ·è¿è¡Œçš„" class="headerlink" title="ç»æµæœºå™¨æ˜¯æ€æ ·è¿è¡Œçš„"></a>ç»æµæœºå™¨æ˜¯æ€æ ·è¿è¡Œçš„</h3><p><a href="https://www.youtube.com/watch?v=rFV7wdEX-Mo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=rFV7wdEX-Mo</a></p><h3 id="x2APIC-Virtualization-and-Posted-Interrupt-Processing"><a href="#x2APIC-Virtualization-and-Posted-Interrupt-Processing" class="headerlink" title="x2APIC Virtualization and Posted Interrupt Processing"></a>x2APIC Virtualization and Posted Interrupt Processing</h3><p><a href="https://cs.stanford.edu/~jhumphri/documents/x2apic-posted-ipi.pdf" target="_blank" rel="noopener">https://cs.stanford.edu/~jhumphri/documents/x2apic-posted-ipi.pdf</a></p><p><a href="/pdf/x2apic-posted-ipi.pdf">x2APIC Virtualization and Posted Interrupt Processing</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Nvidiaä¸ºä»€ä¹ˆæ”¶è´­Mellanoxï¼Ÿ&quot;&gt;&lt;a href=&quot;#Nvidiaä¸ºä»€ä¹ˆæ”¶è´­Mellanoxï¼Ÿ&quot; class=&quot;headerlink&quot; title=&quot;Nvidiaä¸ºä»€ä¹ˆæ”¶è´­Mellanoxï¼Ÿ&quot;&gt;&lt;/a&gt;Nvidiaä¸ºä»€ä¹ˆæ”¶è´­Mellanoxï¼Ÿ&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.jiqizhixin.com/articles/2019-03-15-13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jiqizhixin.com/articles/2019-03-15-13&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ç»éªŒ" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="ç»éªŒ" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Deep into CR0/CR4 in VMX operation</title>
    <link href="http://liujunming.github.io/2020/12/26/Deep-into-CR0-CR4-in-VMX-operation/"/>
    <id>http://liujunming.github.io/2020/12/26/Deep-into-CR0-CR4-in-VMX-operation/</id>
    <published>2020-12-26T05:12:10.000Z</published>
    <updated>2021-01-24T07:38:51.961Z</updated>
    
    <content type="html"><![CDATA[<p>In VMX operation, the value of guest CR0/CR4 need to consider the following cases:</p><ol><li>processors may fix certain bits in CR0 and CR4 to specific values and not support other values. </li><li>Guest/Host Masks and Read Shadows for CR0 and CR4</li></ol><a id="more"></a><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><p>For the first case, you can refer to intel SDM Vol. 3D A.7(<strong>VMX-FIXED BITS IN CR0</strong>) and A.8(<strong>VMX-FIXED BITS IN CR4</strong>).</p><p>Weâ€™ll deep into the second case.</p><p><img src="/images/2020/12/3.PNG" alt></p><p>From the description, please try to answer this question: Why needs the <strong>guest/host masks</strong>  and <strong>read shadow</strong>?</p><p>Letâ€™s consider this example:</p><p><img src="/images/2020/12/4.PNG" alt></p><p>From SDM description, CR4.VMXE must be 1 in VMX operation. Without <strong>guest/host masks</strong> and <strong>read shadow</strong>, if guest is a normal operating system, not a VMM, when guest want to get CR4.VMXE, it would be 1. Thatâ€™s the wrong value for guest. But we still need to ensure physical CR4.VMXE is1 in non-root mode!</p><p>How can we satisfy all the above requirements?</p><p><strong>guest/host masks</strong> and <strong>read shadow</strong> help us solve the issue.</p><ol><li><p>set VMCS Guest CR4(00006804H ) field VMXE bit to be 1, to ensure physical CR4.VMXE  is 1 in non-root mode;</p></li><li><p>set CR4 guest/host masks(00006002H ) field VMXE bit to be 1, means VMXE bit is owned by host;</p></li><li>set CR4 read shadow(00006006H ) field VMXE bit to be 0.</li></ol><p>When guest reads CR4.VMXE, hardware will return value for this bit from the corresponding read shadow(the value is 0 here). While physical CR4.VMXE  still is 1 in non-root mode.</p><h3 id="2-Example"><a href="#2-Example" class="headerlink" title="2. Example"></a>2. Example</h3><p>Letâ€™s take <a href="https://github.com/projectacrn/acrn-hypervisor/blob/acrn-2020w51.5-180000p/hypervisor/arch/x86/guest/virtual_cr.c" target="_blank" rel="noopener">ACRN virtual_cr.c</a> as an example.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Physical CR4 bits in VMX operation may be either flexible or fixed.</span></span><br><span class="line"><span class="comment"> * Guest CR4 bits may be operatable or reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All the guest reserved bits should be TRAPed and EMULATed by HV</span></span><br><span class="line"><span class="comment"> * (inject #GP).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For guest operatable bits, it may be:</span></span><br><span class="line"><span class="comment"> * CR4_PASSTHRU_BITS:</span></span><br><span class="line"><span class="comment"> *Bits that may be passed through to guest. The actual passthru bits</span></span><br><span class="line"><span class="comment"> *should be masked by flexible bits.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CR4_TRAP_AND_PASSTHRU_BITS:</span></span><br><span class="line"><span class="comment"> *The bits are trapped by HV and HV emulation will eventually write</span></span><br><span class="line"><span class="comment"> *the guest value to physical CR4 (GUEST_CR4) too. The actual bits</span></span><br><span class="line"><span class="comment"> *should be masked by flexible bits.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CR4_TRAP_AND_EMULATE_BITS:</span></span><br><span class="line"><span class="comment"> *The bits are trapped by HV and emulated, but HV updates vCR4 only</span></span><br><span class="line"><span class="comment"> *(no update to physical CR4), i.e. pure software emulation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CR4_EMULATED_RESERVE_BITS:</span></span><br><span class="line"><span class="comment"> *The bits are trapped, but are emulated by injecting a #GP.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> Above bits should not overlap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_TRAP_AND_PASSTHRU_BITS(CR0_PE | CR0_PG | CR0_WP)</span></span><br></pre></td></tr></table></figure><p>CR0_PG is trapped by HV and HV emulation will eventually write the guest value to physical CR0 (GUEST_CR0) too. Can we pass through CR0_PG to guest? The answer is no!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((cr0_changed_bits &amp; CR0_PG) != <span class="number">0U</span>L) &#123;</span><br><span class="line"><span class="comment">/* PG bit changes */</span></span><br><span class="line"><span class="keyword">if</span> ((effective_cr0 &amp; CR0_PG) != <span class="number">0U</span>L) &#123;</span><br><span class="line"><span class="comment">/* Enable paging */</span></span><br><span class="line"><span class="keyword">if</span> ((vcpu_get_efer(vcpu) &amp; MSR_IA32_EFER_LME_BIT) != <span class="number">0U</span>L) &#123;</span><br><span class="line"><span class="comment">/* Enable long mode */</span></span><br><span class="line">pr_dbg(<span class="string">"VMM: Enable long mode"</span>);</span><br><span class="line">entry_ctrls = exec_vmread32(VMX_ENTRY_CONTROLS);</span><br><span class="line">entry_ctrls |= VMX_ENTRY_CTLS_IA32E_MODE;</span><br><span class="line">exec_vmwrite32(VMX_ENTRY_CONTROLS, entry_ctrls);</span><br><span class="line"></span><br><span class="line">vcpu_set_efer(vcpu, vcpu_get_efer(vcpu) | MSR_IA32_EFER_LMA_BIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hereâ€™s the reason why we set the<code>VMX_ENTRY_CTLS_IA32E_MODE</code> and <code>MSR_IA32_EFER_LMA_BIT</code>.</p><p><img src="/images/2020/12/5.PNG" alt></p><p>If pass through CR0_PG to guest, while guest runs in non-root mode, hardware couldnâ€™t update<code>VMX_ENTRY_CONTROLS</code> field. So we should trap CR0_PG, and HV will  update<code>VMX_ENTRY_CONTROLS</code> field in root mode.</p><h3 id="3-Conclusion"><a href="#3-Conclusion" class="headerlink" title="3. Conclusion"></a>3. Conclusion</h3><p>If one bit has restriction in VMX operation or needs to do some operations in root mode, Itâ€™s better to trap(owned by host) this bit. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;In VMX operation, the value of guest CR0/CR4 need to consider the following cases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;processors may fix certain bits in CR0 and CR4 to specific values and not support other values. &lt;/li&gt;
&lt;li&gt;Guest/Host Masks and Read Shadows for CR0 and CR4&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="VT-x" scheme="http://liujunming.github.io/categories/VT-x/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-x" scheme="http://liujunming.github.io/tags/VT-x/"/>
    
  </entry>
  
  <entry>
    <title>VT-x:Relative Priority of Faults and VM Exits</title>
    <link href="http://liujunming.github.io/2020/12/01/VT-x-Relative-Priority-of-Faults-and-VM-Exits/"/>
    <id>http://liujunming.github.io/2020/12/01/VT-x-Relative-Priority-of-Faults-and-VM-Exits/</id>
    <published>2020-12-01T08:55:04.000Z</published>
    <updated>2020-12-01T14:36:04.198Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡ä¸»è¦è®°å½•SDMä¸­<code>Relative Priority of Faults and VM Exits</code>ä¸€èŠ‚çš„ç›¸å…³ç¬”è®°ã€‚<a id="more"></a><br>The following principles describe the ordering between existing faults and VM exits:</p><ul><li>Certain exceptions have priority over VM exits. These include <strong>invalid-opcode exceptions (#UD)</strong>, <strong>faults based on privilege level</strong>, and general-protection exceptions that are based on checking I/O permission bits in the taskstate segment (TSS). For example, execution of RDMSR with CPL = 3 generates a general-protection exception and not a VM exit.</li></ul><p>ä»¥<code>XSETBV</code>instructionä¸ºä¾‹ï¼š<br><img src="/images/2020/12/2.PNG" alt></p><p>In non-root modeï¼Œif the current privileage level is not 0, VM exit wonâ€™t happen. Because <strong>faults based on privilege level</strong> has priority over VM exits.</p><p>In non-root modeï¼Œif CR4.OSXSAVE[bit 18] = 0, VM exit wonâ€™t happen. Because <strong>invalid-opcode exceptions(#UD)</strong> has priority over VM exits.</p><p>è¯¦ç»†å†…å®¹å¯å‚è€ƒpatchï¼š<a href="https://github.com/projectacrn/acrn-hypervisor/commit/56eb859ea4e3af1edbd15b80276e9f2404a43e2b" target="_blank" rel="noopener">hv: vmexit: refine xsetbv_vmexit_handler API</a>ã€‚</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡ä¸»è¦è®°å½•SDMä¸­&lt;code&gt;Relative Priority of Faults and VM Exits&lt;/code&gt;ä¸€èŠ‚çš„ç›¸å…³ç¬”è®°ã€‚
    
    </summary>
    
      <category term="VT-x" scheme="http://liujunming.github.io/categories/VT-x/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-x" scheme="http://liujunming.github.io/tags/VT-x/"/>
    
  </entry>
  
  <entry>
    <title>VT-x:Information for VM Exits During Event Delivery</title>
    <link href="http://liujunming.github.io/2020/12/01/VT-x-Information-for-VM-Exits-During-Event-Delivery/"/>
    <id>http://liujunming.github.io/2020/12/01/VT-x-Information-for-VM-Exits-During-Event-Delivery/</id>
    <published>2020-12-01T05:11:55.000Z</published>
    <updated>2020-12-01T14:37:10.379Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡ä¸»è¦è®°å½•SDMä¸­<code>Information for VM Exits During Event Delivery</code>ä¸€èŠ‚çš„ç›¸å…³ç¬”è®°ã€‚<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p><code>Information for VM Exits That Occur During Event Delivery</code> defined fields containing information for VM exits that occur while delivering an event through the IDT and as a result of any of the following cases:</p><ul><li>A fault occurs during event delivery and causes a VM exit (because the bit associated with the fault is set to 1 in the exception bitmap).</li><li>A task switch is invoked through a task gate in the IDT. The VM exit occurs due to the task switch only after the initial checks of the task switch pass.</li><li>Event delivery causes an APIC-access VM exit.</li><li>An EPT violation, EPT misconfiguration, page-modification log-full event, or SPP-related event that occurs during event delivery.</li></ul><p>ACRNä¸­çš„<a href="https://github.com/projectacrn/acrn-hypervisor/blob/v2.2/hypervisor/arch/x86/guest/vmexit.c#L183" target="_blank" rel="noopener">å®ç°</a>å¦‚ä¸‹ï¼š<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vcpu-&gt;arch.idt_vectoring_info = exec_vmread32(VMX_IDT_VEC_INFO_FIELD);</span><br><span class="line"><span class="keyword">if</span> ((vcpu-&gt;arch.idt_vectoring_info &amp; VMX_INT_INFO_VALID) != <span class="number">0U</span>) &#123;</span><br><span class="line"><span class="keyword">uint32_t</span> vector_info = vcpu-&gt;arch.idt_vectoring_info;</span><br><span class="line"><span class="keyword">uint32_t</span> <span class="built_in">vector</span> = vector_info &amp; <span class="number">0xff</span>U;</span><br><span class="line"><span class="keyword">uint32_t</span> type = (vector_info &amp; VMX_INT_TYPE_MASK) &gt;&gt; <span class="number">8U</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> err_code = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == VMX_INT_TYPE_HW_EXP) &#123;</span><br><span class="line"><span class="keyword">if</span> ((vector_info &amp; VMX_INT_INFO_ERR_CODE_VALID) != <span class="number">0U</span>) &#123;</span><br><span class="line">err_code = exec_vmread32(VMX_IDT_VEC_ERROR_CODE);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">void</span>)vcpu_queue_exception(vcpu, <span class="built_in">vector</span>, err_code);</span><br><span class="line">vcpu-&gt;arch.idt_vectoring_info = <span class="number">0U</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == VMX_INT_TYPE_NMI) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_notification_nmi(vcpu-&gt;vm)) &#123;</span><br><span class="line">pr_dbg(<span class="string">"This NMI is used as notification signal. So ignore it."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">vcpu_make_request(vcpu, ACRN_REQUEST_NMI);</span><br><span class="line">vcpu-&gt;arch.idt_vectoring_info = <span class="number">0U</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* No action on EXT_INT or SW exception. */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>hardware exceptionçš„å®šä¹‰:<br><img src="/images/2020/12/1.PNG" alt></p><h3 id="2-æµ‹è¯•ç”¨ä¾‹"><a href="#2-æµ‹è¯•ç”¨ä¾‹" class="headerlink" title="2. æµ‹è¯•ç”¨ä¾‹"></a>2. æµ‹è¯•ç”¨ä¾‹</h3><p>å¯¹äº<code>A fault occurs during event delivery and causes a VM exit</code> caseï¼Œå¯ä»¥åˆ©ç”¨å¦‚ä¸‹æµ‹è¯•ç”¨ä¾‹å¤ç°ï¼š</p><ol><li>è®¾ç½®guest IDTä¸­Divide Error vectoré¡¹çš„presentä½ä¸º0(to trigger NP fault)ï¼›</li><li>è®¾ç½®VMCS  exception bitmap fieldä¸­çš„NP faultä½ä¸º1(to trigger VM exit)ï¼›</li><li>guestæ‰§è¡Œdivide 0æŒ‡ä»¤ã€‚</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡ä¸»è¦è®°å½•SDMä¸­&lt;code&gt;Information for VM Exits During Event Delivery&lt;/code&gt;ä¸€èŠ‚çš„ç›¸å…³ç¬”è®°ã€‚
    
    </summary>
    
      <category term="VT-x" scheme="http://liujunming.github.io/categories/VT-x/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-x" scheme="http://liujunming.github.io/tags/VT-x/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to SR-IOV</title>
    <link href="http://liujunming.github.io/2020/10/24/Introduction-to-SR-IOV/"/>
    <id>http://liujunming.github.io/2020/10/24/Introduction-to-SR-IOV/</id>
    <published>2020-10-24T01:37:02.000Z</published>
    <updated>2020-10-25T08:45:21.038Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡åªä»‹ç»SR-IOVçš„åŸºæœ¬å†…å®¹ï¼Œå¹¶ä¸èƒ½cover SR-IOVçš„å…¨éƒ¨çŸ¥è¯†ç‚¹ã€‚<a id="more"></a></p><h3 id="1-prerequisites"><a href="#1-prerequisites" class="headerlink" title="1. prerequisites"></a>1. prerequisites</h3><ol><li>éœ€è¦ç†è§£VT-dçš„DMA remapping,interrupt remapping ,posted interrupt<ul><li><a href="/2020/10/10/VT-d-Interrupt-Remapping/">VT-d Interrupt Remapping</a></li><li><a href="/2020/10/11/VT-d-Posted-Interrupt/">VT-d Posted Interrupt</a></li></ul></li><li>éœ€è¦ç†è§£PCI&amp;PCIeçš„config spaceï¼ŒMSIä¸MSI-X.<ul><li><a href="https://tcbbd.moe/ref-and-spec/pci/" target="_blank" rel="noopener">PCI Local Bus (i.e. Conventional PCI)</a></li></ul></li><li>éœ€è¦ç†è§£ATS,ACS,ARI<ul><li><a href="/2019/11/24/Introduction-to-PCIe-Address-Translation-Services/">Introduction to PCIe Address Translation Services</a></li><li><a href="/2019/11/24/Introduction-to-PCIe-Access-Control-Services/">Introduction to PCIe Access Control Services</a></li><li>PCIe Alternative Routing-ID Interpretation (ARI)<ul><li>Enable up-to 256 functions for single PCI Express component</li></ul></li></ul></li><li>PCIe config spaceä½äºMMIOç©ºé—´å†…</li></ol><h3 id="2-motivation"><a href="#2-motivation" class="headerlink" title="2. motivation"></a>2. motivation</h3><p>æ¨èè®ºæ–‡ï¼šHigh Performance Network Virtualization with SRIOV</p><p>å¯é˜…è¯»<a href="https://github.com/liujunming/paper_reading_notes/issues/1" target="_blank" rel="noopener">Junmingâ€™s notes</a>ã€‚</p><p><img src="https://user-images.githubusercontent.com/11829057/97032861-0ac62400-1595-11eb-8a98-412ffb6a57b4.png" alt></p><p><img src="https://user-images.githubusercontent.com/11829057/97033169-81fbb800-1595-11eb-8db4-94d969346946.png" alt></p><p><img src="https://user-images.githubusercontent.com/11829057/97033444-f33b6b00-1595-11eb-940d-2d687db55fc7.png" alt></p><p><img src="https://user-images.githubusercontent.com/11829057/97034420-7dd09a00-1597-11eb-9027-03c31b5234ff.png" alt></p><p><img src="https://user-images.githubusercontent.com/11829057/97034474-904ad380-1597-11eb-9e00-e52f8fa7d5d1.png" alt></p><h3 id="3-details"><a href="#3-details" class="headerlink" title="3. details"></a>3. details</h3><p><strong>BIOS should be able to enumerate SR-IOV capable device and allocate MMIO (Memory mapped IO) resource for VFs.</strong></p><p><a href="https://projectacrn.github.io/latest/tutorials/sriov_virtualization.html#sr-iov-extended-capability" target="_blank" rel="noopener">SR-IOV Extended Capability</a> The SR-IOV Extended Capability defined here is a PCIe extended capability that must be implemented in each PF device that supports the SR-IOV feature. This capability is used to describe and control a PFâ€™s SR-IOV capabilities.</p><h4 id="3-1-the-differences-between-a-normal-passthrough-device-and-SR-IOV-VF-device"><a href="#3-1-the-differences-between-a-normal-passthrough-device-and-SR-IOV-VF-device" class="headerlink" title="3.1 the differences between a normal passthrough device and SR-IOV VF device"></a>3.1 the differences between a normal passthrough device and SR-IOV VF device</h4><ol><li>physical device detection</li></ol><p>The hypervisor uses <code>Subsystem Vendor ID</code> to detect the SR-IOV VF physical device instead of <code>Vendor ID</code> since no valid <code>Vendor ID</code> exists for the SR-IOV VF physical device. </p><ol start="2"><li>BARs initialization</li></ol><p>The VF BARs are initialized by its associated PFâ€™s SR-IOV capabilities, not PCI standard BAR registers. </p><ol start="3"><li>MSI-X initialization</li></ol><p>The MSI-X mapping base address is also from the PFâ€™s SR-IOV capabilities, not PCI standard BAR registers.</p><h4 id="3-2-VFçš„bdf-numberå¦‚ä½•åˆ†é…"><a href="#3-2-VFçš„bdf-numberå¦‚ä½•åˆ†é…" class="headerlink" title="3.2 VFçš„bdf numberå¦‚ä½•åˆ†é…"></a>3.2 VFçš„bdf numberå¦‚ä½•åˆ†é…</h4><p>Routing IDå°±æ˜¯BDF number,<strong>å³é‡‡ç”¨Bus Numberã€Device Numberå’ŒFunction Numberæ¥ç¡®å®šç›®æ ‡è®¾å¤‡çš„ä½ç½®çš„idã€‚</strong></p><p>SR-IOV Extended Capabilityä¸­ç”¨FirstVF Offsetå’ŒVF Strideæ¥æ ‡è®°VFçš„Routing IDã€‚VFçš„Routing IDæ˜¯ä»¥PFçš„Routing IDå€¼ä¸ºå‚è€ƒæ¥è®¡ç®—çš„ã€‚</p><p><strong>FirstVF Offset</strong>ï¼šç¬¬ä¸€ä¸ªVFç›¸å¯¹PFçš„Routing IDçš„åç§»é‡</p><p><strong>VF Stride</strong>ï¼š ç›¸é‚»VFä¹‹é—´çš„Routing IDçš„åç§»é‡</p><p>PFçš„Routing IDåœ¨PFæšä¸¾ä¹‹åå°±å·²ç»åˆ†é…å¥½äº†ã€‚PFçš„é©±åŠ¨ç¨‹åºé€šè¿‡é…ç½®SR-IOV Extended Capabilityï¼Œæ‰“å¼€è¿™ä¸ªPFå…³è”çš„VFä¹‹åï¼Œé€šè¿‡<strong>FirstVF Offsetå’ŒVF Stride</strong>å°±èƒ½è®¡ç®—å‡ºVFä»¬çš„Routing IDã€‚</p><h4 id="3-3-VFçš„BARç©ºé—´å¦‚ä½•åˆ†é…"><a href="#3-3-VFçš„BARç©ºé—´å¦‚ä½•åˆ†é…" class="headerlink" title="3.3 VFçš„BARç©ºé—´å¦‚ä½•åˆ†é…"></a>3.3 VFçš„BARç©ºé—´å¦‚ä½•åˆ†é…</h4><p>VFçš„BAR[n]ç©ºé—´æ˜¯é€šè¿‡PFçš„SR-IOV Capabilityä¸­æ¯ä¸ªVF_BAR[n]æ¥åˆ†é…çš„ï¼Œå’ŒVF Configuration Spaceçš„BARæ— å…³ã€‚</p><p><img src="/images/2020/10/25.PNG" alt></p><h4 id="3-4-ACRN-Enable-SR-IOV-Virtualization"><a href="#3-4-ACRN-Enable-SR-IOV-Virtualization" class="headerlink" title="3.4 ACRN Enable SR-IOV Virtualization"></a>3.4 ACRN Enable SR-IOV Virtualization</h4><p>å»ºè®®é˜…è¯»<a href="https://projectacrn.github.io/latest/tutorials/sriov_virtualization.html" target="_blank" rel="noopener">ACRN Enable SR-IOV Virtualization</a>ã€‚ğŸ˜Š</p><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li>Chapter 9 of PCI-SIGâ€™s <a href="https://pcisig.com/pci-express-architecture-configuration-space-test-specification-revision-40-version-10" target="_blank" rel="noopener">PCI Express Base Specification Revision 4.0, Version 1.0</a></li><li><a href="https://www.snia.org/sites/default/orig/sdc_archives/2010_presentations/thursday/RichardSolomon_PCI_Express.pdf" target="_blank" rel="noopener">RichardSolomon_PCI_Express.pdf</a></li><li><a href="https://projectacrn.github.io/latest/tutorials/sriov_virtualization.html" target="_blank" rel="noopener">ACRN Enable SR-IOV Virtualization</a></li><li><a href="https://blog.csdn.net/u010443710/article/details/104756445" target="_blank" rel="noopener">SR-IOVåŠlinuxé©±åŠ¨æµ…æ</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡åªä»‹ç»SR-IOVçš„åŸºæœ¬å†…å®¹ï¼Œå¹¶ä¸èƒ½cover SR-IOVçš„å…¨éƒ¨çŸ¥è¯†ç‚¹ã€‚
    
    </summary>
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about pause loop exiting</title>
    <link href="http://liujunming.github.io/2020/10/23/Some-notes-about-pause-loop-exiting/"/>
    <id>http://liujunming.github.io/2020/10/23/Some-notes-about-pause-loop-exiting/</id>
    <published>2020-10-23T00:59:55.000Z</published>
    <updated>2020-12-01T11:31:02.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-background"><a href="#1-background" class="headerlink" title="1. background"></a>1. background</h3><p>Spin-locking code typically uses <code>PAUSE</code> instructions in a loop.<a id="more"></a></p><p>For more details, please refer to <a href="/2020/05/01/Introduction-to-halt-pause-monitor-mwait-instruction/#pause">pause</a>.</p><h3 id="2-motivation"><a href="#2-motivation" class="headerlink" title="2. motivation"></a>2. motivation</h3><p>ä¸ºä»€ä¹ˆéœ€è¦pause loop exiting(ple)è¿™ä¸€featureå‘¢?<br><img src="/images/2020/10/21.PNG" alt></p><p><img src="/images/2020/10/22.PNG" alt></p><p><img src="/images/2020/10/23.PNG" alt></p><p><img src="/images/2020/10/24.PNG" alt></p><h3 id="3-details"><a href="#3-details" class="headerlink" title="3. details"></a>3. details</h3><p>Basic Exit Reason 40<br><img src="/images/2020/10/18.PNG" alt></p><p>PLE_Gap - upper bound on the amount of time between two successive executions of PAUSE in a loop.<br>PLE_Window - upper bound on the amount of time a guest is allowed to execute in a PAUSE loop</p><p>If the time, between this execution of PAUSE and previous one, exceeds the PLE_Gap, processor consider this PAUSE belongs to a new loop. Otherwise, processor determins the the total execution time of this loop(since 1st PAUSE in this loop), and triggers a VM exit if total time exceeds the PLE_Window.</p><p>Pause-Loop Exiting can be used to detect Lock-Holder Preemption, where one VCPU is sched-out after hold a spinlock, then other VCPUs for same lock are sched-in to waste the CPU time.</p><p>ä¸ªäººæ„Ÿè§‰PLE_Gapä¸PLE_Windowçš„è®¾ç½®ï¼Œå°±æ˜¯è°ƒå‚å§ã€‚</p><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li><a href="https://surriel.com/system/files/riel_t_1620_kvm_performance.pdf" target="_blank" rel="noopener">riel_t_1620_kvm_performance.pdf</a></li><li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/linux-containers-hypervisor-based-vms-paper.pdf" target="_blank" rel="noopener">linux-containers-hypervisor-based-vms-paper.pdf</a></li><li><a href="https://kernel-team.narkive.com/x1rgNbzk/patch-0-2-kvm-add-support-for-pause-loop-exit" target="_blank" rel="noopener">KVM: add support for Pause-Loop exit</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-background&quot;&gt;&lt;a href=&quot;#1-background&quot; class=&quot;headerlink&quot; title=&quot;1. background&quot;&gt;&lt;/a&gt;1. background&lt;/h3&gt;&lt;p&gt;Spin-locking code typically uses &lt;code&gt;PAUSE&lt;/code&gt; instructions in a loop.
    
    </summary>
    
      <category term="VT-x" scheme="http://liujunming.github.io/categories/VT-x/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
      <category term="VT-x" scheme="http://liujunming.github.io/tags/VT-x/"/>
    
  </entry>
  
  <entry>
    <title>VT-d Posted Interrupt</title>
    <link href="http://liujunming.github.io/2020/10/11/VT-d-Posted-Interrupt/"/>
    <id>http://liujunming.github.io/2020/10/11/VT-d-Posted-Interrupt/</id>
    <published>2020-10-11T11:23:20.000Z</published>
    <updated>2020-10-23T15:18:20.489Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡å°†ä»‹ç»VT-d Posted Interruptçš„ç›¸å…³å†…å®¹ã€‚é¦–å…ˆä¼šä»¥ä¸€ä¸ªä¾‹å­ä»‹ç»Posted interruptçš„motivationï¼›ç„¶åè¯¦ç»†é˜è¿°æ¶‰åŠåˆ°çš„ç¡¬ä»¶å’Œè½¯ä»¶ç»†èŠ‚ï¼›æ¥ä¸‹æ¥ä¼šä»‹ç»ä¸åŒvCPUçŠ¶æ€ä¸‹çš„å·®å¼‚åŒ–å¤„ç†ï¼›æœ€åæ€»ç»“ä¸‹æœ¬æ–‡ã€‚<a id="more"></a></p><p>é˜…è¯»æœ¬æ–‡å‰ï¼Œéœ€å…ˆé˜…è¯»ä»¥ä¸‹æ–‡ç« ï¼š</p><ol><li><a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/" target="_blank" rel="noopener">Intel SDM Chapter 29: APIC Virtualizaton &amp; Virtual Interrupts</a></li><li><a href="/2020/10/07/Introduction-to-Posted-interrupt/">Introduction to CPU-based Posted-interrupt</a></li><li><a href="/2020/10/10/VT-d-Interrupt-Remapping/">VT-d Interrupt Remapping</a></li></ol><h3 id="1-terms"><a href="#1-terms" class="headerlink" title="1. terms"></a>1. terms</h3><ul><li>PI(Posted Interrupt)</li><li>hv(hypervisor)</li><li>VM(Virtual Machine)</li><li>IRTE(Interrupt Remapping Table Entry)</li><li>PID(Posted Interrupt Descriptor)</li><li>PIR( Posted Interrupt Requests)</li><li>ON(Outstanding Notification)</li><li>NV(Notification Vector)</li><li>ANV(Active Notification Vector)</li><li>WNV(Wake-up Notification Vector)</li><li>ple(pause loop exiting)</li></ul><h3 id="2-motivation"><a href="#2-motivation" class="headerlink" title="2.  motivation"></a>2.  motivation</h3><p>åœ¨<a href="/2020/10/10/VT-d-Interrupt-Remapping/#demo-usage">VT-d Interrupt Remapping demo usage</a>ä¸­ï¼Œå¦‚æœç›®æ ‡vCPUæ­£åœ¨è¿è¡Œï¼Œä½†æ˜¯ï¼Œå½“ç‰©ç†CPUæ¥å—åˆ°physical interruptæ—¶ï¼Œéœ€å‘ç”ŸVM-Exitï¼Œç”±hvä¸ºguestæ³¨å…¥vectorä¸º30çš„virtualä¸­æ–­ã€‚</p><p>æ€è€ƒä¸‹ï¼šæ˜¯å¦å¯ä»¥çœå»å¦‚ä¸‹æ­¥éª¤ï¼š<em>å½“ç‰©ç†CPUæ¥å—åˆ°physical interruptæ—¶ï¼Œéœ€å‘ç”ŸVM-Exitï¼Œç”±hvä¸ºguestæ³¨å…¥vectorä¸º30çš„virtualä¸­æ–­</em>ã€‚ç”±ç¡¬ä»¶ä¸ºæ­£åœ¨è¿è¡Œçš„vCPUç›´æ¥æ³¨å…¥vectorä¸º30çš„virtual ä¸­æ–­(è¿™æ ·é¿å…äº†ä¸€æ¬¡VM-Exit)ï¼Œè€Œè¿™æ­£æ˜¯VT-d PIæ‰€èƒ½å®Œæˆçš„åŠŸèƒ½ã€‚</p><h3 id="3-details"><a href="#3-details" class="headerlink" title="3. details"></a>3. details</h3><h4 id="3-1-CAP-REGçš„PIä½"><a href="#3-1-CAP-REGçš„PIä½" class="headerlink" title="3.1 CAP_REGçš„PIä½"></a>3.1 CAP_REGçš„PIä½</h4><p>IOMMUé€šè¿‡Capability Register(CAP_REG)çš„PIä½æ¥æŠ¥å‘Šinterrupt posting capabilityã€‚<br><img src="/images/2020/10/7.PNG" alt></p><h4 id="3-2-IRTE"><a href="#3-2-IRTE" class="headerlink" title="3.2 IRTE"></a>3.2 IRTE</h4><p>VT-d PIæ˜¯VT-d Interrupt Remappingçš„ä¸€ä¸ªæ‰©å±•åŠŸèƒ½ã€‚æ ¹æ®<a href="/2020/10/10/VT-d-Interrupt-Remapping/">Interrupt Remapping</a>å¯çŸ¥ï¼Œ æ‰€æœ‰çš„Remappingæ ¼å¼ä¸­æ–­è¯·æ±‚éƒ½éœ€è¦é€šè¿‡ä¸­æ–­é‡æ˜ å°„è¡¨æ¥æŠ•é€’ï¼Œ IRTEä¸­çš„ModeåŸŸ(IM)ç”¨æ¥æŒ‡å®šè¿™ä¸ªremappableä¸­æ–­è¯·æ±‚æ˜¯interrupt-remappingæ–¹å¼è¿˜æ˜¯interrupt-postingæ–¹å¼ã€‚</p><p>å¦‚æœIRTEçš„IMä½ä¸º1ï¼Œåˆ™VT-dç¡¬ä»¶å°†ä¼šä»¥PIçš„å½¢å¼æ¥è§£æè¯¥IRTEï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š<br><img src="/images/2020/10/9.PNG" alt></p><p>éœ€è¦å…³æ³¨PIæ ¼å¼çš„IRTEçš„ä»¥ä¸‹å‡ ä¸ªfieldï¼š</p><ol><li>Posted Descriptor Address Low/Highï¼Œè¯¥åŒºåŸŸä¿å­˜ä¸€ä¸ªæŒ‡å‘å†…å­˜çš„æŒ‡é’ˆï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘çš„ä½ç½®å°±æ˜¯PIDã€‚</li><li>Urgentä½ï¼Œè¯¥ä½ç”¨äºè¡¨ç¤ºè¯¥ä¸­æ–­æ˜¯å¦æ˜¯ç´§æ€¥çš„ï¼Œå³æ˜¯å¦éœ€è¦ç›®æ ‡CPUç«‹å³å“åº”ã€‚</li><li>Vectorç”¨äºæŒ‡å®šPID.PIRä¸­å“ªä¸ªbitè¦ç½®ä½ã€‚</li></ol><h4 id="3-3-PID"><a href="#3-3-PID" class="headerlink" title="3.3 PID"></a>3.3 PID</h4><p>æ¯ä¸ªPIDçš„å¤§å°ä¸º64 Byteï¼Œç›´æ¥è¢«ç¡¬ä»¶ç”¨æ¥è®°å½•å°†è¦postçš„ä¸­æ–­è¯·æ±‚ã€‚å…¶æ ¼å¼å¦‚ä¸‹æ‰€ç¤ºï¼š<br><img src="/images/2020/10/8.PNG" alt></p><ol><li>Posted Interrupt Request (PIR)åŸŸï¼Œä¸€å…±256 bitï¼Œæ¯ä¸ªbitå¯¹åº”ä¸€ä¸ªä¸­æ–­å‘é‡ï¼Œå½“VT-dç¡¬ä»¶å°†ä¸­æ–­è¯·æ±‚postè¿‡æ¥çš„æ—¶å€™ï¼ŒIRTE.Vectorå¯¹åº”çš„bitå°†ä¼šè¢«ç½®èµ·ã€‚</li><li><p>Outstanding Notification (ON)åŸŸï¼Œè¡¨ç¤ºè¯¥PIDå½“å‰æ˜¯å¦å·²ç»å‘å‡ºäº†ä¸€ä¸ªNotification Eventç­‰å¾…CPUçš„å¤„ç†ã€‚</p><ul><li><p>å½“VT-dç¡¬ä»¶å°†ä¸­æ–­è¯·æ±‚è®°å½•åˆ°PIRçš„æ—¶å€™ï¼Œå¦‚æœONä¸º0ï¼Œå¹¶ä¸”å…è®¸ç«‹å³å‘å‡ºä¸€ä¸ªNotification Eventæ—¶ï¼Œåˆ™å°†ä¼šå°†ONç½®èµ·æ¥ï¼Œå¹¶ä¸”äº§ç”Ÿä¸€ä¸ªNotification Eventï¼›å¦‚æœONå·²ç»è¢«ç½®èµ·æ¥ï¼Œåˆ™ä¸ä¼šäº§ç”Ÿä¸€ä¸ªNotification Eventã€‚</p></li><li><p>ONçš„æ¸…é›¶ã€‚</p><p><img src="/images/2020/10/16.PNG" alt></p></li></ul></li><li>Suppress Notification (SN)åŸŸï¼Œè¡¨ç¤ºå½“PIRå¯„å­˜å™¨è®°å½•åˆ°non-urgentçš„ä¸­æ–­æ—¶ï¼Œæ˜¯å¦ä¸å‘å‡ºNotification Eventï¼Œå¦‚æœè¯¥ä½ä¸º1ï¼Œåˆ™å½“PIRè®°å½•åˆ°non-urgentä¸­æ–­çš„æ—¶å€™ï¼Œä¸å‘å‡ºNotification Eventï¼Œå¹¶ä¸”ä¸æ›´æ”¹Outstanding Notificationä½çš„å€¼ã€‚</li><li>Notification Vector (NV)åŸŸï¼Œè¡¨ç¤ºå¦‚æœå‘å‡ºNotification Eventæ—¶ï¼Œå…·ä½“çš„Vectorå€¼ã€‚</li><li>Notification Destination (NDST)åŸŸï¼Œè¡¨ç¤ºå¦‚æœå‘å‡ºNotification Eventæ—¶ï¼Œè¦ä¼ é€’çš„ç‰©ç†CPUçš„LAPIC IDã€‚</li></ol><h4 id="3-4-ç¡¬ä»¶ä¸ŠPosted-Interruptçš„å¤„ç†è¿‡ç¨‹"><a href="#3-4-ç¡¬ä»¶ä¸ŠPosted-Interruptçš„å¤„ç†è¿‡ç¨‹" class="headerlink" title="3.4 ç¡¬ä»¶ä¸ŠPosted Interruptçš„å¤„ç†è¿‡ç¨‹"></a>3.4 ç¡¬ä»¶ä¸ŠPosted Interruptçš„å¤„ç†è¿‡ç¨‹</h4><p><img src="/images/2020/10/15.PNG" alt></p><p>PSTå³IRTEä¸­çš„Interrupt Modeä½ã€‚</p><p><img src="/images/2020/10/10.jpg" alt></p><p>å½“VT-dç¡¬ä»¶æ¥æ”¶åˆ°å…¶æ——ä¸‹I/Oè®¾å¤‡ä¼ é€’è¿‡æ¥çš„ä¸­æ–­è¯·æ±‚æ—¶ï¼Œä¼šå…ˆæŸ¥çœ‹è‡ªå·±çš„ä¸­æ–­é‡å®šå‘åŠŸèƒ½æ˜¯å¦æ‰“å¼€ï¼Œå¦‚æœæ²¡æœ‰æ‰“å¼€åˆ™ï¼Œç›´æ¥ä¸Šä¼ ç»™LAPICã€‚å¦‚æœä¸­æ–­é‡å®šå‘åŠŸèƒ½æ‰“å¼€ï¼Œåˆ™ä¼šæŸ¥çœ‹ä¸­æ–­è¯·æ±‚çš„æ ¼å¼ï¼Œå¦‚æœæ˜¯ä¸å¯é‡å®šå‘æ ¼å¼ï¼Œåˆ™ç›´æ¥å°†ä¸­æ–­è¯·æ±‚æäº¤ç»™LAPICã€‚å¦‚æœæ˜¯å¯é‡å®šå‘çš„æ ¼å¼ï¼Œåˆ™ä¼šæ ¹æ®ç®—æ³•è®¡ç®—Interrupt_Indexå€¼ï¼Œå¯¹ä¸­æ–­é‡å®šå‘è¡¨è¿›è¡Œç´¢å¼•æ‰¾åˆ°ç›¸åº”çš„IRTEã€‚ç„¶åï¼ŒæŸ¥çœ‹IRTEä¸­çš„Interrupt Modeï¼Œå¦‚æœä¸º0ï¼Œåˆ™è¯¥IRTEçš„æ ¼å¼ä¸ºRemapped Formatï¼Œå³ç«‹å³æ ¹æ®IRTEçš„ä¿¡æ¯äº§ç”Ÿä¸€ä¸ªæ–°çš„ä¸­æ–­è¯·æ±‚ï¼Œæäº¤åˆ°LAPICã€‚å¦‚æœInterrupt Modeä¸º1ï¼Œåˆ™è¡¨ç¤ºè¯¥IRTEçš„æ ¼å¼ä¸ºPosted Formatï¼Œæ ¹æ®IRTEä¸­æä¾›çš„PIDçš„åœ°å€ï¼Œåœ¨å†…å­˜ä¸­æ‰¾åˆ°ç›¸åº”PIDï¼Œå¹¶æ ¹æ®å…¶ONã€URGå’ŒSNçš„è®¾ç½®åˆ¤æ–­æ˜¯å¦éœ€è¦ç«‹å³äº§ç”Ÿä¸€ä¸ªNotification Eventï¼Œå¦‚æœä¸éœ€è¦ï¼Œåˆ™åªæ˜¯å°†è¯¥ä¸­æ–­ä¿¡æ¯è®°å½•åˆ°PID.PIRä¸­ï¼Œç­‰å¾…hvçš„åç»­å¤„ç†(ä¼šåœ¨<a href="/2020/10/11/VT-d-Posted-Interrupt/#4-5-vCPU-is-ready-to-run-or-halted-when-Notification-Event-happen">vCPU is ready-to-run or halted when Notification Event happen</a>ä¸­ä»‹ç»)ã€‚å¦‚æœéœ€è¦ç«‹å³äº§ç”Ÿä¸€ä¸ªNotification Eventï¼Œåˆ™æ ¹æ®PIDï¼ˆä¼šæä¾›ç›®æ ‡APIC IDã€vectorã€ä¼ è¾“æ¨¡å¼å’Œè§¦å‘æ¨¡å¼ç­‰ä¿¡æ¯ï¼‰äº§ç”Ÿä¸€ä¸ªNotification Eventï¼ŒåŒæ—¶å°†ONç½®ä½ã€‚</p><p>ç¡¬ä»¶åœ¨å¯¹PIDè¿›è¡Œä¿®æ”¹çš„æ—¶å€™ï¼Œè¦ä¿è¯è¯¥ä¿®æ”¹æ˜¯åŸå­æ“ä½œï¼Œå³å¯¹PIDçš„è¯»å–ã€ä¿®æ”¹å’Œå†™å…¥å¿…é¡»æ˜¯åŸå­æ“ä½œï¼Œå¹¶ä¸”åœ¨å†™å…¥ä¹‹åï¼Œè¦ä¿è¯ç›¸åº”å†…å­˜åœ¨å„ä¸ªcache agentä¹‹é—´çš„ä¸€è‡´æ€§ï¼Œå³æ‰€æœ‰çš„CPUåº”è¯¥ç«‹é©¬èƒ½å¤Ÿçœ‹åˆ°è¯¥å†…å­˜ä¿®æ”¹ã€‚</p><h4 id="3-5-the-relationship-with-CPU-based-Posted-interrupt"><a href="#3-5-the-relationship-with-CPU-based-Posted-interrupt" class="headerlink" title="3.5 the relationship with CPU-based Posted-interrupt"></a>3.5 the relationship with CPU-based Posted-interrupt</h4><p>CPU-based Posted-interruptéœ€è¦ä¸IOMMUååŒå·¥ä½œæ‰èƒ½å®ç°VT-d Posted Interrupt featureã€‚</p><p>æœ‰ä¸‰ç‚¹éœ€è¦æ³¨æ„ï¼š</p><ol><li>enable APICv</li><li>è®¾ç½®VMCSçš„posted-interrupt descriptorï¼Œè¿™æ­£æ˜¯IRTEä¸­Posted Descriptor Address Low/Highæ‰€è®¾ç½®çš„å€¼ã€‚</li><li>è®¾ç½®VMCSçš„posted-interrupt notification vectorä¸ºANV(ä¸‹èŠ‚ä¼šè¯¦ç»†ä»‹ç»)ã€‚</li></ol><p><img src="/images/2020/10/13.PNG" alt><br><img src="/images/2020/10/14.PNG" alt></p><h3 id="4-ä¸åŒvCPUçŠ¶æ€ä¸‹çš„å·®å¼‚åŒ–å¤„ç†"><a href="#4-ä¸åŒvCPUçŠ¶æ€ä¸‹çš„å·®å¼‚åŒ–å¤„ç†" class="headerlink" title="4. ä¸åŒvCPUçŠ¶æ€ä¸‹çš„å·®å¼‚åŒ–å¤„ç†"></a>4. ä¸åŒvCPUçŠ¶æ€ä¸‹çš„å·®å¼‚åŒ–å¤„ç†</h3><h4 id="4-1-Background"><a href="#4-1-Background" class="headerlink" title="4.1 Background"></a>4.1 Background</h4><p>åœ¨vCPUè°ƒåº¦çš„è¿‡ç¨‹ä¸­ï¼ŒvCPUä¼šæœ‰å¦‚ä¸‹ä¸‰ç§çŠ¶æ€:</p><ol><li>å½“vCPUè¢«scheduleré€‰ä¸­æ¥è¿è¡Œçš„æ—¶å€™ï¼Œæ­¤æ—¶vCPUçš„çŠ¶æ€ä¸ºâ€™activeâ€™ã€‚</li><li>å½“vCPUè¢«æŠ¢å ï¼ˆPreemptedï¼‰ï¼Œä¾‹å¦‚æ—¶é—´ç‰‡åˆ°æœŸäº†ï¼Œæ­¤æ—¶vCPUçš„çŠ¶æ€ä¸ºâ€™ready-to-runâ€™ã€‚</li><li>å½“vCPUæ‰§è¡Œäº†<code>hlt</code>æŒ‡ä»¤æˆ–è€…è§¦å‘äº†<a href="/2020/10/23/Some-notes-about-pause-loop-exiting/">ple</a>ï¼Œhvä¹Ÿä¼šå¹²é¢„è¿›æ¥å°†vCPUç»™blockå‡ºæ¥ï¼Œæ­¤æ—¶vCPUçŠ¶æ€ä¸ºâ€™halted â€˜ã€‚</li></ol><h4 id="4-2-ANV-and-WNV"><a href="#4-2-ANV-and-WNV" class="headerlink" title="4.2 ANV and WNV"></a>4.2 ANV and WNV</h4><p>hvéœ€è¦ä¸ºæ¯ä¸ªvCPUåˆ†é…ç‰©ç†ä¸­æ–­vector:<br>ç¬¬ä¸€ä¸ªç§°ä½œActive Notification Vectorï¼ˆANVï¼‰ï¼Œè¯¥Vectorå¯¹åº”åˆ°vCPUçš„çŠ¶æ€ä¸ºactiveæ—¶ï¼ŒNotification Eventæ‰€ä½¿ç”¨çš„ä¸­æ–­vector(éœ€è¦è®¾ç½®VMCSçš„posted-interrupt notification vectorä¸ºANV)ã€‚</p><p>ç¬¬äºŒä¸ªç§°ä½œWake-up Notification Vectorï¼ˆWNVï¼‰ï¼Œè¯¥Vectorå¯¹åº”åˆ°ç›®æ ‡vCPUä¸åœ¨å½“å‰ç‰©ç†CPUä¸Šæ‰§è¡Œæ—¶ï¼Œç”±äºUrgentè¢«ç½®èµ·æ¥äº§ç”Ÿçš„Notification Eventæ‰€ä½¿ç”¨çš„ä¸­æ–­Vectorã€‚</p><blockquote><p>åœ¨activeçŠ¶æ€ä¸‹ï¼ŒPID.NVçš„å€¼å°±æ˜¯ANVã€‚åœ¨ready-to-runæˆ–è€…haltedçŠ¶æ€ä¸‹ï¼ŒPID.NVçš„å€¼å°±æ˜¯WNVã€‚è¿™é‡Œçš„ANVå’ŒWNVå¯ä»¥æ˜¯åŒä¸€ä¸ªå€¼ã€‚</p></blockquote><p>hvéœ€è¦ä¿è¯çš„æ˜¯ï¼šè¿è¡Œåœ¨åŒä¸€ä¸ªpCPUä¸Šçš„æ‰€æœ‰vCPUçš„PID.NVå€¼ä¸åŒã€‚</p><p>è¯¦æƒ…å¯å‚è€ƒ:<a href="https://projectacrn.github.io/latest/developer-guides/hld/hv-dev-passthrough.html#vt-d-interrupt-remapping" target="_blank" rel="noopener">ACRN posted interrupt</a></p><h4 id="4-3-vCPU-Scheduling"><a href="#4-3-vCPU-Scheduling" class="headerlink" title="4.3 vCPU Scheduling"></a>4.3 vCPU Scheduling</h4><p><img src="/images/2020/10/12.PNG" alt></p><p>åªéœ€ç†è§£çŠ¶æ€è½¬æ¢ï¼Œå¯¹äºâ€˜NVâ€™çš„è®¾ç½®æ˜¯hv specificçš„ï¼Œæ— éœ€æ·±ç©¶ã€‚</p><h4 id="4-4-vCPU-is-active-when-Notification-Event-happen"><a href="#4-4-vCPU-is-active-when-Notification-Event-happen" class="headerlink" title="4.4 vCPU is active when Notification Event happen"></a>4.4 vCPU is active when Notification Event happen</h4><p>gueståœ¨Non-Rootä¸‹å°±èƒ½ç›´æ¥å¤„ç†æ­¤ä¸­æ–­ï¼Œè€Œä¸éœ€è¦hvçš„å‚ä¸ã€‚</p><p>è¯¦ç»†æ­¥éª¤è¯·å‚è€ƒï¼š<a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/#posted-interrupt" target="_blank" rel="noopener">Posted Interrupt</a></p><h4 id="4-5-vCPU-is-ready-to-run-or-halted-when-Notification-Event-happen"><a href="#4-5-vCPU-is-ready-to-run-or-halted-when-Notification-Event-happen" class="headerlink" title="4.5 vCPU is ready-to-run or halted when Notification Event happen"></a>4.5 vCPU is ready-to-run or halted when Notification Event happen</h4><p>WNVçš„handler:</p><p>å¦‚æœvCPUçš„stateä¸ºhaltedï¼Œåˆ™éœ€è¦å…ˆå°†vCPUçš„çŠ¶æ€è®¾ç½®ä¸ºready-to-runã€‚</p><p>handlerä¼šè°ƒåº¦vCPUã€‚</p><p>æ‰«æPID.PIR,æ£€æµ‹æ˜¯å¦æœ‰å¤„äºpendingçŠ¶æ€çš„posted interruptè¯·æ±‚ï¼›å¦‚æœæœ‰å¤„äºpendingçŠ¶æ€çš„posted interruptè¯·æ±‚ï¼Œhvä¼šåœ¨LAPICä¸Šç”Ÿæˆä¸€ä¸ªvectorå·ä¸ºANVçš„self-IPI(æ³¨æ„ï¼šåœ¨è¿˜æœªçœŸæ­£enter guestä¹‹å‰,å½“å‰ç‰©ç†CPUå¤„äºå…³ä¸­æ–­çŠ¶æ€)ã€‚ å½“è¿›å…¥Non-Rootæ¨¡å¼æ—¶ï¼Œç‰©ç†IRRå¯„å­˜å™¨ä¸­çš„ANVä½ä¼šè¢«ç½®ä¸Šï¼Œç¡¬ä»¶(CPU)ä¼šå¤„ç†posted interruptã€‚è¯¥ä¸­æ–­çš„å¤„ç†ç±»ä¼¼äºvCPUå¤„äºactiveçŠ¶æ€æ—¶ï¼Œæ¥æ”¶åˆ°äº†ANVçš„ä¸­æ–­è¯·æ±‚ï¼ŒvCPUå¯ä»¥ç›´æ¥å¯¹å…¶è¿›è¡Œå¤„ç†ï¼Œä¸éœ€è¦hvçš„å‚ä¸ã€‚</p><h3 id="5-summary"><a href="#5-summary" class="headerlink" title="5. summary"></a>5. summary</h3><p>VT-d PI advantages</p><ul><li>External interrupts from direct-assigned devices are delivered to guest running in non-root mode directly</li><li>Improve Interrupt virtualization efficiency, e.g. Less VM-Exits.</li><li>Simplify interrupt migration<ul><li>æ›´æ–°PID.NDST</li><li>å¦‚æœper-PCPUçš„IDTå‘é‡ç®¡ç†ä¸ä¸€æ ·ï¼Œè¿˜éœ€è¦æ›´æ–°PCPU IDTçš„vector<br><img src="/images/2020/10/17.PNG" alt></li></ul></li><li>Consume less physical interrupts</li></ul><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li><a href="https://kernelgo.org/posted-interrupt.html" target="_blank" rel="noopener">fangying:VT-d Posted Interrupt</a></li><li><a href="https://zhuanlan.zhihu.com/p/51018597" target="_blank" rel="noopener">æ²³é©¬ Intel VT-dï¼ˆ4ï¼‰- Interrupt Posting</a></li><li><a href="https://events.static.linuxfound.org/sites/events/files/slides/VT-d%20Posted%20Interrupts-final%20.pdf" target="_blank" rel="noopener">Feng Wu:VT-d Posted Interrupts </a></li><li><a href="https://lettieri.iet.unipi.it/virtualization/2018/passthrough.pdf" target="_blank" rel="noopener">Hardware passthrough</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡å°†ä»‹ç»VT-d Posted Interruptçš„ç›¸å…³å†…å®¹ã€‚é¦–å…ˆä¼šä»¥ä¸€ä¸ªä¾‹å­ä»‹ç»Posted interruptçš„motivationï¼›ç„¶åè¯¦ç»†é˜è¿°æ¶‰åŠåˆ°çš„ç¡¬ä»¶å’Œè½¯ä»¶ç»†èŠ‚ï¼›æ¥ä¸‹æ¥ä¼šä»‹ç»ä¸åŒvCPUçŠ¶æ€ä¸‹çš„å·®å¼‚åŒ–å¤„ç†ï¼›æœ€åæ€»ç»“ä¸‹æœ¬æ–‡ã€‚
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
  <entry>
    <title>VT-d Interrupt Remapping</title>
    <link href="http://liujunming.github.io/2020/10/10/VT-d-Interrupt-Remapping/"/>
    <id>http://liujunming.github.io/2020/10/10/VT-d-Interrupt-Remapping/</id>
    <published>2020-10-10T11:20:19.000Z</published>
    <updated>2020-10-13T22:52:43.868Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡å°†ä»‹ç»VT-d Interrupt Remappingçš„motivationï¼Œç„¶åæ¨èä¸€ç¯‡ä»‹ç»Interrupt Remappingç»†èŠ‚çš„æ–‡ç« ï¼Œæœ€åä»¥ä¸€ä¸ªå…·ä½“çš„ä¾‹å­æ¥å±•ç¤ºVT-d Interrupt Remappingçš„ç”¨æ³•ã€‚<a id="more"></a></p><h3 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h3><ol><li>Supporting isolation and routing of interrupts from devices and external interrupt controllers to appropriate VMs.</li><li>Supporting x2APIC</li></ol><h3 id="details"><a href="#details" class="headerlink" title="details"></a>details</h3><p>å¯ä»¥è¯¦ç»†é˜…è¯»æ­¤æ–‡ã€‚<br><a href="https://kernelgo.org/interrupt-remapping.html" target="_blank" rel="noopener">https://kernelgo.org/interrupt-remapping.html</a></p><h3 id="demo-usage"><a href="#demo-usage" class="headerlink" title="demo usage"></a>demo usage</h3><p><img src="/images/2020/10/6.PNG" alt></p><p>ä»¥ä¸Šå›¾ä¸ºä¾‹ï¼Œå°†å±•ç¤ºVT-d Interrupt Remappingçš„å…·ä½“è¿‡ç¨‹ã€‚</p><ol><li>å½“guesté…ç½®MSI addresså’ŒMSI dataæ—¶ï¼Œhypervisor(hv)ä¼štrapï¼Œè§£æç›¸å…³fieldï¼Œå¾—åˆ°virtual interruptçš„vectorä¸º30ï¼Œè€Œå¯¹åº”çš„physical interruptçš„vectorä¸º60ã€‚è¿™æ ·hvä¼šè®°å½•physical interruptåˆ°virtual interruptçš„æ˜ å°„(vector 60 -&gt; vector 30)ã€‚</li><li>åˆ†é…ä¸€ä¸ªIRTEå¹¶ä¸”æŒ‰ç…§IRTEçš„æ ¼å¼è¦æ±‚å¡«å¥½IRTEçš„æ¯ä¸ªå±æ€§ã€‚å¦‚ï¼šB:D.F, Vector(60), è¿è¡Œç›®æ ‡vCPUçš„ç‰©ç†CPUçš„LAPIC IDã€‚</li><li>æŒ‰ç…§Remapping formatçš„æ ¼å¼å¯¹MSIè¿›è¡Œç¼–ç¨‹ã€‚å¦‚ï¼šå°†Interrupt Formatç½®1ï¼Œè®¾ç½®ä¸­æ–­çš„interrupt_indexã€‚</li><li>è®¾ç½®VMCS(configured to cause vmexit on external interrupt)ã€‚å½“ç‰©ç†CPUæ”¶åˆ°vectorä¸º60çš„ä¸­æ–­æ—¶ï¼Œä¼šå‘ç”ŸVM-Exitã€‚</li><li>hvå¤„ç†VM-Exitï¼Œæ ¹æ®physical interruptåˆ°virtual interruptçš„æ˜ å°„(vector 60 -&gt; vector 30)å…³ç³»ï¼Œä¸ºguestæ³¨å…¥vectorä¸º30çš„interruptã€‚</li><li>VM-Entryåˆ°guest VMï¼Œprocess vectorä¸º30çš„interruptã€‚</li></ol><h3 id="rethinking-the-motivation"><a href="#rethinking-the-motivation" class="headerlink" title="rethinking the motivation"></a>rethinking the motivation</h3><p><img src="/images/2020/10/19.PNG" alt></p><p><img src="/images/2020/10/20.PNG" alt></p><p>ä¸¤è€…å¯ä»¥å®Œæˆç›¸åŒçš„åŠŸèƒ½ã€‚é‚£ä¹ˆä¸ºä»€ä¹ˆè¿˜è¦æœ‰VT-d Interrupt Remappingå‘¢ï¼Ÿ</p><p>åœ¨<a href="https://invisiblethingslab.com/resources/2011/Software%20Attacks%20on%20Intel%20VT-d.pdf" target="_blank" rel="noopener">Following the White Rabbit:Software attacks against Intel(R) VT-d technology</a>ä¸€æ–‡ä¸­æ‰¾åˆ°äº†ç­”æ¡ˆï¼švulnerable to the BDF spoofing attackã€‚</p><blockquote><p>Even though the interrupt remapping seems vulnerable to the BDF spoofing attack (just like DMA<br>remapping is), still we believe it has a potential to prevent all the above-mentioned MSI attacks, because we anticipate that none of the interrupt vector used in our attacks should be allowed to any devices in the system. In that case, BDF spoofing would not bring any advantage to the attacker, as there should be no device at all that the attacker might want to impersonate, which could deliver those dangerous interrupts, such as SIPI, syscall interrupts, or the #AC exception.</p></blockquote><blockquote><p>BDF spoofing is a type of a hardware attack against VT-d, where a malicious device generates PCIe packets with spoofed BDF address. </p></blockquote><p>è¯´ç™½äº†ï¼ŒVT-d Interrupt Remappingå¯ä»¥è§£å†³securityé—®é¢˜ã€‚</p><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li><a href="https://compas.cs.stonybrook.edu/~nhonarmand/courses/sp17/cse506/slides/hw_io_virtualization.pdf" target="_blank" rel="noopener">I/O Virtualization with Hardware Support</a></li><li><a href="https://invisiblethingslab.com/resources/2011/Software%20Attacks%20on%20Intel%20VT-d.pdf" target="_blank" rel="noopener">Following the White Rabbit:Software attacks against Intel(R) VT-d technology</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡å°†ä»‹ç»VT-d Interrupt Remappingçš„motivationï¼Œç„¶åæ¨èä¸€ç¯‡ä»‹ç»Interrupt Remappingç»†èŠ‚çš„æ–‡ç« ï¼Œæœ€åä»¥ä¸€ä¸ªå…·ä½“çš„ä¾‹å­æ¥å±•ç¤ºVT-d Interrupt Remappingçš„ç”¨æ³•ã€‚
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about APICv MSR-Based APIC Accesses</title>
    <link href="http://liujunming.github.io/2020/10/10/Some-notes-about-APICv-MSR-Based-APIC-Accesses/"/>
    <id>http://liujunming.github.io/2020/10/10/Some-notes-about-APICv-MSR-Based-APIC-Accesses/</id>
    <published>2020-10-10T05:11:33.000Z</published>
    <updated>2020-10-10T23:34:43.823Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/#msr-based-apic-accesses" target="_blank" rel="noopener">MSR-Based APIC Accesses</a></p><ol><li><p>Secondary Processor-Based VM-Execution Controls.Virtualize x2APIC Mode[bit 4] = 1æ—¶ï¼ŒVMCSä¸­x2APIC MSR Bitmapçš„è®¾ç½®ä¾ç„¶æœ‰æ•ˆã€‚</p></li><li><p>WRMSR ICR, no APIC Write VM Exit, has potential security issues?<br>Solution: set VMCS MSR Bitmap to trap ICR register write.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/#msr-based-apic-accesses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MSR-Based APIC Ac
      
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about Interrupt Window and NMI Window</title>
    <link href="http://liujunming.github.io/2020/10/09/Some-notes-about-Interrupt-Window/"/>
    <id>http://liujunming.github.io/2020/10/09/Some-notes-about-Interrupt-Window/</id>
    <published>2020-10-09T03:25:32.000Z</published>
    <updated>2020-10-13T10:58:47.613Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡ä¸»è¦ä»‹ç»Interrupt Windowå’ŒNMI Windowçš„ç›¸å…³çŸ¥è¯†ç‚¹ã€‚<a id="more"></a></p><p>å¼ºçƒˆå»ºè®®åœ¨<a href="http://mmc.geofisica.unam.mx/acl/Textos/MaquinasVirtuales/CursoMaquinasVirtuales/Bibliograf%C3%ADaMaquinasVirtuales/Vtx.pdf" target="_blank" rel="noopener">Vtx.pdf</a>æœç´¢Interrupt-window Exitingã€‚</p><blockquote><p>Interrupt-window Exiting. The interrupt-window exiting control bit in the VM-execution controls causes VM exits when guest RFLAGS.IF is 1 and no other conditions block external interrupts. If the control is 1, a VM exit occurs at the beginning of any instruction at which RFLAGS.IF = 1 and on which the interruptibility state of the guest would allow delivery of an interrupt. For example: when the guest executes an STI instruction, RFLAGS = 1, and if at the completion of next instruction the interruptibility state masking due to STI is removed; a VM exit occurs if interruptwindow exiting control is 1. The interrupt-window exiting feature allows a VMM to queue a virtual interrupt to the guest when the guest is not in an interruptible state. The VMM can set the interrupt-window exiting control for the guest and depend on a VM exit to know when the guest becomes interruptible (and, therefore, when it can inject a virtual interrupt). The VMM can detect such VM exits by checking for the basic exit reason â€˜interrupt-windowâ€™ (value = 7). Without interrupt-window exiting support, the VMM will need to poll and check the interruptibility state of the guest to deliver virtual interrupts.</p></blockquote><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><ol><li>IRRä¸å—IF(RFLAGS.IF)ä½çš„å½±å“ã€‚</li><li>äº‹ä»¶æ³¨å…¥æ§åˆ¶:<br><img src="/images/2020/10/5.PNG" alt></li></ol><h3 id="2-Interrupt-Window"><a href="#2-Interrupt-Window" class="headerlink" title="2. Interrupt Window"></a>2. Interrupt Window</h3><p>å¦‚æœGuestæ­£å¤„åœ¨å±è”½å¤–éƒ¨ä¸­æ–­çš„çŠ¶æ€ï¼Œå³Guestçš„<code>RFLAGS.IF = 0</code>æˆ–<em>Guest Non-Register State.Interruptibility State</em>ï¼ˆ<code>VMCS[0x4824](32 bit)</code>ï¼‰çš„Bit 0 (Blocking by STI)å’ŒBit 1 (Blocking by MOV-SS)ä¸å…¨ä¸ºé›¶ï¼Œå°†ä¸å…è®¸åœ¨VM Entryæ—¶è¿›è¡ŒEvent Injectionã€‚ä¸ºäº†å‘vCPUæ³¨å…¥ä¸­æ–­ï¼Œå¯ä»¥ä¸´æ—¶è®¾ç½®<em>Primary Processor-Based VM-Execution Controls.Interrupt-Window Exiting</em> = 1ï¼Œç„¶åä¸»åŠ¨VM Entryè¿›å…¥Non-rootæ¨¡å¼ã€‚ä¸€æ—¦CPUè¿›å…¥èƒ½å¤Ÿæ¥æ”¶ä¸­æ–­çš„çŠ¶æ€ï¼Œå³<code>RFLAGS.IF = 1</code>ä¸”<em>Interruptibility State</em>[1:0] = 0ï¼Œä¾¿ä¼šäº§ç”Ÿä¸€ä¸ªVM Exitï¼ˆ<code>VM Exit No.7</code> <strong>Interrupt Window</strong>ï¼‰ï¼Œæ­¤æ—¶Hypervisorä¾¿å¯æ³¨å…¥åˆšæ‰æ— æ³•æ³¨å…¥çš„ä¸­æ–­ï¼Œå¹¶å°†<em>Interrupt-Window Exiting</em>é‡ç½®ä¸º0ã€‚</p><p>å€¼å¾—æ³¨æ„çš„æ˜¯ï¼šå³ä½¿Guestçš„<code>RFLAGS.IF = 0</code>,Guestçš„IRRå¯„å­˜å™¨ä¾ç„¶ä¼šç½®ä½ï¼Œè¿™ä¸ªè¡Œä¸ºéœ€è¦ä¸nativeä¿æŒä¸€è‡´ã€‚</p><h3 id="3-NMI-Windows"><a href="#3-NMI-Windows" class="headerlink" title="3. NMI Windows"></a>3. NMI Windows</h3><p>Backgroundå¯ä»¥å‚è€ƒ<a href="/2020/10/09/Some-notes-about-x86-interrupt-preemption/">Some notes about x86 interrupt preemption</a>ã€‚</p><blockquote><p>NMI-window Exiting. If the â€œvirtual NMIsâ€ VM-execution is set, the processor tracks virtual-NMI blocking. The NMI-window exiting control bit in VM-execution controls causes VM exits when there is no virtualNMI blocking. For example, after execution of the IRET instruction, a VM exit occurs if NMIwindow exiting control is 1. The NMI-window exiting feature allows a VMM to queue a virtual NMI to a guest when the guest is not ready to receive NMIs. The VMM can set the NMI-window exiting control for the guest and depend on a VM exit to know when the guest becomes ready for NMIs (and, therefore, when it can inject a virtual NMI). The VMM can detect such VM exits by checking for the basic exit reason â€˜NMI windowâ€™ (value = 8). Without NMI-window exiting support, the VMM will need to poll and check the interruptibility state of the guest to deliver virtual NMIs.</p></blockquote><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li><a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/" target="_blank" rel="noopener">Intel SDM Chapter 29: APIC Virtualizaton &amp; Virtual Interrupts</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡ä¸»è¦ä»‹ç»Interrupt Windowå’ŒNMI Windowçš„ç›¸å…³çŸ¥è¯†ç‚¹ã€‚
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about x86 interrupt preemption</title>
    <link href="http://liujunming.github.io/2020/10/09/Some-notes-about-x86-interrupt-preemption/"/>
    <id>http://liujunming.github.io/2020/10/09/Some-notes-about-x86-interrupt-preemption/</id>
    <published>2020-10-09T00:05:47.000Z</published>
    <updated>2020-10-09T03:43:15.063Z</updated>
    
    <content type="html"><![CDATA[<p>x86 disables all local interrupts (except NMI of course) before jumping to the interrupt vector. </p><p>NMIå¯ä»¥æ‰“æ–­é™¤NMIä»¥å¤–çš„ä»»æ„ä¸­æ–­çš„å¤„ç†ã€‚<br><a id="more"></a><br>ç»“è®ºè¯´å®Œäº†ï¼Œä»‹ç»ä¸‹backgroundå§ã€‚</p><blockquote><p>If an interrupt or exception handler is called through an interrupt gate, the processor clears the interrupt enable (IF) flag in the EFLAGS register to prevent subsequent interrupts from interfering with the execution of the handler. </p></blockquote><p>From SDM Volume 1</p><blockquote><p>While an NMI interrupt handler is executing, the processor blocks delivery of subsequent NMIs until the next execution of the IRET instruction. This blocking of NMIs prevents nested execution of the NMI handler</p></blockquote><p>From SDM Volume 3</p><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li><a href="https://stackoverflow.com/questions/11403915/can-an-interrupt-handler-be-preempted-by-the-same-interrupt-handler" target="_blank" rel="noopener">Can an interrupt handler be preempted by the same interrupt handler?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;x86 disables all local interrupts (except NMI of course) before jumping to the interrupt vector. &lt;/p&gt;
&lt;p&gt;NMIå¯ä»¥æ‰“æ–­é™¤NMIä»¥å¤–çš„ä»»æ„ä¸­æ–­çš„å¤„ç†ã€‚&lt;br&gt;
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>The motivation of APICv</title>
    <link href="http://liujunming.github.io/2020/10/08/The-motivation-of-APICv/"/>
    <id>http://liujunming.github.io/2020/10/08/The-motivation-of-APICv/</id>
    <published>2020-10-08T10:35:32.000Z</published>
    <updated>2020-10-08T14:04:17.109Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡å†…å®¹è½¬è½½è‡ª:<a href="https://software.intel.com/content/www/us/en/develop/blogs/apic-virtualization-performance-testing-and-iozone.html" target="_blank" rel="noopener">APIC Virtualization Performance Testing and Iozone*</a>ã€‚</p><a id="more"></a><p>Virtual machine monitors (VMM) emulate most guest access to interrupts and the advanced programmable interrupt controller (APIC) in a virtual environment.  They also virtualize all guest interrupts. These activities require the exit and reentry of the virtual machines (VM), but they are time consuming and are a major source of overhead.  in order to minimize that effect, the latest Intel(R) Xeon(R) processors, such as the Intel(R) Xeon(R) E5-2600 v2 Product Family, emulate those activities in the hardware. </p><p><img src="/images/2020/10/4.jpg" alt></p><center>Figure 1 - VM-VMM interaction with and without APICv</center><p>Figure 1 shows that all virtualized activities relating interrupts and APIC to and from the guest OS have to go through VMM in systems without APICv; however, in systems with APICv, they are executed in the hardware, not in the VMM.  This way all activities can stay inside the VM, thus eliminating the need to issue the â€œVM exitâ€ command; this change results in reduced overhead and increased I/O throughput.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡å†…å®¹è½¬è½½è‡ª:&lt;a href=&quot;https://software.intel.com/content/www/us/en/develop/blogs/apic-virtualization-performance-testing-and-iozone.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;APIC Virtualization Performance Testing and Iozone*
&lt;/a&gt;ã€‚&lt;/p&gt;
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to CPU-based Posted-interrupt</title>
    <link href="http://liujunming.github.io/2020/10/07/Introduction-to-Posted-interrupt/"/>
    <id>http://liujunming.github.io/2020/10/07/Introduction-to-Posted-interrupt/</id>
    <published>2020-10-07T12:46:55.000Z</published>
    <updated>2020-10-09T04:20:36.209Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡ä¸»è¦æ˜¯å¯¹SDM CPU-based <a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/#posted-interrupt" target="_blank" rel="noopener">Posted Interrupt</a>åšç›¸å…³è¡¥å……ã€‚å¯¹äºVT-dçš„Posted-interruptï¼Œæœ¬æ–‡å¹¶ä¸æ¶‰åŠã€‚</p><a id="more"></a><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>Virtual-Interrupt Deliveryåˆ©ç”¨ç¡¬ä»¶åŠŸèƒ½è§£å†³äº†å¦‚ä¸‹ä¸¤ä¸ªé—®é¢˜ï¼šç¬¬ä¸€ä¸ªæ˜¯éœ€è¦Hypervisoræ‰‹åŠ¨æ¨¡æ‹ŸInterrupt Acknowledgement(è¦å…ˆä»IRRä¸­å–å‡ºæœ€é«˜ä¼˜å…ˆçº§çš„ä¸­æ–­ï¼Œè®¾ç½®ISRä¸­å¯¹åº”ä½)ã€Interrupt Delivery(EOI)ï¼›ç¬¬äºŒä¸ªæ˜¯æœ‰æ—¶éœ€è¦äº§ç”Ÿ<strong>Interrupt Window</strong> VM Exitä»¥æ­£ç¡®æ³¨å…¥ä¸­æ–­ã€‚</p><p>Posted Interruptæ˜¯å¯¹Virtual-Interrupt Deliveryçš„è¿›ä¸€æ­¥å‘å±•ï¼Œè®©æˆ‘ä»¬å¯ä»¥çœç•¥Interrupt Acceptanceçš„è¿‡ç¨‹ï¼Œç›´æ¥ä»¤æ­£åœ¨è¿è¡Œçš„vCPUæ”¶åˆ°ä¸€ä¸ªè™šå‡ä¸­æ–­ï¼Œè€Œä¸äº§ç”ŸVM Exitã€‚å®ƒå¯ä»¥å‘æ­£åœ¨è¿è¡Œçš„vCPUæ³¨å…¥ä¸­æ–­ï¼Œé…åˆVT-dçš„Posted InterruptåŠŸèƒ½ï¼Œè¿˜å¯ä»¥å®ç°Passthroughè®¾å¤‡çš„ä¸­æ–­ç›´æ¥å‘ç»™vCPUè€Œä¸å¼•èµ·VM Exitã€‚</p><h3 id="CPU-based-Posted-Interrupt-Processing"><a href="#CPU-based-Posted-Interrupt-Processing" class="headerlink" title="CPU-based Posted-Interrupt Processing"></a>CPU-based Posted-Interrupt Processing</h3><p><img src="/images/2020/10/1.PNG" alt><br><img src="/images/2020/10/2.PNG" alt></p><h3 id="Usage-Examples-and-Enabling-Posted-Interrupt-Processing-in-KVM"><a href="#Usage-Examples-and-Enabling-Posted-Interrupt-Processing-in-KVM" class="headerlink" title="Usage Examples and Enabling Posted-Interrupt Processing in KVM"></a>Usage Examples and Enabling Posted-Interrupt Processing in KVM</h3><p><img src="/images/2020/10/3.PNG" alt><br>Send the event notification:ç»™vCPUæ‰€åœ¨çš„CPUå‘é€ä¸€ä¸ªNotification Eventï¼Œå³ä¸­æ–­å‘é‡å·ä¸ºPosted-Interrupt Notification Vectorçš„ä¸­æ–­ã€‚</p><blockquote><p>å‡è®¾ç°åœ¨æƒ³ç»™ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„vCPUæ³¨å…¥ä¸­æ–­ï¼Œé™¤éè¯¥vCPUæ­£åœ¨å¤„ç†ä¸­æ–­ï¼Œå¦åˆ™ä»…å‡­Virtual-Interrupt Deliveryï¼Œä»éœ€è¦ä»¤å…¶VM Exitå¹¶è®¾ç½®RVIï¼Œä»¥ä¾¿åœ¨VM Entryæ—¶è§¦å‘Virtual-Interrupt Deliveryã€‚è‹¥ä½¿ç”¨Posted Interruptï¼Œåˆ™å¯ä»¥è®¾ç½®PIRä¸­å¯¹åº”ä½ï¼Œç„¶åç»™vCPUæ‰€åœ¨çš„CPUå‘é€ä¸€ä¸ªNotification Eventï¼Œå³ä¸­æ–­å‘é‡å·ä¸ºPosted-Interrupt Notification Vectorçš„ä¸­æ–­ï¼Œè¿™æ ·vCPUæ— éœ€VM Exitå°±å¯ä»¥è¢«æ³¨å…¥ä¸€ä¸ªç”šè‡³å¤šä¸ªä¸­æ–­ã€‚</p></blockquote><hr><p>å‚è€ƒé“¾æ¥ï¼š</p><ol><li><a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/" target="_blank" rel="noopener">Intel SDM Chapter 29: APIC Virtualizaton &amp; Virtual Interrupts</a></li><li><a href="https://www.linux-kvm.org/images/7/70/2012-forum-nakajima_apicv.pdf" target="_blank" rel="noopener">Enabling Optimized Interrupt/APIC Virtualization in KVM </a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡ä¸»è¦æ˜¯å¯¹SDM CPU-based &lt;a href=&quot;https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/#posted-interrupt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Posted Interrupt&lt;/a&gt;åšç›¸å…³è¡¥å……ã€‚å¯¹äºVT-dçš„Posted-interruptï¼Œæœ¬æ–‡å¹¶ä¸æ¶‰åŠã€‚&lt;/p&gt;
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about CVE-2016-5195</title>
    <link href="http://liujunming.github.io/2020/10/05/Some-notes-about-CVE-2016-5195/"/>
    <id>http://liujunming.github.io/2020/10/05/Some-notes-about-CVE-2016-5195/</id>
    <published>2020-10-05T05:51:00.000Z</published>
    <updated>2020-10-07T17:01:32.903Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡ä¸»è¦æ˜¯å¯¹<a href="https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails" target="_blank" rel="noopener">CVE-2016-5195</a>åšç›¸å…³çš„notesã€‚<a id="more"></a><br><a href="http://huntcve.github.io/2017/07/04/dirtycow/" target="_blank" rel="noopener">DirtyCow æ¼æ´åˆ†æ2</a>åˆ†æçš„è¾ƒå¥½ã€‚</p><h3 id="detail"><a href="#detail" class="headerlink" title="detail"></a>detail</h3><ol><li>å¼ºè¡Œå†™å…¥çš„å†…å®¹è¢«å†™åˆ°<strong>å†…æ ¸COWå‡ºæ¥çš„æ‹·è´é¡µ</strong>ä¸­ï¼Œä¾›è¿›ç¨‹ä½¿ç”¨ã€‚</li><li>If CR0.WP = 0, data may be written to any supervisor-mode address. <em>ç”Ÿæˆä¸€ä¸ªæ–°çš„å¯å†™COWé¡µé¢ï¼Œå¹¶æ ‡è®°ä¸ºè„é¡µé¢ï¼ŒåŒæ—¶ä¿ç•™å…¶åªè¯»å±æ€§</em></li></ol><h3 id="material"><a href="#material" class="headerlink" title="material"></a>material</h3><ol><li><a href="https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails" target="_blank" rel="noopener">VulnerabilityDetails</a></li><li><a href="http://huntcve.github.io/2017/07/04/dirtycow/" target="_blank" rel="noopener">DirtyCow æ¼æ´åˆ†æ2</a></li><li><a href="https://www.anquanke.com/post/id/84851" target="_blank" rel="noopener">æ·±å…¥è§£è¯»è„ç‰›Linuxæœ¬åœ°ææƒæ¼æ´</a></li><li><a href="http://pwn4.fun/2017/07/14/Dirty-COW%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Dirty COWï¼ˆCVE-2016-5195ï¼‰æ¼æ´åˆ†æ</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡ä¸»è¦æ˜¯å¯¹&lt;a href=&quot;https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CVE-2016-5195&lt;/a&gt;åšç›¸å…³çš„notesã€‚
    
    </summary>
    
      <category term="Security" scheme="http://liujunming.github.io/categories/Security/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Security" scheme="http://liujunming.github.io/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about CVE-2018-12207</title>
    <link href="http://liujunming.github.io/2020/09/30/Some-notes-about-CVE-2018-12207/"/>
    <id>http://liujunming.github.io/2020/09/30/Some-notes-about-CVE-2018-12207/</id>
    <published>2020-09-30T12:10:05.000Z</published>
    <updated>2020-10-07T17:01:32.903Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡ä¸»è¦æ˜¯å¯¹<a href="https://software.intel.com/security-software-guidance/api-app/insights/deep-dive-machine-check-error-avoidance-page-size-change" target="_blank" rel="noopener">CVE-2018-12207</a>åšç›¸å…³çš„backgroundè¡¥å……ã€‚åŸæ–‡å†™çš„ç›¸å½“å¥½ï¼Œå»ºè®®è¯¦è¯»ã€‚<a id="more"></a></p><h3 id="Description-of-errata"><a href="#Description-of-errata" class="headerlink" title="Description of errata"></a>Description of errata</h3><p>Software sequences that may lead to machine check error code 0150H can be summarized as follows:</p><ol><li>Code is fetched from a linear address translated using a 4 KB translation cached in the ITLB.</li><li>Software modifies the paging structures so that the same linear address is translated using a large page (2 MB, 4 MB, or 1 GB) with a different physical address or memory type.</li><li>After the paging structure modification, but before software invalidates any ITLB entries for the linear address, code fetch happens again on the same linear address.</li><li>This may cause a machine-check error (IA32_MCi_STATUS.MCACOD=150H), which can result in a system hang or shutdown.</li></ol><h3 id="extension1"><a href="#extension1" class="headerlink" title="extension1"></a>extension1</h3><p>The VMM can use Extended Page Tables (EPT) to enforce that each guest physical address is 4 KB in size and that guest software cannot change the hardware page size for translations.</p><blockquote><p>For correctness, the TLB must consider the page size for a given translation to be the smaller of the nested and guest page sizes.</p></blockquote><p>From ASPLOSâ€™08 ã€ŠAccelerating Two-Dimensional Page Walksã€‹2.4 Large Page Sizeã€‚</p><h3 id="extension2"><a href="#extension2" class="headerlink" title="extension2"></a>extension2</h3><p>The sequence above requires bit 10 (Execute access for user-mode linear address) to be treated in the same manner as bit 2 when mode-based execution controls are active (the mode-based execute control for EPT feature is present and the VM execution control is set to 1).</p><ul><li><p>å„çº§é¡µè¡¨é¡¹çš„ç¬¬2ä½ä¸ºX (eXecute)ï¼Œå–1è¡¨ç¤ºå¯æ‰§è¡Œ</p><ul><li>è‹¥Secondary Processor-Based VM-Execution Controls.Mode-based execute control for EPT[bit 22]å–1ï¼Œåˆ™è¯¥ä½å–1ä»…è¡¨ç¤ºå¯¹äºGuestçš„å†…æ ¸é¡µå¯æ‰§è¡Œï¼Œä¸è¡¨ç¤ºå¯¹äºGuestçš„ç”¨æˆ·é¡µå¯æ‰§è¡Œ</li></ul></li><li><p>å„çº§é¡µè¡¨é¡¹çš„ç¬¬10ä½ä¸ºXU (eXecute for User)ï¼Œå–1è¡¨ç¤ºå¯¹äºGuestçš„ç”¨æˆ·é¡µå¯æ‰§è¡Œ</p><ul><li>ä»…å½“Secondary Processor-Based VM-Execution Controls.Mode-based execute control for EPT[bit 22]å–1æ—¶æœ‰æ•ˆï¼Œå¦åˆ™è¯¥ä½ä¼šè¢«å¿½ç•¥</li></ul></li></ul><p>From <a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch28/" target="_blank" rel="noopener">Intel SDM Chapter 28: VMX Support for Address Translation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡ä¸»è¦æ˜¯å¯¹&lt;a href=&quot;https://software.intel.com/security-software-guidance/api-app/insights/deep-dive-machine-check-error-avoidance-page-size-change&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CVE-2018-12207&lt;/a&gt;åšç›¸å…³çš„backgroundè¡¥å……ã€‚åŸæ–‡å†™çš„ç›¸å½“å¥½ï¼Œå»ºè®®è¯¦è¯»ã€‚
    
    </summary>
    
      <category term="Security" scheme="http://liujunming.github.io/categories/Security/"/>
    
    
      <category term="å†…å­˜ç®¡ç†" scheme="http://liujunming.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="Security" scheme="http://liujunming.github.io/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>Without EPT or SPT, guest still can access memory?</title>
    <link href="http://liujunming.github.io/2020/08/30/Without-EPT-or-SPT-guest-still-can-access-memory/"/>
    <id>http://liujunming.github.io/2020/08/30/Without-EPT-or-SPT-guest-still-can-access-memory/</id>
    <published>2020-08-30T01:28:10.000Z</published>
    <updated>2020-08-30T01:42:12.121Z</updated>
    
    <content type="html"><![CDATA[<p>Without EPT or SPT(shadow page table), guest can access memory?<br><a id="more"></a><br>åœ¨çœ‹kvm-unit-testæ—¶ï¼Œå‘ç°ï¼šæ²¡æœ‰ä¸ºgueståˆ›å»ºEPT or SPTï¼Œä½†æ˜¯ï¼Œguestä¾ç„¶å¯ä»¥è®¿é—®memoryï¼Œè¿™æ˜¯æ€ä¹ˆåšåˆ°çš„å‘¢ï¼Ÿ</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_vmcs_guest</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 26.3 CHECKING AND LOADING GUEST STATE */</span></span><br><span class="line">ulong guest_cr3;</span><br><span class="line"><span class="comment">/* 26.3.1.1 */</span></span><br><span class="line">guest_cr3 = read_cr3();</span><br><span class="line">...</span><br><span class="line">vmcs_write(GUEST_CR3, guest_cr3);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ç­”æ¡ˆä¾¿åœ¨ä¸Šè¿°ä»£ç ç‰‡æ®µä¸­ï¼šå°†hostçš„cr3èµ‹å€¼ç»™guestçš„cr3ã€‚è¿™æ ·ï¼Œç›´æ¥å°†MMU pass-thruç»™guestï¼Œå¹¶ä¸”guestå’Œhostå¤ç”¨ç›¸åŒçš„é¡µè¡¨ã€‚</p><p>è¿™æ ·æ¯”è¾ƒtrickyåšæ³•çš„ç¼ºç‚¹æ˜¯:å¤±å»äº†éš”ç¦»æ€§ã€‚</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Without EPT or SPT(shadow page table), guest can access memory?&lt;br&gt;
    
    </summary>
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about Queued Invalidation in VT-d</title>
    <link href="http://liujunming.github.io/2020/08/29/Some-notes-about-Queued-Invalidaion-in-VT-d/"/>
    <id>http://liujunming.github.io/2020/08/29/Some-notes-about-Queued-Invalidaion-in-VT-d/</id>
    <published>2020-08-29T12:48:47.000Z</published>
    <updated>2020-10-23T15:18:20.487Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡å°†ä»‹ç»VT-dä¸­Queued Invalidationçš„ç›¸å…³çŸ¥è¯†ç‚¹ã€‚<br><a id="more"></a></p><p>Queued Invalidationçš„è¯¦ç»†å†…å®¹è¯·å‚è€ƒVT-d spcçš„6.5.2èŠ‚ã€‚</p><h2 id="æ¦‚å¿µ"><a href="#æ¦‚å¿µ" class="headerlink" title="æ¦‚å¿µ"></a>æ¦‚å¿µ</h2><p>specä¸­çš„æè¿°å¦‚ä¸‹ï¼š</p><blockquote><p>The queued invalidation provides an advanced interface for software to submit invalidation requests to hardware and to synchronize invalidation completions with hardware.</p></blockquote><h2 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h2><blockquote><p>The queued invalidation interface uses IQ(Invalidation Queue), which is a circular buffer in system memory. Software submits commands by writing Invalidation Descriptors to the IQ. </p></blockquote><p><a href="https://github.com/projectacrn/acrn-hypervisor/blob/release_2.0/hypervisor/arch/x86/vtd.c#L546" target="_blank" rel="noopener">dmar_issue_qi_request</a>æ˜¯ç ”ç©¶Queued Invalidationçš„å…¥å£å‡½æ•°ã€‚</p><p>ä»æºç ä¸­å¯ä»¥çœ‹åˆ°ï¼Œacrnåœ¨invalid dmar context cache, invalid dmar iotlb, invalid dmar interrupt entry cacheæ—¶ï¼Œä¼šä½¿ç”¨åˆ°Queued Invalidationã€‚</p><p>acrnå‘QIä¸­submit ä¸€ä¸ªInvalidation Descriptoræ—¶ï¼Œç´§æ¥ç€ä¼šsubmit Invalidation Wait Descriptor(VT-d spec 6.5.2.8)ã€‚</p><p><img src="/images/2020/05/6.PNG" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">invalidate_desc_ptr-&gt;hi_64 = hva2hpa(&amp;qi_status);</span><br><span class="line">invalidate_desc_ptr-&gt;lo_64 = DMAR_INV_WAIT_DESC_LOWER;</span><br><span class="line">dmar_unit-&gt;qi_tail = (dmar_unit-&gt;qi_tail + DMAR_QI_INV_ENTRY_SIZE) % DMAR_INVALIDATION_QUEUE_SIZE;</span><br><span class="line"></span><br><span class="line">qi_status = DMAR_INV_STATUS_INCOMPLETE;</span><br><span class="line">iommu_write32(dmar_unit, DMAR_IQT_REG, dmar_unit-&gt;qi_tail);</span><br><span class="line"></span><br><span class="line">start = rdtsc();</span><br><span class="line"><span class="keyword">while</span> (qi_status != DMAR_INV_STATUS_COMPLETED) &#123;</span><br><span class="line"><span class="keyword">if</span> ((rdtsc() - start) &gt; CYCLES_PER_MS) &#123;</span><br><span class="line">pr_err(<span class="string">"DMAR OP Timeout! @ %s"</span>, __func__);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">asm_pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>å°†<code>&amp;qi_status</code>å†™å…¥Addr,å°†<code>DMAR_INV_STATUS_COMPLETED</code>å†™å…¥Status Data(è§ä¸Šå›¾)ï¼Œè¿™æ„å‘³ç€ï¼šå½“ç¡¬ä»¶å¤„ç†å®Œinvalidation requests æ—¶ï¼Œä¼šå°†<code>qi_status</code>çš„å€¼èµ‹å€¼ä¸º<code>DMAR_INV_STATUS_COMPLETED</code>ã€‚</p><p>è½¯ä»¶å…ˆå°†<code>qi_status</code>èµ‹å€¼ä¸º<code>DMAR_INV_STATUS_INCOMPLETE</code>ï¼Œç„¶åloopï¼Œç›´è‡³ç¡¬ä»¶å°†<code>qi_status</code>çš„å€¼èµ‹å€¼ä¸º<code>DMAR_INV_STATUS_COMPLETED</code>ã€‚</p><h2 id="details"><a href="#details" class="headerlink" title="details"></a>details</h2><p>Since information from the context-cache may be used to tag entries in the PASID-cache, IOTLB and paging-structure caches, software must always follow a context-cache invalidation with a PASID cache invalidation (if context-cache entry supports requests-with-PASID, or if Scalable Mode Translation is enabled), followed by an IOTLB invalidation. </p><p>context-cache invalidation and IOTLB invalidation has dependency relationship.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡å°†ä»‹ç»VT-dä¸­Queued Invalidationçš„ç›¸å…³çŸ¥è¯†ç‚¹ã€‚&lt;br&gt;
    
    </summary>
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
      <category term="acrn" scheme="http://liujunming.github.io/tags/acrn/"/>
    
  </entry>
  
</feed>
