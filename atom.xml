<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2020-12-01T11:31:02.531Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VT-x:Information for VM Exits During Event Delivery</title>
    <link href="http://liujunming.github.io/2020/12/01/VT-x-Information-for-VM-Exits-During-Event-Delivery/"/>
    <id>http://liujunming.github.io/2020/12/01/VT-x-Information-for-VM-Exits-During-Event-Delivery/</id>
    <published>2020-12-01T05:11:55.000Z</published>
    <updated>2020-12-01T11:31:02.531Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡ä¸»è¦è®°å½•SDMä¸­<code>Information for VM Exits During Event Delivery</code>ä¸€èŠ‚çš„ç›¸å…³ç¬”è®°ã€‚<a id="more"></a></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p><code>Information for VM Exits That Occur During Event Delivery</code> defined fields containing information for VM exits that occur while delivering an event through the IDT and as a result of any of the following cases:</p><ul><li>A fault occurs during event delivery and causes a VM exit (because the bit associated with the fault is set to 1 in the exception bitmap).</li><li>A task switch is invoked through a task gate in the IDT. The VM exit occurs due to the task switch only after the initial checks of the task switch pass.</li><li>Event delivery causes an APIC-access VM exit.</li><li>An EPT violation, EPT misconfiguration, page-modification log-full event, or SPP-related event that occurs during event delivery.</li></ul><h3 id="å®ç°"><a href="#å®ç°" class="headerlink" title="å®ç°"></a>å®ç°</h3><p>ACRNä¸­çš„<a href="https://github.com/projectacrn/acrn-hypervisor/blob/v2.2/hypervisor/arch/x86/guest/vmexit.c#L183" target="_blank" rel="noopener">å®ç°</a>å¦‚ä¸‹ï¼š<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vcpu-&gt;arch.idt_vectoring_info = exec_vmread32(VMX_IDT_VEC_INFO_FIELD);</span><br><span class="line"><span class="keyword">if</span> ((vcpu-&gt;arch.idt_vectoring_info &amp; VMX_INT_INFO_VALID) != <span class="number">0U</span>) &#123;</span><br><span class="line"><span class="keyword">uint32_t</span> vector_info = vcpu-&gt;arch.idt_vectoring_info;</span><br><span class="line"><span class="keyword">uint32_t</span> <span class="built_in">vector</span> = vector_info &amp; <span class="number">0xff</span>U;</span><br><span class="line"><span class="keyword">uint32_t</span> type = (vector_info &amp; VMX_INT_TYPE_MASK) &gt;&gt; <span class="number">8U</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> err_code = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == VMX_INT_TYPE_HW_EXP) &#123;</span><br><span class="line"><span class="keyword">if</span> ((vector_info &amp; VMX_INT_INFO_ERR_CODE_VALID) != <span class="number">0U</span>) &#123;</span><br><span class="line">err_code = exec_vmread32(VMX_IDT_VEC_ERROR_CODE);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">void</span>)vcpu_queue_exception(vcpu, <span class="built_in">vector</span>, err_code);</span><br><span class="line">vcpu-&gt;arch.idt_vectoring_info = <span class="number">0U</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == VMX_INT_TYPE_NMI) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_notification_nmi(vcpu-&gt;vm)) &#123;</span><br><span class="line">pr_dbg(<span class="string">"This NMI is used as notification signal. So ignore it."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">vcpu_make_request(vcpu, ACRN_REQUEST_NMI);</span><br><span class="line">vcpu-&gt;arch.idt_vectoring_info = <span class="number">0U</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* No action on EXT_INT or SW exception. */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>hardware exceptionçš„å®šä¹‰:<br><img src="/images/2020/12/1.PNG" alt></p><h3 id="æµ‹è¯•ç”¨ä¾‹"><a href="#æµ‹è¯•ç”¨ä¾‹" class="headerlink" title="æµ‹è¯•ç”¨ä¾‹"></a>æµ‹è¯•ç”¨ä¾‹</h3><p>å¯¹äº<code>A fault occurs during event delivery and causes a VM exit</code> caseï¼Œå¯ä»¥åˆ©ç”¨å¦‚ä¸‹æµ‹è¯•ç”¨ä¾‹å¤ç°ï¼š</p><ol><li>è®¾ç½®guest IDTä¸­Divide Error vectoré¡¹çš„presentä½ä¸º0(to trigger NP fault)ï¼›</li><li>è®¾ç½®VMCS  exception bitmap fieldä¸­çš„NP falutä½ä¸º1(to trigger VM exit)ï¼›</li><li>guestæ‰§è¡Œdivide 0æŒ‡ä»¤ã€‚</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡ä¸»è¦è®°å½•SDMä¸­&lt;code&gt;Information for VM Exits During Event Delivery&lt;/code&gt;ä¸€èŠ‚çš„ç›¸å…³ç¬”è®°ã€‚
    
    </summary>
    
      <category term="VT-x" scheme="http://liujunming.github.io/categories/VT-x/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-x" scheme="http://liujunming.github.io/tags/VT-x/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to SR-IOV</title>
    <link href="http://liujunming.github.io/2020/10/24/Introduction-to-SR-IOV/"/>
    <id>http://liujunming.github.io/2020/10/24/Introduction-to-SR-IOV/</id>
    <published>2020-10-24T01:37:02.000Z</published>
    <updated>2020-10-25T08:45:21.038Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡åªä»‹ç»SR-IOVçš„åŸºæœ¬å†…å®¹ï¼Œå¹¶ä¸èƒ½cover SR-IOVçš„å…¨éƒ¨çŸ¥è¯†ç‚¹ã€‚<a id="more"></a></p><h3 id="1-prerequisites"><a href="#1-prerequisites" class="headerlink" title="1. prerequisites"></a>1. prerequisites</h3><ol><li>éœ€è¦ç†è§£VT-dçš„DMA remapping,interrupt remapping ,posted interrupt<ul><li><a href="/2020/10/10/VT-d-Interrupt-Remapping/">VT-d Interrupt Remapping</a></li><li><a href="/2020/10/11/VT-d-Posted-Interrupt/">VT-d Posted Interrupt</a></li></ul></li><li>éœ€è¦ç†è§£PCI&amp;PCIeçš„config spaceï¼ŒMSIä¸MSI-X.<ul><li><a href="https://tcbbd.moe/ref-and-spec/pci/" target="_blank" rel="noopener">PCI Local Bus (i.e. Conventional PCI)</a></li></ul></li><li>éœ€è¦ç†è§£ATS,ACS,ARI<ul><li><a href="/2019/11/24/Introduction-to-PCIe-Address-Translation-Services/">Introduction to PCIe Address Translation Services</a></li><li><a href="/2019/11/24/Introduction-to-PCIe-Access-Control-Services/">Introduction to PCIe Access Control Services</a></li><li>PCIe Alternative Routing-ID Interpretation (ARI)<ul><li>Enable up-to 256 functions for single PCI Express component</li></ul></li></ul></li><li>PCIe config spaceä½äºMMIOç©ºé—´å†…</li></ol><h3 id="2-motivation"><a href="#2-motivation" class="headerlink" title="2. motivation"></a>2. motivation</h3><p>æ¨èè®ºæ–‡ï¼šHigh Performance Network Virtualization with SRIOV</p><p>å¯é˜…è¯»<a href="https://github.com/liujunming/paper_reading_notes/issues/1" target="_blank" rel="noopener">Junmingâ€™s notes</a>ã€‚</p><p><img src="https://user-images.githubusercontent.com/11829057/97032861-0ac62400-1595-11eb-8a98-412ffb6a57b4.png" alt></p><p><img src="https://user-images.githubusercontent.com/11829057/97033169-81fbb800-1595-11eb-8db4-94d969346946.png" alt></p><p><img src="https://user-images.githubusercontent.com/11829057/97033444-f33b6b00-1595-11eb-940d-2d687db55fc7.png" alt></p><p><img src="https://user-images.githubusercontent.com/11829057/97034420-7dd09a00-1597-11eb-9027-03c31b5234ff.png" alt></p><p><img src="https://user-images.githubusercontent.com/11829057/97034474-904ad380-1597-11eb-9e00-e52f8fa7d5d1.png" alt></p><h3 id="3-details"><a href="#3-details" class="headerlink" title="3. details"></a>3. details</h3><p><strong>BIOS should be able to enumerate SR-IOV capable device and allocate MMIO (Memory mapped IO) resource for VFs.</strong></p><p><a href="https://projectacrn.github.io/latest/tutorials/sriov_virtualization.html#sr-iov-extended-capability" target="_blank" rel="noopener">SR-IOV Extended Capability</a> The SR-IOV Extended Capability defined here is a PCIe extended capability that must be implemented in each PF device that supports the SR-IOV feature. This capability is used to describe and control a PFâ€™s SR-IOV capabilities.</p><h4 id="3-1-the-differences-between-a-normal-passthrough-device-and-SR-IOV-VF-device"><a href="#3-1-the-differences-between-a-normal-passthrough-device-and-SR-IOV-VF-device" class="headerlink" title="3.1 the differences between a normal passthrough device and SR-IOV VF device"></a>3.1 the differences between a normal passthrough device and SR-IOV VF device</h4><ol><li>physical device detection</li></ol><p>The hypervisor uses <code>Subsystem Vendor ID</code> to detect the SR-IOV VF physical device instead of <code>Vendor ID</code> since no valid <code>Vendor ID</code> exists for the SR-IOV VF physical device. </p><ol start="2"><li>BARs initialization</li></ol><p>The VF BARs are initialized by its associated PFâ€™s SR-IOV capabilities, not PCI standard BAR registers. </p><ol start="3"><li>MSI-X initialization</li></ol><p>The MSI-X mapping base address is also from the PFâ€™s SR-IOV capabilities, not PCI standard BAR registers.</p><h4 id="3-2-VFçš„bdf-numberå¦‚ä½•åˆ†é…"><a href="#3-2-VFçš„bdf-numberå¦‚ä½•åˆ†é…" class="headerlink" title="3.2 VFçš„bdf numberå¦‚ä½•åˆ†é…"></a>3.2 VFçš„bdf numberå¦‚ä½•åˆ†é…</h4><p>Routing IDå°±æ˜¯BDF number,<strong>å³é‡‡ç”¨Bus Numberã€Device Numberå’ŒFunction Numberæ¥ç¡®å®šç›®æ ‡è®¾å¤‡çš„ä½ç½®çš„idã€‚</strong></p><p>SR-IOV Extended Capabilityä¸­ç”¨FirstVF Offsetå’ŒVF Strideæ¥æ ‡è®°VFçš„Routing IDã€‚VFçš„Routing IDæ˜¯ä»¥PFçš„Routing IDå€¼ä¸ºå‚è€ƒæ¥è®¡ç®—çš„ã€‚</p><p><strong>FirstVF Offset</strong>ï¼šç¬¬ä¸€ä¸ªVFç›¸å¯¹PFçš„Routing IDçš„åç§»é‡</p><p><strong>VF Stride</strong>ï¼š ç›¸é‚»VFä¹‹é—´çš„Routing IDçš„åç§»é‡</p><p>PFçš„Routing IDåœ¨PFæšä¸¾ä¹‹åå°±å·²ç»åˆ†é…å¥½äº†ã€‚PFçš„é©±åŠ¨ç¨‹åºé€šè¿‡é…ç½®SR-IOV Extended Capabilityï¼Œæ‰“å¼€è¿™ä¸ªPFå…³è”çš„VFä¹‹åï¼Œé€šè¿‡<strong>FirstVF Offsetå’ŒVF Stride</strong>å°±èƒ½è®¡ç®—å‡ºVFä»¬çš„Routing IDã€‚</p><h4 id="3-3-VFçš„BARç©ºé—´å¦‚ä½•åˆ†é…"><a href="#3-3-VFçš„BARç©ºé—´å¦‚ä½•åˆ†é…" class="headerlink" title="3.3 VFçš„BARç©ºé—´å¦‚ä½•åˆ†é…"></a>3.3 VFçš„BARç©ºé—´å¦‚ä½•åˆ†é…</h4><p>VFçš„BAR[n]ç©ºé—´æ˜¯é€šè¿‡PFçš„SR-IOV Capabilityä¸­æ¯ä¸ªVF_BAR[n]æ¥åˆ†é…çš„ï¼Œå’ŒVF Configuration Spaceçš„BARæ— å…³ã€‚</p><p><img src="/images/2020/10/25.PNG" alt></p><h4 id="3-4-ACRN-Enable-SR-IOV-Virtualization"><a href="#3-4-ACRN-Enable-SR-IOV-Virtualization" class="headerlink" title="3.4 ACRN Enable SR-IOV Virtualization"></a>3.4 ACRN Enable SR-IOV Virtualization</h4><p>å»ºè®®é˜…è¯»<a href="https://projectacrn.github.io/latest/tutorials/sriov_virtualization.html" target="_blank" rel="noopener">ACRN Enable SR-IOV Virtualization</a>ã€‚ğŸ˜Š</p><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li>Chapter 9 of PCI-SIGâ€™s <a href="https://pcisig.com/pci-express-architecture-configuration-space-test-specification-revision-40-version-10" target="_blank" rel="noopener">PCI Express Base Specification Revision 4.0, Version 1.0</a></li><li><a href="https://www.snia.org/sites/default/orig/sdc_archives/2010_presentations/thursday/RichardSolomon_PCI_Express.pdf" target="_blank" rel="noopener">RichardSolomon_PCI_Express.pdf</a></li><li><a href="https://projectacrn.github.io/latest/tutorials/sriov_virtualization.html" target="_blank" rel="noopener">ACRN Enable SR-IOV Virtualization</a></li><li><a href="https://blog.csdn.net/u010443710/article/details/104756445" target="_blank" rel="noopener">SR-IOVåŠlinuxé©±åŠ¨æµ…æ</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡åªä»‹ç»SR-IOVçš„åŸºæœ¬å†…å®¹ï¼Œå¹¶ä¸èƒ½cover SR-IOVçš„å…¨éƒ¨çŸ¥è¯†ç‚¹ã€‚
    
    </summary>
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/tags/PCI-PCIe/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about pause loop exiting</title>
    <link href="http://liujunming.github.io/2020/10/23/Some-notes-about-pause-loop-exiting/"/>
    <id>http://liujunming.github.io/2020/10/23/Some-notes-about-pause-loop-exiting/</id>
    <published>2020-10-23T00:59:55.000Z</published>
    <updated>2020-12-01T11:31:02.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-background"><a href="#1-background" class="headerlink" title="1. background"></a>1. background</h3><p>Spin-locking code typically uses <code>PAUSE</code> instructions in a loop.<a id="more"></a></p><p>For more details, please refer to <a href="/2020/05/01/Introduction-to-halt-pause-monitor-mwait-instruction/#pause">pause</a>.</p><h3 id="2-motivation"><a href="#2-motivation" class="headerlink" title="2. motivation"></a>2. motivation</h3><p>ä¸ºä»€ä¹ˆéœ€è¦pause loop exiting(ple)è¿™ä¸€featureå‘¢?<br><img src="/images/2020/10/21.PNG" alt></p><p><img src="/images/2020/10/22.PNG" alt></p><p><img src="/images/2020/10/23.PNG" alt></p><p><img src="/images/2020/10/24.PNG" alt></p><h3 id="3-details"><a href="#3-details" class="headerlink" title="3. details"></a>3. details</h3><p>Basic Exit Reason 40<br><img src="/images/2020/10/18.PNG" alt></p><p>PLE_Gap - upper bound on the amount of time between two successive executions of PAUSE in a loop.<br>PLE_Window - upper bound on the amount of time a guest is allowed to execute in a PAUSE loop</p><p>If the time, between this execution of PAUSE and previous one, exceeds the PLE_Gap, processor consider this PAUSE belongs to a new loop. Otherwise, processor determins the the total execution time of this loop(since 1st PAUSE in this loop), and triggers a VM exit if total time exceeds the PLE_Window.</p><p>Pause-Loop Exiting can be used to detect Lock-Holder Preemption, where one VCPU is sched-out after hold a spinlock, then other VCPUs for same lock are sched-in to waste the CPU time.</p><p>ä¸ªäººæ„Ÿè§‰PLE_Gapä¸PLE_Windowçš„è®¾ç½®ï¼Œå°±æ˜¯è°ƒå‚å§ã€‚</p><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li><a href="https://surriel.com/system/files/riel_t_1620_kvm_performance.pdf" target="_blank" rel="noopener">riel_t_1620_kvm_performance.pdf</a></li><li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/linux-containers-hypervisor-based-vms-paper.pdf" target="_blank" rel="noopener">linux-containers-hypervisor-based-vms-paper.pdf</a></li><li><a href="https://kernel-team.narkive.com/x1rgNbzk/patch-0-2-kvm-add-support-for-pause-loop-exit" target="_blank" rel="noopener">KVM: add support for Pause-Loop exit</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-background&quot;&gt;&lt;a href=&quot;#1-background&quot; class=&quot;headerlink&quot; title=&quot;1. background&quot;&gt;&lt;/a&gt;1. background&lt;/h3&gt;&lt;p&gt;Spin-locking code typically uses &lt;code&gt;PAUSE&lt;/code&gt; instructions in a loop.
    
    </summary>
    
      <category term="VT-x" scheme="http://liujunming.github.io/categories/VT-x/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Concurrency" scheme="http://liujunming.github.io/tags/Concurrency/"/>
    
      <category term="VT-x" scheme="http://liujunming.github.io/tags/VT-x/"/>
    
  </entry>
  
  <entry>
    <title>VT-d Posted Interrupt</title>
    <link href="http://liujunming.github.io/2020/10/11/VT-d-Posted-Interrupt/"/>
    <id>http://liujunming.github.io/2020/10/11/VT-d-Posted-Interrupt/</id>
    <published>2020-10-11T11:23:20.000Z</published>
    <updated>2020-10-23T15:18:20.489Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡å°†ä»‹ç»VT-d Posted Interruptçš„ç›¸å…³å†…å®¹ã€‚é¦–å…ˆä¼šä»¥ä¸€ä¸ªä¾‹å­ä»‹ç»Posted interruptçš„motivationï¼›ç„¶åè¯¦ç»†é˜è¿°æ¶‰åŠåˆ°çš„ç¡¬ä»¶å’Œè½¯ä»¶ç»†èŠ‚ï¼›æ¥ä¸‹æ¥ä¼šä»‹ç»ä¸åŒvCPUçŠ¶æ€ä¸‹çš„å·®å¼‚åŒ–å¤„ç†ï¼›æœ€åæ€»ç»“ä¸‹æœ¬æ–‡ã€‚<a id="more"></a></p><p>é˜…è¯»æœ¬æ–‡å‰ï¼Œéœ€å…ˆé˜…è¯»ä»¥ä¸‹æ–‡ç« ï¼š</p><ol><li><a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/" target="_blank" rel="noopener">Intel SDM Chapter 29: APIC Virtualizaton &amp; Virtual Interrupts</a></li><li><a href="/2020/10/07/Introduction-to-Posted-interrupt/">Introduction to CPU-based Posted-interrupt</a></li><li><a href="/2020/10/10/VT-d-Interrupt-Remapping/">VT-d Interrupt Remapping</a></li></ol><h3 id="1-terms"><a href="#1-terms" class="headerlink" title="1. terms"></a>1. terms</h3><ul><li>PI(Posted Interrupt)</li><li>hv(hypervisor)</li><li>VM(Virtual Machine)</li><li>IRTE(Interrupt Remapping Table Entry)</li><li>PID(Posted Interrupt Descriptor)</li><li>PIR( Posted Interrupt Requests)</li><li>ON(Outstanding Notification)</li><li>NV(Notification Vector)</li><li>ANV(Active Notification Vector)</li><li>WNV(Wake-up Notification Vector)</li><li>ple(pause loop exiting)</li></ul><h3 id="2-motivation"><a href="#2-motivation" class="headerlink" title="2.  motivation"></a>2.  motivation</h3><p>åœ¨<a href="/2020/10/10/VT-d-Interrupt-Remapping/#demo-usage">VT-d Interrupt Remapping demo usage</a>ä¸­ï¼Œå¦‚æœç›®æ ‡vCPUæ­£åœ¨è¿è¡Œï¼Œä½†æ˜¯ï¼Œå½“ç‰©ç†CPUæ¥å—åˆ°physical interruptæ—¶ï¼Œéœ€å‘ç”ŸVM-Exitï¼Œç”±hvä¸ºguestæ³¨å…¥vectorä¸º30çš„virtualä¸­æ–­ã€‚</p><p>æ€è€ƒä¸‹ï¼šæ˜¯å¦å¯ä»¥çœå»å¦‚ä¸‹æ­¥éª¤ï¼š<em>å½“ç‰©ç†CPUæ¥å—åˆ°physical interruptæ—¶ï¼Œéœ€å‘ç”ŸVM-Exitï¼Œç”±hvä¸ºguestæ³¨å…¥vectorä¸º30çš„virtualä¸­æ–­</em>ã€‚ç”±ç¡¬ä»¶ä¸ºæ­£åœ¨è¿è¡Œçš„vCPUç›´æ¥æ³¨å…¥vectorä¸º30çš„virtual ä¸­æ–­(è¿™æ ·é¿å…äº†ä¸€æ¬¡VM-Exit)ï¼Œè€Œè¿™æ­£æ˜¯VT-d PIæ‰€èƒ½å®Œæˆçš„åŠŸèƒ½ã€‚</p><h3 id="3-details"><a href="#3-details" class="headerlink" title="3. details"></a>3. details</h3><h4 id="3-1-CAP-REGçš„PIä½"><a href="#3-1-CAP-REGçš„PIä½" class="headerlink" title="3.1 CAP_REGçš„PIä½"></a>3.1 CAP_REGçš„PIä½</h4><p>IOMMUé€šè¿‡Capability Register(CAP_REG)çš„PIä½æ¥æŠ¥å‘Šinterrupt posting capabilityã€‚<br><img src="/images/2020/10/7.PNG" alt></p><h4 id="3-2-IRTE"><a href="#3-2-IRTE" class="headerlink" title="3.2 IRTE"></a>3.2 IRTE</h4><p>VT-d PIæ˜¯VT-d Interrupt Remappingçš„ä¸€ä¸ªæ‰©å±•åŠŸèƒ½ã€‚æ ¹æ®<a href="/2020/10/10/VT-d-Interrupt-Remapping/">Interrupt Remapping</a>å¯çŸ¥ï¼Œ æ‰€æœ‰çš„Remappingæ ¼å¼ä¸­æ–­è¯·æ±‚éƒ½éœ€è¦é€šè¿‡ä¸­æ–­é‡æ˜ å°„è¡¨æ¥æŠ•é€’ï¼Œ IRTEä¸­çš„ModeåŸŸ(IM)ç”¨æ¥æŒ‡å®šè¿™ä¸ªremappableä¸­æ–­è¯·æ±‚æ˜¯interrupt-remappingæ–¹å¼è¿˜æ˜¯interrupt-postingæ–¹å¼ã€‚</p><p>å¦‚æœIRTEçš„IMä½ä¸º1ï¼Œåˆ™VT-dç¡¬ä»¶å°†ä¼šä»¥PIçš„å½¢å¼æ¥è§£æè¯¥IRTEï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š<br><img src="/images/2020/10/9.PNG" alt></p><p>éœ€è¦å…³æ³¨PIæ ¼å¼çš„IRTEçš„ä»¥ä¸‹å‡ ä¸ªfieldï¼š</p><ol><li>Posted Descriptor Address Low/Highï¼Œè¯¥åŒºåŸŸä¿å­˜ä¸€ä¸ªæŒ‡å‘å†…å­˜çš„æŒ‡é’ˆï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘çš„ä½ç½®å°±æ˜¯PIDã€‚</li><li>Urgentä½ï¼Œè¯¥ä½ç”¨äºè¡¨ç¤ºè¯¥ä¸­æ–­æ˜¯å¦æ˜¯ç´§æ€¥çš„ï¼Œå³æ˜¯å¦éœ€è¦ç›®æ ‡CPUç«‹å³å“åº”ã€‚</li><li>Vectorç”¨äºæŒ‡å®šPID.PIRä¸­å“ªä¸ªbitè¦ç½®ä½ã€‚</li></ol><h4 id="3-3-PID"><a href="#3-3-PID" class="headerlink" title="3.3 PID"></a>3.3 PID</h4><p>æ¯ä¸ªPIDçš„å¤§å°ä¸º64 Byteï¼Œç›´æ¥è¢«ç¡¬ä»¶ç”¨æ¥è®°å½•å°†è¦postçš„ä¸­æ–­è¯·æ±‚ã€‚å…¶æ ¼å¼å¦‚ä¸‹æ‰€ç¤ºï¼š<br><img src="/images/2020/10/8.PNG" alt></p><ol><li>Posted Interrupt Request (PIR)åŸŸï¼Œä¸€å…±256 bitï¼Œæ¯ä¸ªbitå¯¹åº”ä¸€ä¸ªä¸­æ–­å‘é‡ï¼Œå½“VT-dç¡¬ä»¶å°†ä¸­æ–­è¯·æ±‚postè¿‡æ¥çš„æ—¶å€™ï¼ŒIRTE.Vectorå¯¹åº”çš„bitå°†ä¼šè¢«ç½®èµ·ã€‚</li><li><p>Outstanding Notification (ON)åŸŸï¼Œè¡¨ç¤ºè¯¥PIDå½“å‰æ˜¯å¦å·²ç»å‘å‡ºäº†ä¸€ä¸ªNotification Eventç­‰å¾…CPUçš„å¤„ç†ã€‚</p><ul><li><p>å½“VT-dç¡¬ä»¶å°†ä¸­æ–­è¯·æ±‚è®°å½•åˆ°PIRçš„æ—¶å€™ï¼Œå¦‚æœONä¸º0ï¼Œå¹¶ä¸”å…è®¸ç«‹å³å‘å‡ºä¸€ä¸ªNotification Eventæ—¶ï¼Œåˆ™å°†ä¼šå°†ONç½®èµ·æ¥ï¼Œå¹¶ä¸”äº§ç”Ÿä¸€ä¸ªNotification Eventï¼›å¦‚æœONå·²ç»è¢«ç½®èµ·æ¥ï¼Œåˆ™ä¸ä¼šäº§ç”Ÿä¸€ä¸ªNotification Eventã€‚</p></li><li><p>ONçš„æ¸…é›¶ã€‚</p><p><img src="/images/2020/10/16.PNG" alt></p></li></ul></li><li>Suppress Notification (SN)åŸŸï¼Œè¡¨ç¤ºå½“PIRå¯„å­˜å™¨è®°å½•åˆ°non-urgentçš„ä¸­æ–­æ—¶ï¼Œæ˜¯å¦ä¸å‘å‡ºNotification Eventï¼Œå¦‚æœè¯¥ä½ä¸º1ï¼Œåˆ™å½“PIRè®°å½•åˆ°non-urgentä¸­æ–­çš„æ—¶å€™ï¼Œä¸å‘å‡ºNotification Eventï¼Œå¹¶ä¸”ä¸æ›´æ”¹Outstanding Notificationä½çš„å€¼ã€‚</li><li>Notification Vector (NV)åŸŸï¼Œè¡¨ç¤ºå¦‚æœå‘å‡ºNotification Eventæ—¶ï¼Œå…·ä½“çš„Vectorå€¼ã€‚</li><li>Notification Destination (NDST)åŸŸï¼Œè¡¨ç¤ºå¦‚æœå‘å‡ºNotification Eventæ—¶ï¼Œè¦ä¼ é€’çš„ç‰©ç†CPUçš„LAPIC IDã€‚</li></ol><h4 id="3-4-ç¡¬ä»¶ä¸ŠPosted-Interruptçš„å¤„ç†è¿‡ç¨‹"><a href="#3-4-ç¡¬ä»¶ä¸ŠPosted-Interruptçš„å¤„ç†è¿‡ç¨‹" class="headerlink" title="3.4 ç¡¬ä»¶ä¸ŠPosted Interruptçš„å¤„ç†è¿‡ç¨‹"></a>3.4 ç¡¬ä»¶ä¸ŠPosted Interruptçš„å¤„ç†è¿‡ç¨‹</h4><p><img src="/images/2020/10/15.PNG" alt></p><p>PSTå³IRTEä¸­çš„Interrupt Modeä½ã€‚</p><p><img src="/images/2020/10/10.jpg" alt></p><p>å½“VT-dç¡¬ä»¶æ¥æ”¶åˆ°å…¶æ——ä¸‹I/Oè®¾å¤‡ä¼ é€’è¿‡æ¥çš„ä¸­æ–­è¯·æ±‚æ—¶ï¼Œä¼šå…ˆæŸ¥çœ‹è‡ªå·±çš„ä¸­æ–­é‡å®šå‘åŠŸèƒ½æ˜¯å¦æ‰“å¼€ï¼Œå¦‚æœæ²¡æœ‰æ‰“å¼€åˆ™ï¼Œç›´æ¥ä¸Šä¼ ç»™LAPICã€‚å¦‚æœä¸­æ–­é‡å®šå‘åŠŸèƒ½æ‰“å¼€ï¼Œåˆ™ä¼šæŸ¥çœ‹ä¸­æ–­è¯·æ±‚çš„æ ¼å¼ï¼Œå¦‚æœæ˜¯ä¸å¯é‡å®šå‘æ ¼å¼ï¼Œåˆ™ç›´æ¥å°†ä¸­æ–­è¯·æ±‚æäº¤ç»™LAPICã€‚å¦‚æœæ˜¯å¯é‡å®šå‘çš„æ ¼å¼ï¼Œåˆ™ä¼šæ ¹æ®ç®—æ³•è®¡ç®—Interrupt_Indexå€¼ï¼Œå¯¹ä¸­æ–­é‡å®šå‘è¡¨è¿›è¡Œç´¢å¼•æ‰¾åˆ°ç›¸åº”çš„IRTEã€‚ç„¶åï¼ŒæŸ¥çœ‹IRTEä¸­çš„Interrupt Modeï¼Œå¦‚æœä¸º0ï¼Œåˆ™è¯¥IRTEçš„æ ¼å¼ä¸ºRemapped Formatï¼Œå³ç«‹å³æ ¹æ®IRTEçš„ä¿¡æ¯äº§ç”Ÿä¸€ä¸ªæ–°çš„ä¸­æ–­è¯·æ±‚ï¼Œæäº¤åˆ°LAPICã€‚å¦‚æœInterrupt Modeä¸º1ï¼Œåˆ™è¡¨ç¤ºè¯¥IRTEçš„æ ¼å¼ä¸ºPosted Formatï¼Œæ ¹æ®IRTEä¸­æä¾›çš„PIDçš„åœ°å€ï¼Œåœ¨å†…å­˜ä¸­æ‰¾åˆ°ç›¸åº”PIDï¼Œå¹¶æ ¹æ®å…¶ONã€URGå’ŒSNçš„è®¾ç½®åˆ¤æ–­æ˜¯å¦éœ€è¦ç«‹å³äº§ç”Ÿä¸€ä¸ªNotification Eventï¼Œå¦‚æœä¸éœ€è¦ï¼Œåˆ™åªæ˜¯å°†è¯¥ä¸­æ–­ä¿¡æ¯è®°å½•åˆ°PID.PIRä¸­ï¼Œç­‰å¾…hvçš„åç»­å¤„ç†(ä¼šåœ¨<a href="/2020/10/11/VT-d-Posted-Interrupt/#4-5-vCPU-is-ready-to-run-or-halted-when-Notification-Event-happen">vCPU is ready-to-run or halted when Notification Event happen</a>ä¸­ä»‹ç»)ã€‚å¦‚æœéœ€è¦ç«‹å³äº§ç”Ÿä¸€ä¸ªNotification Eventï¼Œåˆ™æ ¹æ®PIDï¼ˆä¼šæä¾›ç›®æ ‡APIC IDã€vectorã€ä¼ è¾“æ¨¡å¼å’Œè§¦å‘æ¨¡å¼ç­‰ä¿¡æ¯ï¼‰äº§ç”Ÿä¸€ä¸ªNotification Eventï¼ŒåŒæ—¶å°†ONç½®ä½ã€‚</p><p>ç¡¬ä»¶åœ¨å¯¹PIDè¿›è¡Œä¿®æ”¹çš„æ—¶å€™ï¼Œè¦ä¿è¯è¯¥ä¿®æ”¹æ˜¯åŸå­æ“ä½œï¼Œå³å¯¹PIDçš„è¯»å–ã€ä¿®æ”¹å’Œå†™å…¥å¿…é¡»æ˜¯åŸå­æ“ä½œï¼Œå¹¶ä¸”åœ¨å†™å…¥ä¹‹åï¼Œè¦ä¿è¯ç›¸åº”å†…å­˜åœ¨å„ä¸ªcache agentä¹‹é—´çš„ä¸€è‡´æ€§ï¼Œå³æ‰€æœ‰çš„CPUåº”è¯¥ç«‹é©¬èƒ½å¤Ÿçœ‹åˆ°è¯¥å†…å­˜ä¿®æ”¹ã€‚</p><h4 id="3-5-the-relationship-with-CPU-based-Posted-interrupt"><a href="#3-5-the-relationship-with-CPU-based-Posted-interrupt" class="headerlink" title="3.5 the relationship with CPU-based Posted-interrupt"></a>3.5 the relationship with CPU-based Posted-interrupt</h4><p>CPU-based Posted-interruptéœ€è¦ä¸IOMMUååŒå·¥ä½œæ‰èƒ½å®ç°VT-d Posted Interrupt featureã€‚</p><p>æœ‰ä¸‰ç‚¹éœ€è¦æ³¨æ„ï¼š</p><ol><li>enable APICv</li><li>è®¾ç½®VMCSçš„posted-interrupt descriptorï¼Œè¿™æ­£æ˜¯IRTEä¸­Posted Descriptor Address Low/Highæ‰€è®¾ç½®çš„å€¼ã€‚</li><li>è®¾ç½®VMCSçš„posted-interrupt notification vectorä¸ºANV(ä¸‹èŠ‚ä¼šè¯¦ç»†ä»‹ç»)ã€‚</li></ol><p><img src="/images/2020/10/13.PNG" alt><br><img src="/images/2020/10/14.PNG" alt></p><h3 id="4-ä¸åŒvCPUçŠ¶æ€ä¸‹çš„å·®å¼‚åŒ–å¤„ç†"><a href="#4-ä¸åŒvCPUçŠ¶æ€ä¸‹çš„å·®å¼‚åŒ–å¤„ç†" class="headerlink" title="4. ä¸åŒvCPUçŠ¶æ€ä¸‹çš„å·®å¼‚åŒ–å¤„ç†"></a>4. ä¸åŒvCPUçŠ¶æ€ä¸‹çš„å·®å¼‚åŒ–å¤„ç†</h3><h4 id="4-1-Background"><a href="#4-1-Background" class="headerlink" title="4.1 Background"></a>4.1 Background</h4><p>åœ¨vCPUè°ƒåº¦çš„è¿‡ç¨‹ä¸­ï¼ŒvCPUä¼šæœ‰å¦‚ä¸‹ä¸‰ç§çŠ¶æ€:</p><ol><li>å½“vCPUè¢«scheduleré€‰ä¸­æ¥è¿è¡Œçš„æ—¶å€™ï¼Œæ­¤æ—¶vCPUçš„çŠ¶æ€ä¸ºâ€™activeâ€™ã€‚</li><li>å½“vCPUè¢«æŠ¢å ï¼ˆPreemptedï¼‰ï¼Œä¾‹å¦‚æ—¶é—´ç‰‡åˆ°æœŸäº†ï¼Œæ­¤æ—¶vCPUçš„çŠ¶æ€ä¸ºâ€™ready-to-runâ€™ã€‚</li><li>å½“vCPUæ‰§è¡Œäº†<code>hlt</code>æŒ‡ä»¤æˆ–è€…è§¦å‘äº†<a href="/2020/10/23/Some-notes-about-pause-loop-exiting/">ple</a>ï¼Œhvä¹Ÿä¼šå¹²é¢„è¿›æ¥å°†vCPUç»™blockå‡ºæ¥ï¼Œæ­¤æ—¶vCPUçŠ¶æ€ä¸ºâ€™halted â€˜ã€‚</li></ol><h4 id="4-2-ANV-and-WNV"><a href="#4-2-ANV-and-WNV" class="headerlink" title="4.2 ANV and WNV"></a>4.2 ANV and WNV</h4><p>hvéœ€è¦ä¸ºæ¯ä¸ªvCPUåˆ†é…ç‰©ç†ä¸­æ–­vector:<br>ç¬¬ä¸€ä¸ªç§°ä½œActive Notification Vectorï¼ˆANVï¼‰ï¼Œè¯¥Vectorå¯¹åº”åˆ°vCPUçš„çŠ¶æ€ä¸ºactiveæ—¶ï¼ŒNotification Eventæ‰€ä½¿ç”¨çš„ä¸­æ–­vector(éœ€è¦è®¾ç½®VMCSçš„posted-interrupt notification vectorä¸ºANV)ã€‚</p><p>ç¬¬äºŒä¸ªç§°ä½œWake-up Notification Vectorï¼ˆWNVï¼‰ï¼Œè¯¥Vectorå¯¹åº”åˆ°ç›®æ ‡vCPUä¸åœ¨å½“å‰ç‰©ç†CPUä¸Šæ‰§è¡Œæ—¶ï¼Œç”±äºUrgentè¢«ç½®èµ·æ¥äº§ç”Ÿçš„Notification Eventæ‰€ä½¿ç”¨çš„ä¸­æ–­Vectorã€‚</p><blockquote><p>åœ¨activeçŠ¶æ€ä¸‹ï¼ŒPID.NVçš„å€¼å°±æ˜¯ANVã€‚åœ¨ready-to-runæˆ–è€…haltedçŠ¶æ€ä¸‹ï¼ŒPID.NVçš„å€¼å°±æ˜¯WNVã€‚è¿™é‡Œçš„ANVå’ŒWNVå¯ä»¥æ˜¯åŒä¸€ä¸ªå€¼ã€‚</p></blockquote><p>hvéœ€è¦ä¿è¯çš„æ˜¯ï¼šè¿è¡Œåœ¨åŒä¸€ä¸ªpCPUä¸Šçš„æ‰€æœ‰vCPUçš„PID.NVå€¼ä¸åŒã€‚</p><p>è¯¦æƒ…å¯å‚è€ƒ:<a href="https://projectacrn.github.io/latest/developer-guides/hld/hv-dev-passthrough.html#vt-d-interrupt-remapping" target="_blank" rel="noopener">ACRN posted interrupt</a></p><h4 id="4-3-vCPU-Scheduling"><a href="#4-3-vCPU-Scheduling" class="headerlink" title="4.3 vCPU Scheduling"></a>4.3 vCPU Scheduling</h4><p><img src="/images/2020/10/12.PNG" alt></p><p>åªéœ€ç†è§£çŠ¶æ€è½¬æ¢ï¼Œå¯¹äºâ€˜NVâ€™çš„è®¾ç½®æ˜¯hv specificçš„ï¼Œæ— éœ€æ·±ç©¶ã€‚</p><h4 id="4-4-vCPU-is-active-when-Notification-Event-happen"><a href="#4-4-vCPU-is-active-when-Notification-Event-happen" class="headerlink" title="4.4 vCPU is active when Notification Event happen"></a>4.4 vCPU is active when Notification Event happen</h4><p>gueståœ¨Non-Rootä¸‹å°±èƒ½ç›´æ¥å¤„ç†æ­¤ä¸­æ–­ï¼Œè€Œä¸éœ€è¦hvçš„å‚ä¸ã€‚</p><p>è¯¦ç»†æ­¥éª¤è¯·å‚è€ƒï¼š<a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/#posted-interrupt" target="_blank" rel="noopener">Posted Interrupt</a></p><h4 id="4-5-vCPU-is-ready-to-run-or-halted-when-Notification-Event-happen"><a href="#4-5-vCPU-is-ready-to-run-or-halted-when-Notification-Event-happen" class="headerlink" title="4.5 vCPU is ready-to-run or halted when Notification Event happen"></a>4.5 vCPU is ready-to-run or halted when Notification Event happen</h4><p>WNVçš„handler:</p><p>å¦‚æœvCPUçš„stateä¸ºhaltedï¼Œåˆ™éœ€è¦å…ˆå°†vCPUçš„çŠ¶æ€è®¾ç½®ä¸ºready-to-runã€‚</p><p>handlerä¼šè°ƒåº¦vCPUã€‚</p><p>æ‰«æPID.PIR,æ£€æµ‹æ˜¯å¦æœ‰å¤„äºpendingçŠ¶æ€çš„posted interruptè¯·æ±‚ï¼›å¦‚æœæœ‰å¤„äºpendingçŠ¶æ€çš„posted interruptè¯·æ±‚ï¼Œhvä¼šåœ¨LAPICä¸Šç”Ÿæˆä¸€ä¸ªvectorå·ä¸ºANVçš„self-IPI(æ³¨æ„ï¼šåœ¨è¿˜æœªçœŸæ­£enter guestä¹‹å‰,å½“å‰ç‰©ç†CPUå¤„äºå…³ä¸­æ–­çŠ¶æ€)ã€‚ å½“è¿›å…¥Non-Rootæ¨¡å¼æ—¶ï¼Œç‰©ç†IRRå¯„å­˜å™¨ä¸­çš„ANVä½ä¼šè¢«ç½®ä¸Šï¼Œç¡¬ä»¶(CPU)ä¼šå¤„ç†posted interruptã€‚è¯¥ä¸­æ–­çš„å¤„ç†ç±»ä¼¼äºvCPUå¤„äºactiveçŠ¶æ€æ—¶ï¼Œæ¥æ”¶åˆ°äº†ANVçš„ä¸­æ–­è¯·æ±‚ï¼ŒvCPUå¯ä»¥ç›´æ¥å¯¹å…¶è¿›è¡Œå¤„ç†ï¼Œä¸éœ€è¦hvçš„å‚ä¸ã€‚</p><h3 id="5-summary"><a href="#5-summary" class="headerlink" title="5. summary"></a>5. summary</h3><p>VT-d PI advantages</p><ul><li>External interrupts from direct-assigned devices are delivered to guest running in non-root mode directly</li><li>Improve Interrupt virtualization efficiency, e.g. Less VM-Exits.</li><li>Simplify interrupt migration<ul><li>æ›´æ–°PID.NDST</li><li>å¦‚æœper-PCPUçš„IDTå‘é‡ç®¡ç†ä¸ä¸€æ ·ï¼Œè¿˜éœ€è¦æ›´æ–°PCPU IDTçš„vector<br><img src="/images/2020/10/17.PNG" alt></li></ul></li><li>Consume less physical interrupts</li></ul><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li><a href="https://kernelgo.org/posted-interrupt.html" target="_blank" rel="noopener">fangying:VT-d Posted Interrupt</a></li><li><a href="https://zhuanlan.zhihu.com/p/51018597" target="_blank" rel="noopener">æ²³é©¬ Intel VT-dï¼ˆ4ï¼‰- Interrupt Posting</a></li><li><a href="https://events.static.linuxfound.org/sites/events/files/slides/VT-d%20Posted%20Interrupts-final%20.pdf" target="_blank" rel="noopener">Feng Wu:VT-d Posted Interrupts </a></li><li><a href="https://lettieri.iet.unipi.it/virtualization/2018/passthrough.pdf" target="_blank" rel="noopener">Hardware passthrough</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡å°†ä»‹ç»VT-d Posted Interruptçš„ç›¸å…³å†…å®¹ã€‚é¦–å…ˆä¼šä»¥ä¸€ä¸ªä¾‹å­ä»‹ç»Posted interruptçš„motivationï¼›ç„¶åè¯¦ç»†é˜è¿°æ¶‰åŠåˆ°çš„ç¡¬ä»¶å’Œè½¯ä»¶ç»†èŠ‚ï¼›æ¥ä¸‹æ¥ä¼šä»‹ç»ä¸åŒvCPUçŠ¶æ€ä¸‹çš„å·®å¼‚åŒ–å¤„ç†ï¼›æœ€åæ€»ç»“ä¸‹æœ¬æ–‡ã€‚
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
  <entry>
    <title>VT-d Interrupt Remapping</title>
    <link href="http://liujunming.github.io/2020/10/10/VT-d-Interrupt-Remapping/"/>
    <id>http://liujunming.github.io/2020/10/10/VT-d-Interrupt-Remapping/</id>
    <published>2020-10-10T11:20:19.000Z</published>
    <updated>2020-10-13T22:52:43.868Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡å°†ä»‹ç»VT-d Interrupt Remappingçš„motivationï¼Œç„¶åæ¨èä¸€ç¯‡ä»‹ç»Interrupt Remappingç»†èŠ‚çš„æ–‡ç« ï¼Œæœ€åä»¥ä¸€ä¸ªå…·ä½“çš„ä¾‹å­æ¥å±•ç¤ºVT-d Interrupt Remappingçš„ç”¨æ³•ã€‚<a id="more"></a></p><h3 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h3><ol><li>Supporting isolation and routing of interrupts from devices and external interrupt controllers to appropriate VMs.</li><li>Supporting x2APIC</li></ol><h3 id="details"><a href="#details" class="headerlink" title="details"></a>details</h3><p>å¯ä»¥è¯¦ç»†é˜…è¯»æ­¤æ–‡ã€‚<br><a href="https://kernelgo.org/interrupt-remapping.html" target="_blank" rel="noopener">https://kernelgo.org/interrupt-remapping.html</a></p><h3 id="demo-usage"><a href="#demo-usage" class="headerlink" title="demo usage"></a>demo usage</h3><p><img src="/images/2020/10/6.PNG" alt></p><p>ä»¥ä¸Šå›¾ä¸ºä¾‹ï¼Œå°†å±•ç¤ºVT-d Interrupt Remappingçš„å…·ä½“è¿‡ç¨‹ã€‚</p><ol><li>å½“guesté…ç½®MSI addresså’ŒMSI dataæ—¶ï¼Œhypervisor(hv)ä¼štrapï¼Œè§£æç›¸å…³fieldï¼Œå¾—åˆ°virtual interruptçš„vectorä¸º30ï¼Œè€Œå¯¹åº”çš„physical interruptçš„vectorä¸º60ã€‚è¿™æ ·hvä¼šè®°å½•physical interruptåˆ°virtual interruptçš„æ˜ å°„(vector 60 -&gt; vector 30)ã€‚</li><li>åˆ†é…ä¸€ä¸ªIRTEå¹¶ä¸”æŒ‰ç…§IRTEçš„æ ¼å¼è¦æ±‚å¡«å¥½IRTEçš„æ¯ä¸ªå±æ€§ã€‚å¦‚ï¼šB:D.F, Vector(60), è¿è¡Œç›®æ ‡vCPUçš„ç‰©ç†CPUçš„LAPIC IDã€‚</li><li>æŒ‰ç…§Remapping formatçš„æ ¼å¼å¯¹MSIè¿›è¡Œç¼–ç¨‹ã€‚å¦‚ï¼šå°†Interrupt Formatç½®1ï¼Œè®¾ç½®ä¸­æ–­çš„interrupt_indexã€‚</li><li>è®¾ç½®VMCS(configured to cause vmexit on external interrupt)ã€‚å½“ç‰©ç†CPUæ”¶åˆ°vectorä¸º60çš„ä¸­æ–­æ—¶ï¼Œä¼šå‘ç”ŸVM-Exitã€‚</li><li>hvå¤„ç†VM-Exitï¼Œæ ¹æ®physical interruptåˆ°virtual interruptçš„æ˜ å°„(vector 60 -&gt; vector 30)å…³ç³»ï¼Œä¸ºguestæ³¨å…¥vectorä¸º30çš„interruptã€‚</li><li>VM-Entryåˆ°guest VMï¼Œprocess vectorä¸º30çš„interruptã€‚</li></ol><h3 id="rethinking-the-motivation"><a href="#rethinking-the-motivation" class="headerlink" title="rethinking the motivation"></a>rethinking the motivation</h3><p><img src="/images/2020/10/19.PNG" alt></p><p><img src="/images/2020/10/20.PNG" alt></p><p>ä¸¤è€…å¯ä»¥å®Œæˆç›¸åŒçš„åŠŸèƒ½ã€‚é‚£ä¹ˆä¸ºä»€ä¹ˆè¿˜è¦æœ‰VT-d Interrupt Remappingå‘¢ï¼Ÿ</p><p>åœ¨<a href="https://invisiblethingslab.com/resources/2011/Software%20Attacks%20on%20Intel%20VT-d.pdf" target="_blank" rel="noopener">Following the White Rabbit:Software attacks against Intel(R) VT-d technology</a>ä¸€æ–‡ä¸­æ‰¾åˆ°äº†ç­”æ¡ˆï¼švulnerable to the BDF spoofing attackã€‚</p><blockquote><p>Even though the interrupt remapping seems vulnerable to the BDF spoofing attack (just like DMA<br>remapping is), still we believe it has a potential to prevent all the above-mentioned MSI attacks, because we anticipate that none of the interrupt vector used in our attacks should be allowed to any devices in the system. In that case, BDF spoofing would not bring any advantage to the attacker, as there should be no device at all that the attacker might want to impersonate, which could deliver those dangerous interrupts, such as SIPI, syscall interrupts, or the #AC exception.</p></blockquote><blockquote><p>BDF spoofing is a type of a hardware attack against VT-d, where a malicious device generates PCIe packets with spoofed BDF address. </p></blockquote><p>è¯´ç™½äº†ï¼ŒVT-d Interrupt Remappingå¯ä»¥è§£å†³securityé—®é¢˜ã€‚</p><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li><a href="https://compas.cs.stonybrook.edu/~nhonarmand/courses/sp17/cse506/slides/hw_io_virtualization.pdf" target="_blank" rel="noopener">I/O Virtualization with Hardware Support</a></li><li><a href="https://invisiblethingslab.com/resources/2011/Software%20Attacks%20on%20Intel%20VT-d.pdf" target="_blank" rel="noopener">Following the White Rabbit:Software attacks against Intel(R) VT-d technology</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡å°†ä»‹ç»VT-d Interrupt Remappingçš„motivationï¼Œç„¶åæ¨èä¸€ç¯‡ä»‹ç»Interrupt Remappingç»†èŠ‚çš„æ–‡ç« ï¼Œæœ€åä»¥ä¸€ä¸ªå…·ä½“çš„ä¾‹å­æ¥å±•ç¤ºVT-d Interrupt Remappingçš„ç”¨æ³•ã€‚
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about APICv MSR-Based APIC Accesses</title>
    <link href="http://liujunming.github.io/2020/10/10/Some-notes-about-APICv-MSR-Based-APIC-Accesses/"/>
    <id>http://liujunming.github.io/2020/10/10/Some-notes-about-APICv-MSR-Based-APIC-Accesses/</id>
    <published>2020-10-10T05:11:33.000Z</published>
    <updated>2020-10-10T23:34:43.823Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/#msr-based-apic-accesses" target="_blank" rel="noopener">MSR-Based APIC Accesses</a></p><ol><li><p>Secondary Processor-Based VM-Execution Controls.Virtualize x2APIC Mode[bit 4] = 1æ—¶ï¼ŒVMCSä¸­x2APIC MSR Bitmapçš„è®¾ç½®ä¾ç„¶æœ‰æ•ˆã€‚</p></li><li><p>WRMSR ICR, no APIC Write VM Exit, has potential security issues?<br>Solution: set VMCS MSR Bitmap to trap ICR register write.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/#msr-based-apic-accesses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MSR-Based APIC Ac
      
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about Interrupt Window and NMI Window</title>
    <link href="http://liujunming.github.io/2020/10/09/Some-notes-about-Interrupt-Window/"/>
    <id>http://liujunming.github.io/2020/10/09/Some-notes-about-Interrupt-Window/</id>
    <published>2020-10-09T03:25:32.000Z</published>
    <updated>2020-10-13T10:58:47.613Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡ä¸»è¦ä»‹ç»Interrupt Windowå’ŒNMI Windowçš„ç›¸å…³çŸ¥è¯†ç‚¹ã€‚<a id="more"></a></p><p>å¼ºçƒˆå»ºè®®åœ¨<a href="http://mmc.geofisica.unam.mx/acl/Textos/MaquinasVirtuales/CursoMaquinasVirtuales/Bibliograf%C3%ADaMaquinasVirtuales/Vtx.pdf" target="_blank" rel="noopener">Vtx.pdf</a>æœç´¢Interrupt-window Exitingã€‚</p><blockquote><p>Interrupt-window Exiting. The interrupt-window exiting control bit in the VM-execution controls causes VM exits when guest RFLAGS.IF is 1 and no other conditions block external interrupts. If the control is 1, a VM exit occurs at the beginning of any instruction at which RFLAGS.IF = 1 and on which the interruptibility state of the guest would allow delivery of an interrupt. For example: when the guest executes an STI instruction, RFLAGS = 1, and if at the completion of next instruction the interruptibility state masking due to STI is removed; a VM exit occurs if interruptwindow exiting control is 1. The interrupt-window exiting feature allows a VMM to queue a virtual interrupt to the guest when the guest is not in an interruptible state. The VMM can set the interrupt-window exiting control for the guest and depend on a VM exit to know when the guest becomes interruptible (and, therefore, when it can inject a virtual interrupt). The VMM can detect such VM exits by checking for the basic exit reason â€˜interrupt-windowâ€™ (value = 7). Without interrupt-window exiting support, the VMM will need to poll and check the interruptibility state of the guest to deliver virtual interrupts.</p></blockquote><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><ol><li>IRRä¸å—IF(RFLAGS.IF)ä½çš„å½±å“ã€‚</li><li>äº‹ä»¶æ³¨å…¥æ§åˆ¶:<br><img src="/images/2020/10/5.PNG" alt></li></ol><h3 id="2-Interrupt-Window"><a href="#2-Interrupt-Window" class="headerlink" title="2. Interrupt Window"></a>2. Interrupt Window</h3><p>å¦‚æœGuestæ­£å¤„åœ¨å±è”½å¤–éƒ¨ä¸­æ–­çš„çŠ¶æ€ï¼Œå³Guestçš„<code>RFLAGS.IF = 0</code>æˆ–<em>Guest Non-Register State.Interruptibility State</em>ï¼ˆ<code>VMCS[0x4824](32 bit)</code>ï¼‰çš„Bit 0 (Blocking by STI)å’ŒBit 1 (Blocking by MOV-SS)ä¸å…¨ä¸ºé›¶ï¼Œå°†ä¸å…è®¸åœ¨VM Entryæ—¶è¿›è¡ŒEvent Injectionã€‚ä¸ºäº†å‘vCPUæ³¨å…¥ä¸­æ–­ï¼Œå¯ä»¥ä¸´æ—¶è®¾ç½®<em>Primary Processor-Based VM-Execution Controls.Interrupt-Window Exiting</em> = 1ï¼Œç„¶åä¸»åŠ¨VM Entryè¿›å…¥Non-rootæ¨¡å¼ã€‚ä¸€æ—¦CPUè¿›å…¥èƒ½å¤Ÿæ¥æ”¶ä¸­æ–­çš„çŠ¶æ€ï¼Œå³<code>RFLAGS.IF = 1</code>ä¸”<em>Interruptibility State</em>[1:0] = 0ï¼Œä¾¿ä¼šäº§ç”Ÿä¸€ä¸ªVM Exitï¼ˆ<code>VM Exit No.7</code> <strong>Interrupt Window</strong>ï¼‰ï¼Œæ­¤æ—¶Hypervisorä¾¿å¯æ³¨å…¥åˆšæ‰æ— æ³•æ³¨å…¥çš„ä¸­æ–­ï¼Œå¹¶å°†<em>Interrupt-Window Exiting</em>é‡ç½®ä¸º0ã€‚</p><p>å€¼å¾—æ³¨æ„çš„æ˜¯ï¼šå³ä½¿Guestçš„<code>RFLAGS.IF = 0</code>,Guestçš„IRRå¯„å­˜å™¨ä¾ç„¶ä¼šç½®ä½ï¼Œè¿™ä¸ªè¡Œä¸ºéœ€è¦ä¸nativeä¿æŒä¸€è‡´ã€‚</p><h3 id="3-NMI-Windows"><a href="#3-NMI-Windows" class="headerlink" title="3. NMI Windows"></a>3. NMI Windows</h3><p>Backgroundå¯ä»¥å‚è€ƒ<a href="/2020/10/09/Some-notes-about-x86-interrupt-preemption/">Some notes about x86 interrupt preemption</a>ã€‚</p><blockquote><p>NMI-window Exiting. If the â€œvirtual NMIsâ€ VM-execution is set, the processor tracks virtual-NMI blocking. The NMI-window exiting control bit in VM-execution controls causes VM exits when there is no virtualNMI blocking. For example, after execution of the IRET instruction, a VM exit occurs if NMIwindow exiting control is 1. The NMI-window exiting feature allows a VMM to queue a virtual NMI to a guest when the guest is not ready to receive NMIs. The VMM can set the NMI-window exiting control for the guest and depend on a VM exit to know when the guest becomes ready for NMIs (and, therefore, when it can inject a virtual NMI). The VMM can detect such VM exits by checking for the basic exit reason â€˜NMI windowâ€™ (value = 8). Without NMI-window exiting support, the VMM will need to poll and check the interruptibility state of the guest to deliver virtual NMIs.</p></blockquote><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li><a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/" target="_blank" rel="noopener">Intel SDM Chapter 29: APIC Virtualizaton &amp; Virtual Interrupts</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡ä¸»è¦ä»‹ç»Interrupt Windowå’ŒNMI Windowçš„ç›¸å…³çŸ¥è¯†ç‚¹ã€‚
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about x86 interrupt preemption</title>
    <link href="http://liujunming.github.io/2020/10/09/Some-notes-about-x86-interrupt-preemption/"/>
    <id>http://liujunming.github.io/2020/10/09/Some-notes-about-x86-interrupt-preemption/</id>
    <published>2020-10-09T00:05:47.000Z</published>
    <updated>2020-10-09T03:43:15.063Z</updated>
    
    <content type="html"><![CDATA[<p>x86 disables all local interrupts (except NMI of course) before jumping to the interrupt vector. </p><p>NMIå¯ä»¥æ‰“æ–­é™¤NMIä»¥å¤–çš„ä»»æ„ä¸­æ–­çš„å¤„ç†ã€‚<br><a id="more"></a><br>ç»“è®ºè¯´å®Œäº†ï¼Œä»‹ç»ä¸‹backgroundå§ã€‚</p><blockquote><p>If an interrupt or exception handler is called through an interrupt gate, the processor clears the interrupt enable (IF) flag in the EFLAGS register to prevent subsequent interrupts from interfering with the execution of the handler. </p></blockquote><p>From SDM Volume 1</p><blockquote><p>While an NMI interrupt handler is executing, the processor blocks delivery of subsequent NMIs until the next execution of the IRET instruction. This blocking of NMIs prevents nested execution of the NMI handler</p></blockquote><p>From SDM Volume 3</p><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li><a href="https://stackoverflow.com/questions/11403915/can-an-interrupt-handler-be-preempted-by-the-same-interrupt-handler" target="_blank" rel="noopener">Can an interrupt handler be preempted by the same interrupt handler?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;x86 disables all local interrupts (except NMI of course) before jumping to the interrupt vector. &lt;/p&gt;
&lt;p&gt;NMIå¯ä»¥æ‰“æ–­é™¤NMIä»¥å¤–çš„ä»»æ„ä¸­æ–­çš„å¤„ç†ã€‚&lt;br&gt;
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>The motivation of APICv</title>
    <link href="http://liujunming.github.io/2020/10/08/The-motivation-of-APICv/"/>
    <id>http://liujunming.github.io/2020/10/08/The-motivation-of-APICv/</id>
    <published>2020-10-08T10:35:32.000Z</published>
    <updated>2020-10-08T14:04:17.109Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡å†…å®¹è½¬è½½è‡ª:<a href="https://software.intel.com/content/www/us/en/develop/blogs/apic-virtualization-performance-testing-and-iozone.html" target="_blank" rel="noopener">APIC Virtualization Performance Testing and Iozone*</a>ã€‚</p><a id="more"></a><p>Virtual machine monitors (VMM) emulate most guest access to interrupts and the advanced programmable interrupt controller (APIC) in a virtual environment.  They also virtualize all guest interrupts. These activities require the exit and reentry of the virtual machines (VM), but they are time consuming and are a major source of overhead.  in order to minimize that effect, the latest Intel(R) Xeon(R) processors, such as the Intel(R) Xeon(R) E5-2600 v2 Product Family, emulate those activities in the hardware. </p><p><img src="/images/2020/10/4.jpg" alt></p><center>Figure 1 - VM-VMM interaction with and without APICv</center><p>Figure 1 shows that all virtualized activities relating interrupts and APIC to and from the guest OS have to go through VMM in systems without APICv; however, in systems with APICv, they are executed in the hardware, not in the VMM.  This way all activities can stay inside the VM, thus eliminating the need to issue the â€œVM exitâ€ command; this change results in reduced overhead and increased I/O throughput.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡å†…å®¹è½¬è½½è‡ª:&lt;a href=&quot;https://software.intel.com/content/www/us/en/develop/blogs/apic-virtualization-performance-testing-and-iozone.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;APIC Virtualization Performance Testing and Iozone*
&lt;/a&gt;ã€‚&lt;/p&gt;
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to CPU-based Posted-interrupt</title>
    <link href="http://liujunming.github.io/2020/10/07/Introduction-to-Posted-interrupt/"/>
    <id>http://liujunming.github.io/2020/10/07/Introduction-to-Posted-interrupt/</id>
    <published>2020-10-07T12:46:55.000Z</published>
    <updated>2020-10-09T04:20:36.209Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡ä¸»è¦æ˜¯å¯¹SDM CPU-based <a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/#posted-interrupt" target="_blank" rel="noopener">Posted Interrupt</a>åšç›¸å…³è¡¥å……ã€‚å¯¹äºVT-dçš„Posted-interruptï¼Œæœ¬æ–‡å¹¶ä¸æ¶‰åŠã€‚</p><a id="more"></a><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>Virtual-Interrupt Deliveryåˆ©ç”¨ç¡¬ä»¶åŠŸèƒ½è§£å†³äº†å¦‚ä¸‹ä¸¤ä¸ªé—®é¢˜ï¼šç¬¬ä¸€ä¸ªæ˜¯éœ€è¦Hypervisoræ‰‹åŠ¨æ¨¡æ‹ŸInterrupt Acknowledgement(è¦å…ˆä»IRRä¸­å–å‡ºæœ€é«˜ä¼˜å…ˆçº§çš„ä¸­æ–­ï¼Œè®¾ç½®ISRä¸­å¯¹åº”ä½)ã€Interrupt Delivery(EOI)ï¼›ç¬¬äºŒä¸ªæ˜¯æœ‰æ—¶éœ€è¦äº§ç”Ÿ<strong>Interrupt Window</strong> VM Exitä»¥æ­£ç¡®æ³¨å…¥ä¸­æ–­ã€‚</p><p>Posted Interruptæ˜¯å¯¹Virtual-Interrupt Deliveryçš„è¿›ä¸€æ­¥å‘å±•ï¼Œè®©æˆ‘ä»¬å¯ä»¥çœç•¥Interrupt Acceptanceçš„è¿‡ç¨‹ï¼Œç›´æ¥ä»¤æ­£åœ¨è¿è¡Œçš„vCPUæ”¶åˆ°ä¸€ä¸ªè™šå‡ä¸­æ–­ï¼Œè€Œä¸äº§ç”ŸVM Exitã€‚å®ƒå¯ä»¥å‘æ­£åœ¨è¿è¡Œçš„vCPUæ³¨å…¥ä¸­æ–­ï¼Œé…åˆVT-dçš„Posted InterruptåŠŸèƒ½ï¼Œè¿˜å¯ä»¥å®ç°Passthroughè®¾å¤‡çš„ä¸­æ–­ç›´æ¥å‘ç»™vCPUè€Œä¸å¼•èµ·VM Exitã€‚</p><h3 id="CPU-based-Posted-Interrupt-Processing"><a href="#CPU-based-Posted-Interrupt-Processing" class="headerlink" title="CPU-based Posted-Interrupt Processing"></a>CPU-based Posted-Interrupt Processing</h3><p><img src="/images/2020/10/1.PNG" alt><br><img src="/images/2020/10/2.PNG" alt></p><h3 id="Usage-Examples-and-Enabling-Posted-Interrupt-Processing-in-KVM"><a href="#Usage-Examples-and-Enabling-Posted-Interrupt-Processing-in-KVM" class="headerlink" title="Usage Examples and Enabling Posted-Interrupt Processing in KVM"></a>Usage Examples and Enabling Posted-Interrupt Processing in KVM</h3><p><img src="/images/2020/10/3.PNG" alt><br>Send the event notification:ç»™vCPUæ‰€åœ¨çš„CPUå‘é€ä¸€ä¸ªNotification Eventï¼Œå³ä¸­æ–­å‘é‡å·ä¸ºPosted-Interrupt Notification Vectorçš„ä¸­æ–­ã€‚</p><blockquote><p>å‡è®¾ç°åœ¨æƒ³ç»™ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„vCPUæ³¨å…¥ä¸­æ–­ï¼Œé™¤éè¯¥vCPUæ­£åœ¨å¤„ç†ä¸­æ–­ï¼Œå¦åˆ™ä»…å‡­Virtual-Interrupt Deliveryï¼Œä»éœ€è¦ä»¤å…¶VM Exitå¹¶è®¾ç½®RVIï¼Œä»¥ä¾¿åœ¨VM Entryæ—¶è§¦å‘Virtual-Interrupt Deliveryã€‚è‹¥ä½¿ç”¨Posted Interruptï¼Œåˆ™å¯ä»¥è®¾ç½®PIRä¸­å¯¹åº”ä½ï¼Œç„¶åç»™vCPUæ‰€åœ¨çš„CPUå‘é€ä¸€ä¸ªNotification Eventï¼Œå³ä¸­æ–­å‘é‡å·ä¸ºPosted-Interrupt Notification Vectorçš„ä¸­æ–­ï¼Œè¿™æ ·vCPUæ— éœ€VM Exitå°±å¯ä»¥è¢«æ³¨å…¥ä¸€ä¸ªç”šè‡³å¤šä¸ªä¸­æ–­ã€‚</p></blockquote><hr><p>å‚è€ƒé“¾æ¥ï¼š</p><ol><li><a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/" target="_blank" rel="noopener">Intel SDM Chapter 29: APIC Virtualizaton &amp; Virtual Interrupts</a></li><li><a href="https://www.linux-kvm.org/images/7/70/2012-forum-nakajima_apicv.pdf" target="_blank" rel="noopener">Enabling Optimized Interrupt/APIC Virtualization in KVM </a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡ä¸»è¦æ˜¯å¯¹SDM CPU-based &lt;a href=&quot;https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch29/#posted-interrupt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Posted Interrupt&lt;/a&gt;åšç›¸å…³è¡¥å……ã€‚å¯¹äºVT-dçš„Posted-interruptï¼Œæœ¬æ–‡å¹¶ä¸æ¶‰åŠã€‚&lt;/p&gt;
    
    </summary>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/categories/%E4%B8%AD%E6%96%AD/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="ä¸­æ–­" scheme="http://liujunming.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about CVE-2016-5195</title>
    <link href="http://liujunming.github.io/2020/10/05/Some-notes-about-CVE-2016-5195/"/>
    <id>http://liujunming.github.io/2020/10/05/Some-notes-about-CVE-2016-5195/</id>
    <published>2020-10-05T05:51:00.000Z</published>
    <updated>2020-10-07T17:01:32.903Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡ä¸»è¦æ˜¯å¯¹<a href="https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails" target="_blank" rel="noopener">CVE-2016-5195</a>åšç›¸å…³çš„notesã€‚<a id="more"></a><br><a href="http://huntcve.github.io/2017/07/04/dirtycow/" target="_blank" rel="noopener">DirtyCow æ¼æ´åˆ†æ2</a>åˆ†æçš„è¾ƒå¥½ã€‚</p><h3 id="detail"><a href="#detail" class="headerlink" title="detail"></a>detail</h3><ol><li>å¼ºè¡Œå†™å…¥çš„å†…å®¹è¢«å†™åˆ°<strong>å†…æ ¸COWå‡ºæ¥çš„æ‹·è´é¡µ</strong>ä¸­ï¼Œä¾›è¿›ç¨‹ä½¿ç”¨ã€‚</li><li>If CR0.WP = 0, data may be written to any supervisor-mode address. <em>ç”Ÿæˆä¸€ä¸ªæ–°çš„å¯å†™COWé¡µé¢ï¼Œå¹¶æ ‡è®°ä¸ºè„é¡µé¢ï¼ŒåŒæ—¶ä¿ç•™å…¶åªè¯»å±æ€§</em></li></ol><h3 id="material"><a href="#material" class="headerlink" title="material"></a>material</h3><ol><li><a href="https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails" target="_blank" rel="noopener">VulnerabilityDetails</a></li><li><a href="http://huntcve.github.io/2017/07/04/dirtycow/" target="_blank" rel="noopener">DirtyCow æ¼æ´åˆ†æ2</a></li><li><a href="https://www.anquanke.com/post/id/84851" target="_blank" rel="noopener">æ·±å…¥è§£è¯»è„ç‰›Linuxæœ¬åœ°ææƒæ¼æ´</a></li><li><a href="http://pwn4.fun/2017/07/14/Dirty-COW%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Dirty COWï¼ˆCVE-2016-5195ï¼‰æ¼æ´åˆ†æ</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡ä¸»è¦æ˜¯å¯¹&lt;a href=&quot;https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CVE-2016-5195&lt;/a&gt;åšç›¸å…³çš„notesã€‚
    
    </summary>
    
      <category term="Security" scheme="http://liujunming.github.io/categories/Security/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Security" scheme="http://liujunming.github.io/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about CVE-2018-12207</title>
    <link href="http://liujunming.github.io/2020/09/30/Some-notes-about-CVE-2018-12207/"/>
    <id>http://liujunming.github.io/2020/09/30/Some-notes-about-CVE-2018-12207/</id>
    <published>2020-09-30T12:10:05.000Z</published>
    <updated>2020-10-07T17:01:32.903Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡ä¸»è¦æ˜¯å¯¹<a href="https://software.intel.com/security-software-guidance/api-app/insights/deep-dive-machine-check-error-avoidance-page-size-change" target="_blank" rel="noopener">CVE-2018-12207</a>åšç›¸å…³çš„backgroundè¡¥å……ã€‚åŸæ–‡å†™çš„ç›¸å½“å¥½ï¼Œå»ºè®®è¯¦è¯»ã€‚<a id="more"></a></p><h3 id="Description-of-errata"><a href="#Description-of-errata" class="headerlink" title="Description of errata"></a>Description of errata</h3><p>Software sequences that may lead to machine check error code 0150H can be summarized as follows:</p><ol><li>Code is fetched from a linear address translated using a 4 KB translation cached in the ITLB.</li><li>Software modifies the paging structures so that the same linear address is translated using a large page (2 MB, 4 MB, or 1 GB) with a different physical address or memory type.</li><li>After the paging structure modification, but before software invalidates any ITLB entries for the linear address, code fetch happens again on the same linear address.</li><li>This may cause a machine-check error (IA32_MCi_STATUS.MCACOD=150H), which can result in a system hang or shutdown.</li></ol><h3 id="extension1"><a href="#extension1" class="headerlink" title="extension1"></a>extension1</h3><p>The VMM can use Extended Page Tables (EPT) to enforce that each guest physical address is 4 KB in size and that guest software cannot change the hardware page size for translations.</p><blockquote><p>For correctness, the TLB must consider the page size for a given translation to be the smaller of the nested and guest page sizes.</p></blockquote><p>From ASPLOSâ€™08 ã€ŠAccelerating Two-Dimensional Page Walksã€‹2.4 Large Page Sizeã€‚</p><h3 id="extension2"><a href="#extension2" class="headerlink" title="extension2"></a>extension2</h3><p>The sequence above requires bit 10 (Execute access for user-mode linear address) to be treated in the same manner as bit 2 when mode-based execution controls are active (the mode-based execute control for EPT feature is present and the VM execution control is set to 1).</p><ul><li><p>å„çº§é¡µè¡¨é¡¹çš„ç¬¬2ä½ä¸ºX (eXecute)ï¼Œå–1è¡¨ç¤ºå¯æ‰§è¡Œ</p><ul><li>è‹¥Secondary Processor-Based VM-Execution Controls.Mode-based execute control for EPT[bit 22]å–1ï¼Œåˆ™è¯¥ä½å–1ä»…è¡¨ç¤ºå¯¹äºGuestçš„å†…æ ¸é¡µå¯æ‰§è¡Œï¼Œä¸è¡¨ç¤ºå¯¹äºGuestçš„ç”¨æˆ·é¡µå¯æ‰§è¡Œ</li></ul></li><li><p>å„çº§é¡µè¡¨é¡¹çš„ç¬¬10ä½ä¸ºXU (eXecute for User)ï¼Œå–1è¡¨ç¤ºå¯¹äºGuestçš„ç”¨æˆ·é¡µå¯æ‰§è¡Œ</p><ul><li>ä»…å½“Secondary Processor-Based VM-Execution Controls.Mode-based execute control for EPT[bit 22]å–1æ—¶æœ‰æ•ˆï¼Œå¦åˆ™è¯¥ä½ä¼šè¢«å¿½ç•¥</li></ul></li></ul><p>From <a href="https://tcbbd.moe/ref-and-spec/intel-sdm/sdm-vmx-ch28/" target="_blank" rel="noopener">Intel SDM Chapter 28: VMX Support for Address Translation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡ä¸»è¦æ˜¯å¯¹&lt;a href=&quot;https://software.intel.com/security-software-guidance/api-app/insights/deep-dive-machine-check-error-avoidance-page-size-change&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CVE-2018-12207&lt;/a&gt;åšç›¸å…³çš„backgroundè¡¥å……ã€‚åŸæ–‡å†™çš„ç›¸å½“å¥½ï¼Œå»ºè®®è¯¦è¯»ã€‚
    
    </summary>
    
      <category term="Security" scheme="http://liujunming.github.io/categories/Security/"/>
    
    
      <category term="å†…å­˜ç®¡ç†" scheme="http://liujunming.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="Security" scheme="http://liujunming.github.io/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>Without EPT or SPT, guest still can access memory?</title>
    <link href="http://liujunming.github.io/2020/08/30/Without-EPT-or-SPT-guest-still-can-access-memory/"/>
    <id>http://liujunming.github.io/2020/08/30/Without-EPT-or-SPT-guest-still-can-access-memory/</id>
    <published>2020-08-30T01:28:10.000Z</published>
    <updated>2020-08-30T01:42:12.121Z</updated>
    
    <content type="html"><![CDATA[<p>Without EPT or SPT(shadow page table), guest can access memory?<br><a id="more"></a><br>åœ¨çœ‹kvm-unit-testæ—¶ï¼Œå‘ç°ï¼šæ²¡æœ‰ä¸ºgueståˆ›å»ºEPT or SPTï¼Œä½†æ˜¯ï¼Œguestä¾ç„¶å¯ä»¥è®¿é—®memoryï¼Œè¿™æ˜¯æ€ä¹ˆåšåˆ°çš„å‘¢ï¼Ÿ</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_vmcs_guest</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 26.3 CHECKING AND LOADING GUEST STATE */</span></span><br><span class="line">ulong guest_cr3;</span><br><span class="line"><span class="comment">/* 26.3.1.1 */</span></span><br><span class="line">guest_cr3 = read_cr3();</span><br><span class="line">...</span><br><span class="line">vmcs_write(GUEST_CR3, guest_cr3);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ç­”æ¡ˆä¾¿åœ¨ä¸Šè¿°ä»£ç ç‰‡æ®µä¸­ï¼šå°†hostçš„cr3èµ‹å€¼ç»™guestçš„cr3ã€‚è¿™æ ·ï¼Œç›´æ¥å°†MMU pass-thruç»™guestï¼Œå¹¶ä¸”guestå’Œhostå¤ç”¨ç›¸åŒçš„é¡µè¡¨ã€‚</p><p>è¿™æ ·æ¯”è¾ƒtrickyåšæ³•çš„ç¼ºç‚¹æ˜¯:å¤±å»äº†éš”ç¦»æ€§ã€‚</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Without EPT or SPT(shadow page table), guest can access memory?&lt;br&gt;
    
    </summary>
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Some notes about Queued Invalidation in VT-d</title>
    <link href="http://liujunming.github.io/2020/08/29/Some-notes-about-Queued-Invalidaion-in-VT-d/"/>
    <id>http://liujunming.github.io/2020/08/29/Some-notes-about-Queued-Invalidaion-in-VT-d/</id>
    <published>2020-08-29T12:48:47.000Z</published>
    <updated>2020-10-23T15:18:20.487Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡å°†ä»‹ç»VT-dä¸­Queued Invalidationçš„ç›¸å…³çŸ¥è¯†ç‚¹ã€‚<br><a id="more"></a></p><p>Queued Invalidationçš„è¯¦ç»†å†…å®¹è¯·å‚è€ƒVT-d spcçš„6.5.2èŠ‚ã€‚</p><h2 id="æ¦‚å¿µ"><a href="#æ¦‚å¿µ" class="headerlink" title="æ¦‚å¿µ"></a>æ¦‚å¿µ</h2><p>specä¸­çš„æè¿°å¦‚ä¸‹ï¼š</p><blockquote><p>The queued invalidation provides an advanced interface for software to submit invalidation requests to hardware and to synchronize invalidation completions with hardware.</p></blockquote><h2 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h2><blockquote><p>The queued invalidation interface uses IQ(Invalidation Queue), which is a circular buffer in system memory. Software submits commands by writing Invalidation Descriptors to the IQ. </p></blockquote><p><a href="https://github.com/projectacrn/acrn-hypervisor/blob/release_2.0/hypervisor/arch/x86/vtd.c#L546" target="_blank" rel="noopener">dmar_issue_qi_request</a>æ˜¯ç ”ç©¶Queued Invalidationçš„å…¥å£å‡½æ•°ã€‚</p><p>ä»æºç ä¸­å¯ä»¥çœ‹åˆ°ï¼Œacrnåœ¨invalid dmar context cache, invalid dmar iotlb, invalid dmar interrupt entry cacheæ—¶ï¼Œä¼šä½¿ç”¨åˆ°Queued Invalidationã€‚</p><p>acrnå‘QIä¸­submit ä¸€ä¸ªInvalidation Descriptoræ—¶ï¼Œç´§æ¥ç€ä¼šsubmit Invalidation Wait Descriptor(VT-d spec 6.5.2.8)ã€‚</p><p><img src="/images/2020/05/6.PNG" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">invalidate_desc_ptr-&gt;hi_64 = hva2hpa(&amp;qi_status);</span><br><span class="line">invalidate_desc_ptr-&gt;lo_64 = DMAR_INV_WAIT_DESC_LOWER;</span><br><span class="line">dmar_unit-&gt;qi_tail = (dmar_unit-&gt;qi_tail + DMAR_QI_INV_ENTRY_SIZE) % DMAR_INVALIDATION_QUEUE_SIZE;</span><br><span class="line"></span><br><span class="line">qi_status = DMAR_INV_STATUS_INCOMPLETE;</span><br><span class="line">iommu_write32(dmar_unit, DMAR_IQT_REG, dmar_unit-&gt;qi_tail);</span><br><span class="line"></span><br><span class="line">start = rdtsc();</span><br><span class="line"><span class="keyword">while</span> (qi_status != DMAR_INV_STATUS_COMPLETED) &#123;</span><br><span class="line"><span class="keyword">if</span> ((rdtsc() - start) &gt; CYCLES_PER_MS) &#123;</span><br><span class="line">pr_err(<span class="string">"DMAR OP Timeout! @ %s"</span>, __func__);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">asm_pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>å°†<code>&amp;qi_status</code>å†™å…¥Addr,å°†<code>DMAR_INV_STATUS_COMPLETED</code>å†™å…¥Status Data(è§ä¸Šå›¾)ï¼Œè¿™æ„å‘³ç€ï¼šå½“ç¡¬ä»¶å¤„ç†å®Œinvalidation requests æ—¶ï¼Œä¼šå°†<code>qi_status</code>çš„å€¼èµ‹å€¼ä¸º<code>DMAR_INV_STATUS_COMPLETED</code>ã€‚</p><p>è½¯ä»¶å…ˆå°†<code>qi_status</code>èµ‹å€¼ä¸º<code>DMAR_INV_STATUS_INCOMPLETE</code>ï¼Œç„¶åloopï¼Œç›´è‡³ç¡¬ä»¶å°†<code>qi_status</code>çš„å€¼èµ‹å€¼ä¸º<code>DMAR_INV_STATUS_COMPLETED</code>ã€‚</p><h2 id="details"><a href="#details" class="headerlink" title="details"></a>details</h2><p>Since information from the context-cache may be used to tag entries in the PASID-cache, IOTLB and paging-structure caches, software must always follow a context-cache invalidation with a PASID cache invalidation (if context-cache entry supports requests-with-PASID, or if Scalable Mode Translation is enabled), followed by an IOTLB invalidation. </p><p>context-cache invalidation and IOTLB invalidation has dependency relationship.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡å°†ä»‹ç»VT-dä¸­Queued Invalidationçš„ç›¸å…³çŸ¥è¯†ç‚¹ã€‚&lt;br&gt;
    
    </summary>
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="VT-d" scheme="http://liujunming.github.io/tags/VT-d/"/>
    
      <category term="acrn" scheme="http://liujunming.github.io/tags/acrn/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to ept misconfig</title>
    <link href="http://liujunming.github.io/2020/07/12/Introduction-to-ept-misconfig/"/>
    <id>http://liujunming.github.io/2020/07/12/Introduction-to-ept-misconfig/</id>
    <published>2020-07-12T09:01:48.000Z</published>
    <updated>2020-08-30T01:17:15.245Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡ä¸»è¦è®°å½•ept misconfigçš„ç›¸å…³ç¬”è®°ã€‚å†…å®¹ä¸»è¦è½¬è½½è‡ª<a href="http://happyseeker.github.io/kernel/2018/05/29/ept-misconfig.html" target="_blank" rel="noopener">EPT misconfig</a>ã€‚<br><a id="more"></a></p><h3 id="EPT-Voilation"><a href="#EPT-Voilation" class="headerlink" title="EPT Voilation"></a>EPT Voilation</h3><p>ç›¸å½“äºEPT(æ‰©å±•é¡µè¡¨)çš„page faultï¼Œæ˜¯ä¸€ç§ç‰¹æ®Šçš„ç¡¬ä»¶å¼‚å¸¸ã€‚å½“EPTä¸­ä¸å­˜åœ¨æŒ‡å®šGPA-&gt;HPAçš„æ˜ å°„æ—¶è§¦å‘ï¼Œç¡¬ä»¶è§¦å‘ã€‚</p><h3 id="EPT-misconfig"><a href="#EPT-misconfig" class="headerlink" title="EPT misconfig"></a>EPT misconfig</h3><p>æœ¬è´¨ä¸Šä¹Ÿæ˜¯ä¸€ç§page faultï¼Œä¸EPT voilationä¸åŒ(å½“page not presentæ—¶è§¦å‘)ï¼ŒEPT misconfigç±»ä¼¼äº reserved bit set page faultï¼Œä¹Ÿå°±æ˜¯è¯´å½“é¡µè¡¨é¡¹ä¸­çš„ä¿ç•™ä½è®¾ç½®æ—¶è§¦å‘ï¼Œä¹Ÿæ˜¯ç¡¬ä»¶è§¦å‘ã€‚</p><p>SDMä¸­å…³äºEPT misconfigçš„æè¿°ï¼š</p><blockquote><p>An EPT misconfiguration occurs when, in the course of translating a guest-physical address, the logical processor encounters an EPT paging-structure entry that contains an unsupported value. An EPT violation occurs when there is no EPT misconfiguration but the EPT paging-structure entries disallow an access using the guest physical address.</p></blockquote><h3 id="EPT-misconfigç”¨é€”"><a href="#EPT-misconfigç”¨é€”" class="headerlink" title="EPT misconfigç”¨é€”"></a>EPT misconfigç”¨é€”</h3><p>EPT misconfigå¯ä»¥ç”¨æ¥å¤„ç†æ²¡æœ‰passed-throughç»™Guestçš„mmioåŒºåŸŸã€‚</p><p>å½“é¦–æ¬¡è®¿é—®æŸmmio pageæ—¶ï¼Œä¼šè§¦å‘EPT violationï¼ŒKVMåœ¨EPT violationçš„å¤„ç†è¿‡ç¨‹ä¸­è®¾ç½®ç›¸åº”EPT entryä¸­çš„ä¿ç•™ä½ï¼Œç„¶ååœ¨ä¸‹ä¸€æ¬¡å†è®¿é—®è¯¥pageæ—¶ï¼Œå³ä¼šè§¦å‘EPT misconfigã€‚</p><p>è¯¦ç»†æ­¥éª¤å¦‚ä¸‹ï¼š</p><ol><li>QEMU declares a memory region(but not allocate ram or commit it to kvm)</li><li>Guest first access the MMIO address, cause a EPT violation VM-exit</li><li>KVM construct the EPT page table and marks the page table entry with special mark(110b)</li><li>Later the guest access these MMIO, it will be processed by EPT misconfig VM-exit handler</li></ol><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li><a href="http://happyseeker.github.io/kernel/2018/05/29/ept-misconfig.html" target="_blank" rel="noopener">EPT misconfig</a></li><li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/09/03/kvm-mmio" target="_blank" rel="noopener">KVM MMIO implementation</a></li><li><a href="http://ningfxkvm.blogspot.com/2015/11/kvmept-exception.html" target="_blank" rel="noopener">KVMä¸­çš„EPT Exception</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡ä¸»è¦è®°å½•ept misconfigçš„ç›¸å…³ç¬”è®°ã€‚å†…å®¹ä¸»è¦è½¬è½½è‡ª&lt;a href=&quot;http://happyseeker.github.io/kernel/2018/05/29/ept-misconfig.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EPT misconfig&lt;/a&gt;ã€‚&lt;br&gt;
    
    </summary>
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="è™šæ‹ŸåŒ–" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>æ¯å‘¨åˆ†äº«ç¬¬17æœŸ</title>
    <link href="http://liujunming.github.io/2020/07/12/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC17%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2020/07/12/æ¯å‘¨åˆ†äº«ç¬¬17æœŸ/</id>
    <published>2020-07-12T05:47:40.000Z</published>
    <updated>2020-08-30T01:17:15.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RPMåŒ…"><a href="#RPMåŒ…" class="headerlink" title="RPMåŒ…"></a>RPMåŒ…</h3><p>RPM(Redhat Linux Packet Manager)æ˜¯Red Hatå…¬å¸éšRedhat Linuxæ¨å‡ºäº†ä¸€ä¸ªè½¯ä»¶åŒ…ç®¡ç†å™¨ï¼Œé€šè¿‡å®ƒèƒ½å¤Ÿæ›´åŠ è½»æ¾å®¹æ˜“åœ°å®ç°è½¯ä»¶çš„å®‰è£…ã€‚</p><p><a href="https://blog.csdn.net/cuiyifang/article/details/7850703" target="_blank" rel="noopener">https://blog.csdn.net/cuiyifang/article/details/7850703</a><br><a href="https://zhuanlan.zhihu.com/p/27608663" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27608663</a></p><a id="more"></a><h3 id="bochs-vs-qemu"><a href="#bochs-vs-qemu" class="headerlink" title="bochs vs qemu"></a>bochs vs qemu</h3><p>Like bochs, QEMU emulates an x86 CPU. But QEMU is much faster than bochs as it uses dynamic compilation. Bochs is closely tied to x86 PC emulation while QEMU can emulate several processors. Like Valgrind, QEMU does user space emulation and dynamic translation.</p><p><a href="http://people.redhat.com/pbonzini/qemu-test-doc/_build/html/topics/QEMU-compared-to-other-emulators.html" target="_blank" rel="noopener">http://people.redhat.com/pbonzini/qemu-test-doc/_build/html/topics/QEMU-compared-to-other-emulators.html</a></p><h3 id="PCI-PCI-Express-Configuration-Space-Access"><a href="#PCI-PCI-Express-Configuration-Space-Access" class="headerlink" title="PCI/PCI Express Configuration Space Access"></a>PCI/PCI Express Configuration Space Access</h3><blockquote><p>Accesses made using either access mechanism are equivalent. The PCI Express Extended Configuration Space can only be accessed by using the ECAM.</p></blockquote><p>On x86 and x64 platforms, the address of each memory area is determined by the ACPI â€˜MCFGâ€™ table. </p><p><a href="http://developer.amd.com/wordpress/media/2012/10/pci%20-%20pci%20express%20configuration%20space%20access.pdf" target="_blank" rel="noopener">PCI/PCI Express Configuration Space Access</a><br><a href="https://stackoverflow.com/questions/57457283/how-to-access-pcie-configuration-space-ecam" target="_blank" rel="noopener">How to access PCIe configuration space</a></p><h3 id="ä½•å°é¾™"><a href="#ä½•å°é¾™" class="headerlink" title="ä½•å°é¾™"></a>ä½•å°é¾™</h3><p><a href="https://blog.csdn.net/hexiaolong2009" target="_blank" rel="noopener">https://blog.csdn.net/hexiaolong2009</a><br>æœ‰gpuç›¸å…³çš„èµ„æ–™ã€‚</p><h3 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h3><p>chrootï¼Œå³ change root directory (æ›´æ”¹ root ç›®å½•)ã€‚åœ¨ linux ç³»ç»Ÿä¸­ï¼Œç³»ç»Ÿé»˜è®¤çš„ç›®å½•ç»“æ„éƒ½æ˜¯ä»¥ /ï¼Œå³ä»¥æ ¹ (root) å¼€å§‹çš„ã€‚è€Œåœ¨ä½¿ç”¨ chroot ä¹‹åï¼Œç³»ç»Ÿçš„ç›®å½•ç»“æ„å°†ä»¥æŒ‡å®šçš„ä½ç½®ä½œä¸º / ä½ç½®ã€‚</p><p><a href="https://www.cnblogs.com/sparkdev/p/8556075.html" target="_blank" rel="noopener">https://www.cnblogs.com/sparkdev/p/8556075.html</a></p><h3 id="nomodesetï¼Œquietå’Œsplashå†…æ ¸å‚æ•°æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ"><a href="#nomodesetï¼Œquietå’Œsplashå†…æ ¸å‚æ•°æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ" class="headerlink" title="nomodesetï¼Œquietå’Œsplashå†…æ ¸å‚æ•°æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ"></a>nomodesetï¼Œquietå’Œsplashå†…æ ¸å‚æ•°æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ</h3><ul><li><p>nomodeset</p><blockquote><p>The newest kernels have moved the video mode setting into the kernel. So all the programming of the hardware specific clock rates and registers on the video card happen in the kernel rather than in the X driver when the X server starts.. This makes it possible to have high resolution nice looking splash (boot) screens and flicker free transitions from boot splash to login screen. Unfortunately, on some cards this doesnâ€™t work properly and you end up with a black screen. Adding the nomodeset parameter instructs the kernel to not load video drivers and use BIOS modes instead until X is loaded.</p></blockquote></li><li><p>quiet splash</p><blockquote><p>The splash (which eventually ends up in your /boot/grub/grub.cfg ) causes the splash screen to be shown.<br>At the same time you want the boot process to be quiet, as otherwise all kinds of messages would disrupt that splash screen.</p></blockquote></li></ul><p><a href="https://askubuntu.com/questions/716957/what-do-the-nomodeset-quiet-and-splash-kernel-parameters-mean" target="_blank" rel="noopener">What do the nomodeset, quiet and splash kernel parameters mean?</a></p><h3 id="GRUB-CMDLINE-LINUX-vs-GRUB-CMDLINE-LINUX-DEFAULT"><a href="#GRUB-CMDLINE-LINUX-vs-GRUB-CMDLINE-LINUX-DEFAULT" class="headerlink" title="GRUB_CMDLINE_LINUX vs GRUB_CMDLINE_LINUX_DEFAULT"></a>GRUB_CMDLINE_LINUX vs GRUB_CMDLINE_LINUX_DEFAULT</h3><ul><li>Options in <code>GRUB_CMDLINE_LINUX</code> are <strong>always effective</strong>.</li><li>Options in <code>GRUB_CMDLINE_LINUX_DEFAULT</code> are <strong>effective ONLY during normal boot</strong> (NOT during recovery mode).</li></ul><p><a href="https://askubuntu.com/questions/575651/what-is-the-difference-between-grub-cmdline-linux-and-grub-cmdline-linux-default" target="_blank" rel="noopener">What is the difference between GRUB_CMDLINE_LINUX and GRUB_CMDLINE_LINUX_DEFAULT in /etc/default/grub</a></p><h3 id="Intro-to-Time-Sensitive-Networking-and-IntelÂ®-Time-Coordinated-Computing-IntelÂ®-TCC"><a href="#Intro-to-Time-Sensitive-Networking-and-IntelÂ®-Time-Coordinated-Computing-IntelÂ®-TCC" class="headerlink" title="Intro to Time-Sensitive Networking and IntelÂ® Time Coordinated Computing (IntelÂ® TCC)"></a>Intro to Time-Sensitive Networking and IntelÂ® Time Coordinated Computing (IntelÂ® TCC)</h3><p>TCC makes sure each device executes its operations exactly when it supposed to.<br><a href="https://www.intel.com/content/www/us/en/now/inside-iot/concept-of-time-video.html" target="_blank" rel="noopener">https://www.intel.com/content/www/us/en/now/inside-iot/concept-of-time-video.html</a></p><h3 id="hurley-x86æ¶æ„æ“ä½œç³»ç»Ÿå†…æ ¸çš„å®ç°"><a href="#hurley-x86æ¶æ„æ“ä½œç³»ç»Ÿå†…æ ¸çš„å®ç°" class="headerlink" title="hurley x86æ¶æ„æ“ä½œç³»ç»Ÿå†…æ ¸çš„å®ç°"></a>hurley x86æ¶æ„æ“ä½œç³»ç»Ÿå†…æ ¸çš„å®ç°</h3><p><a href="http://wiki.0xffffff.org/" target="_blank" rel="noopener">http://wiki.0xffffff.org/</a><br><a href="https://github.com/hurley25/hurlex-doc/blob/master/doc/hurlex-index.pdf" target="_blank" rel="noopener">https://github.com/hurley25/hurlex-doc/blob/master/doc/hurlex-index.pdf</a></p><h3 id="Lockstep"><a href="#Lockstep" class="headerlink" title="Lockstep"></a>Lockstep</h3><p>Lockstep systems are fault-tolerant computer systems that run the same set of operations at the same time in parallel.<br><a href="https://en.wikipedia.org/wiki/Lockstep_(computing)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Lockstep_(computing)</a></p><h3 id="COLO"><a href="#COLO" class="headerlink" title="COLO"></a>COLO</h3><p>COLO (COarse-grained LOck-stepping)æ˜¯ä¸€ç§è™šæ‹Ÿæœºçš„é«˜å¯ç”¨è§£å†³æ–¹æ¡ˆã€‚å½“å¯ç”¨çš„COLOåŠŸèƒ½å, ä¸»è™šæ‹Ÿæœº(PVM)å’Œå¤‡è™šæ‹Ÿæœº(SVM)éƒ½ä¼šåŒæ—¶å¤„äºrunning çŠ¶æ€ã€‚PVMå’ŒSVMéƒ½å¯ä»¥æ¥æ”¶åˆ°æ¥è‡ªclientçš„ç½‘ç»œæ•°æ®åŒ…, å¹¶å¯¹æ•°æ®åŒ…åšå‡ºå›åº”ã€‚å½“PVMå’ŒSVMå›å¤çš„æ•°æ®åŒ…çš„å†…å®¹ç›¸åŒ, åˆ™PVMå›å¤çš„æ•°æ®åŒ…ä¼šè¿”å›ç»™client, å¦åˆ™ä¼šè§¦å‘checkpointå¯¹PVMå’ŒSVMè¿›è¡ŒåŒæ­¥ï¼Œç„¶åå†å°†æ•°æ®åŒ…è¿”å›ç»™clientã€‚å½“PVMæ‰€åœ¨çš„ç‰©ç†æœºå‘ç”Ÿå®•æœºæ—¶å€™, SVMå¯ä»¥ç«‹å³æ¥ç®¡, ä¸ºclientæä¾›æœåŠ¡ã€‚</p><p><a href="https://cloud.tencent.com/developer/article/1087097" target="_blank" rel="noopener">kvmè™šæ‹Ÿæœºçš„FTï¼ˆå®¹é”™ï¼‰æ–¹æ¡ˆ</a><br><a href="https://wiki.qemu.org/Features/COLO" target="_blank" rel="noopener">Features/COLO</a><br><a href="https://blog.csdn.net/zhongbeida_xue/article/details/70759266" target="_blank" rel="noopener">QEMU COLO (Fault Tolerance) å®¹é”™åŠŸèƒ½æ€»ç»“</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RPMåŒ…&quot;&gt;&lt;a href=&quot;#RPMåŒ…&quot; class=&quot;headerlink&quot; title=&quot;RPMåŒ…&quot;&gt;&lt;/a&gt;RPMåŒ…&lt;/h3&gt;&lt;p&gt;RPM(Redhat Linux Packet Manager)æ˜¯Red Hatå…¬å¸éšRedhat Linuxæ¨å‡ºäº†ä¸€ä¸ªè½¯ä»¶åŒ…ç®¡ç†å™¨ï¼Œé€šè¿‡å®ƒèƒ½å¤Ÿæ›´åŠ è½»æ¾å®¹æ˜“åœ°å®ç°è½¯ä»¶çš„å®‰è£…ã€‚&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/cuiyifang/article/details/7850703&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/cuiyifang/article/details/7850703&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27608663&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/27608663&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ç»éªŒ" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="ç»éªŒ" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>æ¯å‘¨åˆ†äº«ç¬¬16æœŸ</title>
    <link href="http://liujunming.github.io/2020/07/05/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC16%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2020/07/05/æ¯å‘¨åˆ†äº«ç¬¬16æœŸ/</id>
    <published>2020-07-05T04:07:02.000Z</published>
    <updated>2020-08-30T01:17:15.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fzf"><a href="#fzf" class="headerlink" title="fzf"></a>fzf</h3><p>å‘½ä»¤è¡Œæ–‡æœ¬å¢å¼ºå·¥å…·</p><p><a href="https://www.jianshu.com/p/8acfc103fa2f" target="_blank" rel="noopener">https://www.jianshu.com/p/8acfc103fa2f</a></p><a id="more"></a><h3 id="Intel-CPU-security-features"><a href="#Intel-CPU-security-features" class="headerlink" title="Intel CPU security features"></a>Intel CPU security features</h3><p><a href="https://github.com/huku-/research/wiki/Intel-CPU-security-features" target="_blank" rel="noopener">https://github.com/huku-/research/wiki/Intel-CPU-security-features</a></p><h3 id="How-to-use-sed-to-find-and-replace-text-in-files"><a href="#How-to-use-sed-to-find-and-replace-text-in-files" class="headerlink" title="How to use sed to find and replace text in files"></a>How to use sed to find and replace text in files</h3><p><a href="https://www.cyberciti.biz/faq/how-to-use-sed-to-find-and-replace-text-in-files-in-linux-unix-shell/" target="_blank" rel="noopener">https://www.cyberciti.biz/faq/how-to-use-sed-to-find-and-replace-text-in-files-in-linux-unix-shell/</a></p><h3 id="Board-Support-Package"><a href="#Board-Support-Package" class="headerlink" title="Board Support Package"></a>Board Support Package</h3><p>In embedded systems, a board support package (BSP) is the layer of software containing hardware-specific drivers and other routines that allow a particular operating system (traditionally a real-time operating system, or RTOS) to function in a particular hardware environment (a computer or CPU card), integrated with the RTOS itself. Third-party hardware developers who wish to support a particular RTOS must create a BSP that allows that RTOS to run on their platform. In most cases the RTOS image and license, the BSP containing it, and the hardware are bundled together by the hardware vendor.</p><p><a href="https://en.wikipedia.org/wiki/Board_support_package" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Board_support_package</a></p><p><a href="https://www.microcontrollertips.com/board-support-package/" target="_blank" rel="noopener">https://www.microcontrollertips.com/board-support-package/</a></p><h3 id="ä¸ºä»€ä¹ˆè¦æ¸…é™¤BSSæ®µ"><a href="#ä¸ºä»€ä¹ˆè¦æ¸…é™¤BSSæ®µ" class="headerlink" title="ä¸ºä»€ä¹ˆè¦æ¸…é™¤BSSæ®µ"></a>ä¸ºä»€ä¹ˆè¦æ¸…é™¤BSSæ®µ</h3><p><a href="https://www.cnblogs.com/cainiaoaixuexi/p/3276444.html" target="_blank" rel="noopener">https://www.cnblogs.com/cainiaoaixuexi/p/3276444.html</a></p><h3 id="ELFä¸­çš„-bss-sectionå’ŒCOMMON-section"><a href="#ELFä¸­çš„-bss-sectionå’ŒCOMMON-section" class="headerlink" title="ELFä¸­çš„.bss sectionå’ŒCOMMON section"></a>ELFä¸­çš„.bss sectionå’ŒCOMMON section</h3><p><a href="https://stackoverflow.com/questions/16835716/bss-vs-common-what-goes-where" target="_blank" rel="noopener">https://stackoverflow.com/questions/16835716/bss-vs-common-what-goes-where</a></p><p><a href="http://swaywang.blogspot.com/2012/06/elfbss-sectioncommon-section.html" target="_blank" rel="noopener">http://swaywang.blogspot.com/2012/06/elfbss-sectioncommon-section.html</a></p><h3 id="How-To-Create-View-Extract-Modify-C-Archive-Files"><a href="#How-To-Create-View-Extract-Modify-C-Archive-Files" class="headerlink" title="How To Create, View, Extract, Modify C Archive Files"></a>How To Create, View, Extract, Modify C Archive Files</h3><p><a href="https://www.thegeekstuff.com/2010/08/ar-command-examples/" target="_blank" rel="noopener">https://www.thegeekstuff.com/2010/08/ar-command-examples/</a></p><h3 id="gcc-linker-map-files"><a href="#gcc-linker-map-files" class="headerlink" title="gcc linker map files"></a>gcc linker map files</h3><p><a href="https://blog.csdn.net/szullc/article/details/84946863" target="_blank" rel="noopener">https://blog.csdn.net/szullc/article/details/84946863</a></p><p><a href="https://stackoverflow.com/questions/22199844/what-are-gcc-linker-map-files-used-for" target="_blank" rel="noopener">https://stackoverflow.com/questions/22199844/what-are-gcc-linker-map-files-used-for</a></p><p>Experience: map fileæ¯”objdumpæ›´ç²¾ç¡®</p><h3 id="nm-å‘½ä»¤æ˜¾ç¤ºå…³äºæŒ‡å®š-File-ä¸­ç¬¦å·çš„ä¿¡æ¯"><a href="#nm-å‘½ä»¤æ˜¾ç¤ºå…³äºæŒ‡å®š-File-ä¸­ç¬¦å·çš„ä¿¡æ¯" class="headerlink" title="nm å‘½ä»¤æ˜¾ç¤ºå…³äºæŒ‡å®š File ä¸­ç¬¦å·çš„ä¿¡æ¯"></a>nm å‘½ä»¤æ˜¾ç¤ºå…³äºæŒ‡å®š File ä¸­ç¬¦å·çš„ä¿¡æ¯</h3><p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/nm.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/nm.html</a></p><h3 id="Alder-Lake"><a href="#Alder-Lake" class="headerlink" title="Alder Lake"></a>Alder Lake</h3><p><a href="https://en.wikichip.org/wiki/intel/microarchitectures/alder_lake" target="_blank" rel="noopener">https://en.wikichip.org/wiki/intel/microarchitectures/alder_lake</a></p><h3 id="Windows-10X"><a href="#Windows-10X" class="headerlink" title="Windows 10X"></a>Windows 10X</h3><p><a href="https://www.youtube.com/watch?v=dIz0WDwBonc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=dIz0WDwBonc</a></p><h3 id="windows-core-os"><a href="#windows-core-os" class="headerlink" title="windows core os"></a>windows core os</h3><p><a href="https://www.windowscentral.com/windows-core-os" target="_blank" rel="noopener">https://www.windowscentral.com/windows-core-os</a></p><h3 id="Intel-Hardware-Accelerated-Execution-Manager-HAXM"><a href="#Intel-Hardware-Accelerated-Execution-Manager-HAXM" class="headerlink" title="Intel Hardware Accelerated Execution Manager (HAXM)"></a>Intel Hardware Accelerated Execution Manager (HAXM)</h3><p>HAXM is a cross-platform hardware-assisted virtualization engine (hypervisor), widely used as an accelerator for <a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">Android Emulator</a> and <a href="https://www.qemu.org/" target="_blank" rel="noopener">QEMU</a>. It has always supported running on Windows and macOS, and has been ported to other host operating systems as well, such as Linux and NetBSD.</p><p>HAXM runs as a kernel-mode driver on the host operating system, and provides a KVM-like interface to user space, thereby enabling applications like QEMU to utilize the hardware virtualization capabilities built into modern Intel CPUs, namely <a href="https://www.intel.com/content/www/us/en/virtualization/virtualization-technology/intel-virtualization-technology.html" target="_blank" rel="noopener">Intel Virtualization Technology</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;fzf&quot;&gt;&lt;a href=&quot;#fzf&quot; class=&quot;headerlink&quot; title=&quot;fzf&quot;&gt;&lt;/a&gt;fzf&lt;/h3&gt;&lt;p&gt;å‘½ä»¤è¡Œæ–‡æœ¬å¢å¼ºå·¥å…·&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/8acfc103fa2f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/8acfc103fa2f&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ç»éªŒ" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="ç»éªŒ" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>æ¯å‘¨åˆ†äº«ç¬¬15æœŸ</title>
    <link href="http://liujunming.github.io/2020/06/14/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC15%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2020/06/14/æ¯å‘¨åˆ†äº«ç¬¬15æœŸ/</id>
    <published>2020-06-14T06:35:42.000Z</published>
    <updated>2020-08-30T01:17:15.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Burn-the-Clear-Linux-to-the-USB-driver"><a href="#Burn-the-Clear-Linux-to-the-USB-driver" class="headerlink" title="Burn the Clear Linux to the USB driver"></a>Burn the Clear Linux to the USB driver</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/sdaX</span><br><span class="line"></span><br><span class="line">dd if=clear-2xxxx-installer.img of=/dev/sdb bs=4M status=progress</span><br><span class="line">sync</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="ACRN-è…¾è®¯äº‘å¤§å­¦"><a href="#ACRN-è…¾è®¯äº‘å¤§å­¦" class="headerlink" title="ACRN  è…¾è®¯äº‘å¤§å­¦"></a>ACRN  è…¾è®¯äº‘å¤§å­¦</h3><p><a href="https://cloud.tencent.com/edu/learning/course-2675-51869" target="_blank" rel="noopener">https://cloud.tencent.com/edu/learning/course-2675-51869</a></p><h3 id="gitmemory"><a href="#gitmemory" class="headerlink" title="gitmemory"></a>gitmemory</h3><p><a href="https://www.gitmemory.com/liujunming" target="_blank" rel="noopener">https://www.gitmemory.com/liujunming</a></p><h3 id="é€šè¿‡è¡¨æƒ…ç¬¦å·ä¸ºæ‚¨çš„ç”µå­é‚®ä»¶å¢æ·»é£æ ¼"><a href="#é€šè¿‡è¡¨æƒ…ç¬¦å·ä¸ºæ‚¨çš„ç”µå­é‚®ä»¶å¢æ·»é£æ ¼" class="headerlink" title="é€šè¿‡è¡¨æƒ…ç¬¦å·ä¸ºæ‚¨çš„ç”µå­é‚®ä»¶å¢æ·»é£æ ¼"></a>é€šè¿‡è¡¨æƒ…ç¬¦å·ä¸ºæ‚¨çš„ç”µå­é‚®ä»¶å¢æ·»é£æ ¼</h3><p><a href="https://support.microsoft.com/zh-cn/office/%e9%80%9a%e8%bf%87%e8%a1%a8%e6%83%85%e7%ac%a6%e5%8f%b7%e4%b8%ba%e6%82%a8%e7%9a%84%e7%94%b5%e5%ad%90%e9%82%ae%e4%bb%b6%e5%a2%9e%e6%b7%bb%e9%a3%8e%e6%a0%bc-b7ffd919-6749-4f07-a998-c0fa1bc0a4d6?ui=zh-cn&amp;rs=zh-cn&amp;ad=cn" target="_blank" rel="noopener">é€šè¿‡è¡¨æƒ…ç¬¦å·ä¸ºæ‚¨çš„ç”µå­é‚®ä»¶å¢æ·»é£æ ¼</a><br>è‹¥è¦è®¿é—® Windows 10 è¡¨æƒ…ç¬¦å·é€‰å–å™¨ï¼Œè¯·æŒ‰ Windows é”®å’Œå¥ç‚¹ï¼ˆ.ï¼‰ é”®ã€‚</p><h3 id="DediProg"><a href="#DediProg" class="headerlink" title="DediProg"></a>DediProg</h3><p><a href="https://www.dediprog.com/page/companyinformationch" target="_blank" rel="noopener">https://www.dediprog.com/page/companyinformationch</a><br>çƒ§å½•å™¨</p><h3 id="pkill-f"><a href="#pkill-f" class="headerlink" title="pkill -f"></a>pkill -f</h3><p><code>pkill -f abc</code> æ€æ‰è¿›ç¨‹ååŒ…å«<code>abc</code>çš„æ‰€æœ‰è¿›ç¨‹ã€‚</p><h3 id="åŸºäº-Docker-Qemu-å¿«é€Ÿæ„å»º-Linux-å†…æ ¸å®éªŒç¯å¢ƒ"><a href="#åŸºäº-Docker-Qemu-å¿«é€Ÿæ„å»º-Linux-å†…æ ¸å®éªŒç¯å¢ƒ" class="headerlink" title="åŸºäº Docker/Qemu å¿«é€Ÿæ„å»º Linux å†…æ ¸å®éªŒç¯å¢ƒ"></a>åŸºäº Docker/Qemu å¿«é€Ÿæ„å»º Linux å†…æ ¸å®éªŒç¯å¢ƒ</h3><p><a href="http://tinylab.org/docker-qemu-linux-lab/" target="_blank" rel="noopener">http://tinylab.org/docker-qemu-linux-lab/</a></p><h3 id="SMRAM"><a href="#SMRAM" class="headerlink" title="SMRAM"></a>SMRAM</h3><p>Short for System Management RAM, SMRAM is a portion of the systems memory used by the processor to store code used with SMM.</p><p><a href="https://www.computerhope.com/jargon/s/smram.htm" target="_blank" rel="noopener">https://www.computerhope.com/jargon/s/smram.htm</a></p><h3 id="System-Management-Mode"><a href="#System-Management-Mode" class="headerlink" title="System Management Mode"></a>System Management Mode</h3><p>System Management Mode is an operating mode of x86 central processor units (CPUs) in which all normal execution, including the operating system, is suspended. An alternate software system which usually resides in the computerâ€™s firmware, or a hardware-assisted debugger, is then executed with high privileges.</p><p>System Management Mode (SMM) is intended to be used for advanced power-management features and other operating-system-independent functions. The chipset is programmed to recognize many types of events and timeouts. When such an event occurs, the chipset asserts the SMI# input pin. At the next instruction boundary, the microprocessor saves its entire state and enters SMM.</p><p>åªæœ‰SMIæ‰ä¼šå¼•èµ·è¿›å…¥SMMï¼Œå¤„ç†å™¨ä¿æŠ¤ç°åœºï¼Œåˆ‡æ¢åˆ°SMRAMé‡Œçš„ä¸€ä¸ªç‹¬ç«‹åœ°å€ç©ºé—´æ‰§è¡ŒSMMä»£ç ï¼ŒRSMæŒ‡ä»¤ä¼šä½¿ç³»ç»Ÿè¿”å›åˆ°åŸæ¥çš„æ­£å¸¸æ¨¡å¼ã€‚SMMç›¸å½“äºå®æ¨¡å¼ï¼Œæ²¡æœ‰ç‰¹æƒçº§å’Œåœ°å€æ˜ å°„ï¼Œå¯å¯»å€4GBï¼Œå¯æ‰§è¡Œæ‰€æœ‰I/Oå’Œå¯ç”¨ç³»ç»ŸæŒ‡ä»¤ã€‚</p><p><a href="https://en.wikipedia.org/wiki/System_Management_Mode" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/System_Management_Mode</a><br><a href="https://www.rdzhijia.com/thread-29-1-1.html" target="_blank" rel="noopener">https://www.rdzhijia.com/thread-29-1-1.html</a><br><a href="https://blog.csdn.net/lightseed/article/details/4627069" target="_blank" rel="noopener">https://blog.csdn.net/lightseed/article/details/4627069</a></p><h3 id="Windows-Imaging-Format"><a href="#Windows-Imaging-Format" class="headerlink" title="Windows Imaging Format"></a>Windows Imaging Format</h3><p>The Windows IMaging Format (WIM) is a file-based disk image format.</p><p>Like other disk image formats, a WIM file contains a set of files and associated filesystem metadata. However, unlike sector-based formats (such as ISO or VHD), WIM is file-based: The fundamental unit of information in a WIM is a file.</p><p><a href="https://en.wikipedia.org/wiki/Windows_Imaging_Format" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Windows_Imaging_Format</a></p><h3 id="CSE-481A"><a href="#CSE-481A" class="headerlink" title="CSE 481A"></a>CSE 481A</h3><p>CSE 481A is a capstone course on operating systems, with an emphasis on virtualization.<br><a href="https://courses.cs.washington.edu/courses/cse481a/18wi/index.html" target="_blank" rel="noopener">https://courses.cs.washington.edu/courses/cse481a/18wi/index.html</a></p><h3 id="Capstone-project"><a href="#Capstone-project" class="headerlink" title="Capstone project"></a>Capstone project</h3><p>Capstone projectå«é¡¶ç‚¹è¯¾ç¨‹<br>é¡¶ç‚¹è¯¾ç¨‹æ˜¯ç¾å›½é«˜æ ¡ä¸ºé«˜å¹´çº§å­¦ç”Ÿï¼Œç‰¹åˆ«æ˜¯ä¸´è¿‘æ¯•ä¸šçš„å­¦ç”Ÿå¼€è®¾çš„ä¸€ç§ç»¼åˆæ€§è¯¾ç¨‹ã€‚<br>é¡¶ç‚¹è¯¾ç¨‹æœ€æ˜¾è‘—çš„ä¸¤ä¸ªç‰¹ç‚¹ï¼š<br>1ï¼‰æ˜¯ä¸ºå­¦ç”Ÿæä¾›æ•´åˆå·²å¾—çš„çŸ¥è¯†ã€æŠ€èƒ½å’Œæ€åº¦ç­‰çš„æœºä¼š<br>2ï¼‰æ˜¯ä¸ºå­¦ç”Ÿè¿›å…¥çœŸå®ä¸–ç•Œåšå‡†å¤‡ï¼Œå³é€šè¿‡è¦æ±‚å­¦ç”Ÿå®Œæˆä¸€äº›åº”ç”¨æ€§çš„é¡¹ç›®ï¼Œå¦‚æœåŠ¡æ€§å®ä¹ ã€å®ä¹ ç­‰ï¼Œä¸ºå­¦ç”Ÿæä¾›å‚ä¸çœŸå®ä¸–ç•Œçš„æœºä¼šï¼Œè®©å­¦ç”ŸæŠŠå…ˆå‰æ‰€å­¦çŸ¥è¯†å’ŒæŠ€èƒ½åº”ç”¨äºè§£å†³å®é™…é—®é¢˜ï¼Œä¸ºå­¦ç”Ÿè¿›å…¥èŒä¸šé¢†åŸŸåšå‡†å¤‡ã€‚</p><h3 id="è™šæ‹ŸåŒ–ä»VirtIO-without-Virtåˆ°DPU"><a href="#è™šæ‹ŸåŒ–ä»VirtIO-without-Virtåˆ°DPU" class="headerlink" title="è™šæ‹ŸåŒ–ä»VirtIO without Virtåˆ°DPU"></a>è™šæ‹ŸåŒ–ä»VirtIO without Virtåˆ°DPU</h3><p><a href="https://mp.weixin.qq.com/s/vGOGuh1-8aeEU3QwoKDzcA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vGOGuh1-8aeEU3QwoKDzcA</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Burn-the-Clear-Linux-to-the-USB-driver&quot;&gt;&lt;a href=&quot;#Burn-the-Clear-Linux-to-the-USB-driver&quot; class=&quot;headerlink&quot; title=&quot;Burn the Clear Linux to the USB driver&quot;&gt;&lt;/a&gt;Burn the Clear Linux to the USB driver&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;umount /dev/sdaX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dd if=clear-2xxxx-installer.img of=/dev/sdb bs=4M status=progress&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sync&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="ç»éªŒ" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="ç»éªŒ" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>æ¯å‘¨åˆ†äº«ç¬¬14æœŸ</title>
    <link href="http://liujunming.github.io/2020/05/24/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC14%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2020/05/24/æ¯å‘¨åˆ†äº«ç¬¬14æœŸ/</id>
    <published>2020-05-24T07:20:49.000Z</published>
    <updated>2020-08-30T01:17:15.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h3><p>ANSIæ˜¯ä¸€ç§å­—ç¬¦ä»£ç ï¼Œä¸ºä½¿è®¡ç®—æœºæ”¯æŒæ›´å¤šè¯­è¨€ï¼Œé€šå¸¸ä½¿ç”¨ 0x00~0x7f èŒƒå›´çš„1 ä¸ªå­—èŠ‚æ¥è¡¨ç¤º 1 ä¸ªè‹±æ–‡å­—ç¬¦ã€‚è¶…å‡ºæ­¤èŒƒå›´çš„ä½¿ç”¨0x80~0xFFFFæ¥ç¼–ç ï¼Œå³æ‰©å±•çš„ASCIIç¼–ç ã€‚<br><a id="more"></a><br>åœ¨å®é™…åº”ç”¨ä¸­æ¥è§¦æ¯”è¾ƒå¤šçš„æ–‡æœ¬ç¼–ç æœ‰3ç§ï¼šASCIIã€ANSIå’ŒUNICODEï¼Œå…¶ä¸­ASCIIç æ˜¯åä¸¤ç§ç¼–ç çš„åŸºç¡€ã€‚</p><h3 id="zGlue"><a href="#zGlue" class="headerlink" title="zGlue"></a>zGlue</h3><p><a href="http://www.sigmaintell.com/news.php?cid=27&amp;id=5305" target="_blank" rel="noopener">http://www.sigmaintell.com/news.php?cid=27&amp;id=5305</a></p><h3 id="suse-linux"><a href="#suse-linux" class="headerlink" title="suse linux"></a>suse linux</h3><p><a href="https://baike.baidu.com/item/SUSE/60409?fromtitle=suse%20linux&amp;fromid=649234&amp;fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/SUSE/60409?fromtitle=suse%20linux&amp;fromid=649234&amp;fr=aladdin</a></p><h3 id="diffinity"><a href="#diffinity" class="headerlink" title="diffinity"></a>diffinity</h3><p>Diffinity is a free diff and merging tool for Windows with focus on accurate and easy to read source code diffs. </p><p><a href="http://truehumandesign.se/s_diffinity.php" target="_blank" rel="noopener">http://truehumandesign.se/s_diffinity.php</a></p><h3 id="ä¸­å›½ç¥å‰§æ¨è"><a href="#ä¸­å›½ç¥å‰§æ¨è" class="headerlink" title="ä¸­å›½ç¥å‰§æ¨è"></a>ä¸­å›½ç¥å‰§æ¨è</h3><ol><li>ã€Šå¤§æ˜ç‹æœ1566ã€‹</li><li>ã€Šå¤©é“ã€‹</li><li>ã€Šèµ°å‘å…±å’Œã€‹</li><li>ã€Šç”Ÿå­˜ä¹‹æ°‘å·¥ã€‹</li></ol><h3 id="pagemap"><a href="#pagemap" class="headerlink" title="pagemap"></a>pagemap</h3><p><a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/vm/pagemap.txt</a><br><a href="https://www.cnblogs.com/pengdonglin137/p/6802108.html" target="_blank" rel="noopener">https://www.cnblogs.com/pengdonglin137/p/6802108.html</a></p><h3 id="åä¸ºè‡ªåŠ¨é©¾é©¶æ“ä½œç³»ç»Ÿå†…æ ¸-ISO-26262-ASIL-D"><a href="#åä¸ºè‡ªåŠ¨é©¾é©¶æ“ä½œç³»ç»Ÿå†…æ ¸-ISO-26262-ASIL-D" class="headerlink" title="åä¸ºè‡ªåŠ¨é©¾é©¶æ“ä½œç³»ç»Ÿå†…æ ¸ ISO 26262 ASIL-D"></a>åä¸ºè‡ªåŠ¨é©¾é©¶æ“ä½œç³»ç»Ÿå†…æ ¸ ISO 26262 ASIL-D</h3><p><a href="https://www.huawei.com/cn/press-events/news/2020/5/aos-core-asil-d-certificate" target="_blank" rel="noopener">https://www.huawei.com/cn/press-events/news/2020/5/aos-core-asil-d-certificate</a></p><h3 id="åä¸œå¸ˆèŒƒå¤§å­¦-ä½•ç§¯ä¸°"><a href="#åä¸œå¸ˆèŒƒå¤§å­¦-ä½•ç§¯ä¸°" class="headerlink" title="åä¸œå¸ˆèŒƒå¤§å­¦ ä½•ç§¯ä¸°"></a>åä¸œå¸ˆèŒƒå¤§å­¦ ä½•ç§¯ä¸°</h3><p><a href="http://www.sei.ecnu.edu.cn/Data/View/4487" target="_blank" rel="noopener">http://www.sei.ecnu.edu.cn/Data/View/4487</a></p><h3 id="é˜¿é‡Œå·´å·´æ­£å¼å¼€æº-Inclavare-Containers"><a href="#é˜¿é‡Œå·´å·´æ­£å¼å¼€æº-Inclavare-Containers" class="headerlink" title="é˜¿é‡Œå·´å·´æ­£å¼å¼€æº Inclavare Containers"></a>é˜¿é‡Œå·´å·´æ­£å¼å¼€æº Inclavare Containers</h3><p><a href="https://kernel.taobao.org/2020/05/Inclavare-Containers/" target="_blank" rel="noopener">https://kernel.taobao.org/2020/05/Inclavare-Containers/</a></p><h3 id="Difference-between-DPL-and-RPL-in-x86"><a href="#Difference-between-DPL-and-RPL-in-x86" class="headerlink" title="Difference between DPL and RPL in x86"></a>Difference between DPL and RPL in x86</h3><p>Segment protection was introduced with the 286, before paging existed in the x86 family of processors. Back then, segmentation was the only way to restrict access to kernel memory from a user-mode context. RPL provided a convenient way to enforce this restriction when passing pointers across different privilege levels.</p><p>Modern operating systems use paging to restrict access to memory, which removes the need for segmentation. So RPL is mostly an unused leftover from older times.</p><p><a href="https://stackoverflow.com/questions/36617718/difference-between-dpl-and-rpl-in-x86" target="_blank" rel="noopener">https://stackoverflow.com/questions/36617718/difference-between-dpl-and-rpl-in-x86</a><br><a href="http://blog.chinaunix.net/uid-21736802-id-1817645.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-21736802-id-1817645.html</a><br><a href="http://qcd.phys.cmu.edu/QCDcluster/intel/vtune/reference/vc17a.htm" target="_blank" rel="noopener">http://qcd.phys.cmu.edu/QCDcluster/intel/vtune/reference/vc17a.htm</a></p><h3 id="stabs"><a href="#stabs" class="headerlink" title="stabs"></a>stabs</h3><p>Stabs (Symbol Table String) refers to a format for information that describes a program to a debugger.</p><p><a href="https://blog.csdn.net/hfyinsdu/article/details/104359578" target="_blank" rel="noopener">https://blog.csdn.net/hfyinsdu/article/details/104359578</a><br><a href="http://blog.sina.com.cn/s/blog_ba1e7c860102wrsz.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_ba1e7c860102wrsz.html</a><br><a href="https://sourceware.org/gdb/onlinedocs/stabs.html" target="_blank" rel="noopener">https://sourceware.org/gdb/onlinedocs/stabs.html</a></p><h3 id="DWARF"><a href="#DWARF" class="headerlink" title="DWARF"></a>DWARF</h3><p>stabs å·²ç»è¢« DWARF æ›¿ä»£<br><a href="https://www.ibm.com/developerworks/cn/aix/library/au-dwarf-debug-format/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/aix/library/au-dwarf-debug-format/index.html</a></p><h3 id="MISRA-Cç¼–ç¨‹è§„èŒƒæ ‡å‡†"><a href="#MISRA-Cç¼–ç¨‹è§„èŒƒæ ‡å‡†" class="headerlink" title="MISRA Cç¼–ç¨‹è§„èŒƒæ ‡å‡†"></a>MISRA Cç¼–ç¨‹è§„èŒƒæ ‡å‡†</h3><p><a href="https://blog.csdn.net/qq_20553613/article/details/81989570" target="_blank" rel="noopener">https://blog.csdn.net/qq_20553613/article/details/81989570</a></p><h3 id="LDRA-Testbed"><a href="#LDRA-Testbed" class="headerlink" title="LDRA Testbed"></a>LDRA Testbed</h3><p>LDRA Testbed provides the core static and dynamic analysis engines for both host and embedded software. LDRA Testbed provides the means to enforce compliance with coding standards such as MISRA, JSF++ AV, CERT C, CWE and provides visibility of software flaws that might typically pass through the standard build and test process to become latent problems.<br><a href="https://en.wikipedia.org/wiki/LDRA_Testbed" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/LDRA_Testbed</a></p><h3 id="rst"><a href="#rst" class="headerlink" title="rst"></a>rst</h3><p><a href="https://www.jianshu.com/p/1885d5570b37" target="_blank" rel="noopener">https://www.jianshu.com/p/1885d5570b37</a></p><h3 id="printf-quot-s-quot-length-string"><a href="#printf-quot-s-quot-length-string" class="headerlink" title="printf(&quot;%.*s&quot;, length, string)"></a><code>printf(&quot;%.*s&quot;, length, string)</code></h3><p><code>printf(&quot;%.*s&quot;, length, string)</code> prints at most <code>length</code> characters of <code>string</code>. </p><h3 id="Long-mode"><a href="#Long-mode" class="headerlink" title="Long mode"></a>Long mode</h3><p>In the x86-64 computer architecture, long mode is the mode where a 64-bit operating system can access 64-bit instructions and registers.</p><h3 id="Bao-a-lightweight-static-partitioning-hypervisor"><a href="#Bao-a-lightweight-static-partitioning-hypervisor" class="headerlink" title="Bao - a lightweight static partitioning hypervisor"></a>Bao - a lightweight static partitioning hypervisor</h3><p><a href="https://github.com/bao-project/bao-hypervisor" target="_blank" rel="noopener">https://github.com/bao-project/bao-hypervisor</a><br><a href="https://drops.dagstuhl.de/opus/volltexte/2020/11779/pdf/OASIcs-NG-RES-2020-3.pdf" target="_blank" rel="noopener">https://drops.dagstuhl.de/opus/volltexte/2020/11779/pdf/OASIcs-NG-RES-2020-3.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ANSI&quot;&gt;&lt;a href=&quot;#ANSI&quot; class=&quot;headerlink&quot; title=&quot;ANSI&quot;&gt;&lt;/a&gt;ANSI&lt;/h3&gt;&lt;p&gt;ANSIæ˜¯ä¸€ç§å­—ç¬¦ä»£ç ï¼Œä¸ºä½¿è®¡ç®—æœºæ”¯æŒæ›´å¤šè¯­è¨€ï¼Œé€šå¸¸ä½¿ç”¨ 0x00~0x7f èŒƒå›´çš„1 ä¸ªå­—èŠ‚æ¥è¡¨ç¤º 1 ä¸ªè‹±æ–‡å­—ç¬¦ã€‚è¶…å‡ºæ­¤èŒƒå›´çš„ä½¿ç”¨0x80~0xFFFFæ¥ç¼–ç ï¼Œå³æ‰©å±•çš„ASCIIç¼–ç ã€‚&lt;br&gt;
    
    </summary>
    
      <category term="ç»éªŒ" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="ç»éªŒ" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>xv6 lab1 notes</title>
    <link href="http://liujunming.github.io/2020/05/18/xv6-lab1-notes/"/>
    <id>http://liujunming.github.io/2020/05/18/xv6-lab1-notes/</id>
    <published>2020-05-18T06:48:52.000Z</published>
    <updated>2020-08-30T01:17:15.255Z</updated>
    
    <content type="html"><![CDATA[<p>æœ¬æ–‡ä¸»è¦è®°å½•xv6 lab1çš„ç›¸å…³ç¬”è®°ã€‚</p><a id="more"></a><h2 id="1-Part-1-PC-Bootstrap"><a href="#1-Part-1-PC-Bootstrap" class="headerlink" title="1. Part 1: PC Bootstrap"></a>1. Part 1: PC Bootstrap</h2><h3 id="1-1-Getting-Started-with-x86-assembly"><a href="#1-1-Getting-Started-with-x86-assembly" class="headerlink" title="1.1 Getting Started with x86 assembly"></a>1.1 Getting Started with x86 assembly</h3><p>recommend some learning materials</p><h3 id="1-2-Simulating-the-x86"><a href="#1-2-Simulating-the-x86" class="headerlink" title="1.2 Simulating the x86"></a>1.2 Simulating the x86</h3><p><code>make qemu-nox</code> </p><p>youâ€™re ready to run QEMU, supplying the file <code>obj/kern/kernel.img</code> as the contents of the emulated PCâ€™s â€œvirtual hard disk.â€ This hard disk image contains both our boot loader (<code>obj/boot/boot</code>) and our kernel (<code>obj/kernel</code>).</p><p>To quit qemu, type <code>Ctrl+a x</code>.</p><h3 id="1-3-The-PCâ€™s-Physical-Address-Space"><a href="#1-3-The-PCâ€™s-Physical-Address-Space" class="headerlink" title="1.3 The PCâ€™s Physical Address Space"></a>1.3 The PCâ€™s Physical Address Space</h3><p> A PCâ€™s physical address space is hard-wired to have the following general layout:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure></p><p>The first PCs, which were based on the 16-bit Intel 8088 processor, were only capable of addressing 1MB of physical memory. The physical address space of an early PC would therefore start at 0x00000000 but end at 0x000FFFFF. The 640KB area marked â€œLow Memoryâ€ was the only random-access memory (RAM) that an early PC could use.</p><p>The 384KB area from 0x000A0000 through 0x000FFFFF was reserved by the hardware for special uses such as video display buffers and firmware held in non-volatile memory. The most important part of this reserved area is the Basic Input/Output System (BIOS), which occupies the 64KB region from 0x000F0000 through 0x000FFFFF. In early PCs the BIOS was held in true read-only memory (ROM), but current PCs store the BIOS in updateable flash memory. The BIOS is responsible for performing basic system initialization such as activating the video card and checking the amount of memory installed. After performing this initialization, the BIOS loads the operating system from some appropriate location such as floppy disk, hard disk, CD-ROM, or the network, and passes control of the machine to the operating system.</p><p>When Intel finally â€œbroke the one megabyte barrierâ€ with the 80286 and 80386 processors, which supported 16MB and 4GB physical address spaces respectively, the PC architects nevertheless preserved the original layout for the low 1MB of physical address space in order to ensure backward compatibility with existing software. Modern PCs therefore have a â€œholeâ€ in physical memory from 0x000A0000 to 0x00100000, dividing RAM into â€œlowâ€ or â€œconventional memoryâ€ (the first 640KB) and â€œextended memoryâ€ (everything else). In addition, some space at the very top of the PCâ€™s 32-bit physical address space, above all physical RAM, is now commonly reserved by the BIOS for use by 32-bit PCI devices.</p><h3 id="1-4-The-ROM-BIOS"><a href="#1-4-The-ROM-BIOS" class="headerlink" title="1.4 The ROM BIOS"></a>1.4 The ROM BIOS</h3><p>Open two terminal windows and <code>cd</code> both shells into your lab directory. In one, enter <code>make qemu-nox-gdb</code>). This starts up QEMU, but QEMU stops just before the processor executes the first instruction and waits for a debugging connection from GDB. In the second terminal, from the same directory you can run <code>make gdb</code>. You should see something like this,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">athena% make gdb</span><br><span class="line">GNU gdb (GDB) 6.8-debian</span><br><span class="line">Copyright (C) 2008 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;i486-linux-gnu&quot;.</span><br><span class="line">+ target remote localhost:26000</span><br><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0] 0xffff0:ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p><p>The following line:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f000:fff0] 0xffff0:ljmp   $0xf000,$0xe05b</span><br></pre></td></tr></table></figure></p><p>is GDBâ€™s disassembly of the first instruction to be executed. From this output you can conclude a few things:</p><ul><li>The IBM PC starts executing at physical address 0x000ffff0, which is at the very top of the 64KB area reserved for the ROM BIOS.</li><li>The PC starts executing with <code>CS = 0xf000</code> and <code>IP = 0xfff0</code>.</li><li>The first instruction to be executed is a <code>jmp</code> instruction, which jumps to the segmented address <code>CS = 0xf000</code> and <code>IP = 0xe05b</code>.</li></ul><p>Why does QEMU start like this? This is how Intel designed the 8088 processor, which IBM used in their original PC. Because the BIOS in a PC is â€œhard-wiredâ€ to the physical address range 0x000f0000-0x000fffff, this design ensures that the BIOS always gets control of the machine first after power-up or any system restart - which is crucial because on power-up there is no other software anywhere in the machineâ€™s RAM that the processor could execute. The QEMU emulator comes with its own BIOS, which it places at this location in the processorâ€™s simulated physical address space. On processor reset, the (simulated) processor enters real mode and sets CS to 0xf000 and the IP to 0xfff0, so that execution begins at that (CS:IP) segment address. How does the segmented address 0xf000:fff0 turn into a physical address?</p><p>To answer that we need to know a bit about real mode addressing. In real mode (the mode that PC starts off in), address translation works according to the formula: <em>physical address</em> = 16 * <em>segment</em> + <em>offset</em>. So, when the PC sets CS to 0xf000 and IP to 0xfff0, the physical address referenced is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16 * 0xf000 + 0xfff0   # in hex multiplication by 16 is</span><br><span class="line">= 0xf0000 + 0xfff0     # easy--just append a 0.</span><br><span class="line">= 0xffff0</span><br></pre></td></tr></table></figure></p><p>When the BIOS runs, it sets up an interrupt descriptor table and initializes various devices such as the VGA display. This is where the â€œ<strong>Starting SeaBIOS</strong>â€œ message you see in the QEMU window comes from.</p><p>After initializing the PCI bus and all the important devices the BIOS knows about, it searches for a bootable device such as a floppy, hard drive, or CD-ROM. Eventually, when it finds a bootable disk, the BIOS reads the <em>boot loader</em> from the disk and transfers control to it.</p><h2 id="2-Part-2-The-Boot-Loader"><a href="#2-Part-2-The-Boot-Loader" class="headerlink" title="2. Part 2: The Boot Loader"></a>2. Part 2: The Boot Loader</h2><p>If the disk is bootable, the first sector is called the <em>boot sector</em>, since this is where the boot loader code resides. When the BIOS finds a bootable floppy or hard disk, it loads the 512-byte boot sector into memory at physical addresses 0x7c00 through 0x7dff, and then uses a <code>jmp</code> instruction to set the CS:IP to <code>0000:7c00</code>, passing control to the boot loader.</p><p>The boot loader consists of one assembly language source file, <code>boot/boot.S</code>, and one C source file, <code>boot/main.c</code></p><p>The boot loader must perform two main functions:</p><ol><li>First, the boot loader switches the processor from real mode to <em>32-bit protected mode</em></li><li>Second, the boot loader reads the kernel from the hard disk by directly accessing the IDE disk device registers via the x86â€™s special I/O instructions. </li></ol><h3 id="2-1-debug"><a href="#2-1-debug" class="headerlink" title="2.1 debug"></a>2.1 debug</h3><p>After you understand the boot loader source code, look at the file <code>obj/boot/boot.asm</code>. This file is a disassembly of the boot loader that our GNUmakefile creates <em>after</em> compiling the boot loader. This disassembly file makes it easy to see exactly where in physical memory all of the boot loaderâ€™s code resides, and makes it easier to track whatâ€™s happening while stepping through the boot loader in GDB. Likewise, <code>obj/kern/kernel.asm</code> contains a disassembly of the JOS kernel, which can often be useful for debugging.</p><p>You can set address breakpoints in GDB with the <code>b</code> command. For example, <code>b *0x7c00</code>sets a breakpoint at address 0x7C00. Once at a breakpoint, you can continue execution using the <code>c</code> and <code>si</code> commands: <code>c</code> causes QEMU to continue execution until the next breakpoint (or until you press <code>Ctrl-C</code> in GDB), and <code>si N</code> steps through the instructions <em>N</em> at a time.</p><p>To examine instructions in memory (besides the immediate next one to be executed, which GDB prints automatically), you use the <code>x/i</code> command. This command has the syntax <code>x/Ni ADDR</code>, where <em>N</em> is the number of consecutive instructions to disassemble and <em>ADDR</em> is the memory address at which to start disassembling.</p><h3 id="2-2-Loading-the-Kernel"><a href="#2-2-Loading-the-Kernel" class="headerlink" title="2.2 Loading the Kernel"></a>2.2 Loading the Kernel</h3><p>Full information about this format is available in <a href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf" target="_blank" rel="noopener">the ELF specification</a>.</p><p>Examine the full list of the names, sizes, and link addresses of all the sections in the kernel executable by typing:</p><p><code>objdump -h obj/kern/kernel</code></p><p> You can inspect the program headers by typing:</p><p> <code>objdump -x obj/kern/kernel</code></p><p> You can see the entry point:</p><p> <code>objdump -f obj/kern/kernel</code></p><h2 id="3-Part-3-The-Kernel"><a href="#3-Part-3-The-Kernel" class="headerlink" title="3. Part 3: The Kernel"></a>3. Part 3: The Kernel</h2><h3 id="3-1-The-Stack"><a href="#3-1-The-Stack" class="headerlink" title="3.1 The Stack"></a>3.1 The Stack</h3><p>The x86 stack pointer (<code>esp</code> register) points to the lowest location on the stack that is currently in use. Everything <em>below</em> that location in the region reserved for the stack is free. Pushing a value onto the stack involves decreasing the stack pointer and then writing the value to the place the stack pointer points to. Popping a value from the stack involves reading the value the stack pointer points to and then increasing the stack pointer. In 32-bit mode, the stack can only hold 32-bit values, and esp is always divisible by four. Various x86 instructions, such as <code>call</code>, are â€œhard-wiredâ€ to use the stack pointer register.</p><p>The <code>ebp</code> (base pointer) register is associated with the stack primarily by software convention. On entry to a C function, the functionâ€™s <em>prologue</em> code normally saves the previous functionâ€™s base pointer by pushing it onto the stack, and then copies the current <code>esp</code> value into <code>ebp</code> for the duration of the function. If all the functions in a program obey this convention, then at any given point during the programâ€™s execution, it is possible to trace back through the stack by following the chain of saved <code>ebp</code> pointers and determining exactly what nested sequence of function calls caused this particular point in the program to be reached. This capability can be particularly useful, for example, when a particular function causes an <code>assert</code> failure or <code>panic</code> because bad arguments were passed to it, but you arenâ€™t sure <em>who</em> passed the bad arguments. A stack backtrace lets you find the offending function.</p><hr><p>å‚è€ƒèµ„æ–™ï¼š</p><ol><li><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/" target="_blank" rel="noopener">Lab 1: Booting a PC</a></li><li><a href="https://github.com/hehao98/MIT6.828Labs-JOS/blob/master/reports/Lab1.md" target="_blank" rel="noopener">https://github.com/hehao98/MIT6.828Labs-JOS/blob/master/reports/Lab1.md</a></li><li><a href="https://hehao98.github.io/posts/2019/03/xv6-1/" target="_blank" rel="noopener">XV6æ“ä½œç³»ç»Ÿä»£ç é˜…è¯»å¿ƒå¾—</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;æœ¬æ–‡ä¸»è¦è®°å½•xv6 lab1çš„ç›¸å…³ç¬”è®°ã€‚&lt;/p&gt;
    
    </summary>
    
      <category term="æ“ä½œç³»ç»Ÿ" scheme="http://liujunming.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="æ“ä½œç³»ç»Ÿ" scheme="http://liujunming.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="xv6" scheme="http://liujunming.github.io/tags/xv6/"/>
    
  </entry>
  
</feed>
