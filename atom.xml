<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2018-11-06T04:58:45.491Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Designing Data-Intensive Applications 读书笔记 -Consistency and Consensus</title>
    <link href="http://liujunming.github.io/2018/10/07/Designing-Data-Intensive-Applications-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Consistency-and-Consensus/"/>
    <id>http://liujunming.github.io/2018/10/07/Designing-Data-Intensive-Applications-读书笔记-Consistency-and-Consensus/</id>
    <published>2018-10-07T09:08:17.000Z</published>
    <updated>2018-11-06T04:58:45.491Z</updated>
    
    <content type="html"><![CDATA[<p><em>consensus</em>: that is, getting all of the nodes to agree on something. </p><p>If two nodes both believe that they are the leader, that situation is called split brain, and it often leads to data loss. Correct implementations of consensus help avoid such problems.<br><a id="more"></a></p><h2 id="Consistency-Guarantees"><a href="#Consistency-Guarantees" class="headerlink" title="Consistency Guarantees"></a>Consistency Guarantees</h2><p>Systems with stronger guarantees may have worse performance or be less fault-tolerant than systems with weaker guarantees.</p><p>Transaction isolation is primarily about avoiding race conditions due to concurrently executing transactions, whereas distributed consistency is mostly about coordinating the state of replicas in the face of delays and faults.</p><h2 id="Linearizability"><a href="#Linearizability" class="headerlink" title="Linearizability"></a>Linearizability</h2><p>中文翻译：线性一致性(强一致性)</p><p>Linearizability，the basic idea is to make a system appear as if there were only one copy of the data, and all operations on it are atomic.</p><p><img src="/images/2018/10/1.png" alt=""></p><h3 id="What-Makes-a-System-Linearizable"><a href="#What-Makes-a-System-Linearizable" class="headerlink" title="What Makes a System Linearizable?"></a>What Makes a System Linearizable?</h3><p><img src="/images/2018/10/2.png" alt=""></p><p>To make the system linearizable, we need to add another constraint.<br><img src="/images/2018/10/3.png" alt=""></p><p><img src="/images/2018/10/4.png" alt=""></p><p><strong>Linearizability Versus Serializability</strong></p><ul><li><em>Serializability</em></li></ul><p>Serializability is an isolation property of transactions, where every transaction may read and write multiple objects (rows, documents, records).It guarantees that transactions behave the same as if they had executed in some serial order (each transaction running to completion before the next transaction starts).</p><ul><li><em>Linearizability</em></li></ul><p>Linearizability is a recency guarantee on reads and writes of a register (an individual object).  It doesn’t group operations together into transactions, so it does not prevent problems such as write skew, unless you take additional measures.</p><h3 id="Relying-on-Linearizability"><a href="#Relying-on-Linearizability" class="headerlink" title="Relying on Linearizability"></a>Relying on Linearizability</h3><h4 id="Locking-and-leader-election"><a href="#Locking-and-leader-election" class="headerlink" title="Locking and leader election"></a>Locking and leader election</h4><h4 id="Constraints-and-uniqueness-guarantees"><a href="#Constraints-and-uniqueness-guarantees" class="headerlink" title="Constraints and uniqueness guarantees"></a>Constraints and uniqueness guarantees</h4><p>Uniqueness constraints are common in databases.</p><p>Similar issues arise if you want to ensure that a bank account balance never goes neg‐ ative, or that you don’t sell more items than you have in stock in the warehouse, or that two people don’t concurrently book the same seat on a flight or in a theater. These constraints all require there to be a single up-to-date value (the account balance, the stock level, the seat occupancy) that all nodes agree on.</p><h4 id="Cross-channel-timing-dependencies"><a href="#Cross-channel-timing-dependencies" class="headerlink" title="Cross-channel timing dependencies"></a>Cross-channel timing dependencies</h4><p><img src="/images/2018/10/5.png" alt=""></p><p> The message queue (steps 3 and 4 in Figure 9-5) might be faster than the internal replication inside the storage service.</p><p> This problem arises because there are two different communication channels between the web server and the resizer: the file storage and the message queue.</p><h3 id="Implementing-Linearizable-Systems"><a href="#Implementing-Linearizable-Systems" class="headerlink" title="Implementing Linearizable Systems"></a>Implementing Linearizable Systems</h3><p>Linearizability essentially means “behave as though there is only a single copy of the data, and all operations on it are atomic”.</p><ul><li>Single-leader replication (potentially linearizable)</li><li>Consensus algorithms (linearizable)</li><li>Multi-leader replication (not linearizable)</li><li>Leaderless replication (probably not linearizable)</li></ul><h4 id="Linearizability-and-quorums"><a href="#Linearizability-and-quorums" class="headerlink" title="Linearizability and quorums"></a>Linearizability and quorums</h4><p>Intuitively, it seems as though strict quorum reads and writes should be linearizable in a Dynamo-style model. However, when we have variable network delays, it is possible to have race conditions, as demonstrated in Figure 9-6.</p><p><img src="/images/2018/10/6.png" alt=""></p><p>It is safest to assume that a leaderless system with Dynamo-style replication does not provide linearizability.</p><h3 id="The-Cost-of-Linearizability"><a href="#The-Cost-of-Linearizability" class="headerlink" title="The Cost of Linearizability"></a>The Cost of Linearizability</h3><p><img src="/images/2018/10/7.png" alt=""></p><h4 id="The-CAP-theorem"><a href="#The-CAP-theorem" class="headerlink" title="The CAP theorem"></a>The CAP theorem</h4><p>The CAP theorem as formally defined is of very narrow scope: it only considers one consistency model (namely linearizability) and one kind of fault(network partitions). It doesn’t say anything about network delays, dead nodes, or other trade-offs. Thus, although CAP has been historically influential, it has little practical value for designing systems.</p><h4 id="Linearizability-and-network-delays"><a href="#Linearizability-and-network-delays" class="headerlink" title="Linearizability and network delays"></a>Linearizability and network delays</h4><h2 id="Ordering-Guarantees"><a href="#Ordering-Guarantees" class="headerlink" title="Ordering Guarantees"></a>Ordering Guarantees</h2><h3 id="Ordering-and-Causality"><a href="#Ordering-and-Causality" class="headerlink" title="Ordering and Causality"></a>Ordering and Causality</h3><p>Causality imposes an ordering on events: cause comes before effect.If a system obeys the ordering imposed by causality, we say that it is <em>causally consistent</em>. </p><h4 id="The-causal-order-is-not-a-total-order"><a href="#The-causal-order-is-not-a-total-order" class="headerlink" title="The causal order is not a total order"></a>The causal order is not a total order</h4><h4 id="Linearizability-is-stronger-than-causal-consistency"><a href="#Linearizability-is-stronger-than-causal-consistency" class="headerlink" title="Linearizability is stronger than causal consistency"></a>Linearizability is stronger than causal consistency</h4><p>Causal consistency is the strongest possible consistency model that does not slow down due to network delays, and remains available in the face of network failures.</p><h4 id="Capturing-causal-dependencies"><a href="#Capturing-causal-dependencies" class="headerlink" title="Capturing causal dependencies"></a>Capturing causal dependencies</h4><p>In order to maintain causality, you need to know which operation happened before which other operation. </p><h3 id="Sequence-Number-Ordering"><a href="#Sequence-Number-Ordering" class="headerlink" title="Sequence Number Ordering"></a>Sequence Number Ordering</h3><p>We can use sequence numbers or timestamps to order events.</p><h4 id="Lamport-timestamps"><a href="#Lamport-timestamps" class="headerlink" title="Lamport timestamps"></a>Lamport timestamps</h4><p><img src="/images/2018/10/8.png" alt=""></p><h4 id="Timestamp-ordering-is-not-sufficient"><a href="#Timestamp-ordering-is-not-sufficient" class="headerlink" title="Timestamp ordering is not sufficient"></a>Timestamp ordering is not sufficient</h4><p>It is not sufficient when a node has just received a request from a user to create a username, and needs to decide <em>right now</em> whether the request should succeed or fail. </p><p>In order to be sure that no other node is in the process of concurrently creating an account with the same username and a lower timestamp, you would have to check with every other node to see what it is doing.</p><p>The problem here is that the total order of operations only emerges after you have collected all of the operations.</p><p>In order to implement something like a uniqueness constraint for usernames, it’s not sufficient to have a total ordering of operations—you also need to know when that order is finalized. </p><p>This idea of knowing when your total order is finalized is captured in the topic of total order broadcast.</p><h3 id="Total-Order-Broadcast"><a href="#Total-Order-Broadcast" class="headerlink" title="Total Order Broadcast"></a>Total Order Broadcast</h3><p>Total order broadcast is usually described as a protocol for exchanging messages between nodes. Informally, it requires that two safety properties always be satisfied:</p><ul><li><em>Reliable delivery</em></li><li><em>Totally ordered delivery</em></li></ul><h4 id="Using-total-order-broadcast"><a href="#Using-total-order-broadcast" class="headerlink" title="Using total order broadcast"></a>Using total order broadcast</h4><p>Consensus services such as ZooKeeper and etcd actually implement total order broadcast. </p><p>An important aspect of total order broadcast is that the order is fixed at the time the messages are delivered.</p><h4 id="Implementing-linearizable-storage-using-total-order-broadcast"><a href="#Implementing-linearizable-storage-using-total-order-broadcast" class="headerlink" title="Implementing linearizable storage using total order broadcast"></a>Implementing linearizable storage using total order broadcast</h4><p>Total order broadcast is asynchronous: messages are guaranteed to be delivered reliably in a fixed order, but there is no guarantee about when a message will be delivered. By contrast, linearizability is a recency guarantee: a read is guaranteed to see the latest value written.</p><h2 id="Distributed-Transactions-and-Consensus"><a href="#Distributed-Transactions-and-Consensus" class="headerlink" title="Distributed Transactions and Consensus"></a>Distributed Transactions and Consensus</h2><ul><li><em>Leader election</em></li><li><em>Atomic commit</em></li></ul><h3 id="Atomic-Commit-and-Two-Phase-Commit-2PC"><a href="#Atomic-Commit-and-Two-Phase-Commit-2PC" class="headerlink" title="Atomic Commit and Two-Phase Commit (2PC)"></a>Atomic Commit and Two-Phase Commit (2PC)</h3><h4 id="From-single-node-to-distributed-atomic-commit"><a href="#From-single-node-to-distributed-atomic-commit" class="headerlink" title="From single-node to distributed atomic commit"></a>From single-node to distributed atomic commit</h4><h4 id="Introduction-to-two-phase-commit"><a href="#Introduction-to-two-phase-commit" class="headerlink" title="Introduction to two-phase commit"></a>Introduction to two-phase commit</h4><p>Two-phase commit is an algorithm for achieving atomic transaction commit across multiple nodes—i.e., to ensure that either all nodes commit or all nodes abort.</p><p>The commit/abort process in 2PC is split into two phases (hence the name).</p><p><img src="/images/2018/10/9.png" alt=""></p><h4 id="Coordinator-failure"><a href="#Coordinator-failure" class="headerlink" title="Coordinator failure"></a>Coordinator failure</h4><p>If any of the prepare requests fail or time out, the coordinator aborts the transaction; if any of the commit or abort requests fail, the coordinator retries them indefinitely.</p><p><img src="/images/2018/10/10.png" alt=""></p><p>The only way 2PC can complete is by waiting for the coordinator to recover.</p><h4 id="Three-phase-commit"><a href="#Three-phase-commit" class="headerlink" title="Three-phase commit"></a>Three-phase commit</h4><p>Two-phase commit is called a <em>blocking</em> atomic commit protocol due to the fact that 2PC can become stuck waiting for the coordinator to recover. </p><p>three-phase commit (3PC)  assumes a network with bounded delay and nodes with bounded response times; in most practical systems with unbounded network delay and process pauses , it cannot guarantee atomicity.</p><h3 id="Distributed-Transactions-in-Practice"><a href="#Distributed-Transactions-in-Practice" class="headerlink" title="Distributed Transactions in Practice"></a>Distributed Transactions in Practice</h3><p><em>Database-internal distributed transactions</em><br><em>Heterogeneous distributed transactions</em></p><h4 id="Exactly-once-message-processing"><a href="#Exactly-once-message-processing" class="headerlink" title="Exactly-once message processing"></a>Exactly-once message processing</h4><h4 id="XA-transactions"><a href="#XA-transactions" class="headerlink" title="XA transactions"></a>XA transactions</h4><p>XA is not a network protocol—it is merely a C API for interfacing with a transaction coordinator.</p><h4 id="Holding-locks-while-in-doubt"><a href="#Holding-locks-while-in-doubt" class="headerlink" title="Holding locks while in doubt"></a>Holding locks while in doubt</h4><h4 id="Recovering-from-coordinator-failure"><a href="#Recovering-from-coordinator-failure" class="headerlink" title="Recovering from coordinator failure"></a>Recovering from coordinator failure</h4><h4 id="Limitations-of-distributed-transactions"><a href="#Limitations-of-distributed-transactions" class="headerlink" title="Limitations of distributed transactions"></a>Limitations of distributed transactions</h4><h3 id="Fault-Tolerant-Consensus"><a href="#Fault-Tolerant-Consensus" class="headerlink" title="Fault-Tolerant Consensus"></a>Fault-Tolerant Consensus</h3><p>Informally, consensus means getting several nodes to agree on something.</p><p>The consensus problem is normally formalized as follows: one or more nodes may <em>propose</em> values, and the consensus algorithm <em>decides</em> on one of those values.</p><p>In this formalism, a consensus algorithm must satisfy the following properties:</p><ul><li>Uniform agreement</li><li>Integrity</li><li>Validity</li><li>Termination</li></ul><h4 id="Consensus-algorithms-and-total-order-broadcast"><a href="#Consensus-algorithms-and-total-order-broadcast" class="headerlink" title="Consensus algorithms and total order broadcast"></a>Consensus algorithms and total order broadcast</h4><p>The best-known fault-tolerant consensus algorithms are Viewstamped Replication (VSR), Paxos, Raft, and Zab.</p><p>They decide on a <em>sequence</em> of values, which makes them <em>total order broadcast</em> algorithms</p><h4 id="Single-leader-replication-and-consensus"><a href="#Single-leader-replication-and-consensus" class="headerlink" title="Single-leader replication and consensus"></a>Single-leader replication and consensus</h4><h4 id="Epoch-numbering-and-quorums"><a href="#Epoch-numbering-and-quorums" class="headerlink" title="Epoch numbering and quorums"></a>Epoch numbering and quorums</h4><p>All of the consensus protocols discussed so far internally use a leader in some form or another, but they don’t guarantee that the leader is unique. Instead, they can make a weaker guarantee: the protocols define an <em>epoch number</em> and guarantee that within each epoch, the leader is unique.</p><p>We have two rounds of voting: once to choose a leader, and a second time to vote on a leader’s proposal. </p><p>This voting process looks superficially similar to two-phase commit. The biggest differences are that in 2PC the coordinator is not elected, and that fault-tolerant consensus algorithms only require votes from a majority of nodes, whereas 2PC requires a “yes” vote from every participant. Moreover, consensus algorithms define a recovery process by which nodes can get into a consistent state after a new leader is elected, ensuring that the safety properties are always met. These differences are key to the correctness and fault tolerance of a consensus algorithm.</p><h4 id="Limitations-of-consensus"><a href="#Limitations-of-consensus" class="headerlink" title="Limitations of consensus"></a>Limitations of consensus</h4><p>The process by which nodes vote on proposals before they are decided is a kind of synchronous replication.<br>Consensus systems always require a strict majority to operate.<br>Most consensus algorithms assume a fixed set of nodes that participate in voting, which means that you can’t just add or remove nodes in the cluster.<br>Consensus systems generally rely on timeouts to detect failed nodes.<br>Sometimes, consensus algorithms are particularly sensitive to network problems.</p><h3 id="Membership-and-Coordination-Services"><a href="#Membership-and-Coordination-Services" class="headerlink" title="Membership and Coordination Services"></a>Membership and Coordination Services</h3><p>ZooKeeper and etcd are designed to hold small amounts of data that can fit entirely in memory.That small amount of data is replicated across all the nodes using a fault-tolerant total order broadcast algorithm. </p><p>ZooKeeper is modeled after Google’s Chubby lock service , implementing not only total order broadcast (and hence consensus), but also an interesting set of other features that turn out to be particularly useful when building distributed systems:</p><ul><li>Linearizable atomic operations</li><li>Total ordering of operations</li><li>Failure detection</li><li>Change notifications</li></ul><h4 id="Allocating-work-to-nodes"><a href="#Allocating-work-to-nodes" class="headerlink" title="Allocating work to nodes"></a>Allocating work to nodes</h4><p>Normally, the kind of data managed by ZooKeeper is quite slow-changing.</p><h4 id="Service-discovery"><a href="#Service-discovery" class="headerlink" title="Service discovery"></a>Service discovery</h4><h4 id="Membership-services"><a href="#Membership-services" class="headerlink" title="Membership services"></a>Membership services</h4><p>A membership service determines which nodes are currently active and live members of a cluster. </p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>It turns out that a wide range of problems are actually reducible to consensus and are equivalent to each other.</p><ul><li>Linearizable compare-and-set registers</li><li>Atomic transaction commit</li><li>Total order broadcast</li><li>Locks and leases</li><li>Membership/coordination service</li><li>Uniqueness constraint</li></ul><p>Not every system necessarily requires consensus: for example, leaderless and multi-leader replication systems typically do not use global consensus.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;consensus&lt;/em&gt;: that is, getting all of the nodes to agree on something. &lt;/p&gt;
&lt;p&gt;If two nodes both believe that they are the leader, that situation is called split brain, and it often leads to data loss. Correct implementations of consensus help avoid such problems.&lt;br&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://liujunming.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://liujunming.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Designing Data-Intensive Applications 读书笔记 -The Trouble with Distributed Systems</title>
    <link href="http://liujunming.github.io/2018/09/25/Designing-Data-Intensive-Applications-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-The-Trouble-with-Distributed-Systems/"/>
    <id>http://liujunming.github.io/2018/09/25/Designing-Data-Intensive-Applications-读书笔记-The-Trouble-with-Distributed-Systems/</id>
    <published>2018-09-25T06:02:17.000Z</published>
    <updated>2018-11-06T08:18:30.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unreliable-Networks"><a href="#Unreliable-Networks" class="headerlink" title="Unreliable Networks"></a>Unreliable Networks</h2><p><img src="/images/2018/9/41.png" alt=""><br>The usual way of handling this issue is a <em>timeout</em>: after some time you give up waiting and assume that the response is not going to arrive. However, when a timeout occurs, you still don’t know whether the remote node got your request or not.<br><a id="more"></a></p><h3 id="Network-Faults-in-Practice"><a href="#Network-Faults-in-Practice" class="headerlink" title="Network Faults in Practice"></a>Network Faults in Practice</h3><h3 id="Detecting-Faults"><a href="#Detecting-Faults" class="headerlink" title="Detecting Faults"></a>Detecting Faults</h3><h3 id="Timeouts-and-Unbounded-Delays"><a href="#Timeouts-and-Unbounded-Delays" class="headerlink" title="Timeouts and Unbounded Delays"></a>Timeouts and Unbounded Delays</h3><p>如果超时是检测故障的唯一可靠方法，那么超时应该等待多久？不幸的是没有简单的答案。</p><h3 id="Synchronous-Versus-Asynchronous-Networks"><a href="#Synchronous-Versus-Asynchronous-Networks" class="headerlink" title="Synchronous Versus Asynchronous Networks"></a>Synchronous Versus Asynchronous Networks</h3><p>It is possible to give hard real-time response guarantees and bounded delays in networks, but doing so is very expensive and results in lower utilization of hardware resources. Most non-safety-critical systems choose cheap and unreliable over expensive and reliable.</p><h2 id="Unreliable-Clocks"><a href="#Unreliable-Clocks" class="headerlink" title="Unreliable Clocks"></a>Unreliable Clocks</h2><p>可以在一定程度上同步时钟：最常用的机制是网络时间协议（NTP），它允许根据一组服务器报告的时间来调整计算机时钟。服务器则从更精确的时间源（如GPS接收机）获取时间。</p><h3 id="Monotonic-Versus-Time-of-Day-Clocks"><a href="#Monotonic-Versus-Time-of-Day-Clocks" class="headerlink" title="Monotonic Versus Time-of-Day Clocks"></a>Monotonic Versus Time-of-Day Clocks</h3><p>时钟可以及时跳回。<br>单调钟适用于测量持续时间（时间间隔），例如超时或服务的响应时间。</p><p>​在分布式系统中，使用单调钟测量经过时间（比如超时）通常很好，因为它不假定不同节点的时钟之间存在任何同步，并且对测量的轻微不准确性不敏感。</p><h3 id="Clock-Synchronization-and-Accuracy"><a href="#Clock-Synchronization-and-Accuracy" class="headerlink" title="Clock Synchronization and Accuracy"></a>Clock Synchronization and Accuracy</h3><h3 id="Relying-on-Synchronized-Clocks"><a href="#Relying-on-Synchronized-Clocks" class="headerlink" title="Relying on Synchronized Clocks"></a>Relying on Synchronized Clocks</h3><h3 id="Process-Pauses"><a href="#Process-Pauses" class="headerlink" title="Process Pauses"></a>Process Pauses</h3><p> Say you have a database with a single leader per partition. Only the leader is allowed to accept writes. How does a node know that it is still leader (that it hasn’t been declared dead by the others), and that it may safely accept writes?</p><p> One option is for the leader to obtain a <em>lease</em> from the other nodes. Only one node can hold the lease at any one time—thus, when a node obtains a lease, it knows that it is the leader for some amount of time, until the lease expires. In order to remain leader, the node must periodically renew the lease before it expires. If the node fails, it stops renewing the lease, so another node can take over when it expires.</p><p> You can imagine the request-handling loop looking something like this:</p><p><img src="/images/2018/9/42.png" alt=""></p><p>Firstly, it’s relying on synchronized clocks.However, what if there is an unexpected pause in the execution of the program? For example, imagine the thread stops for 15 seconds around the line <code>lease.isValid()</code> before finally continuing. In that case, it’s likely that the lease will have expired by the time the request is processed, and another node has already taken over as leader. However, there is nothing to tell this thread that it was paused for so long, so this code won’t notice that the lease has expired until the next iteration of the loop—by which time it may have already done something unsafe by processing the request.</p><h2 id="Knowledge-Truth-and-Lies"><a href="#Knowledge-Truth-and-Lies" class="headerlink" title="Knowledge, Truth, and Lies"></a>Knowledge, Truth, and Lies</h2><p>So far in this chapter we have explored the ways in which distributed systems are different from programs running on a single computer: there is no shared memory, only message passing via an unreliable network with variable delays, and the systems may suffer from partial failures, unreliable clocks, and processing pauses.</p><h3 id="The-Truth-Is-Defined-by-the-Majority"><a href="#The-Truth-Is-Defined-by-the-Majority" class="headerlink" title="The Truth Is Defined by the Majority"></a>The Truth Is Defined by the Majority</h3><p>A node cannot necessarily trust its own judgment of a situation.A distributed system cannot exclusively rely on a single node, because a node may fail at any time, potentially leaving the system stuck and unable to recover. Instead, many distributed algorithms rely on a quorum, that is, voting among the nodes.</p><p>That includes decisions about declaring nodes dead. If a quorum of nodes declares another node dead, then it must be considered dead, even if that node still very much feels alive. The individual node must abide by the quorum decision and step down.</p><h4 id="The-leader-and-the-lock"><a href="#The-leader-and-the-lock" class="headerlink" title="The leader and the lock"></a>The leader and the lock</h4><p><img src="/images/2018/9/43.png" alt=""><br>If the client holding the lease is paused for too long, its lease expires. Another client can obtain a lease for the same file, and start writing to the file. When the paused client comes back, it believes (incorrectly) that it still has a valid lease and proceeds to also write to the file. As a result, the clients’ writes clash and corrupt the file.</p><h4 id="Fencing-tokens"><a href="#Fencing-tokens" class="headerlink" title="Fencing tokens"></a>Fencing tokens</h4><p>Fencing tokens(防护令牌)</p><p>We need to ensure that a node that is under a false belief of being “the chosen one” cannot disrupt the rest of the system.</p><p><img src="/images/2018/9/44.png" alt=""></p><h3 id="Byzantine-Faults"><a href="#Byzantine-Faults" class="headerlink" title="Byzantine Faults"></a>Byzantine Faults</h3><p>Fencing tokens can detect and block a node that is <em>inadvertently</em> acting in error.If the node deliberately wanted to subvert the system’s guarantees, it could easily do so by sending messages with a fake fencing token.</p><p>Distributed systems problems become much harder if there is a risk that nodes may “lie” (send arbitrary faulty or corrupted responses)—for example, if a node may claim to have received a particular message when in fact it didn’t. Such behavior is known as a <em>Byzantine fault</em>, and the problem of reaching consensus in this untrusting environment is known as the <em>Byzantine Generals Problem</em>.</p><p>A system is <em>Byzantine fault-tolerant</em> if it continues to operate correctly even if some of the nodes are malfunctioning and not obeying the protocol, or if malicious attackers are interfering with the network.</p><p>Byzantine是错综复杂的意思。</p><h3 id="System-Model-and-Reality"><a href="#System-Model-and-Reality" class="headerlink" title="System Model and Reality"></a>System Model and Reality</h3><p>With regard to timing assumptions, three system models are in common use:</p><ul><li><em>Synchronous model</em></li><li><em>Partially synchronous model</em></li><li><em>Asynchronous model</em></li></ul><p>Moreover, besides timing issues, we have to consider node failures. The three most common system models for nodes are:</p><ul><li><em>Crash-stop faults</em></li><li><em>Crash-recovery faults</em></li><li><em>Byzantine (arbitrary) faults</em></li></ul><p>For modeling real systems, the partially synchronous model with crash-recovery faults is generally the most useful model.</p><h4 id="Correctness-of-an-algorithm"><a href="#Correctness-of-an-algorithm" class="headerlink" title="Correctness of an algorithm"></a>Correctness of an algorithm</h4><h4 id="Safety-and-liveness"><a href="#Safety-and-liveness" class="headerlink" title="Safety and liveness"></a>Safety and liveness</h4><p>Liveness properties often include the word “eventually” in their definition.</p><p>Safety is often informally defined as <em>nothing bad happens</em>, and liveness as <em>something good eventually happens</em>.</p><p>An advantage of distinguishing between safety and liveness properties is that it helps us deal with difficult system models. </p><h4 id="Mapping-system-models-to-the-real-world"><a href="#Mapping-system-models-to-the-real-world" class="headerlink" title="Mapping system models to the real world"></a>Mapping system models to the real world</h4><p>Safety and liveness properties and system models are very useful for reasoning about the correctness of a distributed algorithm.</p><p>Proving an algorithm correct does not mean its <em>implementation</em> on a real system will necessarily always behave correctly.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Unreliable-Networks&quot;&gt;&lt;a href=&quot;#Unreliable-Networks&quot; class=&quot;headerlink&quot; title=&quot;Unreliable Networks&quot;&gt;&lt;/a&gt;Unreliable Networks&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/2018/9/41.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;The usual way of handling this issue is a &lt;em&gt;timeout&lt;/em&gt;: after some time you give up waiting and assume that the response is not going to arrive. However, when a timeout occurs, you still don’t know whether the remote node got your request or not.&lt;br&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://liujunming.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://liujunming.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Designing Data-Intensive Applications 读书笔记 -Transactions</title>
    <link href="http://liujunming.github.io/2018/09/23/Designing-Data-Intensive-Applications-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Transactions/"/>
    <id>http://liujunming.github.io/2018/09/23/Designing-Data-Intensive-Applications-读书笔记-Transactions/</id>
    <published>2018-09-23T05:03:31.000Z</published>
    <updated>2018-11-06T08:19:49.434Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要是在单机数据库的上下文中，探讨了各种概念与想法。<br><a id="more"></a></p><h2 id="The-Slippery-Concept-of-a-Transaction"><a href="#The-Slippery-Concept-of-a-Transaction" class="headerlink" title="The Slippery Concept of a Transaction"></a>The Slippery Concept of a Transaction</h2><h3 id="The-Meaning-of-ACID"><a href="#The-Meaning-of-ACID" class="headerlink" title="The Meaning of ACID"></a>The Meaning of ACID</h3><p>Systems that do not meet the ACID criteria are sometimes called BASE, which stands for Basically Available, Soft state, and Eventual consistency. </p><h4 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h4><p>ACID atomicity describes what happens if a client wants to make several writes, but a fault occurs after some of the writes have been processed.</p><h4 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h4><p>The word consistency is terribly overloaded:</p><ul><li>replica consistency and the issue of eventual consistency that arises in asynchronously replicated systems.</li><li>Consistent hashing is an approach to partitioning that some systems use for rebalancing.</li><li>In the CAP theorem , the word consistency is used to mean linearizability.</li></ul><p>The idea of ACID consistency is that you have certain statements about your data (invariants) that must always be true.</p><h4 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h4><p>Most databases are accessed by several clients at the same time. That is no problem if they are reading and writing different parts of the database, but if they are accessing the same database records, you can run into concurrency problems (race conditions).</p><p>ACID意义上的隔离性意味着，同时执行的事务是相互隔离的：它们不能相互冒犯。</p><h4 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h4><p>持久性 是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。</p><h3 id="Single-Object-and-Multi-Object-Operations"><a href="#Single-Object-and-Multi-Object-Operations" class="headerlink" title="Single-Object and Multi-Object Operations"></a>Single-Object and Multi-Object Operations</h3><p>图7-2展示了一个来自邮件应用的例子。执行以下查询来显示用户未读邮件数量：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> emails <span class="keyword">WHERE</span> recipient_id = <span class="number">2</span> <span class="keyword">AND</span> unread_flag = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>但如果邮件太多，你可能会觉得这个查询太慢，并决定用单独的字段存储未读邮件的数量。现在每当一个新消息写入时，也必须增长未读计数器，每当一个消息被标记为已读时，也必须减少未读计数器。</p><p>在图7-2中，用户2 遇到异常情况：邮件列表里显示有未读消息，但计数器显示为零未读消息，因为计数器增长还没有发生。隔离性可以避免这个问题：通过确保用户2要么同时看到新邮件和增长后的计数器，要么都看不到，反正不会看到执行到一半的中间结果。</p><p><img src="/images/2018/9/28.png" alt=""></p><p>图7-3说明了对原子性的需求：如果在事务过程中发生错误，邮箱和未读计数器的内容可能会失去同步。在原子事务中，如果对计数器的更新失败，事务将被中止，并且插入的电子邮件将被回滚。</p><p><img src="/images/2018/9/29.png" alt=""></p><p>A transaction is usually understood as a mechanism for grouping multiple operations on multiple objects into one unit of execution.</p><h2 id="Weak-Isolation-Levels"><a href="#Weak-Isolation-Levels" class="headerlink" title="Weak Isolation Levels"></a>Weak Isolation Levels</h2><p>如果两个事务不触及相同的数据，它们可以安全地并行（parallel） 运行，因为两者都不依赖于另一个。当一个事务读取由另一个事务同时修改的数据时，或者当两个事务试图同时修改相同的数据时，并发问题（竞争条件）才会出现。</p><h3 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h3><p>The most basic level of transaction isolation is read committed.It makes two guarantees:</p><ol><li>When reading from the database, you will only see data that has been committed (no dirty reads).</li><li>When writing to the database, you will only overwrite data that has been committed (no dirty writes).</li></ol><h4 id="No-dirty-reads"><a href="#No-dirty-reads" class="headerlink" title="No dirty reads"></a>No dirty reads</h4><p>Imagine a transaction has written some data to the database, but the transaction has not yet committed or aborted. Can another transaction see that uncommitted data? If yes, that is called a <em>dirty read</em>.</p><p><img src="/images/2018/9/31.png" alt=""></p><h4 id="No-dirty-writes"><a href="#No-dirty-writes" class="headerlink" title="No dirty writes"></a>No dirty writes</h4><p>What happens if two transactions concurrently try to update the same object in a database? We don’t know in which order the writes will happen, but we normally assume that the later write overwrites the earlier write.</p><p>However, what happens if the earlier write is part of a transaction that has not yet committed, so the later write overwrites an uncommitted value? This is called a <em>dirty write</em>. Transactions running at the read committed isolation level must prevent dirty writes, usually by delaying the second write until the first write’s transaction has committed or aborted.</p><p><img src="/images/2018/9/32.png" alt=""></p><h4 id="Implementing-read-committed"><a href="#Implementing-read-committed" class="headerlink" title="Implementing read committed"></a>Implementing read committed</h4><p>Most commonly, databases prevent dirty writes by using row-level locks.</p><p>Most databases prevent dirty reads using the approach illustrated in Figure 7-4: for every object that is written, the database remembers both the old committed value and the new value set by the transaction that currently holds the write lock. </p><h3 id="Snapshot-Isolation"><a href="#Snapshot-Isolation" class="headerlink" title="Snapshot Isolation"></a>Snapshot Isolation</h3><p>在PostgreSQL and MySQL中，Snapshot Isolation即为Repeatable Read。</p><p>图7-6说明了read committed可能发生的问题。<br><img src="/images/2018/9/33.png" alt=""></p><p>这种异常被称为不可重复读（nonrepeatable read）或读取偏差（read skew）。</p><p><em>Snapshot isolation</em>能解决read skew问题。The idea is that each transaction reads from a <em>consistent snapshot</em> of the database—that is, the transaction sees all the data that was committed in the database at the start of the transaction. Even if the data is subsequently changed by another transaction, each transaction sees only the old data from that particular point in time.</p><h4 id="Implementing-snapshot-isolation"><a href="#Implementing-snapshot-isolation" class="headerlink" title="Implementing snapshot isolation"></a>Implementing snapshot isolation</h4><p>A key principle of snapshot isolation is <em>readers never block writers, and writers never block readers</em>.</p><p>The database must potentially keep several different committed versions of an object, because various in-progress transactions may need to see the state of the database at different points in time. Because it maintains several versions of an object side by side, this technique is known as <em>multi-version concurrency control</em>(MVCC).</p><p>图7-7说明了如何在PostgreSQL中实现基于MVCC的快照隔离。当一个事务开始时，它被赋予一个唯一的事务ID。每当事务向数据库写入任何内容时，它所写入的数据都会被标记上写入者的事务ID。</p><p><img src="/images/2018/9/34.png" alt=""></p><h4 id="Visibility-rules-for-observing-a-consistent-snapshot"><a href="#Visibility-rules-for-observing-a-consistent-snapshot" class="headerlink" title="Visibility rules for observing a consistent snapshot"></a>Visibility rules for observing a consistent snapshot</h4><p>When a transaction reads from the database, transaction IDs are used to decide which objects it can see and which are invisible. By carefully defining visibility rules,the database can present a consistent snapshot of the database to the application. </p><h4 id="Indexes-and-snapshot-isolation"><a href="#Indexes-and-snapshot-isolation" class="headerlink" title="Indexes and snapshot isolation"></a>Indexes and snapshot isolation</h4><p><img src="/images/2018/9/30.png" alt=""></p><h3 id="Preventing-Lost-Updates"><a href="#Preventing-Lost-Updates" class="headerlink" title="Preventing Lost Updates"></a>Preventing Lost Updates</h3><p>到目前为止已经讨论的read committed和snapshot isolation级别，主要保证了只读事务在并发写入时可以看到什么。却忽略了两个事务并发写入的问题——我们只讨论了脏写。</p><p>并发的写入事务之间还有其他几种有趣的冲突。其中最着名的是丢失更新（lost update） 问题，如下图所示，以两个并发计数器增量为例。</p><p><img src="/images/2018/9/35.png" alt=""></p><p>The lost update problem can occur if an application reads some value from the database, modifies it, and writes back the modified value (a <em>read-modify-write cycle</em>). If two transactions do this concurrently, one of the modifications can be lost, because the second write does not include the first modification.</p><p>Because this is such a common problem, a variety of solutions have been developed.</p><h4 id="Atomic-write-operations"><a href="#Atomic-write-operations" class="headerlink" title="Atomic write operations"></a>Atomic write operations</h4><p>Many databases provide atomic update operations, which remove the need to implement read-modify-write cycles in application code.</p><h4 id="Explicit-locking"><a href="#Explicit-locking" class="headerlink" title="Explicit locking"></a>Explicit locking</h4><p>Another option for preventing lost updates, if the database’s built-in atomic operations don’t provide the necessary functionality, is for the application to explicitly lock objects that are going to be updated.</p><p><img src="/images/2018/9/36.png" alt=""></p><h4 id="Automatically-detecting-lost-updates"><a href="#Automatically-detecting-lost-updates" class="headerlink" title="Automatically detecting lost updates"></a>Automatically detecting lost updates</h4><p>Atomic operations and locks are ways of preventing lost updates by forcing the read-modify-write cycles to happen sequentially. An alternative is to allow them to execute in parallel and, if the transaction manager detects a lost update, abort the transaction and force it to retry its read-modify-write cycle.</p><h4 id="Compare-and-set-CAS"><a href="#Compare-and-set-CAS" class="headerlink" title="Compare-and-set(CAS)"></a>Compare-and-set(CAS)</h4><p>In databases that don’t provide transactions, you sometimes find an <strong>atomic</strong> compare-and-set operation. The purpose of this operation is to avoid lost updates by allowing an update to happen only if the value has not changed since you last read it. If the current value does not match what you previously read, the update has no effect, and the read-modify-write cycle must be retried.</p><p>For example, to prevent two users concurrently updating the same wiki page, you might try something like this, expecting the update to occur only if the content of the page hasn’t changed since the user started editing it:</p><p><img src="/images/2018/9/37.png" alt=""></p><h4 id="Conflict-resolution-and-replication"><a href="#Conflict-resolution-and-replication" class="headerlink" title="Conflict resolution and replication"></a>Conflict resolution and replication</h4><p>Locks and compare-and-set operations assume that there is a single up-to-date copy of the data. However, databases with multi-leader or leaderless replication usually allow several writes to happen concurrently and replicate them asynchronously, so they cannot guarantee that there is a single up-to-date copy of the data. Thus, techniques based on locks or CAS do not apply in this context.</p><h3 id="Write-Skew-and-Phantoms"><a href="#Write-Skew-and-Phantoms" class="headerlink" title="Write Skew and Phantoms"></a>Write Skew and Phantoms</h3><p>phantoms在本文中的含义是幻读。</p><p>想象一下这个例子：你正在为医院写一个医生轮班管理程序。医院通常会同时要求几位医生值班，但底线是至少有一位医生在值班。医生可以放弃他们的班次（例如，如果他们自己生病了），只要至少有一个同事在这一班中继续工作。<br>现在想象一下，Alice和Bob是两位值班医生。两人都感到不适，所以他们都决定请假。不幸的是，他们恰好在同一时间点击按钮下班。图7-8说明了接下来的事情。</p><p><img src="/images/2018/9/38.png" alt=""></p><p>在两个事务中，应用首先检查是否有两个或以上的医生正在值班；如果是的话，它就假定一名医生可以安全地休班。由于数据库使用Snapshot Isolation，两次检查都返回 2 ，所以两个事务都进入下一个阶段。Alice更新自己的记录休班了，而Bob也做了一样的事情。两个事务都成功提交了，现在没有医生值班了。违反了至少有一名医生在值班的要求。</p><h4 id="Characterizing-write-skew"><a href="#Characterizing-write-skew" class="headerlink" title="Characterizing write skew"></a>Characterizing write skew</h4><p>这种异常称为 <em>write skew</em>.</p><p> Write skew can occur if two transactions read the same objects, and then update some of those objects (different transactions may update different objects). In the special case where different transactions update the same object, you get a dirty write or lost update anomaly (depending on the timing).</p><h4 id="More-examples-of-write-skew"><a href="#More-examples-of-write-skew" class="headerlink" title="More examples of write skew"></a>More examples of write skew</h4><h4 id="Phantoms-causing-write-skew"><a href="#Phantoms-causing-write-skew" class="headerlink" title="Phantoms causing write skew"></a>Phantoms causing write skew</h4><p>This effect, where a write in one transaction changes the result of a search query in another transaction, is called a <em>phantom</em>.</p><h2 id="Serializability"><a href="#Serializability" class="headerlink" title="Serializability"></a>Serializability</h2><p>目前大多数提供可序列化的数据库都使用了三种技术。</p><h3 id="Actual-Serial-Execution"><a href="#Actual-Serial-Execution" class="headerlink" title="Actual Serial Execution"></a>Actual Serial Execution</h3><p>If you can make each transaction very fast to execute, and the transaction throughput is low enough to process on a single CPU core, this is a simple and effective option.</p><h3 id="Two-Phase-Locking-2PL"><a href="#Two-Phase-Locking-2PL" class="headerlink" title="Two-Phase Locking (2PL)"></a>Two-Phase Locking (2PL)</h3><h4 id="Implementation-of-two-phase-locking"><a href="#Implementation-of-two-phase-locking" class="headerlink" title="Implementation of two-phase locking"></a>Implementation of two-phase locking</h4><p>After a transaction has acquired the lock, it must continue to hold the lock until the end of the transaction (commit or abort). This is where the name “two-phase” comes from: the first phase (while the transaction is executing) is when the locks are acquired, and the second phase (at the end of the transaction) is when all the locks are released.</p><h3 id="Serializable-Snapshot-Isolation-SSI"><a href="#Serializable-Snapshot-Isolation-SSI" class="headerlink" title="Serializable Snapshot Isolation (SSI)"></a>Serializable Snapshot Isolation (SSI)</h3><h4 id="Pessimistic-versus-optimistic-concurrency-control"><a href="#Pessimistic-versus-optimistic-concurrency-control" class="headerlink" title="Pessimistic versus optimistic concurrency control"></a>Pessimistic versus optimistic concurrency control</h4><p>Two-phase locking is a so-called pessimistic concurrency control mechanism.<br>Serializable snapshot isolation is an optimistic concurrency control technique. </p><p>SSI is based on snapshot isolation—that is, all reads within a transaction are made from a consistent snapshot of the database. This is the main difference compared to earlier optimistic concurrency control techniques. On top of snapshot isolation, SSI adds an algorithm for detecting serialization conflicts among writes and determining which transactions to abort.</p><p>In order to provide serializable isolation, the database must detect situations in which a transaction may have acted on an outdated premise and abort the transaction in that case.</p><p>How does the database know if a query result might have changed? There are two cases to consider:</p><ul><li>Detecting reads of a stale MVCC object version (uncommitted write occurred before the read)</li><li>Detecting writes that affect prior reads (the write occurs after the read)</li></ul><h4 id="Detecting-stale-MVCC-reads"><a href="#Detecting-stale-MVCC-reads" class="headerlink" title="Detecting stale MVCC reads"></a>Detecting stale MVCC reads</h4><p><img src="/images/2018/9/39.png" alt=""></p><h4 id="Detecting-writes-that-affect-prior-reads"><a href="#Detecting-writes-that-affect-prior-reads" class="headerlink" title="Detecting writes that affect prior reads"></a>Detecting writes that affect prior reads</h4><p><img src="/images/2018/9/40.png" alt=""></p><hr><p>参考资料：</p><ol><li><a href="https://github.com/Vonng/ddia/blob/master/ch7.md" target="_blank" rel="noopener">Vonng ddia</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要是在单机数据库的上下文中，探讨了各种概念与想法。&lt;br&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://liujunming.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://liujunming.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Designing Data-Intensive Applications 读书笔记 -Partitioning</title>
    <link href="http://liujunming.github.io/2018/09/20/Designing-Data-Intensive-Applications-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Partitioning/"/>
    <id>http://liujunming.github.io/2018/09/20/Designing-Data-Intensive-Applications-读书笔记-Partitioning/</id>
    <published>2018-09-20T08:23:50.000Z</published>
    <updated>2018-11-06T08:20:17.203Z</updated>
    
    <content type="html"><![CDATA[<p>partition在本文中的翻译为分区。<br>数据量非常大的时候，在单台机器上存储和处理不再可行，则分区十分必要。分区的目标是在多台机器上均匀分布数据和查询负载，避免出现热点（负载不成比例的节点）。这需要选择适合于您的数据的分区方案，并在将节点添加到集群或从集群删除时进行再分区。分区主要是为了可扩展性(scalability)。<br><a id="more"></a></p><h2 id="Partitioning-and-Replication"><a href="#Partitioning-and-Replication" class="headerlink" title="Partitioning and Replication"></a>Partitioning and Replication</h2><p>分区通常与复制结合使用，使得每个分区的副本存储在多个节点上。 这意味着，即使每条记录属于一个分区，它仍然可以存储在多个不同的节点上以获得容错能力。</p><p><img src="/images/2018/9/20.png" alt=""></p><h2 id="Partitioning-of-Key-Value-Data"><a href="#Partitioning-of-Key-Value-Data" class="headerlink" title="Partitioning of Key-Value Data"></a>Partitioning of Key-Value Data</h2><p>如果分区是不公平的，一些分区比其他分区有更多的数据或查询，我们称之为偏斜（skew）。数据偏斜的存在使分区效率下降很多。在极端的情况下，所有的负载可能压在一个分区上，其余节点空闲的，那么瓶颈落在这一个繁忙的节点上。不均衡导致的高负载的分区被称为热点（hot spot）。</p><p>避免热点最简单的方法是将记录随机分配给节点。这将在所有节点上平均分配数据，但是它有一个很大的缺点：当你试图读取一个特定的值时，你无法知道它在哪个节点上，所以你必须并行地查询所有的节点。</p><h3 id="Partitioning-by-Key-Range"><a href="#Partitioning-by-Key-Range" class="headerlink" title="Partitioning by Key Range"></a>Partitioning by Key Range</h3><p>一种分区的方法是为每个分区指定一块连续的键范围（从最小值到最大值），如果知道范围之间的边界，则可以轻松确定哪个分区包含某个值。</p><p><img src="/images/2018/9/21.png" alt=""></p><p>在每个分区中，我们可以按照一定的顺序保存键。优点是进行范围扫描非常简单，缺点是某些特定的访问模式会导致热点。</p><h3 id="Partitioning-by-Hash-of-Key"><a href="#Partitioning-by-Hash-of-Key" class="headerlink" title="Partitioning by Hash of Key"></a>Partitioning by Hash of Key</h3><p>一个好的散列函数可以将将偏斜的数据均匀分布。假设你有一个32位散列函数,无论何时给定一个新的字符串输入，它将返回一个0到2^{32}-1之间的”随机”数。即使输入的字符串非常相似，它们的散列也会均匀分布在这个数字范围内。</p><p>一旦你有一个合适的键散列函数，你可以为每个分区分配一个散列范围（而不是键的范围），每个通过哈希散列落在分区范围内的键将被存储在该分区中。如下图所示。</p><p><img src="/images/2018/9/22.png" alt=""></p><p>不幸的是，通过使用Key散列进行分区，我们失去了键范围分区的一个很好的属性：高效执行范围查询的能力。曾经相邻的Key现在分散在所有分区中，所以它们之间的顺序就丢失了。 </p><p>Cassandra采取了折衷的策略。Cassandra中的表可以使用由多个列组成的复合主键来声明。键中只有第一列会作为散列的依据，而其他列则被用作Casssandra的SSTables中排序数据的连接索引。尽管查询无法在复合主键的第一列中按范围扫表，但如果第一列已经指定了固定值，则可以对该键的其他列执行有效的范围扫描。</p><h3 id="Skewed-Workloads-and-Relieving-Hot-Spots"><a href="#Skewed-Workloads-and-Relieving-Hot-Spots" class="headerlink" title="Skewed Workloads and Relieving Hot Spots"></a>Skewed Workloads and Relieving Hot Spots</h3><p>在极端情况下，所有的读写操作都是针对同一个键的，所有的请求都会被路由到同一个分区。</p><p>​如今，大多数数据系统无法自动补偿这种高度偏斜的负载，因此应用程序有责任减少偏斜。例如，如果一个主键被认为是非常火爆的，一个简单的方法是在主键的开始或结尾添加一个随机数。只要一个两位数的十进制随机数就可以将主键分散为100钟不同的主键,从而存储在不同的分区中。</p><h2 id="Partitioning-and-Secondary-Indexes"><a href="#Partitioning-and-Secondary-Indexes" class="headerlink" title="Partitioning and Secondary Indexes"></a>Partitioning and Secondary Indexes</h2><h3 id="Partitioning-Secondary-Indexes-by-Document"><a href="#Partitioning-Secondary-Indexes-by-Document" class="headerlink" title="Partitioning Secondary Indexes by Document"></a>Partitioning Secondary Indexes by Document</h3><p>按文档分区（本地索引），其中二级索引存储在与主键和值相同的分区中。这意味着只有一个分区需要在写入时更新，但是读取二级索引需要在所有分区之间进行scatter/gather。</p><p><img src="/images/2018/9/23.png" alt=""></p><h3 id="Partitioning-Secondary-Indexes-by-Term"><a href="#Partitioning-Secondary-Indexes-by-Term" class="headerlink" title="Partitioning Secondary Indexes by Term"></a>Partitioning Secondary Indexes by Term</h3><p>按关键词分区（全局索引），其中二级索引存在不同的分区的。当文档写入时，需要更新多个分区中的二级索引；但是可以从单个分区中进行读取</p><p><img src="/images/2018/9/24.png" alt=""></p><h2 id="Rebalancing-Partitions"><a href="#Rebalancing-Partitions" class="headerlink" title="Rebalancing Partitions"></a>Rebalancing Partitions</h2><p>随着时间的推移，数据库会有各种变化。如机器出现故障，其他机器需要接管故障机器。<br>这些更改需要将数据和请求从一个节点移动到另一个节点。 将load从集群中的一个节点向另一个节点移动的过程称为再平衡（reblancing）。</p><h3 id="Strategies-for-Rebalancing"><a href="#Strategies-for-Rebalancing" class="headerlink" title="Strategies for Rebalancing"></a>Strategies for Rebalancing</h3><p>有几种不同的分区分配方法,让我们依次简要讨论一下。</p><h4 id="反面教材：hash-mod-N"><a href="#反面教材：hash-mod-N" class="headerlink" title="反面教材：hash mod N"></a>反面教材：hash mod N</h4><p>模N方法的问题是，如果节点数量N发生变化，大多数Key将需要从一个节点移动到另一个节点。如此频繁的移动使得重新平衡的代价过于昂贵。</p><p>我们需要一种只移动必需数据的方法。</p><h4 id="固定数量的分区"><a href="#固定数量的分区" class="headerlink" title="固定数量的分区"></a>固定数量的分区</h4><p>创建比节点更多的分区，并为每个节点分配多个分区。例如，运行在10个节点的集群上的数据库可能会从一开始就被拆分为1,000个分区，因此大约有100个分区被分配给每个节点。</p><p>现在，如果一个节点被添加到集群中，新节点可以从当前每个节点中窃取一些分区，直到分区再次公平分配。这个过程下图所示。</p><p><img src="/images/2018/9/25.png" alt=""></p><p>如果数据集的总大小难以预估（例如，如果它开始很小，但随着时间的推移可能会变得更大），选择正确的分区数是困难的。由于每个分区包含了总数据量固定比率的数据，因此每个分区的大小与集群中的数据总量成比例增长。如果分区非常大，再平衡和从节点故障恢复变得昂贵。但是，如果分区太小，则会产生太多的开销。当分区大小“恰到好处”的时候才能获得很好的性能，如果分区数量固定，但数据量变动很大，则难以达到最佳性能。</p><h4 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h4><p>对于使用键范围分区的数据库，具有固定边界的固定数量的分区将非常不便，手动重新配置分区边界将非常繁琐。</p><p>出于这个原因，按键的范围进行分区的数据库（如HBase）会动态创建分区。当分区增长到超过配置的大小时（在HBase上，默认值是10GB），会被分成两个分区，每个分区约占一半的数据。与之相反，如果大量数据被删除并且分区缩小到某个阈值以下，则可以将其与相邻分区合并。</p><p>动态分区的一个优点是分区数量适应总数据量。如果只有少量的数据，少量的分区就足够了，所以开销很小;如果有大量的数据，每个分区的大小被限制在一个可配置的最大值。</p><p>动态分区不仅适用于数据的范围分区，而且也适用于hash分区。</p><h4 id="Partitioning-proportionally-to-nodes"><a href="#Partitioning-proportionally-to-nodes" class="headerlink" title="Partitioning proportionally to nodes"></a>Partitioning proportionally to nodes</h4><p>每个节点具有固定数量的分区，在这种情况下，每个分区的大小与数据集大小成比例地增长，而节点数量保持不变，但是当增加节点数时，分区将再次变小。由于较大的数据量通常需要较大数量的节点进行存储，因此这种方法也使每个分区的大小较为稳定。</p><h2 id="Request-Routing"><a href="#Request-Routing" class="headerlink" title="Request Routing"></a>Request Routing</h2><p>现在我们已经将数据集分割到多个机器上运行的多个节点上。但是仍然存在一个悬而未决的问题：当客户想要发出请求时，如何知道要连接哪个节点？随着分区重新平衡，分区对节点的分配也发生变化。为了回答这个问题，需要有人知晓这些变化：如果我想读或写键“foo”，需要连接哪个IP地址和端口号？</p><p>​这个问题可以概括为 服务发现(service discovery) 。</p><p>概括来说，这个问题有几种不同的方案（如下图所示）：<br><img src="/images/2018/9/26.png" alt=""></p><ol><li>允许客户联系任何节点（例如，通过循环策略的负载均衡（Round-Robin Load Balancer））。如果该节点恰巧拥有请求的分区，则它可以直接处理该请求;否则，它将请求转发到适当的节点，接收回复并传递给客户端。</li><li>首先将所有来自客户端的请求发送到路由层，它决定了应该处理请求的节点，并相应地转发。此路由层本身不处理任何请求，它仅负责分区的负载均衡。</li><li>要求客户端知道分区和节点的分配。在这种情况下，客户端可以直接连接到适当的节点，而不需要任何中介。</li></ol><p>以上所有情况中的关键问题是：作出路由决策的组件（可能是节点之一，还是路由层或客户端）如何了解分区-节点之间的分配关系变化？</p><p>许多分布式数据系统都依赖于一个独立的协调服务，比如用ZooKeeper来跟踪集群元数据，如下图所示。 </p><p><img src="/images/2018/9/27.png" alt=""></p><p>每个节点在ZooKeeper中注册自己，ZooKeeper维护分区到节点的可靠映射。 其他参与者（如路由层或分区感知客户端）可以在ZooKeeper中订阅此信息。 只要分区分配发生的改变，或者集群中添加或删除了一个节点，ZooKeeper就会通知路由层使路由信息保持最新状态。</p><p>Cassandra和Riak采取不同的方法：他们在节点之间使用流言协议（gossip protocol） 来传播群集状态的变化。请求可以发送到任意节点，该节点会转发到包含所请求的分区的适当节点（图Figure 6-7中的方法1）。这个模型在数据库节点中增加了更多的复杂性，但是避免了对像ZooKeeper这样的外部协调服务的依赖。</p><hr><p>参考资料：</p><ol><li><a href="https://github.com/Vonng/ddia/blob/master/ch6.md" target="_blank" rel="noopener">Vonng ddia翻译</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;partition在本文中的翻译为分区。&lt;br&gt;数据量非常大的时候，在单台机器上存储和处理不再可行，则分区十分必要。分区的目标是在多台机器上均匀分布数据和查询负载，避免出现热点（负载不成比例的节点）。这需要选择适合于您的数据的分区方案，并在将节点添加到集群或从集群删除时进行再分区。分区主要是为了可扩展性(scalability)。&lt;br&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://liujunming.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://liujunming.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统中clock相关知识点</title>
    <link href="http://liujunming.github.io/2018/09/19/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%ADclock%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://liujunming.github.io/2018/09/19/分布式系统中clock相关知识点/</id>
    <published>2018-09-19T06:43:42.000Z</published>
    <updated>2018-11-06T08:20:50.065Z</updated>
    
    <content type="html"><![CDATA[<p>因为网上资料较多，本文主要是总结一下相关资料。<br><a id="more"></a></p><h2 id="Time-clocks-and-the-ordering-of-events-in-a-distributed-system"><a href="#Time-clocks-and-the-ordering-of-events-in-a-distributed-system" class="headerlink" title="Time, clocks, and the ordering of events in a distributed system"></a>Time, clocks, and the ordering of events in a distributed system</h2><ul><li>论文： Time, clocks, and the ordering of events in a distributed system</li><li>看paper时可以结合着这篇<a href="https://www.cnblogs.com/hzmark/p/- Time_Clocks_Ordering.html" target="_blank" rel="noopener">译文</a></li><li><a href="https://zhuanlan.zhihu.com/p/34057588" target="_blank" rel="noopener">论文笔记</a>总结了该论文</li></ul><h2 id="clock同步"><a href="#clock同步" class="headerlink" title="clock同步"></a>clock同步</h2><ul><li><a href="https://www.cs.rutgers.edu/~pxk/417/notes/content/05-clock-synchronization-slides.pdf" target="_blank" rel="noopener">Clock synchronization</a></li></ul><p>Real-Time Clock (RTC)</p><ul><li><a href="https://www.cs.rutgers.edu/~pxk/417/notes/ptp.html" target="_blank" rel="noopener">Precision Time Protocol - notes</a></li><li><a href="https://www.cs.rutgers.edu/~pxk/417/notes/content/06-logical-clocks-slides.pdf" target="_blank" rel="noopener">Logical clocks</a></li><li><a href="https://www.cs.rutgers.edu/~pxk/417/notes/clocks/index.html" target="_blank" rel="noopener">Vector clocks - notes</a></li></ul><h2 id="Vector-Clock-Version-Clock"><a href="#Vector-Clock-Version-Clock" class="headerlink" title="Vector Clock/Version Clock"></a>Vector Clock/Version Clock</h2><ul><li><a href="http://www.cnblogs.com/foxmailed/p/4985848.html" target="_blank" rel="noopener">吴镝 Vector Clock/Version Clock</a></li></ul><p>Version Clock即为Version Vectors。<br>Vector Clock最初是为了给分布式系统的事件定序发明的，本质上是一种捕获causality的手段，只是他们捕获的是事件的关系。而Version Clock是捕获同一个数据的不同版本之间的causality.</p><ul><li><a href="https://haslab.wordpress.com/2011/07/08/version-vectors-are-not-vector-clocks/" target="_blank" rel="noopener">Version Vectors are not Vector Clocks</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为网上资料较多，本文主要是总结一下相关资料。&lt;br&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://liujunming.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://liujunming.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Designing Data-Intensive Applications 读书笔记 -Replication</title>
    <link href="http://liujunming.github.io/2018/09/18/Designing-Data-Intensive-Applications-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Replication/"/>
    <id>http://liujunming.github.io/2018/09/18/Designing-Data-Intensive-Applications-读书笔记-Replication/</id>
    <published>2018-09-18T05:23:36.000Z</published>
    <updated>2018-11-06T08:19:17.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leader-和-Follower"><a href="#Leader-和-Follower" class="headerlink" title="Leader 和 Follower"></a>Leader 和 Follower</h2><ul><li>用户端写入的时候，必须先经过Leader处理</li><li>其它节点是Follower，Leader写入完毕后会通知他们复制数据，保证一致性</li><li>客户端读的时候，可以随便读，但写的时候只能向Leader写</li></ul><p><img src="/images/2018/9/10.png" alt=""><br><a id="more"></a></p><h3 id="同步复制与异步复制"><a href="#同步复制与异步复制" class="headerlink" title="同步复制与异步复制"></a>同步复制与异步复制</h3><p><img src="/images/2018/9/11.png" alt=""><br>上图中Follower1是同步复制，Follower2是异步复制</p><p><strong>同步复制：</strong></p><p>写入请求时，Leader 会一直等到所有 Follower 都确认已经写入后（期间不处理任何写请求），才向客户端返回成功</p><p>优点：保证强一致性</p><p>缺点：如果任何 Follower 挂掉，都会写失败，这在大型系统中是不现实的</p><p>所以在实际的数据库中，使用的都是半同步（semi-synchronous），即一个 Follower 是同步的，其它都是异步；如果同步的那个 Follower 挂了，那么设置一个新的 Follower 为同步模式</p><p><strong>异步复制：</strong></p><p>写入请求时，Leader 自己写入成功后就返回，不等待 Follower</p><p>优点：可以立刻响应写入请求，即使所有 Follower 都挂掉了</p><p>缺点：可能会导致不一致(Leader和Follower中的状态不一样)</p><h3 id="增加新的-Follower"><a href="#增加新的-Follower" class="headerlink" title="增加新的 Follower"></a>增加新的 Follower</h3><p>即如何在集群不断写入数据的同时，加入新的 Follower，让它的数据跟上大部队</p><ol><li>给 Leader 某个时刻的数据做一个快照</li><li>把快照复制到新的 Follower 上</li><li>新的 Follower 连接上 Leader，告诉它从哪个时刻开始同步数据</li><li>直到新 Follower 的数据跟上了 Leader 的步伐（caught up），开始进入工作</li></ol><h3 id="处理节点宕机"><a href="#处理节点宕机" class="headerlink" title="处理节点宕机"></a>处理节点宕机</h3><h4 id="Follower-宕机"><a href="#Follower-宕机" class="headerlink" title="Follower 宕机"></a>Follower 宕机</h4><p>从宕机前的日志开始和 Leader 同步即可，直到Follower 的数据跟上了 Leader 的步伐，开始进入工作</p><h4 id="Leader-宕机"><a href="#Leader-宕机" class="headerlink" title="Leader 宕机"></a>Leader 宕机</h4><p>one of the followers needs to be promoted to be the new leader, clients need to be reconfigured to send their writes to the new leader, and the other followers need to start consuming data changes from the new leader. This process is called <code>failover</code>.</p><p>failover的步骤如下：</p><ol><li>检测 Leader 宕机</li><li>选出新的 Leader</li><li>把系统配置改为新的 Leader</li></ol><h3 id="Implementation-of-Replication-Logs"><a href="#Implementation-of-Replication-Logs" class="headerlink" title="Implementation of Replication Logs"></a>Implementation of Replication Logs</h3><h4 id="Statement-based-replication"><a href="#Statement-based-replication" class="headerlink" title="Statement-based replication"></a>Statement-based replication</h4><p>基于语句的复制，比如在 SQL 中复制 INSERT、UPDATE、DELETE 语句到 Follower。</p><p>存在一些问题：</p><ul><li>NOW()、RANDOM()这样的函数，没法基于语句复制，因为每次运行的结果都不一样</li><li>如果语句依赖自增数，或者跟数据库中现有的数据强相关，那么必须保证语句执行顺序跟 Leader 完全一致，在并发处理多个事务时这一点很难保证</li><li>语句有副作用时，可能会导致不一致的出现</li></ul><h4 id="Write-ahead-log-WAL-shipping"><a href="#Write-ahead-log-WAL-shipping" class="headerlink" title="Write-ahead log (WAL) shipping"></a>Write-ahead log (WAL) shipping</h4><p>本书的第三章讨论了日志结构的储存引擎的实现（SSTable、LSM-Tree 和 B-Tree），如果是这种储存引擎，我们可以把它的每一次写日志都复制到 Follower 上，这样可以保证一致性。</p><p>PostgreSQL 和 Oracle 就是这样实现的，缺陷在于，这种复制方式非常底层，每一条 WAL 包含的信息实际上是“向哪一个硬盘 block 写哪些 bytes”，这就导致 WAL 和储存引擎强相关，也就是必须保证 Leader 和 Follower 的储存引擎底层完全一致，导致集群很难进行版本升级。</p><h4 id="Logical-row-based-log-replication"><a href="#Logical-row-based-log-replication" class="headerlink" title="Logical (row-based) log replication"></a>Logical (row-based) log replication</h4><p>把日志抽象为与底层引擎无关，采用 change data capture，每次有数据更改的时候都记下改了什么，例如记录每次写入的值和行号，MySQL 的 binlog 就是这样实现的。</p><h2 id="复制滞后产生的问题"><a href="#复制滞后产生的问题" class="headerlink" title="复制滞后产生的问题"></a>复制滞后产生的问题</h2><p>对于单 Leader，多 Follower的架构来说，一般是只能向 Leader 写，但可以向任何 Follower 读，这样可以大大增加读的性能。</p><p>但由于写操作需要向 Follower 复制，这里就会产生滞后问题，写完后立刻读，有可能会从 Follower 中读到旧的值（因为此时 Leader 可能还没有同步变化到 Follower 上）。</p><p>当然这种不一致的状态是转临时逝的（如果停止向数据库中写入数据并等待一段时间，从库最终会赶上并与主库保持一致），不会永久存在，也就是所谓的 “最终一致性”。</p><p>因为滞后时间太长引入的不一致性，可不仅是一个理论问题，更是应用设计中会遇到的真实问题。本节将重点介绍三个由复制滞后所带来的问题，并简述解决这些问题的一些方法。</p><h3 id="Reading-Your-Own-Writes"><a href="#Reading-Your-Own-Writes" class="headerlink" title="Reading Your Own Writes"></a>Reading Your Own Writes</h3><p>许多应用让用户提交一些数据，然后查看他们提交的内容。但对于异步复制，问题就来了。如下图所示：如果用户在写入后马上就查看数据，则新数据可能尚未到达副本。对用户而言，看起来好像是刚提交的数据丢失了。<br><img src="/images/2018/9/12.png" alt=""></p><p>在这种情况下，我们需要读写一致性（read-after-write consistency）。这是一个保证，如果用户重新加载页面，他们总会看到他们自己提交的任何更新。它不会对其他用户的写入做出承诺：其他用户的更新可能稍等才会看到。它保证用户自己的输入已被正确保存。</p><p>具体可以有以下策略：</p><ul><li>如果读的字段可能已经发生了变化，那么向 Leader 读取（因为 Leader 的数据一定是最新的）；</li><li>如果读的字段距离上一次变更时间很短，那么向 Leader 读；</li><li>客户端在读请求的时候带上自己最近一次写操作的时间戳，处理这个读请求的服务器看到这个时间戳，就可以知道自己本地的数据是否过时了</li></ul><h3 id="单调读（Monotonic-Reads）"><a href="#单调读（Monotonic-Reads）" class="headerlink" title="单调读（Monotonic Reads）"></a>单调读（Monotonic Reads）</h3><p>客户端进行多次读操作时，这些读操作可能会分配到不同的 Follower 上，所以可能会发生第一次读到了数据，然后第二次读的时候数据又消失了的问题，如下图 User 2345，第一次在 Follower1 上读到了评论，第二次在 Follower2 上没有读到评论：</p><p><img src="/images/2018/9/13.png" alt=""></p><p>所以，客户端读到了新的数据，那么就不能让它读到旧数据。最简单的解决方法就是，把每个客户端的读请求都分配到固定的 Follower 上。</p><h3 id="Consistent-Prefix-Reads"><a href="#Consistent-Prefix-Reads" class="headerlink" title="Consistent Prefix Reads"></a>Consistent Prefix Reads</h3><p>由于服务器之间复制数据可能产生的滞后，数据的时序可能会产生问题。</p><p>比如下图，Mr. Poons 先说了一句话，然后 Mrs. Cake 回复了他，然而对于第三方观察者而言，他们的对话时序可能是混乱的：</p><p><img src="/images/2018/9/14.png" alt=""></p><p>防止这种异常，需要另一种类型的保证：一致前缀读（consistent prefix reads）。 这个保证了：如果一系列写入按某个顺序发生，那么任何人读取这些写入时，也会看见它们以同样的顺序出现。</p><p>​这是分区（partitioned）数据库中的一个特殊问题。如果数据库总是以相同的顺序应用写入，则读取总是会看到一致的前缀，所以这种异常不会发生。但是在许多分布式数据库中，不同的分区独立运行，因此不存在全局写入顺序：当用户从数据库中读取数据时，可能会看到数据库的某些部分处于较旧的状态，而某些处于较新的状态。</p><p>​一种解决方案是，确保任何因果相关的写入都写入相同的分区。对于某些无法高效完成这种操作的应用，还有一些显式跟踪因果依赖关系的算法。</p><h2 id="Multi-Leader-Replication"><a href="#Multi-Leader-Replication" class="headerlink" title="Multi-Leader Replication"></a>Multi-Leader Replication</h2><p>单个 Leader 的缺点在于，如果任何因素导致无法连接 Leader，那么你就无法向数据库写入任何数据了，这会让整个系统非常脆弱，所以我们在一些情境下需要多 Leader 的架构。</p><h3 id="Use-Cases-for-Multi-Leader-Replication"><a href="#Use-Cases-for-Multi-Leader-Replication" class="headerlink" title="Use Cases for Multi-Leader Replication"></a>Use Cases for Multi-Leader Replication</h3><p>下面是一些多 Leader 架构的示例</p><h4 id="多个数据中心"><a href="#多个数据中心" class="headerlink" title="多个数据中心"></a>多个数据中心</h4><p><img src="/images/2018/9/15.png" alt=""></p><p>像上图这种情况，你可以有多个 Leader 分布在不同地方的数据中心，每个数据中心都是一个独立的集群，它们的 Leader 之间会相互同步数据。</p><h4 id="可以离线的客户端"><a href="#可以离线的客户端" class="headerlink" title="可以离线的客户端"></a>可以离线的客户端</h4><p>我们可以把一个支持离线运行的客户端，和服务器端，视为两个“数据中心”，比如一些日历应用，会在本地维护一份数据，直到有网络时，才会和服务器进行数据同步，这就是一个异步的多 Leader 架构。</p><p>CouchDB 就是为此设计的。</p><h4 id="多人协作编辑"><a href="#多人协作编辑" class="headerlink" title="多人协作编辑"></a>多人协作编辑</h4><p>像 Etherpad、Google Docs 这样的应用，允许多人同时编辑同一份文档，每个人都是一个 “Leader”，相互之间同步数据，但这显然会遇到冲突的问题。</p><h3 id="解决写冲突"><a href="#解决写冲突" class="headerlink" title="解决写冲突"></a>解决写冲突</h3><p>多 Leader 之间同步数据，最大的问题就是如何解决写冲突。比如下图中，两个用户都修改了文档的标题，发请求给服务器，都返回了成功，但直到 Leader 之间进行同步时才发现之前的数据有冲突。</p><p><img src="/images/2018/9/16.png" alt=""></p><h4 id="同步冲突检测"><a href="#同步冲突检测" class="headerlink" title="同步冲突检测"></a>同步冲突检测</h4><p>单 Leader 不会发生冲突，因为每次写入都是一个原子化的事务。</p><p>多 Leader 如果采用同步的方式检测冲突，也不会发生冲突。即每次写入时，都向其它的 Leader 检查有没有冲突，如果都没有冲突，那么写入成功。但这样性能极差，也丢掉了多 Leader 架构的好处，还不如用单个 Leader。</p><h4 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h4><p>多 Leader 架构避免冲突最简单的方式就是，让可能产生冲突的请求，都走向同一个 Leader。比如对于同一项资料的修改，都路由到固定的某个 Leader 上。</p><p>这样做的缺陷在于，集群是不断变化的，很难做到长期固定，Leader 的变化就会让这个策略失效。</p><h4 id="收敛至一致的状态"><a href="#收敛至一致的状态" class="headerlink" title="收敛至一致的状态"></a>收敛至一致的状态</h4><p>实现冲突合并解决有多种途径：</p><ul><li>给每个写入一个唯一的ID（例如，一个时间戳，一个长的随机数，一个UUID或者一个键和值的哈希），挑选最高ID的写入作为胜利者，并丢弃其他写入。如果使用时间戳，这种技术被称为最后写入胜利（LWW, last write wins）。虽然这种方法很流行，但是很容易造成数据丢失。</li><li>为每个副本分配一个唯一的ID，ID编号更高的写入具有更高的优先级。这种方法也意味着数据丢失。</li><li>以某种方式将这些值合并在一起 - 例如，按字母顺序排序，然后连接它们（在图5-7中，合并的标题可能类似于“B/C”）。</li><li>在保留所有信息的显式数据结构中记录冲突，并编写解决冲突的应用程序代码（也许通过提示用户的方式）。<br>​ </li></ul><h4 id="自定义冲突解决逻辑"><a href="#自定义冲突解决逻辑" class="headerlink" title="自定义冲突解决逻辑"></a>自定义冲突解决逻辑</h4><p>作为解决冲突最合适的方法可能取决于应用程序，大多数多主复制工具允许使用应用程序代码编写冲突解决逻辑。该代码可以在写入或读取时执行。</p><blockquote><p><strong>自动冲突解决</strong><br>冲突解决规则可能很快变得复杂，并且自定义代码可能容易出错。<br>已经有一些有趣的研究来自动解决由于数据修改引起的冲突。有几个研究值得一提：</p><ul><li>无冲突复制数据类型（Conflict-free replicated datatypes）（CRDT）是可以由多个用户同时编辑的集合，映射，有序列表，计数器等的一系列数据结构，它们以合理的方式自动解决冲突。</li><li>可合并的持久数据结构（Mergeable persistent data structures）显式跟踪历史记录，类似于Git版本控制系统。</li><li>可执行的转换（operational transformation）是Etherpad和Google Docs等合作编辑应用背后的冲突解决算法。</li></ul><p>这些算法在数据库中的实现还很年轻，但很可能将来它们将被集成到更多的复制数据系统中。自动冲突解决方案可以使应用程序处理多领导者数据同步更为简单。</p></blockquote><h3 id="多-Leader-的拓扑结构"><a href="#多-Leader-的拓扑结构" class="headerlink" title="多 Leader 的拓扑结构"></a>多 Leader 的拓扑结构</h3><p>多 Leader 可以有很多种拓扑结构，环形、星形、全连接形。<br><img src="/images/2018/9/17.png" alt=""><br>MySQL 使用的是环形连接。全连接形是最符合直觉的，每个 Leader 都和其它所有 Leader 相互交换数据。<br>另一方面，全连接形拓扑也可能有问题。特别是，一些网络链接可能比其他网络链接更快（例如，由于网络拥塞），结果是一些复制消息可能“超过”其他复制消息，如下图示。</p><p><img src="/images/2018/9/18.png" alt=""></p><p>这是一个因果关系的问题：更新取决于先前的插入，所以我们需要确保所有节点先处理插入，然后再处理更新。</p><p>要正确排序这些事件，可以使用一种称为<strong>version vectors</strong>的技术。</p><h2 id="无-Leader-复制"><a href="#无-Leader-复制" class="headerlink" title="无 Leader 复制"></a>无 Leader 复制</h2><p>无 Leader 复制完全不需要 Leader 的存在，这种架构中，客户端可以向多个节点发起读写请求。</p><h3 id="当有节点挂掉时，如何写入数据库"><a href="#当有节点挂掉时，如何写入数据库" class="headerlink" title="当有节点挂掉时，如何写入数据库"></a>当有节点挂掉时，如何写入数据库</h3><p>只要保证多个节点写入成功，那么客户端就可以认为写入成功。<br><img src="/images/2018/9/19.png" alt=""></p><h4 id="Read-repair-and-anti-entropy"><a href="#Read-repair-and-anti-entropy" class="headerlink" title="Read repair and anti-entropy"></a>Read repair and anti-entropy</h4><p>在读取的时候，可能会存在不一致（因为有部分节点写入失败），这时可以发现不一致并且修复它。或者所有节点都定期检查是否自己的数据跟别人有不一致的地方。</p><h4 id="Quorums-for-reading-and-writing"><a href="#Quorums-for-reading-and-writing" class="headerlink" title="Quorums for reading and writing"></a>Quorums for reading and writing</h4><p>如果有n个副本，每个写入必须由w节点确认才能被认为是成功的，并且我们必须至少为每个读查询r个节点。 只要<code>w + r&gt; n</code>，我们期望在读取时获得最新的值，因为r个读取中至少有一个节点是最新的。</p><h3 id="Quorums-机制的局限性"><a href="#Quorums-机制的局限性" class="headerlink" title="Quorums 机制的局限性"></a>Quorums 机制的局限性</h3><h3 id="Sloppy-Quorums-and-Hinted-Handoff"><a href="#Sloppy-Quorums-and-Hinted-Handoff" class="headerlink" title="Sloppy Quorums and Hinted Handoff"></a>Sloppy Quorums and Hinted Handoff</h3><p><em>sloppy quorum</em>:写和读仍然需要w和r成功的响应，但是那些可能包括不在指定的n个“主”节点中的值。比方说，如果你把自己锁在房子外面，你可能会敲开邻居的门，问你是否可以暂时停留在沙发上。</p><p>​ 一旦网络中断得到解决，代表另一个节点临时接受的一个节点的任何写入都被发送到适当的“本地”节点，这就是hinted handoff。 （一旦你再次找到你的房子的钥匙，你的邻居礼貌地要求你离开沙发回家。）</p><h3 id="Detecting-Concurrent-Writes"><a href="#Detecting-Concurrent-Writes" class="headerlink" title="Detecting Concurrent Writes"></a>Detecting Concurrent Writes</h3><h4 id="Last-write-wins-discarding-concurrent-writes"><a href="#Last-write-wins-discarding-concurrent-writes" class="headerlink" title="Last write wins (discarding concurrent writes)"></a>Last write wins (discarding concurrent writes)</h4><h4 id="The-“happens-before”-relationship-and-concurrency"><a href="#The-“happens-before”-relationship-and-concurrency" class="headerlink" title="The “happens-before” relationship and concurrency"></a>The “happens-before” relationship and concurrency</h4><h4 id="Capturing-the-happens-before-relationship"><a href="#Capturing-the-happens-before-relationship" class="headerlink" title="Capturing the happens-before relationship"></a>Capturing the happens-before relationship</h4><h4 id="Merging-concurrently-written-values"><a href="#Merging-concurrently-written-values" class="headerlink" title="Merging concurrently written values"></a>Merging concurrently written values</h4><h4 id="Version-vectors"><a href="#Version-vectors" class="headerlink" title="Version vectors"></a>Version vectors</h4><hr><p>参考资料：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/36282816" target="_blank" rel="noopener">知乎 Starkwang</a></li><li><a href="https://github.com/Vonng/ddia/blob/master/ch5.md" target="_blank" rel="noopener">Vonng/ddia</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leader-和-Follower&quot;&gt;&lt;a href=&quot;#Leader-和-Follower&quot; class=&quot;headerlink&quot; title=&quot;Leader 和 Follower&quot;&gt;&lt;/a&gt;Leader 和 Follower&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用户端写入的时候，必须先经过Leader处理&lt;/li&gt;
&lt;li&gt;其它节点是Follower，Leader写入完毕后会通知他们复制数据，保证一致性&lt;/li&gt;
&lt;li&gt;客户端读的时候，可以随便读，但写的时候只能向Leader写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018/9/10.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://liujunming.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://liujunming.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Fenwick Tree/Binary Indexed Tree/树状数组</title>
    <link href="http://liujunming.github.io/2018/09/12/Fenwick-Tree-Binary-Indexed-Tree-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>http://liujunming.github.io/2018/09/12/Fenwick-Tree-Binary-Indexed-Tree-树状数组/</id>
    <published>2018-09-12T07:59:22.000Z</published>
    <updated>2018-11-06T08:35:35.270Z</updated>
    
    <content type="html"><![CDATA[<p>观看<a href="https://www.youtube.com/watch?v=WbafSgetDDk" target="_blank" rel="noopener">花花酱 Fenwick Tree / Binary Indexed Tree</a>的视频，结合<a href="https://visualgo.net/bn/fenwicktree" target="_blank" rel="noopener">Visualizer</a>即可理解Fenwick Tree。<a id="more"></a></p><p>Fenwick Tree is mainly designed for solving the single point update range sum problems. e.g. what’s the sum between i-th and j-th element while the values of the elements are mutable.</p><p>Init the tree (include building all prefix sums) takes O(nlogn)</p><p>Update the value of an element takes O(logn)</p><p>Query the range sum takes O(logn)</p><p>Space complexity: O(n)</p><p><img src="/images/2018/9/8.png" alt=""></p><p><img src="/images/2018/9/9.png" alt=""></p><p><em>Using Binary Indexed Tree, we can do both tasks in O(Logn) time. The advantages of Binary Indexed Tree over Segment are, requires less space and very easy to implement..</em></p><p>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FenwickTree</span> &#123;</span>    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FenwickTree(<span class="keyword">int</span> n): sums_(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; sums_.size()) &#123;</span><br><span class="line">            sums_[i] += delta;</span><br><span class="line">            i += lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += sums_[i];</span><br><span class="line">            i -= lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><a href="https://www.youtube.com/watch?v=WbafSgetDDk" target="_blank" rel="noopener">花花酱 Fenwick Tree / Binary Indexed Tree</a></li><li><a href="https://zxi.mytechroad.com/blog/sp/fenwick-tree-binary-indexed-tree-sp3/" target="_blank" rel="noopener">代码</a></li><li><a href="https://visualgo.net/bn/fenwicktree" target="_blank" rel="noopener">Visualizer</a></li><li><a href="https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/" target="_blank" rel="noopener">geeksforgeeks</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观看&lt;a href=&quot;https://www.youtube.com/watch?v=WbafSgetDDk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;花花酱 Fenwick Tree / Binary Indexed Tree&lt;/a&gt;的视频，结合&lt;a href=&quot;https://visualgo.net/bn/fenwicktree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Visualizer&lt;/a&gt;即可理解Fenwick Tree。
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Interval Tree</title>
    <link href="http://liujunming.github.io/2018/09/09/Interval%20Tree/"/>
    <id>http://liujunming.github.io/2018/09/09/Interval Tree/</id>
    <published>2018-09-09T01:41:48.000Z</published>
    <updated>2018-11-06T08:35:25.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Interval-Tree"><a href="#Interval-Tree" class="headerlink" title="Interval Tree"></a>Interval Tree</h3><p>首先看下<a href="https://www.youtube.com/watch?v=q0QOYtSsTg4" target="_blank" rel="noopener">Interval Search Trees</a>视频。<br><a id="more"></a><br>Consider a situation where we have a set of intervals and we need following operations to be implemented efficiently. </p><ol><li>Add an interval</li><li>Remove an interval</li><li>Given an interval x, find if x overlaps with any of the existing intervals.</li></ol><p><em>Interval Tree</em>: The idea is to augment a self-balancing Binary Search Tree (BST) like Red Black Tree, AVL Tree, etc to maintain set of intervals so that all operations can be done in O(Logn) time.</p><p>Every node of Interval Tree stores following information.</p><ol><li>An interval which is represented as a pair <em>[low, high]</em></li><li>Maximum <em>high</em> value in subtree rooted with this node.</li></ol><p>The low value of an interval is used as key to maintain order in BST. The insert and delete operations are same as insert and delete in self-balancing BST used.</p><p><img src="/images/2018/9/7.png" alt=""></p><p>The main operation is to search for an overlapping interval. Following is algorithm for searching an overlapping interval <em>x</em> in an Interval tree rooted with <em>root</em>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Interval overlappingIntervalSearch(root, x)</span><br><span class="line">1) If x overlaps with root&apos;s interval, return the root&apos;s interval.</span><br><span class="line"></span><br><span class="line">2) If left child of root is not empty and the max  in left child </span><br><span class="line">is greater than x&apos;s low value, recur for left child</span><br><span class="line"></span><br><span class="line">3) Else recur for right child.</span><br></pre></td></tr></table></figure><p>此题的具体代码可以参考<a href="https://www.wikiwand.com/en/Interval_tree" target="_blank" rel="noopener">wikiwand</a>中的External_links。</p><hr><p>参考资料：</p><ol><li><a href="https://www.geeksforgeeks.org/interval-tree/" target="_blank" rel="noopener">geeksforgeeks interval-tree</a></li><li><a href="https://www.wikiwand.com/en/Interval_tree" target="_blank" rel="noopener">wikiwand</a></li><li><a href="https://github.com/chaimleib/intervaltree" target="_blank" rel="noopener">intervaltree python</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Interval-Tree&quot;&gt;&lt;a href=&quot;#Interval-Tree&quot; class=&quot;headerlink&quot; title=&quot;Interval Tree&quot;&gt;&lt;/a&gt;Interval Tree&lt;/h3&gt;&lt;p&gt;首先看下&lt;a href=&quot;https://www.youtube.com/watch?v=q0QOYtSsTg4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Interval Search Trees&lt;/a&gt;视频。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="http://liujunming.github.io/2018/09/08/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://liujunming.github.io/2018/09/08/线段树/</id>
    <published>2018-09-08T13:55:33.000Z</published>
    <updated>2018-11-06T08:35:30.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线段树的概念"><a href="#线段树的概念" class="headerlink" title="线段树的概念"></a>线段树的概念</h2><p>Tushar的讲解视频<a href="https://www.youtube.com/watch?v=ZBHKZF5w4YU" target="_blank" rel="noopener">Segment Tree Range Minimum Query</a>清晰明了。<a id="more"></a></p><h2 id="线段树的例子"><a href="#线段树的例子" class="headerlink" title="线段树的例子"></a>线段树的例子</h2><h3 id="Sum-of-given-range"><a href="#Sum-of-given-range" class="headerlink" title="Sum of given range"></a>Sum of given range</h3><p>We have an array arr[0 . . . n-1]. We should be able to</p><ol><li>Find the sum of elements from index l to r where 0 &lt;= l &lt;= r &lt;= n-1</li><li>Change value of a specified element of the array to a new value x. We need to do arr[i] = x where 0 &lt;= i &lt;= n-1.</li></ol><p><strong>Representation of Segment trees</strong></p><ol><li>Leaf Nodes are the elements of the input array.</li><li>Each internal node represents some merging of the leaf nodes. The merging may be different for different problems. For this problem, merging is sum of leaves under a node.</li></ol><p>An array representation of tree is used to represent Segment Trees. For each node at index i, the left child is at index <code>2*i+1</code>, right child at <code>2*i+2</code> and the parent is at<code>(i-1)/2</code>.<br><img src="/images/2018/9/6.png" alt=""><br><strong>Construction of Segment Tree from given array</strong><br>We start with a segment arr[0 . . . n-1]. and every time we divide the current segment into two halves(if it has not yet become a segment of length 1), and then call the same procedure on both halves, and for each such segment, we store the sum in the corresponding node.<br>All levels of the constructed segment tree will be completely filled except the last level. Also, the tree will be a Full Binary Tree because we always divide segments in two halves at every level. Since the constructed tree is always a full binary tree with n leaves, there will be n-1 internal nodes. So total number of nodes will be 2*n – 1.</p><p>Height of the segment tree will be <code>logN</code>. Since the tree is represented using array and relation between parent and child indexes must be maintained, size of memory allocated for segment tree will be  <code>2*pow(2, logN)-1</code>.<br><strong>Query for Sum of given range</strong><br>Once the tree is constructed, how to get the sum using the constructed segment tree. Following is the algorithm to get the sum of elements.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(node, l, r)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> the range of the node is within l <span class="keyword">and</span> r</span><br><span class="line">        <span class="keyword">return</span> value in the node</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> the range of the node is completely outside l <span class="keyword">and</span> r</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> getSum(node's left child, l, r) + </span><br><span class="line">           getSum(node's right child, l, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Update a value</strong><br>Like tree construction and query operations, the update can also be done recursively. We are given an index which needs to be updated. Let <em>diff</em> be the value to be added. We start from root of the segment tree and add <em>diff</em> to all nodes which have given index in their range. If a node doesn’t have given index in its range, we don’t make any changes to that node.<br><strong>Implementation</strong><br>Following is the implementation of segment tree. The program implements construction of segment tree for any given array. It also implements query and update operations.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPP program to show segment tree operations like construction, query </span></span><br><span class="line"><span class="comment">// and update </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to get the middle index from corner indexes. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMid</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;  <span class="keyword">return</span> s + (e -s)/<span class="number">2</span>;  &#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/*  A recursive function to get the sum of values in given range </span></span><br><span class="line"><span class="comment">    of the array. The following are parameters for this function. </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    st    --&gt; Pointer to segment tree </span></span><br><span class="line"><span class="comment">    si    --&gt; Index of current node in the segment tree. Initially </span></span><br><span class="line"><span class="comment">              0 is passed as root is always at index 0 </span></span><br><span class="line"><span class="comment">    ss &amp; se  --&gt; Starting and ending indexes of the segment represented </span></span><br><span class="line"><span class="comment">                 by current node, i.e., st[si] </span></span><br><span class="line"><span class="comment">    qs &amp; qe  --&gt; Starting and ending indexes of query range */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSumUtil</span><span class="params">(<span class="keyword">int</span> *st, <span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> qs, <span class="keyword">int</span> qe, <span class="keyword">int</span> si)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// If segment of this node is a part of given range, then return </span></span><br><span class="line">    <span class="comment">// the sum of the segment </span></span><br><span class="line">    <span class="keyword">if</span> (qs &lt;= ss &amp;&amp; qe &gt;= se) </span><br><span class="line">        <span class="keyword">return</span> st[si]; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If segment of this node is outside the given range </span></span><br><span class="line">    <span class="keyword">if</span> (se &lt; qs || ss &gt; qe) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If a part of this segment overlaps with the given range </span></span><br><span class="line">    <span class="keyword">int</span> mid = getMid(ss, se); </span><br><span class="line">    <span class="keyword">return</span> getSumUtil(st, ss, mid, qs, qe, <span class="number">2</span>*si+<span class="number">1</span>) + </span><br><span class="line">           getSumUtil(st, mid+<span class="number">1</span>, se, qs, qe, <span class="number">2</span>*si+<span class="number">2</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* A recursive function to update the nodes which have the given  </span></span><br><span class="line"><span class="comment">   index in their range. The following are parameters </span></span><br><span class="line"><span class="comment">    st, si, ss and se are same as getSumUtil() </span></span><br><span class="line"><span class="comment">    i    --&gt; index of the element to be updated. This index is  </span></span><br><span class="line"><span class="comment">             in the input array. </span></span><br><span class="line"><span class="comment">   diff --&gt; Value to be added to all nodes which have i in range */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateValueUtil</span><span class="params">(<span class="keyword">int</span> *st, <span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> i, <span class="keyword">int</span> diff, <span class="keyword">int</span> si)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// Base Case: If the input index lies outside the range of  </span></span><br><span class="line">    <span class="comment">// this segment </span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; ss || i &gt; se) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If the input index is in range of this node, then update  </span></span><br><span class="line">    <span class="comment">// the value of the node and its children </span></span><br><span class="line">    st[si] = st[si] + diff; </span><br><span class="line">    <span class="keyword">if</span> (se != ss) &#123; </span><br><span class="line">        <span class="keyword">int</span> mid = getMid(ss, se); </span><br><span class="line">        updateValueUtil(st, ss, mid, i, diff, <span class="number">2</span>*si + <span class="number">1</span>); </span><br><span class="line">        updateValueUtil(st, mid+<span class="number">1</span>, se, i, diff, <span class="number">2</span>*si + <span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The function to update a value in input array and segment tree. </span></span><br><span class="line"><span class="comment">// It uses updateValueUtil() to update the value in segment tree </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateValue</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> *st, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> new_val)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// Check for erroneous input index </span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; n<span class="number">-1</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Invalid Input"</span>); </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Get the difference between new value and old value </span></span><br><span class="line">    <span class="keyword">int</span> diff = new_val - arr[i]; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update the value in array </span></span><br><span class="line">    arr[i] = new_val; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update the values of nodes in segment tree </span></span><br><span class="line">    updateValueUtil(st, <span class="number">0</span>, n<span class="number">-1</span>, i, diff, <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Return sum of elements in range from index qs (quey start) </span></span><br><span class="line"><span class="comment">// to qe (query end).  It mainly uses getSumUtil() </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> *st, <span class="keyword">int</span> n, <span class="keyword">int</span> qs, <span class="keyword">int</span> qe)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// Check for erroneous input values </span></span><br><span class="line">    <span class="keyword">if</span> (qs &lt; <span class="number">0</span> || qe &gt; n<span class="number">-1</span> || qs &gt; qe) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Invalid Input"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> getSumUtil(st, <span class="number">0</span>, n<span class="number">-1</span>, qs, qe, <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A recursive function that constructs Segment Tree for array[ss..se]. </span></span><br><span class="line"><span class="comment">// si is index of current node in segment tree st </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">constructSTUtil</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> *st, <span class="keyword">int</span> si)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// If there is one element in array, store it in current node of </span></span><br><span class="line">    <span class="comment">// segment tree and return </span></span><br><span class="line">    <span class="keyword">if</span> (ss == se) &#123; </span><br><span class="line">        st[si] = arr[ss]; </span><br><span class="line">        <span class="keyword">return</span> arr[ss]; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If there are more than one elements, then recur for left and </span></span><br><span class="line">    <span class="comment">// right subtrees and store the sum of values in this node </span></span><br><span class="line">    <span class="keyword">int</span> mid = getMid(ss, se); </span><br><span class="line">    st[si] =  constructSTUtil(arr, ss, mid, st, si*<span class="number">2</span>+<span class="number">1</span>) + </span><br><span class="line">              constructSTUtil(arr, mid+<span class="number">1</span>, se, st, si*<span class="number">2</span>+<span class="number">2</span>); </span><br><span class="line">    <span class="keyword">return</span> st[si]; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Function to construct segment tree from given array. This function </span></span><br><span class="line"><span class="comment">   allocates memory for segment tree and calls constructSTUtil() to </span></span><br><span class="line"><span class="comment">   fill the allocated memory */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">constructST</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// Allocate memory for the segment tree </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Height of segment tree </span></span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>)(<span class="built_in">ceil</span>(log2(n)));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Maximum size of segment tree </span></span><br><span class="line">    <span class="keyword">int</span> max_size = <span class="number">2</span>*(<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, x) - <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Allocate memory </span></span><br><span class="line">    <span class="keyword">int</span> *st = <span class="keyword">new</span> <span class="keyword">int</span>[max_size]; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Fill the allocated memory st </span></span><br><span class="line">    constructSTUtil(arr, <span class="number">0</span>, n<span class="number">-1</span>, st, <span class="number">0</span>); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Return the constructed segment tree </span></span><br><span class="line">    <span class="keyword">return</span> st; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Driver program to test above functions </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;; </span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Build segment tree from given array </span></span><br><span class="line">    <span class="keyword">int</span> *st = constructST(arr, n); <span class="comment">//确保n大于0</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Print sum of values in array from index 1 to 3 </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Sum of values in given range = "</span>&lt;&lt;getSum(st, n, <span class="number">1</span>, <span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">             </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update: set arr[1] = 10 and update corresponding  </span></span><br><span class="line">    <span class="comment">// segment tree nodes </span></span><br><span class="line">    updateValue(arr, st, n, <span class="number">1</span>, <span class="number">10</span>); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Find sum after the value is updated </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Updated sum of values in given range = "</span>&lt;&lt;getSum(st, n, <span class="number">1</span>, <span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sum of values in given range = 15</span><br><span class="line">Updated sum of values in given range = 22</span><br></pre></td></tr></table></figure></p><p><strong>Time Complexity</strong><br>Time Complexity for tree construction is O(n). There are total 2n-1 nodes, and value of every node is calculated only once in tree construction.</p><p>Time complexity to query is O(logN). To query a sum, we process at most four nodes at every level and number of levels is O(logN).</p><p>The time complexity of update is also O(logN). To update a leaf value, we process one node at every level and number of levels is O(logN).</p><h3 id="Range-Minimum-Query"><a href="#Range-Minimum-Query" class="headerlink" title="Range Minimum Query"></a>Range Minimum Query</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMid</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;  <span class="keyword">return</span> s + (e -s)/<span class="number">2</span>;  &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt;= b ? b : a; &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinUtil</span><span class="params">(<span class="keyword">int</span> *st, <span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> qs, <span class="keyword">int</span> qe, <span class="keyword">int</span> si)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (qs &lt;= ss &amp;&amp; qe &gt;= se) </span><br><span class="line">        <span class="keyword">return</span> st[si]; </span><br><span class="line">    <span class="keyword">if</span> (se &lt; qs || ss &gt; qe) </span><br><span class="line">        <span class="keyword">return</span> INT_MAX; </span><br><span class="line">    <span class="keyword">int</span> mid = getMid(ss, se); </span><br><span class="line">    <span class="keyword">return</span> min(getMinUtil(st, ss, mid, qs, qe, <span class="number">2</span>*si+<span class="number">1</span>), getMinUtil(st, mid+<span class="number">1</span>, se, qs, qe, <span class="number">2</span>*si+<span class="number">2</span>)); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateValueUtil</span><span class="params">(<span class="keyword">int</span> *st, <span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> i, <span class="keyword">int</span> new_val, <span class="keyword">int</span> si)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (i &lt; ss || i &gt; se) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    st[si] = min(st[si], new_val); </span><br><span class="line">    <span class="keyword">if</span> (se != ss) &#123; </span><br><span class="line">        <span class="keyword">int</span> mid = getMid(ss, se); </span><br><span class="line">        updateValueUtil(st, ss, mid, i, new_val, <span class="number">2</span>*si + <span class="number">1</span>); </span><br><span class="line">        updateValueUtil(st, mid+<span class="number">1</span>, se, i, new_val, <span class="number">2</span>*si + <span class="number">2</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateValue</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> *st, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> new_val)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; n<span class="number">-1</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Invalid Input"</span>); </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    arr[i] = new_val; </span><br><span class="line">    updateValueUtil(st, <span class="number">0</span>, n<span class="number">-1</span>, i, new_val, <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> *st, <span class="keyword">int</span> n, <span class="keyword">int</span> qs, <span class="keyword">int</span> qe)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (qs &lt; <span class="number">0</span> || qe &gt; n<span class="number">-1</span> || qs &gt; qe) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Invalid Input"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> getMinUtil(st, <span class="number">0</span>, n<span class="number">-1</span>, qs, qe, <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">constructSTUtil</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> *st, <span class="keyword">int</span> si)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (ss == se) &#123; </span><br><span class="line">        st[si] = arr[ss]; </span><br><span class="line">        <span class="keyword">return</span> arr[ss]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> mid = getMid(ss, se); </span><br><span class="line">    st[si] =  min(constructSTUtil(arr, ss, mid, st, si*<span class="number">2</span>+<span class="number">1</span>), constructSTUtil(arr, mid+<span class="number">1</span>, se, st, si*<span class="number">2</span>+<span class="number">2</span>)); </span><br><span class="line">    <span class="keyword">return</span> st[si]; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">constructST</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>)(<span class="built_in">ceil</span>(log2(n)));  </span><br><span class="line">    <span class="keyword">int</span> max_size = <span class="number">2</span>*(<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, x) - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> *st = <span class="keyword">new</span> <span class="keyword">int</span>[max_size]; </span><br><span class="line">    constructSTUtil(arr, <span class="number">0</span>, n<span class="number">-1</span>, st, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> st; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;; </span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *st = constructST(arr, n); <span class="comment">//确保n大于0</span></span><br><span class="line">    updateValue(arr, st, n, <span class="number">1</span>, <span class="number">-10</span>); </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"min of values in given range = "</span>&lt;&lt;getMin(st, n, <span class="number">1</span>, <span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><a href="https://www.youtube.com/watch?v=ZBHKZF5w4YU" target="_blank" rel="noopener">Tushar Segment Tree Range Minimum Query</a></li><li><a href="https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" target="_blank" rel="noopener">Segment Tree | Set 1 (Sum of given range)</a></li><li><a href="https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/" target="_blank" rel="noopener">Segment Tree | Set 2 (Range Minimum Query)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线段树的概念&quot;&gt;&lt;a href=&quot;#线段树的概念&quot; class=&quot;headerlink&quot; title=&quot;线段树的概念&quot;&gt;&lt;/a&gt;线段树的概念&lt;/h2&gt;&lt;p&gt;Tushar的讲解视频&lt;a href=&quot;https://www.youtube.com/watch?v=ZBHKZF5w4YU&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Segment Tree Range Minimum Query&lt;/a&gt;清晰明了。
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Best Time to Buy and Sell Stock problem</title>
    <link href="http://liujunming.github.io/2018/09/07/Best-Time-to-Buy-and-Sell-Stock-problem/"/>
    <id>http://liujunming.github.io/2018/09/07/Best-Time-to-Buy-and-Sell-Stock-problem/</id>
    <published>2018-09-07T05:58:38.000Z</published>
    <updated>2018-11-06T08:35:20.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock III</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock IV</a><br><a id="more"></a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>k=1</strong><br>当最多只能交易一次时，思路如下：<br>Say the given array is:<br>[7, 1, 5, 3, 6, 4]<br>If we plot the numbers of the given array on a graph, we get:<br><img src="/images/2018/9/4.png" alt=""><br>维护两个变量：minprice代表到目前为止，股票的最低价格；maxprofit代表在最多交易一次的情况下，所能获取的最大利益。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>k&gt;1</strong><br>k=1的情况下比较简单，Best Time to Buy and Sell Stock III是Best Time to Buy and Sell Stock IV的特例，因此，我们研究下k&gt;1的情况即可，找到一个通解。</p><p>看完<a href="https://www.youtube.com/watch?v=oDhu5uGq_ic&amp;t=10s" target="_blank" rel="noopener">Buy/Sell Stock With K transactions To Maximize Profit Dynamic Programming</a>即可理解此过程。<br><img src="/images/2018/9/5.png" alt=""></p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/135704/Detail-explanation-of-DP-solution" target="_blank" rel="noopener">Best Time to Buy and Sell Stock III leetcode题解</a>给出了详细的解答过程，如下：<br>DP recursive formula:<br><code>dp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j-1]), j=[0..i-1]</code></p><p>For k transactions, on i-th day,<br>if we don’t trade then the profit is same as previous day dp[k, i-1];<br>and if we bought the share on j-th day where j=[0..i-1], then sell the share on i-th day then the profit is prices[i] - prices[j] + dp[k-1, j-1] .<br>Actually j can be i as well. When j is i, the one more extra item prices[i] - prices[j] + dp[k-1, j] = dp[k-1, i] looks like we just lose one chance of transaction.</p><p>So the straigtforward implementation is:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">0</span> || prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[K+<span class="number">1</span>][prices.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">                    min = Math.min(min, prices[j] - dp[k-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">                dp[k][i] = Math.max(dp[k][i-<span class="number">1</span>], prices[i] - min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[K][prices.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Time complexity is O(kn^2), space complexity is O(kn).</p><p>In the above code, min is repeated calculated. It can be easily improved as:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">0</span> || prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[K+<span class="number">1</span>][prices.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">                min = Math.min(min, prices[i] - dp[k-<span class="number">1</span>][i-<span class="number">1</span>]);</span><br><span class="line">                dp[k][i] = Math.max(dp[k][i-<span class="number">1</span>], prices[i] - min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[K][prices.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Time complexity is O(kn), space complexity is O(kn).</p><hr><p>如果想获取整个股票交易的过程，可参考<a href="https://github.com/mission-peace/interview/blob/master/src/com/interview/dynamic/StockBuySellKTransactions.java" target="_blank" rel="noopener">StockBuySellKTransactions.java</a>中的代码。</p><p>拿张纸，画出动态规划的过程，即可深刻理解该题。</p><hr><p>参考资料：</p><ol><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution/" target="_blank" rel="noopener">leetcode121题解</a></li><li><a href="https://www.youtube.com/watch?v=oDhu5uGq_ic&amp;t=10s" target="_blank" rel="noopener">Buy/Sell Stock With K transactions To Maximize Profit Dynamic Programming</a></li><li><a href="https://github.com/mission-peace/interview/blob/master/src/com/interview/dynamic/StockBuySellKTransactions.java" target="_blank" rel="noopener">StockBuySellKTransactions.java</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/135704/Detail-explanation-of-DP-solution" target="_blank" rel="noopener">Best Time to Buy and Sell Stock III leetcode题解</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题&quot;&gt;&lt;a href=&quot;#题&quot; class=&quot;headerlink&quot; title=&quot;题&quot;&gt;&lt;/a&gt;题&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Best Time to Buy and Sell Stock&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Best Time to Buy and Sell Stock III&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Best Time to Buy and Sell Stock IV&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://liujunming.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://liujunming.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Minimum Window Substring</title>
    <link href="http://liujunming.github.io/2018/09/06/Minimum-Window-Substring/"/>
    <id>http://liujunming.github.io/2018/09/06/Minimum-Window-Substring/</id>
    <published>2018-09-06T08:51:11.000Z</published>
    <updated>2018-11-06T08:35:16.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题"><a href="#题" class="headerlink" title="题"></a>题</h3><p><a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="noopener">Minimum Window Substring</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看完<a href="https://www.youtube.com/watch?v=9qFR2WQGqkU" target="_blank" rel="noopener">Minimum Window Substring【FLAG高频精选面试题讲解】</a>中小姐姐讲的例子，就可以明白此题的思路。<a id="more"></a></p><p>本题为滑动窗口问题，通过hashmap+快慢指针来解决。</p><p>针对本题，slow和fast为快慢指针，match_count代表字符串T在字符串S中匹配字符的数目，min_len代表the size of the minimum window in S which will contain all the characters in T，index代表最小滑动窗口的开始地址。</p><p>代码是按照<a href="https://www.youtube.com/watch?v=9qFR2WQGqkU" target="_blank" rel="noopener">Minimum Window Substring【FLAG高频精选面试题讲解】</a>来写的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hashmap.count(t[i]))</span><br><span class="line">                hashmap[t[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hashmap[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>, match_count = <span class="number">0</span>, min_len= INT_MAX, index;</span><br><span class="line">        <span class="keyword">for</span>(fast = <span class="number">0</span>; fast &lt; s.size(); ++fast)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s[fast];</span><br><span class="line">            <span class="keyword">if</span>(!hashmap.count(ch))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> count  = hashmap[ch];</span><br><span class="line">            hashmap[ch]--;</span><br><span class="line">            <span class="comment">// match another character</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">1</span>) <span class="comment">//1-&gt;0</span></span><br><span class="line">                match_count++;</span><br><span class="line">            <span class="keyword">while</span>(match_count == hashmap.size())&#123;</span><br><span class="line">                <span class="comment">// find a valid substring</span></span><br><span class="line">                <span class="keyword">if</span>(fast - slow + <span class="number">1</span> &lt; min_len)&#123;</span><br><span class="line">                    min_len = fast - slow + <span class="number">1</span>;</span><br><span class="line">                    index = slow;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> leftmost = s[slow];</span><br><span class="line">                slow++;</span><br><span class="line">                <span class="keyword">if</span>(!hashmap.count(leftmost))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> leftmostCount = hashmap[leftmost];</span><br><span class="line">                hashmap[leftmost]++;</span><br><span class="line">                <span class="keyword">if</span>(leftmostCount == <span class="number">0</span>) <span class="comment">// 0-&gt;1</span></span><br><span class="line">                    match_count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_len == INT_MAX ? <span class="string">""</span> : s.substr(index, min_len);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.youtube.com/watch?v=9qFR2WQGqkU" target="_blank" rel="noopener">Minimum Window Substring【FLAG高频精选面试题讲解】</a></li><li><a href="https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-&#39;substring&#39;-problems" target="_blank" rel="noopener">Here is a 10-line template that can solve most ‘substring’ problems</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题&quot;&gt;&lt;a href=&quot;#题&quot; class=&quot;headerlink&quot; title=&quot;题&quot;&gt;&lt;/a&gt;题&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-window-substring/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Minimum Window Substring&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h3&gt;&lt;p&gt;看完&lt;a href=&quot;https://www.youtube.com/watch?v=9qFR2WQGqkU&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Minimum Window Substring【FLAG高频精选面试题讲解】&lt;/a&gt;中小姐姐讲的例子，就可以明白此题的思路。
    
    </summary>
    
      <category term="算法" scheme="http://liujunming.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://liujunming.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://liujunming.github.io/2018/09/06/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://liujunming.github.io/2018/09/06/拓扑排序/</id>
    <published>2018-09-06T04:35:26.000Z</published>
    <updated>2018-11-06T08:35:11.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拓扑排序的概念"><a href="#拓扑排序的概念" class="headerlink" title="拓扑排序的概念"></a>拓扑排序的概念</h2><p>在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：<a id="more"></a></p><ol><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ol><p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</p><p>例如，下面这个图：</p><p><img src="/images/2018/9/2.png" alt=""></p><p>它是一个 DAG 图，那么如何写出它的拓扑排序呢？这里说一种比较常用的方法：</p><ol><li>从 DAG 图中选择一个入度为0的顶点并输出。</li><li>从图中删除该顶点和所有以它为起点的有向边。</li><li>重复1和2直到当前的DAG 图为空或当前图中不存在入度为0的顶点为止。后一种情况说明有向图中必然存在环。<br><img src="/images/2018/9/1.png" alt=""><br><img src="/images/2018/9/3.png" alt=""></li></ol><p>于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。</p><p>通常，一个有向无环图可以有一个或多个拓扑排序序列。</p><h2 id="拓扑排序的应用"><a href="#拓扑排序的应用" class="headerlink" title="拓扑排序的应用"></a>拓扑排序的应用</h2><p>拓扑排序通常用来“排序”具有依赖关系的任务。</p><p>比如，如果用一个DAG图来表示一个工程，其中每个顶点表示工程中的一个任务，用有向边&lt;A,B&gt;表示在做任务 B 之前必须先完成任务 A。故在这个工程中，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）。</p><h2 id="拓扑排序的例题"><a href="#拓扑排序的例题" class="headerlink" title="拓扑排序的例题"></a>拓扑排序的例题</h2><ol><li>从 DAG 图中选择一个入度为0的顶点并输出。</li><li>从图中删除该顶点和所有以它为起点的有向边。</li><li>重复1和2直到当前的 DAG 图为空或当前图中不存在入度为0的顶点为止。后一种情况说明有向图中必然存在环。</li></ol><p>根据上述三个步骤即可写出bfs代码。</p><h3 id="Course-Schedule"><a href="#Course-Schedule" class="headerlink" title="Course Schedule"></a><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">Course Schedule</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(numCourses, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> ready = prerequisites[i].first;</span><br><span class="line">            <span class="keyword">int</span> pre = prerequisites[i].second;</span><br><span class="line">            <span class="keyword">if</span> (matrix[pre][ready] == <span class="number">0</span>)</span><br><span class="line">                indegree[ready]++; <span class="comment">//duplicate case</span></span><br><span class="line">            matrix[pre][ready] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">                que.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> course = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[course][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    indegree[i]--;</span><br><span class="line">                    <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">                        que.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count == numCourses;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Course-Schedule-II"><a href="#Course-Schedule-II" class="headerlink" title="Course Schedule II"></a><a href="https://leetcode.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener">Course Schedule II</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(numCourses, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> ready = prerequisites[i].first;</span><br><span class="line">            <span class="keyword">int</span> pre = prerequisites[i].second;</span><br><span class="line">            <span class="keyword">if</span> (matrix[pre][ready] == <span class="number">0</span>)</span><br><span class="line">                indegree[ready]++; <span class="comment">//duplicate case</span></span><br><span class="line">            matrix[pre][ready] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">                que.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> course = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            ret.push_back(course);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[course][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    indegree[i]--;</span><br><span class="line">                    <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">                        que.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ret.size() != numCourses)</span><br><span class="line">            ret.clear();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><a href="https://blog.csdn.net/lisonglisonglisong/article/details/45543451" target="_blank" rel="noopener">拓扑排序（Topological Sorting）</a></li><li><a href="https://leetcode.com/problems/course-schedule/discuss/58516/Easy-BFS-Topological-sort-Java" target="_blank" rel="noopener">Easy BFS Topological sort</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;拓扑排序的概念&quot;&gt;&lt;a href=&quot;#拓扑排序的概念&quot; class=&quot;headerlink&quot; title=&quot;拓扑排序的概念&quot;&gt;&lt;/a&gt;拓扑排序的概念&lt;/h2&gt;&lt;p&gt;在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：
    
    </summary>
    
      <category term="算法" scheme="http://liujunming.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://liujunming.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://liujunming.github.io/2018/09/05/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://liujunming.github.io/2018/09/05/并查集/</id>
    <published>2018-09-05T03:40:50.000Z</published>
    <updated>2018-11-06T08:22:28.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并查集概念"><a href="#并查集概念" class="headerlink" title="并查集概念"></a>并查集概念</h2><p>并查集是一种用来管理元素分组情况的数据结构。并查集可以高效地进行如下操作。</p><ul><li>查询元素a和元素b是否属于同一组。</li><li>合并元素a和元素b所在的组。<a id="more"></a><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisjointSets</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent, rank;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DisjointSets(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">        rank = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == parent[p])</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        parent[p] = find(parent[p]);</span><br><span class="line">        <span class="keyword">return</span> parent[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (rank[rootQ] &gt; rank[rootP]) &#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootP] == rank[rootQ]) &#123;</span><br><span class="line">                rank[rootP]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>Disjoint Sets （以下简称DS）的本质是许多棵树。每个圈子里的元素都组成了一棵树。然而我们的表示方法并不是用常规tree node的方法记录的，而是用数组.</p><p>DS里面拥有一个大小为N的vector <code>parent</code>，对于parent[i],存储着第i号元素所属圈子的老大。DS里面的另一个vector <code>rank</code>用来存储树的高度，它的作用会在Union操作中体现出来。</p><p>DS里面经典的两个操作分别是find和Union.</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p> find就是寻找这个圈子的老大（这棵树的root）。对于find来说，在寻找root的过程中，我们不仅要找到root，还要把沿途经过的所有node的parent都变成root，也就是把自己和沿途所有的node都变成root的孩子（同时也变成了深度为1的leaf）。这个操作叫path compression，意义在于下次我们如果寻找这些node的老大，就可以一步到位了（直接通过parent[i]找到root）。这对时间复杂度的优化是非常重要的。</p><h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p> Union是什么？是我们知道了两个元素属于同一个圈子。如果我们的DS已经知道这一点，那么没问题，如果我们的DS不知道这一点，我们要告诉它。并且很重要的是，这里不是针对两个元素，而是要把这两个元素所处的两个圈子融合成一个圈子，这也就是Union叫法的由来。那么我们分别用find找到两个元素所处tree的root，然后通过比较rank[root]的大小看哪棵树更大。最后我们把小的那棵树的root变成大的那棵树的root的孩子。之所以要选择把小的那棵树融合进大的那棵树，是因为我们希望让树的孩子的高度都尽量小。假设小的树的孩子数量是N1，大的树的孩子数量是N2。如果把小数融合进大树，那么我们让N1个node的高度都增加了1，反之我们要让N2个node的高度都增加1。后者明显是违反我们希望让树的孩子的高度都尽量小这个意愿的。<br> <a href="https://www.youtube.com/watch?v=ID00PMy0-vE" target="_blank" rel="noopener">Disjoint Sets using union by rank and path compression Graph Algorithm</a>中以具体的例子演示了Union的过程。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="Friend-Circles"><a href="#Friend-Circles" class="headerlink" title="Friend Circles"></a><a href="https://leetcode.com/problems/friend-circles/description/" target="_blank" rel="noopener">Friend Circles</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DisjointSets</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent, rank;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DisjointSets(<span class="keyword">int</span> num) &#123;</span><br><span class="line">            count = num;</span><br><span class="line">            parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">            rank = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p == parent[p])</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            parent[p] = find(parent[p]);</span><br><span class="line">            <span class="keyword">return</span> parent[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">            <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            count -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootQ] &gt; rank[rootP]) &#123;</span><br><span class="line">                parent[rootP] = rootQ;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootQ] = rootP;</span><br><span class="line">                <span class="keyword">if</span> (rank[rootP] == rank[rootQ]) &#123;</span><br><span class="line">                    rank[rootP]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        DisjointSets ds(M.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = M.size(); i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[i][j]) ds.unionTwo(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ds.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于整个matrix，如果M[i][j]为1，我们则需要告诉DS i和j属于一个圈子。这里因为对称性，我们只需要遍历半个matrix就可以得到所有信息。在DS里面我增加了一个count。count代表现在DS中独立圈子的数量。因为最开始我们什么信息都不知道，假设每个人都属于自己的独立圈子，所以count为人的个数，之后每一次Union操作，如果我们发现i和j所处圈子（的老大）不同（root1 ！= root2），那么说明有两个圈子要合并成一个，那么就少了一个圈子，所以count要减1.最后我们返回count，也就是圈子的数量。</p><h3 id="Number-of-Islands"><a href="#Number-of-Islands" class="headerlink" title="Number of Islands"></a><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener">Number of Islands</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DisjointSets</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent, rank;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DisjointSets(<span class="keyword">int</span> num) &#123;</span><br><span class="line">            count = num;</span><br><span class="line">            parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">            rank = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(num, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p == parent[p])</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            parent[p] = find(parent[p]);</span><br><span class="line">            <span class="keyword">return</span> parent[p];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">            <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">            <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">            count -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootQ] &gt; rank[rootP]) &#123;</span><br><span class="line">                parent[rootP] = rootQ;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootQ] = rootP;</span><br><span class="line">                <span class="keyword">if</span> (rank[rootP] == rank[rootQ]) &#123;</span><br><span class="line">                    rank[rootP]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(grid.size() == <span class="number">0</span> || grid[<span class="number">0</span>].size() ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    hashMap[i*n+j] = num;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">DisjointSets <span class="title">ds</span><span class="params">(num)</span></span>;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; hashMap.count((i<span class="number">-1</span>)*n+j))&#123;</span><br><span class="line">                        ds.unionTwo(hashMap[(i<span class="number">-1</span>)*n+j], hashMap[i*n+j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i + <span class="number">1</span> &lt; m &amp;&amp; hashMap.count((i+<span class="number">1</span>)*n+j))&#123;</span><br><span class="line">                        ds.unionTwo(hashMap[(i+<span class="number">1</span>)*n+j], hashMap[i*n+j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; hashMap.count(i*n+j<span class="number">-1</span>))&#123;</span><br><span class="line">                        ds.unionTwo(hashMap[i*n+j<span class="number">-1</span>], hashMap[i*n+j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; hashMap.count(i*n+j+<span class="number">1</span>))&#123;</span><br><span class="line">                        ds.unionTwo(hashMap[i*n+j+<span class="number">1</span>], hashMap[i*n+j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ds.getCount();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ol><li><a href="https://blog.csdn.net/niushuai666/article/details/6662911" target="_blank" rel="noopener">超有爱的并查集~</a></li><li><a href="https://www.youtube.com/watch?v=ID00PMy0-vE" target="_blank" rel="noopener">Disjoint Sets using union by rank and path compression Graph Algorithm</a></li><li><a href="https://zhuanlan.zhihu.com/p/32112569" target="_blank" rel="noopener">Disjoint Sets / Union Find</a></li><li><a href="https://www.youtube.com/watch?v=JZBQLXgSGfs" target="_blank" rel="noopener">Union Find Kruskal’s Algorithm</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并查集概念&quot;&gt;&lt;a href=&quot;#并查集概念&quot; class=&quot;headerlink&quot; title=&quot;并查集概念&quot;&gt;&lt;/a&gt;并查集概念&lt;/h2&gt;&lt;p&gt;并查集是一种用来管理元素分组情况的数据结构。并查集可以高效地进行如下操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询元素a和元素b是否属于同一组。&lt;/li&gt;
&lt;li&gt;合并元素a和元素b所在的组。
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统中需要记住的数字</title>
    <link href="http://liujunming.github.io/2018/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%9C%80%E8%A6%81%E8%AE%B0%E4%BD%8F%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://liujunming.github.io/2018/07/02/计算机系统中需要记住的数字/</id>
    <published>2018-07-02T01:54:58.000Z</published>
    <updated>2018-07-02T01:54:58.407Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Bloom-Filter的解析</title>
    <link href="http://liujunming.github.io/2018/05/25/Bloom-Filter%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://liujunming.github.io/2018/05/25/Bloom-Filter的解析/</id>
    <published>2018-05-25T05:01:58.000Z</published>
    <updated>2018-11-06T08:28:48.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bloom-Filter概念"><a href="#Bloom-Filter概念" class="headerlink" title="Bloom Filter概念"></a>Bloom Filter概念</h2><p>Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。<br><a id="more"></a></p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ul><li><p>初始状态<br>Bloom Filter是一个m位的位数组，且数组被0所填充。同时，我们需要定义k个不同的hash函数，每一个hash函数都随机的将每一个输入元素映射到位数组中的一个位上。那么对于一个确定的输入，我们会得到k个索引。</p></li><li><p>插入元素<br>经过k个hash函数的映射，我们会得到k个索引，我们把位数组中这k个位置全部置1（不管其中的位之前是0还是1）</p></li><li>查询元素<br>输入元素经过k个hash函数的映射会得到k个索引，如果位数组中这k个索引任意一处是0，那么就说明这个元素不在集合之中；如果元素处于集合之中，那么当插入元素的时候这k个位都是1。但如果这k个索引处的位都是1，被查询的元素就一定在集合之中吗？答案是不一定，也就是说出现了False Positive的情况。<br><img src="/images/2018/5/6.png" alt=""><br>在上图中，当插入x、y、z这三个元素之后，再来查询w，会发现w不在集合之中，而如果w经过三个hash函数计算得出的结果所得索引处的位全是1，那么Bloom Filter就会告诉你，w在集合之中，实际上这里是误报，w并不在集合之中。</li></ul><h2 id="误报率估计"><a href="#误报率估计" class="headerlink" title="误报率估计"></a>误报率估计</h2><p><img src="/images/2018/5/7.png" alt=""></p><h2 id="Bloom-Filter的实现"><a href="#Bloom-Filter的实现" class="headerlink" title="Bloom Filter的实现"></a>Bloom Filter的实现</h2><p>纸上得来终觉浅，绝知此事要躬行。</p><p><a href="https://github.com/liujunming/Tools/tree/master/BloomFilter" target="_blank" rel="noopener">Bloom Filter的实现</a></p><p>若读者想深入研究Bloom Filter，可以去知网下载《基于LSM-tree键值系统读性能优化》(张月明)。</p><hr><p>参考资料:</p><ol><li><a href="https://my.oschina.net/kiwivip/blog/133498" target="_blank" rel="noopener">Bloom Filter 算法简介</a></li><li><a href="http://www.cnblogs.com/kaituorensheng/p/3669140.html" target="_blank" rel="noopener">实例学习Bloom Filter</a></li><li><a href="https://blog.csdn.net/jiaomeng/article/details/1495500" target="_blank" rel="noopener">Bloom Filter概念和原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Bloom-Filter概念&quot;&gt;&lt;a href=&quot;#Bloom-Filter概念&quot; class=&quot;headerlink&quot; title=&quot;Bloom Filter概念&quot;&gt;&lt;/a&gt;Bloom Filter概念&lt;/h2&gt;&lt;p&gt;Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://liujunming.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://liujunming.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>perf内核源码解析</title>
    <link href="http://liujunming.github.io/2018/05/10/perf%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://liujunming.github.io/2018/05/10/perf内核源码解析/</id>
    <published>2018-05-10T04:06:14.000Z</published>
    <updated>2018-11-06T08:33:21.337Z</updated>
    
    <content type="html"><![CDATA[<p>本文所演示的内核版本为<a href="https://elixir.bootlin.com/linux/v3.14.69/source" target="_blank" rel="noopener">3.14.69</a>，平台架构为x86架构,主要以<a href="https://www.zybuluo.com/ljm/note/1125361" target="_blank" rel="noopener">通过perf测试进程的内存带宽</a>为例，讲述了在内核的调用过程。<a id="more"></a></p><h2 id="perf用户态使用"><a href="#perf用户态使用" class="headerlink" title="perf用户态使用"></a>perf用户态使用</h2><p>在用户态，用户可以调用<a href="https://elixir.bootlin.com/linux/v3.14.69/source/kernel/events/core.c#L7094" target="_blank" rel="noopener">perf_event_open</a>系统调用来使用perf。<br>建议读者好好阅读下下面推荐的资料，这样可以对perf_event_open的理解更加深刻些。</p><ol><li><a href="http://man7.org/linux/man-pages/man2/perf_event_open.2.html" target="_blank" rel="noopener">man2　perf_event_open</a></li><li><a href="http://ozlabs.org/~anton/junkcode/perf_events_example1.c" target="_blank" rel="noopener">perf events self profiling example</a></li><li><a href="http://hchen229.iteye.com/blog/585434" target="_blank" rel="noopener">使用performance counter读取硬件或软件Event</a></li><li><a href="https://blog.csdn.net/u012884354/article/details/45720737" target="_blank" rel="noopener">perf_event_open 设置性能监视</a></li></ol><h2 id="perf-event子系统架构"><a href="#perf-event子系统架构" class="headerlink" title="perf event子系统架构"></a>perf event子系统架构</h2><p><img src="/images/2018/5/1.png" alt=""></p><p>The Linux Perf_Event Subsystem consists of the files <a href="https://elixir.bootlin.com/linux/v3.14.69/source/kernel/events/core.c" target="_blank" rel="noopener">core.c</a> and <a href="https://elixir.bootlin.com/linux/v3.14.69/source/arch/x86/kernel/cpu/perf_event.c" target="_blank" rel="noopener">perf_event.c</a>. These files are the interface between the linux kernel and various user space performance monitoring tool.</p><h2 id="perf-event子系统中的数据结构"><a href="#perf-event子系统中的数据结构" class="headerlink" title="perf event子系统中的数据结构"></a>perf event子系统中的数据结构</h2><p>数据结构的定义在<a href="https://elixir.bootlin.com/linux/v3.14.69/source/include/linux/perf_event.h" target="_blank" rel="noopener">perf_event.h</a>文件中。</p><p>The following are some of the important data structures which are used by the perf_event subsystem.</p><p><img src="/images/2018/5/2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct perf_event;</span><br><span class="line">struct perf_event_attr;</span><br><span class="line">struct perf_event_context;</span><br><span class="line">struct pmu;</span><br></pre></td></tr></table></figure><p><strong>Important Fields in the Data Structures</strong></p><h3 id="perf-event"><a href="#perf-event" class="headerlink" title="perf_event"></a>perf_event</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event</span> *<span class="title">group_leader</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmu</span> *<span class="title">pmu</span>;</span></span><br><span class="line">u64 total_time_enabled;</span><br><span class="line">u64 total_time_running;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_attr</span> <span class="title">attr</span>;</span></span><br><span class="line"><span class="keyword">atomic64_t</span> child_count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span> *<span class="title">ctx</span>;</span></span><br><span class="line"><span class="keyword">perf_overflow_handler_t</span> overflow_handler;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>Description:</strong></p><ul><li>group_leader<br>This field specifies the leader of the group of events attached to the process.</li><li>pmu<br>This field points to the generic performance monitoring unit structure.</li><li>total_time_enabled<br>This field specify the total time in nanoseconds that the event has been enabled.</li><li>total_time_running<br>This field specify total time in nanoseconds that the event is running(scheduled onto the<br>CPU)</li><li>owner<br>This field points to the task structure of the process which has monitoring this event.</li></ul><h3 id="perf-event-attr"><a href="#perf-event-attr" class="headerlink" title="perf_event_attr"></a>perf_event_attr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_attr</span> &#123;</span></span><br><span class="line">__u32 type;</span><br><span class="line">__u64 config;</span><br><span class="line">__u64 sample_period;</span><br><span class="line">__u64 sample_freq;</span><br><span class="line">__u64 sample_type;</span><br><span class="line">exclusive : <span class="number">1</span>,</span><br><span class="line">exclude_user : <span class="number">1</span>,</span><br><span class="line">exclude_kernel : <span class="number">1</span>,</span><br><span class="line">exclude_hv : <span class="number">1</span>,</span><br><span class="line">exclude_idle : <span class="number">1</span>,</span><br><span class="line">exclude_host : <span class="number">1</span>,</span><br><span class="line">exclude_guest : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>Description:</strong></p><ul><li>type<br>This field specifies the overall event type.</li><li>config<br>This field specifies which event needs to be monitored. It is used along with type to<br>decide the exact event.</li><li>sample_period, sample_freq<br>Sampling period defines the N value where N is the number of events after which the<br>interrupt is generated. It can be counted in terms of frequency as well.</li><li>sample_type<br>The various bits in this field specify which values to include in the sample.</li><li>exclude_user<br>This bit when enabled the count excludes the user-space events.</li><li>exclude_kernel<br>This bit when enabled the count exclude the kernel-space events.</li></ul><h3 id="perf-event-context"><a href="#perf-event-context" class="headerlink" title="perf_event_context"></a>perf_event_context</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">event_list</span>;</span></span><br><span class="line"><span class="keyword">int</span> nr_events;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span> *<span class="title">parent_ctx</span>;</span></span><br><span class="line">u64 time;</span><br><span class="line">u64 timestamp; &#125;</span><br></pre></td></tr></table></figure><p><strong>Description:</strong></p><ul><li>event_lists<br>This field specifies the list of events.</li><li>nr_events<br>This field specifies the number of events that are currently monitored.</li><li>parent_ctx<br>This fields points to the context of the processes parent.</li><li>time,timestamp<br>These are context clocks, they run when the context is enabled.</li></ul><h3 id="pmu"><a href="#pmu" class="headerlink" title="pmu"></a>pmu</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmu</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> (*pmu_enable) (struct pmu *pmu);</span><br><span class="line"><span class="keyword">void</span> (*pmu_disable) (struct pmu *pmu);</span><br><span class="line"><span class="keyword">void</span> (*start) (struct perf_event *event, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">void</span> (*stop) (struct perf_event *event, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">void</span> (*read) (struct perf_event *event); &#125;</span><br></pre></td></tr></table></figure><p><strong>Description:</strong><br>This structure majorly contains the function pointers to various PMU related functions.</p><ul><li>pmu_enable,pmu_disable<br>These functions are used to fully disable/enable a PMU.</li><li>start,stop<br>These functions are used to start or stop a counter on a PMU.</li><li>read<br>This function is used to update the event value for a particular counter.</li></ul><h2 id="Counting-Support-in-Linux-Perf"><a href="#Counting-Support-in-Linux-Perf" class="headerlink" title="Counting Support in Linux Perf"></a>Counting Support in Linux Perf</h2><p>perf_event assigns one file descriptor per event and either per-thread or per-CPU. The system call perf_event_open() configures the hardware MSRs and creates a file descriptor which can be used for reading the performance measurement data. Once the file descriptor is obtained we can issue subsequent read calls to get the values of the performance counters. These values are then aggregated at the end of the program execution.</p><p>The following is the execution flow for getting the file descriptor.</p><p><img src="/images/2018/5/4.png" alt=""></p><p>For enabling and disabling performance monitoring events we use the ioclt and prctl system calls.</p><p>Execution flow of the read system call:<br> <img src="/images/2018/5/5.png" alt=""></p><h2 id="perf-event-open系统调用的具体过程"><a href="#perf-event-open系统调用的具体过程" class="headerlink" title="perf_event_open系统调用的具体过程"></a>perf_event_open系统调用的具体过程</h2><p><img src="/images/2018/5/3.png" alt=""></p><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><p>好了，背景知识终于介绍完成了，下面介绍下具体的实例，方便读者理解。<br><code>perf stat -e cache-misses -I 1000 -p 2234</code><br>每隔1000ms，会输出2234进程在过去1000ms的cache_misses硬件事件，这是如何做到的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">type:<span class="number">0</span> <span class="comment">//PERF_TYPE_HARDWARE</span></span><br><span class="line">config:<span class="number">3</span> <span class="comment">//PERF_COUNT_HW_CACHE_MISSES</span></span><br></pre></td></tr></table></figure><p>每隔1000ms输出结果是通过用户态程序控制的，阅读完<a href="http://hchen229.iteye.com/blog/585434" target="_blank" rel="noopener">使用performance counter读取硬件或软件Event</a>中的程序即可明白。</p><p>当需要监听2234进程的cache_misses时，实际上是对2234进程中的所有线程进行监听,假设线程的数目为5个，此刻，会调用perf_event_open系统调用5次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">perf_event_read_one</span><span class="params">(struct perf_event *event,</span></span></span><br><span class="line"><span class="function"><span class="params">                 u64 read_format, <span class="keyword">char</span> __user *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u64 enabled, running;</span><br><span class="line">    u64 values[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    values[n++] = perf_event_read_value(event, &amp;enabled, &amp;running);</span><br><span class="line">    printk(<span class="string">"&lt;0&gt;"</span><span class="string">"liujunming  perf_event_read_one value%llu\n"</span>, values[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (read_format &amp; PERF_FORMAT_TOTAL_TIME_ENABLED)</span><br><span class="line">        values[n++] = enabled;</span><br><span class="line">    <span class="keyword">if</span> (read_format &amp; PERF_FORMAT_TOTAL_TIME_RUNNING)</span><br><span class="line">        values[n++] = running;</span><br><span class="line">    <span class="keyword">if</span> (read_format &amp; PERF_FORMAT_ID)</span><br><span class="line">        values[n++] = primary_event_id(event);</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buf, values, n * <span class="keyword">sizeof</span>(u64)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="keyword">sizeof</span>(u64);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>perf_event_read_value会读取相应线程寄存器中记录的cache_miss值。</p><p>当统计2234进程时，实际上是对它5个线程的cache_misses值进行累加。假设前２秒内，2234进程的cache_misses为10000,前3秒内，2234进程的cache_misses为30000。那么在2~3秒这一秒内，进程的cache_misses即为20000。</p><hr><p>参考资料:</p><ol><li><a href="http://rts.lab.asu.edu/web_438/project_final/CSE_598_Performance_Monitoring_Unit.pdf" target="_blank" rel="noopener">A Study of Performance Monitoring Unit, perf and perf_events subsystem</a></li><li><a href="http://cdmd.cnki.com.cn/Article/CDMD-10358-1011284067.htm" target="_blank" rel="noopener">龙芯多核平台上性能分析工具的设计与实现</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文所演示的内核版本为&lt;a href=&quot;https://elixir.bootlin.com/linux/v3.14.69/source&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;3.14.69&lt;/a&gt;，平台架构为x86架构,主要以&lt;a href=&quot;https://www.zybuluo.com/ljm/note/1125361&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;通过perf测试进程的内存带宽&lt;/a&gt;为例，讲述了在内核的调用过程。
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>深度解析perf</title>
    <link href="http://liujunming.github.io/2018/04/24/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90perf/"/>
    <id>http://liujunming.github.io/2018/04/24/深度解析perf/</id>
    <published>2018-04-24T12:27:04.000Z</published>
    <updated>2018-11-06T08:27:20.728Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zybuluo.com/ljm/note/1125361" target="_blank" rel="noopener">通过perf测试进程的内存带宽</a></p><h2 id="perf的基本原理"><a href="#perf的基本原理" class="headerlink" title="perf的基本原理"></a>perf的基本原理</h2><p>Perf 是内置于 Linux 内核源码树中的性能剖析（profiling）工具。它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析，可用于性能瓶颈的查找与热点代码的定位。<br><a id="more"></a><br>以监测“cycles”事件为例，perf的工作过程如下：<br>首先，perf 会通过系统调用sys_perf_event_open在内核中注册一个监测“cycles”事件的性能计数器。内核根据perf提供的信息在PMU(Performance Monitoring Unit)上初始化一个硬件性能计数器（PMC:Performance Monitoring Counter）。PMC随着CPU周期的增加而自动累加。在PMC溢出时，PMU触发一个PMI（Performance Monitoring Interrupt）中断。内核在PMI中断的处理函数中保存PMC的计数值，触发中断时的指令地址（Register IP：Instruction Pointer），当前时间戳以及当前进程的PID，TID，comm等信息。我们把这些信息统称为一个采样（sample）。内核会将收集到的sample放入用于跟用户空间通信的Ring Buffer。用户空间里的perf分析程序采用mmap机制从Ring Buffer中读入采样，并对其解析。perf根据pid，comm等信息可以找到对应的进程。根据IP与ELF文件中的符号表可以查到触发PMI中断的指令所在的函数。</p><p>根据上述的perf采样原理可以得知，perf假设两次采样之间，即两次相邻的PMI中断之间系统执行的是同一个进程的同一个函数。这种假设会带来一定的误差，当读者感觉perf给出的结果不准时，不妨提高采样频率，perf会给出更加精确的结果。</p><h2 id="perf-list简介"><a href="#perf-list简介" class="headerlink" title="perf list简介"></a>perf list简介</h2><p>事件可以分为三种：</p><ol><li>Hardware Event由PMU部件产生，在特定的条件下探测性能事件是否发生以及发生的次数。比如cache命中。</li><li>Software Event是内核产生的事件，分布在各个功能模块中，统计和操作系统相关性能事件。比如进程切换，tick数等。</li><li>Tracepoint Event是内核中静态tracepoint所触发的事件，这些tracepoint用来判断程序运行期间内核的行为细节，比如slab分配器的分配次数等。</li></ol><h2 id="性能事件的属性"><a href="#性能事件的属性" class="headerlink" title="性能事件的属性"></a>性能事件的属性</h2><p>硬件性能事件由处理器中的PMU提供支持。由于现代处理器的主频非常高，再加上深度流水线机制，从性能事件被触发，到处理器响应 PMI中断，流水线上可能已处理过数百条指令。那么PMI中断采到的指令地址就不再是触发性能事件的那条指令的地址了，而且可能具有非常严重的偏差。为了解决这个问题，Intel处理器通过PEBS机制实现了高精度事件采样。PEBS通过硬件在计数器溢出时将处理器现场直接保存到内存（而不是在响应中断时才保存寄存器现场），从而使得 perf能够采到真正触发性能事件的那条指令的地址，提高了采样精度。在默认条件下，perf不使用PEBS机制。用户如果想要使用高精度采样，需要在指定性能事件时，在事件名后添加后缀”:p”或”:pp”。<br>Perf在采样精度上定义了4个级别，如下表所示。</p><table><thead><tr><th>级别</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>无精度保证</td></tr><tr><td>1</td><td>采样指令与触发性能事件的指令之间的偏差为常数（:p）</td></tr><tr><td>2</td><td>需要尽量保证采样指令与触发性能事件的指令之间的偏差为0（:pp）</td></tr><tr><td>3</td><td>保证采样指令与触发性能事件的指令之间的偏差必须为0（:ppp）</td></tr></tbody></table><center>性能事件的精度级别</center><p>目前的X86处理器，包括Intel处理器与AMD处理器均仅能实现前 3 个精度级别。</p><p>除了精度级别以外，性能事件还具有其它几个属性，均可以通过”event:X”的方式予以指定。</p><table><thead><tr><th>标志</th><th>属性</th></tr></thead><tbody><tr><td>u</td><td>仅统计用户空间程序触发的性能事件</td></tr><tr><td>k</td><td>仅统计内核触发的性能事件</td></tr><tr><td>h</td><td>仅统计Hypervisor触发的性能事件</td></tr><tr><td>G</td><td>在KVM虚拟机中，仅统计Guest系统触发的性能事件</td></tr><tr><td>H</td><td>仅统计 Host 系统触发的性能事件</td></tr><tr><td>p</td><td>精度级别</td></tr></tbody></table><center>性能事件的属性</center><hr><p>参考资料:</p><ol><li><a href="http://files.cnblogs.com/files/jiayy/Linux%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%BA%A7%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%E5%B7%A5%E5%85%B7-perf-1.pdf" target="_blank" rel="noopener">Linux 的系统级性能剖析工具‐perf</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.zybuluo.com/ljm/note/1125361&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;通过perf测试进程的内存带宽&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;perf的基本原理&quot;&gt;&lt;a href=&quot;#perf的基本原理&quot; class=&quot;headerlink&quot; title=&quot;perf的基本原理&quot;&gt;&lt;/a&gt;perf的基本原理&lt;/h2&gt;&lt;p&gt;Perf 是内置于 Linux 内核源码树中的性能剖析（profiling）工具。它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析，可用于性能瓶颈的查找与热点代码的定位。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>自我总结</title>
    <link href="http://liujunming.github.io/2018/04/19/%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93/"/>
    <id>http://liujunming.github.io/2018/04/19/自我总结/</id>
    <published>2018-04-19T08:12:33.000Z</published>
    <updated>2018-11-06T08:28:11.912Z</updated>
    
    <content type="html"><![CDATA[<p>一直认为自己是在搞系统的，但是忽然发现对系统的好多知识都不够了解。必须做到在计算机系统结构、操作系统内核、网络、分布式系统、算法这些领域都能游刃有余，方能运筹帷幄，决胜千里。<br><a id="more"></a><br>上了研究生，学习的渠道可能就是博客、论文这些，但是缺乏一个系统的学习流程，后来发现是自己书看的太少了，思考的太少。</p><p>下面列出自己需要看完的书籍吧：</p><ul><li><a href="https://raw.githubusercontent.com/QSCTech/zju-icicles/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%95%99%E6%9D%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E9%87%8F%E5%8C%96%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%94%E7" target="_blank" rel="noopener">计算机体系结构：量化研究方法</a></li></ul><p><a href="https://booksite.elsevier.com/9780123838728/references.php" target="_blank" rel="noopener">Reference Appendices</a><br>两位作者凭借此书，刚刚获得图灵奖，这本书的价值不言而喻。<br><img src="/images/2018/4/11.jpg" alt=""></p><ul><li><p>现代操作系统</p></li><li><p>计算机网络(自顶向下方法)</p></li><li><p>Designing Data-Intensive Applications</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直认为自己是在搞系统的，但是忽然发现对系统的好多知识都不够了解。必须做到在计算机系统结构、操作系统内核、网络、分布式系统、算法这些领域都能游刃有余，方能运筹帷幄，决胜千里。&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>通过Linux内核使用RDT</title>
    <link href="http://liujunming.github.io/2018/04/18/%E9%80%9A%E8%BF%87Linux%E5%86%85%E6%A0%B8%E4%BD%BF%E7%94%A8RDT/"/>
    <id>http://liujunming.github.io/2018/04/18/通过Linux内核使用RDT/</id>
    <published>2018-04-18T06:40:00.000Z</published>
    <updated>2018-11-06T08:27:49.393Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://liujunming.top/2018/04/11/Intel-RDT%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">Intel RDT特性详解</a>介绍了RDT的基本概念，以及通过PQOS工具使用RDT。本文主要是介绍如何通过内核来使用RDT。<br><a id="more"></a><br>我的内核版本为<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.14.32.tar.gz" target="_blank" rel="noopener">4.14.32</a>，内核对RDT的支持有版本要求，详情请参考<a href="https://github.com/intel/intel-cmt-cat/wiki" target="_blank" rel="noopener">OS interface feature support</a>。cpu型号为Intel Xeon E5 2650 v4，共两个cpu。</p><h2 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h2><p>RDT技术的选项位于“processor type and feature” -&gt; “Intel Resource Director Technology Allocation support”。</p><p><img src="/images/2018/4/9.png" alt=""></p><p><img src="/images/2018/4/10.png" alt=""></p><h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><p><code>mount -t resctrl resctrl /sys/fs/resctrl</code></p><h2 id="Resource-alloc-and-monitor-groups"><a href="#Resource-alloc-and-monitor-groups" class="headerlink" title="Resource alloc and monitor groups"></a>Resource alloc and monitor groups</h2><h3 id="Resource-groups"><a href="#Resource-groups" class="headerlink" title="Resource groups"></a>Resource groups</h3><ul><li>CTRL_MON groups</li></ul><p>Resource groups are represented as directories in the resctrl file system.  The default group is the root directory which, immediately after mounting, owns all the tasks and cpus in the system and can make full use of all resources.<br>On a system with RDT control features additional directories can be created in the root directory that specify different amounts of each resource. The root and these additional top level directories are referred to as “CTRL_MON” groups.</p><ul><li>MON groups</li></ul><p>On a system with RDT monitoring the root directory and other top level directories contain a directory named “mon_groups” in which additional directories can be created to monitor subsets of tasks in the CTRL_MON group that is their ancestor. These are called “MON” groups.</p><h3 id="All-groups-contain-the-following-files"><a href="#All-groups-contain-the-following-files" class="headerlink" title="All groups contain the following files"></a>All groups contain the following files</h3><ul><li>tasks<br>Reading this file shows the list of all tasks that belong to this group. Writing a task id to the file will add a task to the group.</li><li>cpus<br>是一个16进制整数，每一个bit代表一个CPU核心，比如我这里有10个“f”，意味着该机器有40个core。</li></ul><h4 id="When-control-is-enabled"><a href="#When-control-is-enabled" class="headerlink" title="When control is enabled"></a>When control is enabled</h4><p>When control is enabled all CTRL_MON groups will also contain:</p><ul><li>schemata<br>策略表，每个策略一行，格式为：<br>L3: cache_id0 = cbm; cache_id1 = cbm<br>这里的cache id可以理解为CPU id，而后面的cbm是分配给cpu的L3单元数量。我这块CPU每个socket会有11个L3 cache 单元也就是7ff。就是指在cpu cache的每个组内，group可以使用的cache line的数量。</li></ul><h4 id="When-monitoring-is-enabled"><a href="#When-monitoring-is-enabled" class="headerlink" title="When monitoring is enabled"></a>When monitoring is enabled</h4><p>When monitoring is enabled all MON groups will also contain:</p><ul><li>mon_data<br>This contains a set of files organized by L3 domain and by RDT event. E.g. on a system with two L3 domains there will be subdirectories “mon_L3_00” and “mon_L3_01”.    Each of these directories have one file per event (e.g. “llc_occupancy”, “mbm_total_bytes”, and “mbm_local_bytes”). In a MON group these files provide a read out of the current value of the event for all tasks in the group(在MON组中，这些文件为组中的所有任务提供读取当前事件的值).</li></ul><h2 id="Examples-for-RDT-allocation-usage"><a href="#Examples-for-RDT-allocation-usage" class="headerlink" title="Examples for RDT allocation usage"></a>Examples for RDT allocation usage</h2><p>具体例子请参考<a href="https://www.kernel.org/doc/Documentation/x86/intel_rdt_ui.txt" target="_blank" rel="noopener">intel_rdt_ui.txt</a></p><h2 id="Examples-for-RDT-Monitoring-along-with-allocation-usage"><a href="#Examples-for-RDT-Monitoring-along-with-allocation-usage" class="headerlink" title="Examples for RDT Monitoring along with allocation usage"></a>Examples for RDT Monitoring along with allocation usage</h2><p>具体例子请参考<a href="https://www.kernel.org/doc/Documentation/x86/intel_rdt_ui.txt" target="_blank" rel="noopener">intel_rdt_ui.txt</a></p><hr><p>参考资料：</p><ol><li><a href="https://www.kernel.org/doc/Documentation/x86/intel_rdt_ui.txt" target="_blank" rel="noopener">intel_rdt_ui.txt</a></li><li><a href="http://www.litrin.net/2017/02/21/linux-4-10%E4%B8%ADcat%E7%9A%84%E4%BD%BF%E7%94%A8/2/" target="_blank" rel="noopener">Linux 4.10中CAT的使用</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://liujunming.top/2018/04/11/Intel-RDT%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Intel RDT特性详解&lt;/a&gt;介绍了RDT的基本概念，以及通过PQOS工具使用RDT。本文主要是介绍如何通过内核来使用RDT。&lt;br&gt;
    
    </summary>
    
      <category term="计算机系统" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机系统" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统资料</title>
    <link href="http://liujunming.github.io/2018/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%96%99/"/>
    <id>http://liujunming.github.io/2018/04/17/分布式系统资料/</id>
    <published>2018-04-17T01:47:04.000Z</published>
    <updated>2018-11-06T08:22:40.505Z</updated>
    
    <content type="html"><![CDATA[<p>汇总分布式系统的资料。<br><a id="more"></a></p><ul><li><a href="https://www.cs.rutgers.edu/~pxk/417/notes/index.html" target="_blank" rel="noopener">rutgers Distributed Systems </a></li><li><a href="http://www.scs.stanford.edu/17au-cs244b/" target="_blank" rel="noopener">Stanford Distributed Systems</a></li><li><a href="http://nil.csail.mit.edu/6.824/2017/index.html" target="_blank" rel="noopener">Mit Distributed Systems</a></li><li><a href="https://github.com/feixiao/Distributed-Systems" target="_blank" rel="noopener">MIT课程《Distributed Systems 》学习和翻译</a></li><li><a href="https://github.com/zhenlohuang/awesome-distributed-systems" target="_blank" rel="noopener">awesome-distributed-systems</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汇总分布式系统的资料。&lt;br&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://liujunming.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://liujunming.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
