<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L</title>
  
  <subtitle>make it simple, make it happen.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujunming.github.io/"/>
  <updated>2021-06-02T13:03:16.216Z</updated>
  <id>http://liujunming.github.io/</id>
  
  <author>
    <name>liujunming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>QEMU x86架构的Machine:Q35 vs. I440FX</title>
    <link href="http://liujunming.github.io/2021/06/02/Qemu-X86%E6%9E%B6%E6%9E%84%E7%9A%84Machine-Type/"/>
    <id>http://liujunming.github.io/2021/06/02/Qemu-X86架构的Machine-Type/</id>
    <published>2021-06-02T03:23:06.000Z</published>
    <updated>2021-06-02T13:03:16.216Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容转载自:<a href="https://remimin.github.io/2019/07/09/qemu_machine_type/" target="_blank" rel="noopener">Qemu X86架构的Machine Type</a>。</p><p>QEMU支持的X86架构非常少，在Q35出现之前，就只有诞生于1996年的I440FX/PIIX一个架构。Intel不断推出新的芯片组， 加入了PCIe、AHCI等等。I440FX已经无法满足需求，为此，在 KVM Forum 2012 上，Jason Baron带来了 <a href="https://www.linux-kvm.org/images/0/06/2012-forum-Q35.pdf" target="_blank" rel="noopener">A New Chipset For Qemu - Intel’s Q35</a>。<a id="more"></a></p><h3 id="1-Q35-vs-I440FX"><a href="#1-Q35-vs-I440FX" class="headerlink" title="1. Q35 vs. I440FX"></a>1. Q35 vs. I440FX</h3><p>Q35是Intel在2007年9月推出的芯片组。</p><p>Topology of I440FX/PIIX4 Vs. Q35</p><ul><li>Q35 has IOMMU</li><li>Q35 has PCIe</li><li>Q35 has Super I/O chip with LPC interconnect</li><li>Q35 has 12 USB ports</li><li>Q35 SATA vs. PATA</li></ul><p>IRQ Routing I440FX/PIIX4 Vs. Q35</p><ul><li>Q35 PIRQ has 8 pins - PIRQ A-H</li><li>Q35 has two PIC modes – legacy PIC vs I/O APIC</li><li>Q35 runs in I/O APIC mode</li><li>Slots 0-24 are mapped to PIRQ E-H round robin</li><li>PCIe Bus to PIRQ mappings can be programmed<ul><li>Slots 25-31</li></ul></li><li>Q35 has 8 PCI IRQ vectors available, I440FX/PIIX4 only 2</li></ul><p>I440FX/PIIX4 vs. Q35 devices</p><ul><li>AHCI vs. Legacy IDE</li><li>PCI addresses</li><li>Populate slots using flags</li><li>Default slots</li></ul><h3 id="2-i440fx-PIIX架构"><a href="#2-i440fx-PIIX架构" class="headerlink" title="2. i440fx/PIIX架构"></a>2. i440fx/PIIX架构</h3><p>Intel 440FX是北桥芯片，用于连接主板上的高速设备。向上可以连接多个处理器；向下则主要提供了连接DRAM的接口和连接PCI总线的接口(通过PCI Host Bridge)， 通过该PCI root port扩展出整个PCI设备树，包括PIIX南桥芯片。</p><p>PIIX是南桥芯片，用于连接主板上的低速设备，主要包括IDE控制器、DMA控制器，USB控制器， SMBus总线控制器，X-Bus控制器，USB控制，PIT（Programmable Interval Timer）， RTC（Real Time Clock，实时时钟)， PIC（可编程中断控制器）等，并且提供ISA bridge连接ISA总线，用于连接更多的低速设备。</p><p><img src="/images/2021/06/2.PNG" alt></p><h3 id="3-Q35架构"><a href="#3-Q35架构" class="headerlink" title="3. Q35架构"></a>3. Q35架构</h3><p>北桥为GMCH(Graphics and Memory Controller Hub)，南桥为ICH9(I/O Controller Hub)。CPU 通过前端总线(FSB)连接到GMCH；GMCH连接内存，显卡，高速PCIe接口等；南桥芯片则为USB，低速PCI / SATA 等提供接入。</p><p><img src="/images/2021/06/3.PNG" alt></p><h3 id="4-list-QEMU-supported-machines"><a href="#4-list-QEMU-supported-machines" class="headerlink" title="4. list QEMU supported machines"></a>4. list QEMU supported machines</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">kvm@kvm:~$ qemu-system-x86_64 -machine help</span><br><span class="line">Supported machines are:</span><br><span class="line">pc                   Standard PC (i440FX + PIIX, 1996) (alias of pc-i440fx-4.0)</span><br><span class="line">pc-i440fx-4.0        Standard PC (i440FX + PIIX, 1996) (default)</span><br><span class="line">pc-i440fx-3.1        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-3.0        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-2.9        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-2.8        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-2.7        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-2.6        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-2.5        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-2.4        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-2.3        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-2.2        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-2.12       Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-2.11       Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-2.10       Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-2.1        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-2.0        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-1.7        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-1.6        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-1.5        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-i440fx-1.4        Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-1.3               Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-1.2               Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-1.1               Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-1.0               Standard PC (i440FX + PIIX, 1996)</span><br><span class="line">pc-0.15              Standard PC (i440FX + PIIX, 1996) (deprecated)</span><br><span class="line">pc-0.14              Standard PC (i440FX + PIIX, 1996) (deprecated)</span><br><span class="line">pc-0.13              Standard PC (i440FX + PIIX, 1996) (deprecated)</span><br><span class="line">pc-0.12              Standard PC (i440FX + PIIX, 1996) (deprecated)</span><br><span class="line">q35                  Standard PC (Q35 + ICH9, 2009) (alias of pc-q35-4.0.1)</span><br><span class="line">pc-q35-4.0.1         Standard PC (Q35 + ICH9, 2009)</span><br><span class="line">pc-q35-4.0           Standard PC (Q35 + ICH9, 2009)</span><br><span class="line">pc-q35-3.1           Standard PC (Q35 + ICH9, 2009)</span><br><span class="line">pc-q35-3.0           Standard PC (Q35 + ICH9, 2009)</span><br><span class="line">pc-q35-2.9           Standard PC (Q35 + ICH9, 2009)</span><br><span class="line">pc-q35-2.8           Standard PC (Q35 + ICH9, 2009)</span><br><span class="line">pc-q35-2.7           Standard PC (Q35 + ICH9, 2009)</span><br><span class="line">pc-q35-2.6           Standard PC (Q35 + ICH9, 2009)</span><br><span class="line">pc-q35-2.5           Standard PC (Q35 + ICH9, 2009)</span><br><span class="line">pc-q35-2.4           Standard PC (Q35 + ICH9, 2009)</span><br><span class="line">pc-q35-2.12          Standard PC (Q35 + ICH9, 2009)</span><br><span class="line">pc-q35-2.11          Standard PC (Q35 + ICH9, 2009)</span><br><span class="line">pc-q35-2.10          Standard PC (Q35 + ICH9, 2009)</span><br><span class="line">isapc                ISA-only PC</span><br><span class="line">none                 empty machine</span><br></pre></td></tr></table></figure><hr><p>参考资料:</p><ol><li><a href="https://www.linux-kvm.org/images/0/06/2012-forum-Q35.pdf" target="_blank" rel="noopener">A New Chipset For Qemu - Intel’s Q35</a></li><li><a href="https://www.binss.me/blog/qemu-note-of-Q35-machine/" target="_blank" rel="noopener">QEMU学习笔记——Q35</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容转载自:&lt;a href=&quot;https://remimin.github.io/2019/07/09/qemu_machine_type/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Qemu X86架构的Machine Type&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;QEMU支持的X86架构非常少，在Q35出现之前，就只有诞生于1996年的I440FX/PIIX一个架构。Intel不断推出新的芯片组， 加入了PCIe、AHCI等等。I440FX已经无法满足需求，为此，在 KVM Forum 2012 上，Jason Baron带来了 &lt;a href=&quot;https://www.linux-kvm.org/images/0/06/2012-forum-Q35.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A New Chipset For Qemu - Intel’s Q35&lt;/a&gt;。
    
    </summary>
    
      <category term="QEMU" scheme="http://liujunming.github.io/categories/QEMU/"/>
    
    
      <category term="虚拟化" scheme="http://liujunming.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="QEMU" scheme="http://liujunming.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to netplan</title>
    <link href="http://liujunming.github.io/2021/06/01/Introduction-to-netplan/"/>
    <id>http://liujunming.github.io/2021/06/01/Introduction-to-netplan/</id>
    <published>2021-05-31T22:37:56.000Z</published>
    <updated>2021-06-02T13:03:16.215Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容源于<a href="https://netplan.io/" target="_blank" rel="noopener">netplan</a>，并展示一个作者用到的配置。<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>Netplan is a utility for easily configuring networking on a linux system. You simply create a YAML description of the required network interfaces and what each should be configured to do. From this description Netplan will generate all the necessary configuration for your chosen renderer tool.</p><h3 id="2-How-does-it-work"><a href="#2-How-does-it-work" class="headerlink" title="2. How does it work?"></a>2. How does it work?</h3><p><img src="/images/2021/06/1.PNG" alt></p><p>Netplan reads network configuration from <code>/etc/netplan/*.yaml</code> which are written by administrators, installers, cloud image instantiations, or other OS deployments. During early boot, Netplan generates backend specific configuration files in <code>/run</code> to hand off control of devices to a particular networking daemon.</p><p>Netplan currently works with these supported renderers</p><ul><li><a href="https://help.ubuntu.com/community/NetworkManager" target="_blank" rel="noopener">NetworkManager</a></li><li><a href="http://manpages.ubuntu.com/manpages/bionic/man5/systemd.network.5.html" target="_blank" rel="noopener">Systemd-networkd</a></li></ul><h3 id="3-How-do-I-use-it"><a href="#3-How-do-I-use-it" class="headerlink" title="3. How do I use it?"></a>3. How do I use it?</h3><h4 id="3-1-Configuration"><a href="#3-1-Configuration" class="headerlink" title="3.1 Configuration"></a>3.1 Configuration</h4><p>Obviously, without configuration, netplan will not do anything. The most useful configuration snippet (to bring up things via dhcp) is as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br></pre></td></tr></table></figure><p>This will make NetworkManager manage all devices (and by default, any ethernet device will come up with DHCP once carrier is detected).</p><p>Using networkd as a renderer does not let devices automatically come up using DHCP; each interface needs to be specified in a file in <code>/etc/netplan</code> for its configuration to be written and for it to be used in networkd.</p><h5 id="3-1-1-One-example"><a href="#3-1-1-One-example" class="headerlink" title="3.1.1 One example"></a>3.1.1 One example</h5><p>个人使用的一个配置: <strong>Configuring network bridges</strong><br><a href="https://github.com/liujunming/qemu_usage/tree/master/0002-set-net-on-kvm" target="_blank" rel="noopener">https://github.com/liujunming/qemu_usage/tree/master/0002-set-net-on-kvm</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">   version: 2</span><br><span class="line">   renderer: networkd</span><br><span class="line">   ethernets:</span><br><span class="line">       eno1:</span><br><span class="line">           dhcp4: no</span><br><span class="line">   bridges:</span><br><span class="line">       br0:</span><br><span class="line">           dhcp4: yes</span><br><span class="line">           interfaces: [eno1]</span><br></pre></td></tr></table></figure><p><strong>eno1</strong> should be you network interface name</p><p><a href="https://netplan.io/reference/" target="_blank" rel="noopener">netplan reference</a></p><p>如果想了解更多的配置，请参考<a href="https://netplan.io/examples/" target="_blank" rel="noopener">https://netplan.io/examples/</a> 。</p><h4 id="3-2-Commands"><a href="#3-2-Commands" class="headerlink" title="3.2 Commands"></a>3.2 Commands</h4><p>Netplan uses a set of subcommands to drive its behavior:</p><ul><li><strong>netplan generate</strong>: Use <code>/etc/netplan</code> to generate the required configuration for the renderers.</li><li><strong>netplan apply</strong>: Apply all configuration for the renderers, restarting them as necessary.</li><li><strong>netplan try</strong>: Apply configuration and wait for user confirmation; will roll back if network is broken or no confirmation is given.</li></ul><hr><p>参考资料:</p><ol><li><a href="https://netplan.io/" target="_blank" rel="noopener">https://netplan.io/</a></li><li><a href="https://netplan.io/examples/" target="_blank" rel="noopener">https://netplan.io/examples/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容源于&lt;a href=&quot;https://netplan.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;netplan&lt;/a&gt;，并展示一个作者用到的配置。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>lspci usage</title>
    <link href="http://liujunming.github.io/2021/05/31/lspci-usage/"/>
    <id>http://liujunming.github.io/2021/05/31/lspci-usage/</id>
    <published>2021-05-31T12:29:50.000Z</published>
    <updated>2021-06-01T14:12:08.829Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简单介绍下PCI ID database和Class Codes相关知识，然后分享<code>lspci</code>的常用操作。<a id="more"></a></p><h3 id="PCI-ID-database"><a href="#PCI-ID-database" class="headerlink" title="PCI ID database"></a>PCI ID database</h3><p><a href="https://pci-ids.ucw.cz/" target="_blank" rel="noopener">https://pci-ids.ucw.cz/</a></p><p>tools: <a href="https://www.pcilookup.com/" target="_blank" rel="noopener">PCI Lookup</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lspci -n -s 00:02.0</span><br><span class="line">00:02.0 0300: 8086:5a85 (rev 0b)</span><br></pre></td></tr></table></figure><p>查询结果<a href="https://www.pcilookup.com/?ven=8086&amp;dev=5a85&amp;action=submit" target="_blank" rel="noopener">HD Graphics 500</a>.</p><h3 id="Class-Codes"><a href="#Class-Codes" class="headerlink" title="Class Codes"></a>Class Codes</h3><p><a href="https://blog.ladsai.com/pci-configuration-space-class-code.html" target="_blank" rel="noopener">https://blog.ladsai.com/pci-configuration-space-class-code.html</a><br>The Class Code, Subclass, and Prog IF registers are used to identify the device’s type, the device’s function, and the device’s register-level programming interface, respectively. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lspci -n -s 00:02.0</span><br><span class="line">00:02.0 0300: 8086:5a85 (rev 0b)</span><br></pre></td></tr></table></figure><p>0300: VGA-Compatible Controller</p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lspci -n</span><br><span class="line"></span><br><span class="line">lspci -t</span><br><span class="line"></span><br><span class="line">lspci -v</span><br><span class="line"></span><br><span class="line">lspci -s 03:00.0</span><br><span class="line"></span><br><span class="line">lspci -k</span><br><span class="line"></span><br><span class="line">lspci -vxxx -s 0:02.0</span><br><span class="line"></span><br><span class="line">lspci -nxxx -s 0:02.0</span><br><span class="line"></span><br><span class="line">lspci -vmm</span><br><span class="line"></span><br><span class="line">lspci -D</span><br></pre></td></tr></table></figure><p>Each device is given a bus number, a device number and a function number. On Linux, PCI devices are also given domain numbers, but they are usually omitted by lspci since very often all devices have the same domain number (usually zero).</p><p>For more detailed guideline, please type <code>man lspci</code> or <code>info lspci</code>.同时可以参考<a href="https://diego.assencio.com/?index=649b7a71b35fc7ad41e03b6d0e825f07" target="_blank" rel="noopener">Interpreting the output of lspci</a>.</p><hr><p>参考资料:</p><ol><li><a href="https://wiki.osdev.org/PCI" target="_blank" rel="noopener">osdev PCI</a></li><li><a href="https://www.thegeekstuff.com/2014/04/lspci-examples/" target="_blank" rel="noopener">7 Linux lspci Command Examples to Get PCI Bus Hardware Device Info</a></li><li><a href="https://diego.assencio.com/?index=649b7a71b35fc7ad41e03b6d0e825f07" target="_blank" rel="noopener">Interpreting the output of lspci</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简单介绍下PCI ID database和Class Codes相关知识，然后分享&lt;code&gt;lspci&lt;/code&gt;的常用操作。
    
    </summary>
    
      <category term="PCI&amp;PCIe" scheme="http://liujunming.github.io/categories/PCI-PCIe/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Notes about Kernel parameters</title>
    <link href="http://liujunming.github.io/2021/05/29/Notes-about-Kernel-parameters/"/>
    <id>http://liujunming.github.io/2021/05/29/Notes-about-Kernel-parameters/</id>
    <published>2021-05-28T16:06:13.000Z</published>
    <updated>2021-05-28T17:29:29.035Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录内核参数相关笔记。</p><a id="more"></a><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>There are three ways to pass options to the kernel and thus control its behavior:</p><ol><li>When building the kernel—in the kernel’s <code>config</code> file. </li><li>When starting the kernel—using command line parameters (usually through a boot loader).</li><li>At runtime—through the files in <code>/proc/sys/</code> and <code>/sys/</code>.</li></ol><p> This page only explains the second method (kernel command line parameters).</p><h3 id="2-Set-kernel-command-line-parameters-in-GRUB"><a href="#2-Set-kernel-command-line-parameters-in-GRUB" class="headerlink" title="2. Set kernel command line parameters in GRUB"></a>2. Set kernel command line parameters in GRUB</h3><p>Kernel parameters can be set either temporarily by editing the boot entry in the boot loader’s boot selection menu, or permanently by modifying the boot loader’s configuration file.</p><p>The following examples add the <code>quiet</code> and <code>splash</code> parameters to GRUB.</p><ul><li><p>Press <code>e</code> when the menu shows up and add them on the <code>linux</code> line:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux /boot/vmlinuz-linux root=UUID=0a3407de-014b-458b-b5c1-848e92a327a3 rw quiet splash</span><br></pre></td></tr></table></figure><p>Press <code>Ctrl+x</code> to boot with these parameters.</p></li><li><p>To make the change persistent after reboot, the best practice is to:</p><p>Edit <code>/etc/default/grub</code> and append your kernel options between the quotes in the <code>GRUB_CMDLINE_LINUX_DEFAULT</code> line:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;</span><br></pre></td></tr></table></figure><p>And then automatically re-generate the <code>grub.cfg</code> file with <code>update-grub</code>.</p></li></ul><h3 id="3-Verification"><a href="#3-Verification" class="headerlink" title="3. Verification"></a>3. Verification</h3><p>You can check the parameters your system was booted up with by running <code>cat /proc/cmdline</code> and see if it includes your changes.</p><h3 id="4-Parameter-list"><a href="#4-Parameter-list" class="headerlink" title="4. Parameter list"></a>4. Parameter list</h3><p><a href="https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html" target="_blank" rel="noopener">“The kernel’s command-line parameters” documentation</a></p><p><a href="http://files.kroah.com/lkn/lkn_pdf/ch09.pdf" target="_blank" rel="noopener">List of kernel parameters with further explanation and grouped by similar options</a></p><hr><p>参考资料:</p><ol><li><a href="https://wiki.archlinux.org/title/Kernel_parameters" target="_blank" rel="noopener">Kernel parameters</a></li><li><a href="https://askubuntu.com/questions/716957/what-do-the-nomodeset-quiet-and-splash-kernel-parameters-mean" target="_blank" rel="noopener">What do the nomodeset, quiet and splash kernel parameters mean?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录内核参数相关笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Kernel" scheme="http://liujunming.github.io/categories/Kernel/"/>
    
    
      <category term="Kernel" scheme="http://liujunming.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Have fun with Unix</title>
    <link href="http://liujunming.github.io/2021/05/23/Have-fun-with-Unix/"/>
    <id>http://liujunming.github.io/2021/05/23/Have-fun-with-Unix/</id>
    <published>2021-05-23T12:29:28.000Z</published>
    <updated>2021-05-23T13:21:40.099Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自:<a href="https://blog.csdn.net/ce123_zhouwei/article/details/9073869" target="_blank" rel="noopener">国际C语言混乱代码大赛代码赏析(一)</a>。</p><p>近段时间在看《C专家编程》，里面提到国际C语言混乱代码大赛（The International Obfuscated C Code Contest IOCCC）。IOCCC有许多令人捧腹之处，不管你是自己编写还是时候分析获胜者的代码，都能够以令人惊讶的方式扩展你的知识。通常有10种类型的获胜者：“对规则的最奇怪的滥用”，“最具创意的源代码布局”，“最简单的单行代码”等。综合性的“最佳上镜”奖授予最难阅读、行为最为古怪（但能够运行）的C程序的作者。下面我们来欣赏并分析1987年，贝尔实验室的David Korn提交的获奖代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;<span class="built_in">printf</span>(&amp;unix[<span class="string">"\021%six\012\0"</span>], (unix)[<span class="string">"have"</span>] + <span class="string">"fun"</span> - <span class="number">0x60</span>);&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>这段代码打印出什么东西？（提示：和“have fun无关”）。<br><br> 首先看一段代码:<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="number">3</span>[a]); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在C语言中，其实数组的引用可以3[a]这样的形式的，等价于a[3]。 再看下面一段代码: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,i=<span class="number">4</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="number">3</span>[a]); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i[a]); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这样的表示也是可以的。i[a]实际上相当于a[4]了。 再看下面一段代码: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,unix); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 为什么我没有定义unix也能打印出来呢？ 原因是unix被编译器定义为一个宏。 相当于#define unix 1 ,这样打印出来1。 下面来解释一下这个问题. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>,(unix)[<span class="string">"have"</span>]); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的unix相当于1 ，那么unix[“have”]相当于 “have”[1] 我们都知道”have”是个字符数组。那么 “have”[1]就相当于引用这个”have”数组下标为1的字符了，实际上就是a;：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%x"</span>,<span class="string">'a'</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  a的ascii码的16进制表示为0x61。(unix)[“have”]+”fun”-0x60就相当于0x61-0x60+”fun”相当于 0x01+”fun” ，相当于字符指针后移并指向”un”了 。这样后面的部分解释完了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">printf</span>(&amp;unix[<span class="string">"\021ix\012\0"</span>]); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们首先把%s去掉。%s实际上是刚刚讲过的”un”的格式。 我们知道unix宏的值 是1，那么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(&amp;unix[<span class="string">"\021ix\012\0"</span>]);</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(&amp;<span class="number">1</span>[<span class="string">"\021ix\012\0"</span>]);</span><br></pre></td></tr></table></figure><p>  根据上面我说的 1[“have”]这个形式，同理能得到：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(&amp;<span class="string">"\021ix\012\0"</span>[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p><p> 这个形式了。 这个引用和上面的有所区别，区别在于&amp;。那么一个字符数组从它的下标为1 的元素取地址就可以得到一个字符串指针。 还原回去 相当于<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(&amp;<span class="string">"\021%six\012\0"</span>[<span class="number">1</span>],<span class="string">"un"</span>);</span><br></pre></td></tr></table></figure></p><p>  也就是说把第一个元素跳过去了即把\021跳了过去。相当于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%six\012\0"</span>,<span class="string">"un"</span>)</span><br></pre></td></tr></table></figure></p><p> \012 是ascii码里的回车。这个相当于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%six\n\0"</span>,<span class="string">"un"</span>);</span><br></pre></td></tr></table></figure></p><p>至此 这个问题解决了…</p><p><strong>Notes:</strong></p><ol><li><p>An octal escape sequence consists of <code>\</code> followed by one, two, or three octal digits. The octal escape sequence ends when it either contains three octal digits already, or the next character is not an octal digit.</p></li><li><p>“a[i] = i[a]= *(a+i)“ 即下标运算符的可交换性。</p></li><li><p><code>unix</code>这个宏是属于gcc提供的 System-specific Predefined Macros，值为1。</p></li><li><p><a href="https://www.geeksforgeeks.org/whats-difference-between-char-s-and-char-s-in-c/" target="_blank" rel="noopener">What’s difference between char s[] and char *s in C?</a></p></li></ol><hr><p>参考资料:</p><ol><li><a href="https://stackoverflow.com/questions/29819239/understanding-output-of-printf-containing-backslash-012" target="_blank" rel="noopener">Understanding output of printf containing backslash (\012)</a></li><li><a href="https://www.geeksforgeeks.org/whats-difference-between-char-s-and-char-s-in-c/" target="_blank" rel="noopener">What’s difference between char s[] and char *s in C?</a></li><li><a href="https://zhuanlan.zhihu.com/p/147528327" target="_blank" rel="noopener">C语言混乱大赛1987年获奖作品</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自:&lt;a href=&quot;https://blog.csdn.net/ce123_zhouwei/article/details/9073869&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国际C语言混乱代码大赛代码赏析(一)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;近段时间在看《C专家编程》，里面提到国际C语言混乱代码大赛（The International Obfuscated C Code Contest IOCCC）。IOCCC有许多令人捧腹之处，不管你是自己编写还是时候分析获胜者的代码，都能够以令人惊讶的方式扩展你的知识。通常有10种类型的获胜者：“对规则的最奇怪的滥用”，“最具创意的源代码布局”，“最简单的单行代码”等。综合性的“最佳上镜”奖授予最难阅读、行为最为古怪（但能够运行）的C程序的作者。下面我们来欣赏并分析1987年，贝尔实验室的David Korn提交的获奖代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;main() &amp;#123;&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&amp;amp;unix[&lt;span class=&quot;string&quot;&gt;&quot;\021%six\012\0&quot;&lt;/span&gt;], (unix)[&lt;span class=&quot;string&quot;&gt;&quot;have&quot;&lt;/span&gt;] + &lt;span class=&quot;string&quot;&gt;&quot;fun&quot;&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;0x60&lt;/span&gt;);&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://liujunming.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://liujunming.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>grub初级用法</title>
    <link href="http://liujunming.github.io/2021/05/22/grub%E5%88%9D%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>http://liujunming.github.io/2021/05/22/grub初级用法/</id>
    <published>2021-05-22T00:41:51.000Z</published>
    <updated>2021-05-23T04:30:17.403Z</updated>
    
    <content type="html"><![CDATA[<p>本文将分享grub初级用法的一些经验与心得。<a id="more"></a></p><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>强烈建议阅读<a href="https://opensource.com/article/17/3/introduction-grub2-configuration-linux" target="_blank" rel="noopener">An introduction to GRUB2 configuration for your Linux machine</a>。</p><p>个人notes:</p><ul><li>The <strong>grub.cfg</strong> file is the GRUB configuration file. Try <code>vim /boot/grub/grub.cfg</code> to see your own <strong>grub.cfg</strong>.</li><li>The <strong>grub.cfg</strong> file is generated by the <code>grub-mkconfig</code> program using a set of primary configuration files and the grub default file as a source for user configuration specifications.<ul><li>grub configuration files: the main set of configuration files for <strong>grub.cfg</strong> is located in the <strong>/etc/grub.d</strong> directory.</li><li>grub default file: the <strong>/etc/default/grub</strong></li></ul></li></ul><h3 id="GRUB-configuration-files"><a href="#GRUB-configuration-files" class="headerlink" title="GRUB configuration files"></a>GRUB configuration files</h3><p>The main set of configuration files for <strong>grub.cfg</strong> is located in the <strong>/etc/grub.d</strong> directory. Each of the files in that directory contains GRUB code that is collected into the final grub.cfg file. The numbering scheme used in the names of these configuration files is designed to provide ordering so that the final <strong>grub.cfg</strong> file is assembled into the correct sequence. Each of these files has a comment to denote the beginning and end of the section, and those comments are also part of the final grub.cfg file so that it is possible to see from which file each section is generated. The delimiting comments look like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### BEGIN /etc/grub.d/10_linux ###</span><br><span class="line"></span><br><span class="line">### END /etc/grub.d/10_linux ###</span><br></pre></td></tr></table></figure><p>These files should not be modified unless you are a GRUB expert and understand what the changes will do. Even then you should always keep a backup copy of the original, working <strong>grub.cfg</strong> file. The specific files, <strong>40_custom</strong> and <strong>41_custom</strong> are intended to be used to generate user modifications to the GRUB configuration. You should still be aware of the consequences of any changes you make to these files and maintain a backup of the original <strong>grub.cfg</strong> file.</p><h3 id="GRUB-defaults-file"><a href="#GRUB-defaults-file" class="headerlink" title="GRUB defaults file"></a>GRUB defaults file</h3><p>The <strong>/etc/default/grub</strong> file is very simple. The grub defaults file has a number of valid key/value pairs listed already. You can simply change the values of existing keys or add other keys that are not already in the file.</p><p> spec:<a href="https://www.gnu.org/software/grub/manual/grub/grub.html#Simple-configuration" target="_blank" rel="noopener">Simple configuration handling</a></p><h3 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h3><ul><li><p>make the Grub menu visible when booting:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#GRUB_TIMEOUT_STYLE=hidden</span><br><span class="line">GRUB_TIMEOUT=5</span><br></pre></td></tr></table></figure></li><li><p>set the default menu entry: <code>GRUB_DEFAULT</code></p></li><li><p><code>update-grub</code>:update-grub is a stub for running <code>grub-mkconfig -o /boot/grub/grub.cfg</code> to generate <strong>grub.cfg</strong> file.</p></li><li><p>spec:<a href="https://www.gnu.org/software/grub/manual/grub/grub.html" target="_blank" rel="noopener">GNU GRUB Manual 2.04</a></p></li><li><p>阅读<a href="https://projectacrn.github.io/2.4/getting-started/rt_industry_ubuntu.html" target="_blank" rel="noopener">Getting Started Guide for ACRN Industry Scenario With Ubuntu Service VM</a>，看看实例是如何配置grub的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将分享grub初级用法的一些经验与心得。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>如何将grub输出到串口</title>
    <link href="http://liujunming.github.io/2021/05/21/%E5%A6%82%E4%BD%95%E5%B0%86grub%E8%BE%93%E5%87%BA%E5%88%B0%E4%B8%B2%E5%8F%A3/"/>
    <id>http://liujunming.github.io/2021/05/21/如何将grub输出到串口/</id>
    <published>2021-05-21T09:55:56.000Z</published>
    <updated>2021-05-21T15:49:21.429Z</updated>
    
    <content type="html"><![CDATA[<p>edit <code>/etc/default/grub</code> and enable serial input and output support:<a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GRUB_TERMINAL_INPUT=&quot;console serial&quot;</span><br><span class="line">...</span><br><span class="line">GRUB_TERMINAL_OUTPUT=&quot;gfxterm serial&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Next add the <code>GRUB_SERIAL_COMMAND</code> variable and set the options for the serial connection. For COM1 (<code>/dev/ttyS0</code>) with baud rate of 115200 bit/s:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GRUB_SERIAL_COMMAND=&quot;serial --unit=0 --speed=115200&quot;</span><br></pre></td></tr></table></figure><p>Then <code>update-grub</code> </p><hr><p>参考资料:</p><ol><li><a href="https://wiki.archlinux.org/title/Working_with_the_serial_console" target="_blank" rel="noopener">Working with the serial console</a></li><li><a href="http://emmoblin.github.io/blog/2013/03/02/grub-output-to-serial/" target="_blank" rel="noopener">Grub重定向到串口</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;edit &lt;code&gt;/etc/default/grub&lt;/code&gt; and enable serial input and output support:
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>How to dump OpRegion and analyze its content</title>
    <link href="http://liujunming.github.io/2021/05/20/How-to-dump-OpRegion-and-analyze-its-content/"/>
    <id>http://liujunming.github.io/2021/05/20/How-to-dump-OpRegion-and-analyze-its-content/</id>
    <published>2021-05-20T13:51:18.000Z</published>
    <updated>2021-05-21T15:49:21.428Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍dump OpRegion的方法以及OpRegion内容的含义。<a id="more"></a></p><h3 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h3><p><a href="/2019/11/23/gpu-display-in-uefi-phase/">gpu display in uefi bios phase</a></p><h3 id="2-How-to-dump-OpRegion"><a href="#2-How-to-dump-OpRegion" class="headerlink" title="2. How to dump OpRegion"></a>2. How to dump OpRegion</h3><p>在i915 driver的debugfs中，<code>hexdump</code>出OpRegion的具体内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@junming:/sys/kernel/debug/dri/0# pwd</span><br><span class="line">/sys/kernel/debug/dri/0</span><br><span class="line">root@junming:/sys/kernel/debug/dri/0# hexdump -C i915_opregion</span><br><span class="line">00000000  49 6e 74 65 6c 47 72 61  70 68 69 63 73 4d 65 6d  |IntelGraphicsMem|</span><br><span class="line">00000010  08 00 00 00 00 00 00 02  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>i915 driver中的源码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i915_opregion</span><span class="params">(struct seq_file *m, <span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intel_opregion</span> *<span class="title">opregion</span> = &amp;<span class="title">node_to_i915</span>(<span class="title">m</span>-&gt;<span class="title">private</span>)-&gt;<span class="title">opregion</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (opregion-&gt;header)</span><br><span class="line">seq_write(m, opregion-&gt;header, OPREGION_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-How-to-analyze-OpRegion-content"><a href="#3-How-to-analyze-OpRegion-content" class="headerlink" title="3. How to analyze OpRegion content"></a>3. How to analyze OpRegion content</h3><p>spec: <a href="https://01.org/sites/default/files/documentation/skl_opregion_rev0p5.pdf" target="_blank" rel="noopener">IGD OpRegion/Software SCI/_DSM for Skylake Processors</a></p><p><img src="/images/2021/05/16.PNG" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000  49 6e 74 65 6c 47 72 61  70 68 69 63 73 4d 65 6d  |IntelGraphicsMem|</span><br></pre></td></tr></table></figure><p>由此可见，解析出来的内容与spec一致。</p><p><img src="/images/2021/05/17.PNG" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000010  08 00 00 00 00 00 00 02  00 00 00 00 00 00 00 00  |................|</span><br></pre></td></tr></table></figure><p>根据spec，从<code>00 00 00 02</code>可知，OpRegion的version是2.0。</p><p>人肉解析OpRegion的内容，OpRegion一般也就看关键几个位置，不用全部解析。</p><hr><p>参考资料：</p><ol><li><a href="https://lists.freedesktop.org/archives/intel-gfx/2015-December/082667.html" target="_blank" rel="noopener">how to use i915 debugfs interface</a></li><li><a href="https://01.org/sites/default/files/documentation/skl_opregion_rev0p5.pdf" target="_blank" rel="noopener">IGD OpRegion/Software SCI/_DSM for Skylake Processors</a></li><li><a href="https://elixir.bootlin.com/linux/v5.12.4/source/drivers/gpu/drm/i915/display" target="_blank" rel="noopener">Linux kernel i915 driver</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍dump OpRegion的方法以及OpRegion内容的含义。
    
    </summary>
    
      <category term="GPU" scheme="http://liujunming.github.io/categories/GPU/"/>
    
    
      <category term="GPU" scheme="http://liujunming.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to minicom</title>
    <link href="http://liujunming.github.io/2021/05/17/Introduction-to-minicom/"/>
    <id>http://liujunming.github.io/2021/05/17/Introduction-to-minicom/</id>
    <published>2021-05-17T12:42:54.000Z</published>
    <updated>2021-05-18T14:20:07.370Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍minicom相关知识。<a id="more"></a></p><h3 id="1-What"><a href="#1-What" class="headerlink" title="1. What"></a>1. What</h3><p>Minicom is a text-based modem control and terminal emulator program for Unix-like operating systems.</p><p>Linux下的Minicom可以通过串口控制外部的硬件设备。适于在Linux通过超级终端对嵌入式设备行管理。</p><p>在ACRN hypervisor开发过程中，可以将KBL NUC通过串口连接到ubuntu主机，然后在ubuntu中打开minicom，从而进入到acrn shell中。在acrn shell中，研发人员可以（1）查看hypervisor的log信息；（2）执行<a href="https://projectacrn.github.io/latest/user-guides/acrn-shell.html" target="_blank" rel="noopener">ACRN Shell Commands</a>。</p><h3 id="2-How"><a href="#2-How" class="headerlink" title="2. How"></a>2. How</h3><p>type <code>man minicom</code> for more detailed steps.</p><p><strong>case1:</strong></p><p><code>sudo minicom -D /dev/ttyUSB0</code></p><p><strong>case2:</strong></p><p><code>minicom -s</code>出现配置菜单 -&gt; 选serial port setup，进入串口配置</p><ul><li>输入A配置串口驱动为/dev/ttyUSB0</li><li><p>输入F将 Hardware Flow Control 设 为 NO</p></li><li><p>在配置菜单 选Save setup as dfl保存（一定要记得这一步）</p></li><li><p>选Exit退出</p></li></ul><p><strong>case3:</strong></p><p><code>Ctrl-a</code> + “x”: 退出minicom</p><p><code>Ctrl-a</code> + “z”: 弹出help屏幕</p><p><strong>issue1</strong></p><p>非正常关闭minicom，会在/var/lock下创建几个文件LCK*，这几个文件阻止了minicom的运行，将它们删除后即可恢复。</p><p><strong>issue2</strong></p><p>minicom输入无反应，可以尝试设置hardware flow: <code>minicom -s F hardware no</code></p><h3 id="3-MISC"><a href="#3-MISC" class="headerlink" title="3. MISC"></a>3. MISC</h3><p>在ACRN开发过程中，如果发现ubuntu中的minicom无法进入acrn shell，不妨查看KBL NUC BIOS中是否开启了串口。</p><hr><p>参考资料：</p><ol><li><a href="https://blog.csdn.net/bird67/article/details/2127235" target="_blank" rel="noopener">linux超级终端minicom的使用方法</a></li><li><a href="https://en.wikipedia.org/wiki/Minicom" target="_blank" rel="noopener">wikipedia Minicom</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍minicom相关知识。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to upx</title>
    <link href="http://liujunming.github.io/2021/05/16/Introduction-to-upx/"/>
    <id>http://liujunming.github.io/2021/05/16/Introduction-to-upx/</id>
    <published>2021-05-16T12:54:02.000Z</published>
    <updated>2021-05-16T14:32:19.749Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍upx相关知识。<a id="more"></a></p><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>upx(The Ultimate Packer for eXecutables)的基本原理:</p><ol><li>将可执行文件压缩</li><li>将压缩完的程序作为新程序的一部分</li><li>在新程序的开头加上解压和执行代码</li></ol><p>压缩完的新程序是可执行的。</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>对于可执行程序，upx是用时间换空间的做法。</p><p>需要注意的是，实际使用中，需要保证压缩率产生的收益比加上额外的解压代码要高，否则就没意义。</p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">junmingl@junming:~/test$ cp /bin/ls ls_upx</span><br><span class="line">junmingl@junming:~/test$ ./ls_upx -ls</span><br><span class="line">total 132</span><br><span class="line">132 -rwxr-xr-x 1 junmingl junmingl 133792 5月  17 05:09 ls_upx</span><br><span class="line">junmingl@junming:~/test$ upx ls_upx</span><br><span class="line">                       Ultimate Packer for eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2017</span><br><span class="line">UPX 3.94        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   May 12th 2017</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">    133792 -&gt;     61332   45.84%   linux/amd64   ls_upx</span><br><span class="line"></span><br><span class="line">Packed 1 file.</span><br><span class="line">junmingl@junming:~/test$ ./ls_upx -ls</span><br><span class="line">total 60</span><br><span class="line">60 -rwxr-xr-x 1 junmingl junmingl 61332 5月  17 05:09 ls_upx</span><br></pre></td></tr></table></figure><p>压缩了有超过 50%。UPX 的压缩成绩是 50~70%，关键是，可执行程序压缩完还是可以执行的。</p><hr><p>参考资料：</p><ol><li><a href="http://tinylab.org/program-size-opt-with-upx/" target="_blank" rel="noopener">单个程序 Size 优化之压缩后自解压执行</a></li><li><a href="https://linux.die.net/man/1/upx" target="_blank" rel="noopener">upx(1) - Linux man page</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍upx相关知识。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第23期</title>
    <link href="http://liujunming.github.io/2021/05/16/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC23%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/05/16/每周分享第23期/</id>
    <published>2021-05-16T04:14:22.000Z</published>
    <updated>2021-05-16T14:32:19.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Quick-Assist"><a href="#Quick-Assist" class="headerlink" title="Quick Assist"></a>Quick Assist</h3><p><a href="https://support.microsoft.com/en-us/windows/solve-pc-problems-over-a-remote-connection-b077e31a-16f4-2529-1a47-21f6a9040bf3" target="_blank" rel="noopener">Solve PC problems over a remote connection</a><a id="more"></a></p><h3 id="科学思想的核心"><a href="#科学思想的核心" class="headerlink" title="科学思想的核心"></a>科学思想的核心</h3><p>先于验证就能理解某种事物的能力，是科学思想的核心。</p><h3 id="stanford-cs-101"><a href="#stanford-cs-101" class="headerlink" title="stanford cs 101"></a>stanford cs 101</h3><p><a href="https://web.stanford.edu/class/cs101/" target="_blank" rel="noopener">https://web.stanford.edu/class/cs101/</a></p><h3 id="codesys"><a href="#codesys" class="headerlink" title="codesys"></a>codesys</h3><p>CODESYS is the leading manufacturer-independent IEC 61131-3 automation software for engineering control systems.</p><h3 id="VNC-还是-RDP-云上的远程桌面究竟该如何选"><a href="#VNC-还是-RDP-云上的远程桌面究竟该如何选" class="headerlink" title="VNC 还是 RDP? 云上的远程桌面究竟该如何选"></a>VNC 还是 RDP? 云上的远程桌面究竟该如何选</h3><p><a href="https://aws.amazon.com/cn/blogs/china/vnc-or-rdp-how-to-choose-a-remote-desktop-on-the-cloud/" target="_blank" rel="noopener">https://aws.amazon.com/cn/blogs/china/vnc-or-rdp-how-to-choose-a-remote-desktop-on-the-cloud/</a></p><h3 id="一名系统研究者的攀登之路"><a href="#一名系统研究者的攀登之路" class="headerlink" title="一名系统研究者的攀登之路"></a>一名系统研究者的攀登之路</h3><p><a href="http://prof.ict.ac.cn/lugang/readings/%E4%B8%80%E5%90%8D%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6%E8%80%85%E7%9A%84%E6%94%80%E7%99%BB%E4%B9%8B%E8%B7%AF.pdf" target="_blank" rel="noopener">http://prof.ict.ac.cn/lugang/readings/%E4%B8%80%E5%90%8D%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6%E8%80%85%E7%9A%84%E6%94%80%E7%99%BB%E4%B9%8B%E8%B7%AF.pdf</a></p><h3 id="what-is-the-reason-for-explicitly-declaring-L-or-UL-for-long-values"><a href="#what-is-the-reason-for-explicitly-declaring-L-or-UL-for-long-values" class="headerlink" title="what is the reason for explicitly declaring L or UL for long values"></a>what is the reason for explicitly declaring L or UL for long values</h3><p><a href="https://stackoverflow.com/questions/13134956/what-is-the-reason-for-explicitly-declaring-l-or-ul-for-long-values" target="_blank" rel="noopener">https://stackoverflow.com/questions/13134956/what-is-the-reason-for-explicitly-declaring-l-or-ul-for-long-values</a></p><h3 id="Why-can’t-I-write-to-the-file-mmaped"><a href="#Why-can’t-I-write-to-the-file-mmaped" class="headerlink" title="Why can’t I write to the file mmaped"></a>Why can’t I write to the file mmaped</h3><p><a href="https://stackoverflow.com/questions/27645215/why-cant-i-write-to-the-file-mmaped" target="_blank" rel="noopener">https://stackoverflow.com/questions/27645215/why-cant-i-write-to-the-file-mmaped</a></p><h3 id="SPDK-vhost-NVMe-Accelerating-I-Os-in-virtual-machines-on-NVMe-SSDs-via-user-space-vhost-target"><a href="#SPDK-vhost-NVMe-Accelerating-I-Os-in-virtual-machines-on-NVMe-SSDs-via-user-space-vhost-target" class="headerlink" title="SPDK vhost-NVMe: Accelerating I/Os in virtual machines on NVMe SSDs via user space vhost target"></a>SPDK vhost-NVMe: Accelerating I/Os in virtual machines on NVMe SSDs via user space vhost target</h3><h3 id="百代小红楼"><a href="#百代小红楼" class="headerlink" title="百代小红楼"></a>百代小红楼</h3><p><a href="https://www.sohu.com/a/347046007_617488" target="_blank" rel="noopener">https://www.sohu.com/a/347046007_617488</a></p><h3 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h3><p>Provides control over the resources available to the shell and processes it creates, on systems that allow such control.</p><p>For more details, please type <code>ulimit --help</code></p><h3 id="如何评价上海交通大学-18-级计算机系第一名「迟先生」的言论？"><a href="#如何评价上海交通大学-18-级计算机系第一名「迟先生」的言论？" class="headerlink" title="如何评价上海交通大学 18 级计算机系第一名「迟先生」的言论？"></a>如何评价上海交通大学 18 级计算机系第一名「迟先生」的言论？</h3><p><a href="https://www.zhihu.com/question/439622084/answer/1695860678" target="_blank" rel="noopener">https://www.zhihu.com/question/439622084/answer/1695860678</a></p><ul><li>培养能力而非其他</li><li>见识决定了你的上限</li><li>努力决定了你的下限</li><li>自驱：让这个过程更加美好</li><li>分享：与世界一起成长</li><li>创造：本质幸福的来源</li><li>后记：科班教育能带给我们什么</li></ul><h3 id="以大多数人努力程度之低，根本轮不到拼智商"><a href="#以大多数人努力程度之低，根本轮不到拼智商" class="headerlink" title="以大多数人努力程度之低，根本轮不到拼智商"></a>以大多数人努力程度之低，根本轮不到拼智商</h3><p><a href="https://www.zhihu.com/question/20712208" target="_blank" rel="noopener">https://www.zhihu.com/question/20712208</a><br><a href="http://www.360doc.com/content/17/1121/11/11555490_705804890.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/17/1121/11/11555490_705804890.shtml</a></p><h3 id="jekyll-page-build-failure"><a href="#jekyll-page-build-failure" class="headerlink" title="jekyll page build failure"></a>jekyll page build failure</h3><p><a href="https://stackoverflow.com/questions/40176947/jekyll-page-build-failure" target="_blank" rel="noopener">https://stackoverflow.com/questions/40176947/jekyll-page-build-failure</a></p><p>The problem was caused by a GitHub server outage, not a problem in my code.</p><p>Anyone can check over at the <a href="https://www.githubstatus.com/" target="_blank" rel="noopener">github status website</a> if their server is down. If it is, there isn’t much you can do except wait until it is back up again…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Quick-Assist&quot;&gt;&lt;a href=&quot;#Quick-Assist&quot; class=&quot;headerlink&quot; title=&quot;Quick Assist&quot;&gt;&lt;/a&gt;Quick Assist&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://support.microsoft.com/en-us/windows/solve-pc-problems-over-a-remote-connection-b077e31a-16f4-2529-1a47-21f6a9040bf3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Solve PC problems over a remote connection&lt;/a&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>how to configure thunderbird to read the mailing list</title>
    <link href="http://liujunming.github.io/2021/05/15/how-to-configure-thunderbird-to-read-the-patch/"/>
    <id>http://liujunming.github.io/2021/05/15/how-to-configure-thunderbird-to-read-the-patch/</id>
    <published>2021-05-15T10:42:56.000Z</published>
    <updated>2021-05-15T11:59:22.532Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何配置thunderbird以阅读邮件列表。<a id="more"></a><br>为什么要这么折腾呢？是为了在Windows系统下，方便阅读邮件列表以提高效率。</p><h3 id="1-Why"><a href="#1-Why" class="headerlink" title="1. Why"></a>1. Why</h3><h4 id="1-1-Thread视图"><a href="#1-1-Thread视图" class="headerlink" title="1.1 Thread视图"></a>1.1 Thread视图</h4><p>outlook<br><img src="/images/2021/05/09.PNG" alt></p><p>thunderbird<br><img src="/images/2021/05/11.PNG" alt></p><h4 id="1-2-嵌套引用"><a href="#1-2-嵌套引用" class="headerlink" title="1.2 嵌套引用"></a>1.2 嵌套引用</h4><p>outlook<br><img src="/images/2021/05/10.PNG" alt></p><p>thunderbird<br><img src="/images/2021/05/12.PNG" alt></p><h4 id="1-3-Patch邮件"><a href="#1-3-Patch邮件" class="headerlink" title="1.3 Patch邮件"></a>1.3 Patch邮件</h4><p>outlook<br><img src="/images/2021/05/10.PNG" alt></p><p>thunderbird<br><img src="/images/2021/05/13.PNG" alt></p><h3 id="2-How"><a href="#2-How" class="headerlink" title="2. How"></a>2. How</h3><h4 id="2-1-配置IMAP-and-SMTP-server"><a href="#2-1-配置IMAP-and-SMTP-server" class="headerlink" title="2.1 配置IMAP  and SMTP server"></a>2.1 配置IMAP  and SMTP server</h4><p>这个步骤是specific的，需要根据你的邮箱server信息正确配置。</p><h4 id="2-2-Message-threading-in-Thunderbird"><a href="#2-2-Message-threading-in-Thunderbird" class="headerlink" title="2.2 Message threading in Thunderbird"></a>2.2 Message threading in Thunderbird</h4><p><img src="/images/2021/05/14.PNG" alt></p><h4 id="2-3-Highlighting-patch-format"><a href="#2-3-Highlighting-patch-format" class="headerlink" title="2.3 Highlighting patch format"></a>2.3 Highlighting patch format</h4><p>Thunderbird has a <a href="https://addons.mozilla.org/en-us/thunderbird/addon/colored-diffs/" target="_blank" rel="noopener">Colored Diffs</a> add-on.</p><p><img src="/images/2021/05/15.png" alt></p><p>  个人遇到的坑：在Windows系统下，有时候高亮显示有问题，不妨重启下系统试试（貌似thunderbird关闭，之后再打开，就不会有高亮显示，重启下系统再打开又会有高亮了）。</p><hr><p> 参考资料：</p><ol><li><a href="https://support.mozilla.org/en-US/kb/message-threading-thunderbird" target="_blank" rel="noopener">Message threading in Thunderbird - keep messages grouped by conversation</a></li><li><a href="https://stackoverflow.com/questions/16185408/recommended-email-client-to-read-apply-git-patches" target="_blank" rel="noopener">Recommended email client to read/apply git patches?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍如何配置thunderbird以阅读邮件列表。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Mutt</title>
    <link href="http://liujunming.github.io/2021/05/09/Introduction-to-Mutt/"/>
    <id>http://liujunming.github.io/2021/05/09/Introduction-to-Mutt/</id>
    <published>2021-05-09T00:24:10.000Z</published>
    <updated>2021-05-09T08:59:09.229Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容转载自:<a href="https://fancyseeker.github.io/2015/08/19/mutt/" target="_blank" rel="noopener">Mutt: 阅读邮件列表</a>。对该文甚是喜欢，个人收获是：不仅仅学到了Mutt这个tools，还可以借鉴作者学习工具的思路。<a id="more"></a></p><blockquote><p> 我需要用Mutt来阅读邮件列表, 之所以选Mutt而不使用传统的邮件客户端或是常用的邮箱是因为其在阅读邮件列表时表现不佳, 缺乏效率. 而当我要着手配置Mutt的时候, 网络上的诸多文章仅仅只能起到参考的作用, 我希望能做到自己来定制Mutt并且是真的了解为什么这么配才去配, 而不是随手拿来一个配置文件就用. 再者, 就是本人有些许强迫症, 像Mutt和其它的一些在Unix-like环境下运行的Tools具有极强定制性的工具, 总是希望能将其尽可能的配置到顺手为止. 因此, 我才花时间来写下这篇文章, 一方面记录自己的配置过程, 方便以后回顾用, 另一方面, 若能顺便帮助下有需要的人, 那也算是意外收获了吧.</p></blockquote><h3 id="1-Why-为什么使用Mutt"><a href="#1-Why-为什么使用Mutt" class="headerlink" title="1. Why: 为什么使用Mutt"></a>1. Why: 为什么使用Mutt</h3><p>从阅读邮件的角度来说, 有很多很好用的邮箱, Gmail就是本人很喜欢的邮箱, 并且一直在用, 除了一些不可控的原因影响其用户体验外, 其它方面确实表现的很好. 那为什么我还要花这么大的力气去配置Mutt呢? Mutt跟其它的邮箱相比, 到底有哪些好处呢? 接下来我们来对比下集中应用场景(主要针对邮件列表阅读).</p><h4 id="1-1-Thread视图"><a href="#1-1-Thread视图" class="headerlink" title="1.1 Thread视图"></a>1.1 Thread视图</h4><p><img src="/images/2021/05/02.jpg" alt><br>Gmail中的邮件列表视图</p><p><img src="/images/2021/05/03.png" alt><br>Mutt中的邮件列表视图</p><p>从上图的对比中可以看到, Gmail中的邮件列表视图是基于发信时间的, 虽然这样可以查看到最新的邮件, 但是邮件列表的上下文逻辑就看不清楚了. Mutt则是基于邮件主题的模式进行排列的, 每封邮件都按照Thread的前后回复逻辑组织在一起, 一眼看去回复关系非常清楚, 而且Mutt还能设置高亮, 例如在上图的配置中, 将未读的邮件设置成高亮的蓝色, 已读的邮件设置成白色, 未读的Thread设置成高亮蓝色, 部分已读部分未读的Thread设置成紫色, 这些高亮都是可以自定义的, 因此打开Mutt的邮件列表视图, 一眼看去就知道哪些邮件是已经看过的, 哪些邮件是完全没看过的以及哪些邮件是只看一部分未看全的.</p><h4 id="1-2-嵌套引用"><a href="#1-2-嵌套引用" class="headerlink" title="1.2 嵌套引用"></a>1.2 嵌套引用</h4><p><img src="/images/2021/05/04.png" alt><br>Gmail中的嵌套引用</p><p><img src="/images/2021/05/05.png" alt><br>Mutt中的嵌套引用</p><p>在邮件列表的阅读中, 经常会出现多层的嵌套引用, 从上图的对比中可以看出, Gmail并未对嵌套的引文做任何处理, 而Mutt则可以使用不同的颜色区分不同层的引文, 引用次序非常清晰明了.</p><h4 id="1-3-Patch邮件"><a href="#1-3-Patch邮件" class="headerlink" title="1.3 Patch邮件"></a>1.3 Patch邮件</h4><p><img src="/images/2021/05/06.png" alt><br>Gmail中的Patch邮件</p><p><img src="/images/2021/05/07.png" alt><br>Mutt中的Patch邮件</p><p>在开源社区, 在发送Patch的时候常常使用<code>git sendmail</code>来发送Patch, 而不是以附件的形式. 我们可以看到, 在Gmail中将Patch中代码的部分直接当做正文来处理, 因此很难看清楚到底Patch中对哪里做了修改, 而在Mutt中, 可以通过正则表达式的方式来匹配正文中的任意字段实现高亮, 将其应用到Patch邮件的正文中, 将增减的行高亮出来, 这样就能很清楚的看明白Patch到底对哪里进行了修改.</p><p>以上例子仅仅只是针对邮件列表阅读这种特殊的应用场景而言, 之所以拿Gmail来比较是因为Gmail本身非常优秀, 也是本人最喜欢的邮箱, 并没有贬低Gmail的意思, 只是应用场景不同罢了. 事实上, 除了邮件列表和工作邮件, 本人的其它私人邮件使用的都是Gmail, 一方面UI设计简洁大方, 另一方面, 邮件搜索过滤对于日常应用来说确实非常好~</p><p>在弄清楚了应用场合之后, 我们来进入正文…</p><h3 id="2-What-Mutt是什么"><a href="#2-What-Mutt是什么" class="headerlink" title="2. What: Mutt是什么"></a>2. What: Mutt是什么</h3><h4 id="2-1-Mutt简介"><a href="#2-1-Mutt简介" class="headerlink" title="2.1 Mutt简介"></a>2.1 Mutt简介</h4><p>Mutt是什么? 或者说Mutt是什么样子的? 根据<a href="http://www.mutt.org/" target="_blank" rel="noopener">Mutt官网</a>上的介绍, Mutt是Unix系统环境下一个小巧但是强大的文本邮件客户端. 小是显而易见的, 功能强大对于本人而言主要体现在以下几个<a href="http://www.mutt.org/#Features" target="_blank" rel="noopener">Mutt Features</a>:</p><ul><li>支持配色</li><li>对邮件列表支持很好</li><li>高度可定制, 支持键绑定和宏</li><li>支持正则表达式以及内部模式匹配等多种搜索</li><li>高效</li></ul><p>此外, Mutt还支持其它很多特性, 比如MIME(这是什么我并不知道, 估计也不会用到), PGP(没有加密邮件的习惯), 支持POP3和IMAP协议(是个邮箱都支持), 完全控制邮件头部等等等等…但是这些特性其它的邮箱也有, 有的甚至做的更好.</p><p>因此, 对于Mutt, 我最看重的还是其它邮箱所没有的特性.</p><ol><li>高度可定制化, 键位绑定和宏对于习惯了Vim和CLI的人来说能提高不少效率;</li><li>对邮件列表支持完善, 这也是我之所以选用Mutt最关键的原因, Mutt针对邮件列表添加了很多很方便的设置和操作, 极大的提高了阅读和回复邮件列表的效率;</li><li>邮件内容支持配色, 这对于阅读带有代码或是多层嵌套引用的邮件来说简直是神技.</li><li>高效, 主要反应在打开一个1000+邮件的信箱只需要1s不到时间, 很快.</li></ol><p>诚然Mutt有很多优点, 但是Mutt仅仅只是一个邮件客户端, 那么问题来了, 什么是邮件客户端(Mail Client)? 通常我们认为一个邮件客户端应该像Outlook和Thunderbird那样, 能收能发能整理能查找. 但是很遗憾的, Mutt跟他们并不一样, Mutt是Unix环境下的small and powerful的邮件客户端, 按照Unix大多工具的尿性, 一般只会提供小而精的功能, 并不会做大而全的封装. Mutt也是一样, <strong>Mutt只管理邮件, 而不负责邮件的收发</strong>. 详细点说, Mutt做的事情只是从本机上的某个位置读取邮件, 或是把邮件存放到本机上的某个位置, 此外, 还负责邮件的阅读, 查找, 标记等事务, 与其说Mutt是一个邮件客户端, 不如说<strong>Mutt是一个邮件管理工具</strong>.</p><h4 id="2-2-Email工作原理"><a href="#2-2-Email工作原理" class="headerlink" title="2.2 Email工作原理"></a>2.2 <a href="/2021/05/08/Email工作原理/">Email工作原理</a></h4><h4 id="2-3-Mutt与msmtp-getmail和procmail的关系"><a href="#2-3-Mutt与msmtp-getmail和procmail的关系" class="headerlink" title="2.3 Mutt与msmtp, getmail和procmail的关系"></a>2.3 Mutt与msmtp, getmail和procmail的关系</h4><p>解释了半天, 相信大家已经被各种M*A给整懵了吧. 以下对邮件发送过程中的各个部分(Agent)做下简要的解释:</p><ul><li><strong>MUA(Mail User Agent)</strong>: 邮件客户端, 负责邮件的管理, 阅读等. 一些集成度较高的MUA会带有收发邮件乃至过滤邮件的功能如Outlook和Thunderbird, Mutt也带有简单的发送邮件功能, 不过一般不采用.</li><li><strong>MTA(Mail Transfer Agent)</strong>: 邮件传送代理, 负责邮件的发送, 处理发送过程中的主机识别, 路由跳转等问题. 对于用户而言MTA就是负责从本地发送邮件的部件. 常见的MTA有sendmail, emstp, msmtp.</li><li><strong>MRA(Mail Retrieval Agent)</strong>: 邮件收取代理, 负责从远端的邮件服务器收取邮件至本地文件夹. 常见的MRA有fetchmail, getmail.</li><li><strong>MDA(Mail Delivery Agent)</strong>: 邮件分发代理, 负责根据规则过滤邮件并将邮件投放到不同的文件夹中. 常见的MDA有procmail.</li></ul><p>之所以讲了这么多Email的工作原理, 主要是为了两件事情.</p><ol><li>明确Mutt在整个邮件收发过程中的位置.</li><li>解释为什么在配置Mutt的时候需要额外安装配置msmtp, getmail乃至procmail.</li></ol><p>当弄明白了Email的工作原理后, 其实也就不难理解为什么在网上搜索Mutt相关资料的时候, 跳出来的都是mutt+getmail+msmtp+procmail之类的文章了. 因为光一个Mutt, 根本无法完成最基本的邮件收发功能啊, 必须需要靠msmtp来发邮件, 靠getmail来收邮件, 如果还需要自定义一些邮件分类过滤行为的话, 还需要procmail来帮忙. 因此, 现在我们在谈论Mutt的时候, 我们其实实在谈论mutt+getmail+msmtp这一串东西.</p><p>然后, 我想再来看看以下这张图, 就明白Mutt与getmail, msmtp以及procmail之间的关系了.</p><p><img src="/images/2021/05/08.jpg" alt><br>Mutt与相关工具的关系(图片版权为tekkamanninja所有)</p><hr><p>参考资料：</p><ol><li><a href="/pdf/Mutt_ 阅读邮件列表 _ FancySeeker.pdf">Mutt: 阅读邮件列表</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容转载自:&lt;a href=&quot;https://fancyseeker.github.io/2015/08/19/mutt/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mutt: 阅读邮件列表&lt;/a&gt;。对该文甚是喜欢，个人收获是：不仅仅学到了Mutt这个tools，还可以借鉴作者学习工具的思路。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Email工作原理</title>
    <link href="http://liujunming.github.io/2021/05/08/Email%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://liujunming.github.io/2021/05/08/Email工作原理/</id>
    <published>2021-05-08T07:15:39.000Z</published>
    <updated>2021-05-08T23:34:33.634Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍<a href="https://fancyseeker.github.io/2015/08/19/mutt/#email%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">Email工作原理</a>。<a id="more"></a></p><center><img src="/images/2021/05/01.png" alt></center><br><center>Email的工作原理</center><p>从上面的原理图中, 我们可以看到整个邮件发送接收的过程。首先, 邮件在MUA(Mail User Agent)中编辑完成, 交由MTA(Mail Transfer Agent)进行发送, 在发送的过程中, 邮件会在多个路由和MTA服务器中中转, 邮件从一个MTA服务器被传输到另一个MTA服务器, 其中使用的是名为<a href="https://zh.wikipedia.org/zh/简单邮件传输协议" target="_blank" rel="noopener">SMTP</a>的邮件传输协议。当邮件到达收件人所处的网络中的MTA时, MTA将邮件交给邮件服务器, 邮件服务器负责将邮件发送给指定用户的信箱中, 邮件服务器在分发邮件的时候, 具有MDA(Mail Delivery Agent)的功能, 其中可能会包含防火墙, 过滤垃圾邮件, 屏蔽黑名单等功能, 我们常见的网络邮箱的工作模式大致是这样的。</p><p>另外, 如果我们使用的是邮件客户端来接收邮件的话, 客户端还需要负责从远端的信箱中拖取邮件到本地的信箱中。这里就需要使用MRA(Mail Retrieval Agent)来完成从远端信箱收取邮件至本地的操作, 在MRA取邮件的时候, 涉及到这么一个问题, 是单纯的将远端邮箱的邮件复制来呢, 还是让本机的信箱跟远端的信箱保持同步呢, 根据收取方式的不同, 区分了两种主流的收取邮件协议<a href="https://zh.wikipedia.org/wiki/郵局協定" target="_blank" rel="noopener">POP3</a>和<a href="https://zh.wikipedia.org/wiki/IMAP" target="_blank" rel="noopener">IMAP</a>。 在邮件到达本地后, 有时在本机上, 会再次对邮件进行一部分分拣和过滤, 例如将来自邮件列表的邮件放到一个特定的文件夹中, 将包含特定文字的邮件放到垃圾邮件文件中等, 这些功能, 是通过本地的MDA来完成的。 最后, 邮件到达了特定的文件夹, MUA, 即邮件客户端从特定文件夹读取邮件, 并解码邮件格式, 展示给用户阅读。 而Mutt, 在整个邮件收发过程中, 做的也就是这个部分(MUA)的事情!</p><p><strong>总结一下</strong>：</p><p>4个M*A</p><ul><li>MUA(Mail User Agent)</li><li>MTA(Mail Transfer Agent)</li><li>MRA(Mail Retrieval Agent)</li><li>MDA(Mail Delivery Agent)</li></ul><p>3个协议：</p><ul><li>SMTP(Simple Mail Transfer Protocol)</li><li>POP3(Post Office Protocol - Version 3)</li><li>IMAP(Internet Message Access Protocol)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍&lt;a href=&quot;https://fancyseeker.github.io/2015/08/19/mutt/#email%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Email工作原理&lt;/a&gt;。
    
    </summary>
    
      <category term="工具" scheme="http://liujunming.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://liujunming.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>What is the -fPIE option for position-independent executables in gcc and ld?</title>
    <link href="http://liujunming.github.io/2021/04/17/What-is-the-fPIE-option-for-position-independent-executables-in-gcc-and-ld/"/>
    <id>http://liujunming.github.io/2021/04/17/What-is-the-fPIE-option-for-position-independent-executables-in-gcc-and-ld/</id>
    <published>2021-04-17T05:28:04.000Z</published>
    <updated>2021-04-17T07:31:17.219Z</updated>
    
    <content type="html"><![CDATA[<p>在stackoverflow上看了<a href="https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld" target="_blank" rel="noopener">What is the -fPIE option for position-independent executables in gcc and ld?</a>，对其中的答案甚是满意，所以转载到博客中。<a id="more"></a></p><h3 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h3><p>PIE(position-independent executables) is to support <a href="http://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="noopener">address space layout randomization (ASLR)</a> in executable files.</p><p>Before the PIE mode was created, the program’s executable could not be placed at a random address in memory, only position independent code (PIC) dynamic libraries could be relocated to a random offset. It works very much like what PIC does for dynamic libraries, the difference is that a Procedure Linkage Table (PLT) is not created, instead PC-relative relocation is used.</p><p>After enabling PIE support in gcc/linkers, the body of program is compiled and linked as position-independent code. A dynamic linker does full relocation processing on the program module, just like dynamic libraries. Any usage of global data is converted to access via the Global Offsets Table (GOT) and GOT relocations are added.</p><h3 id="2-Example"><a href="#2-Example" class="headerlink" title="2. Example"></a>2. Example</h3><h4 id="2-1-Minimal-runnable-example-GDB-the-executable-twice"><a href="#2-1-Minimal-runnable-example-GDB-the-executable-twice" class="headerlink" title="2.1 Minimal runnable example: GDB the executable twice"></a>2.1 Minimal runnable example: GDB the executable twice</h4><p>Let’s see ASLR work on the PIE executable and change addresses across runs:</p><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/usr/bin/env bash</span><br><span class="line">echo 2 | sudo tee /proc/sys/kernel/randomize_va_space</span><br><span class="line">for pie in no-pie pie; do</span><br><span class="line">  exe="$&#123;pie&#125;.out"</span><br><span class="line">  gcc -O0 -std=c99 "-$&#123;pie&#125;" "-f$&#123;pie&#125;" -ggdb3 -o "$exe" main.c</span><br><span class="line">  gdb -batch -nh -q \</span><br><span class="line">    -ex 'set disable-randomization off' \</span><br><span class="line">    -ex 'break main' \</span><br><span class="line">    -ex 'run' \</span><br><span class="line">    -ex 'printf "pc = 0x%llx\n", (long  long unsigned)$pc' \</span><br><span class="line">    -ex 'run' \</span><br><span class="line">    -ex 'printf "pc = 0x%llx\n", (long  long unsigned)$pc' \</span><br><span class="line">    "./$exe" \</span><br><span class="line">  ;</span><br><span class="line">  echo</span><br><span class="line">  echo</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>For the one with <code>-no-pie</code>, everything is boring:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1 at 0x40052a: file main.c, line 4.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:4</span><br><span class="line">4           puts(&quot;hello&quot;);</span><br><span class="line">pc = 0x40052a</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:4</span><br><span class="line">4           puts(&quot;hello&quot;);</span><br><span class="line">pc = 0x40052a</span><br></pre></td></tr></table></figure><p>Before starting execution, <code>break main</code> sets a breakpoint at <code>0x40052a</code>.</p><p>Then, during both executions, <code>run</code> stops at address <code>0x40052a</code>.</p><p>The one with <code>-pie</code> however is much more interesting:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1 at 0x754: file main.c, line 4.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:4</span><br><span class="line">4           puts(&quot;hello&quot;);</span><br><span class="line">pc = 0x56093aa99754</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:4</span><br><span class="line">4           puts(&quot;hello&quot;);</span><br><span class="line">pc = 0x55615b05e754</span><br></pre></td></tr></table></figure><p>Before starting execution, GDB just takes a “dummy” address that is present in the executable: <code>0x754</code>.</p><p>After it starts however, GDB intelligently notices that the dynamic loader placed the program in a different location, and the first break stopped at <code>0x56093aa99754</code>.</p><p>Then, the second run also intelligently noticed that the executable moved again, and ended up breaking at <code>0x55615b05e754</code>.</p><p><code>echo 2 | sudo tee /proc/sys/kernel/randomize_va_space</code> ensures that ASLR is on: <a href="https://askubuntu.com/questions/318315/how-can-i-temporarily-disable-aslr-address-space-layout-randomization" target="_blank" rel="noopener">How can I temporarily disable ASLR (Address space layout randomization)? | Ask Ubuntu</a>.</p><p><code>set disable-randomization off</code> is needed otherwise GDB, as the name suggests, turns off ASLR for the process by default to give fixed addresses across runs to improve the debugging experience: <a href="https://stackoverflow.com/questions/10061475/difference-between-gdb-addresses-and-real-addresses" target="_blank" rel="noopener">Difference between gdb addresses and “real” addresses? | Stack Overflow</a>.</p><p><strong>readelf analysis</strong></p><p>Furthermore, we can also observe that:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s ./no-pie.out | grep main</span><br></pre></td></tr></table></figure><p>gives the actual runtime load address (pc pointed to the following instruction 4 bytes after):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">68: 0000000000400526    21 FUNC    GLOBAL DEFAULT   14 main</span><br></pre></td></tr></table></figure><p>while:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s ./pie.out | grep main</span><br></pre></td></tr></table></figure><p>gives just an offset:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">68: 0000000000000750    23 FUNC    GLOBAL DEFAULT   14 main</span><br></pre></td></tr></table></figure><p>By turning ASLR off (with either <code>randomize_va_space</code> or <code>set disable-randomization off</code>), GDB always gives <code>main</code> the address: <code>0x555555554754</code>, so we deduce that the <code>-pie</code> address is composed from:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x555555554000 + random offset + symbol offset (750)</span><br></pre></td></tr></table></figure><h4 id="2-2-Minimal-assembly-example"><a href="#2-2-Minimal-assembly-example" class="headerlink" title="2.2 Minimal assembly example"></a>2.2 Minimal assembly example</h4><p>Another cool thing we can do is to play around with some assembly code to understand more concretely what PIE means.</p><p>We can do that with a Linux x86_64 freestanding assembly hello world:</p><p>main.S</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        .global _start</span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line">_start:</span><br><span class="line">        # write(1, message, 13)</span><br><span class="line">        mov     $1, %rax                # system call 1 is write</span><br><span class="line">        mov     $1, %rdi                # file handle 1 is stdout</span><br><span class="line">        mov     $message, %rsi          # address of string to output</span><br><span class="line">        mov     $13, %rdx               # number of bytes</span><br><span class="line">        syscall                         # invoke operating system to do the write</span><br><span class="line"></span><br><span class="line">        # exit(0)</span><br><span class="line">        mov     $60, %rax               # system call 60 is exit</span><br><span class="line">        xor     %rdi, %rdi              # we want return code 0</span><br><span class="line">        syscall                         # invoke operating system to exit</span><br><span class="line">message:</span><br><span class="line">        .ascii  <span class="string">"Hello, world\n"</span></span><br></pre></td></tr></table></figure><p>and it assembles and runs fine with:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">as -o main.o main.S</span><br><span class="line">ld -o main.out main.o</span><br><span class="line">./main.out</span><br></pre></td></tr></table></figure><p>However, if we try to link it as PIE with (<code>--no-dynamic-linker</code> is required as explained at: <a href="https://stackoverflow.com/questions/55664494/how-to-create-a-statically-linked-position-independent-executable-elf-in-linux" target="_blank" rel="noopener">How to create a statically linked position independent executable ELF in Linux?</a>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld --no-dynamic-linker -pie -o main.out main.o</span><br></pre></td></tr></table></figure><p>then link will fail with:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ld: main.o: relocation R_X86_64_32S against `.text&apos; can not be used when making a shared object; recompile with -fPIC</span><br><span class="line">main.o: error adding symbols: Bad value</span><br></pre></td></tr></table></figure><p>Because the line:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     $message, %rsi          # address of string to output</span><br></pre></td></tr></table></figure><p>hardcodes the message address in the <code>mov</code> operand, and is therefore not position independent.</p><p>If we instead write it in a position independent way:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea message(%rip), %rsi# address of string to output</span><br></pre></td></tr></table></figure><p>then PIE link works fine, and GDB shows us that the executable does get loaded at a different location in memory every time.</p><p>The difference here is that <code>lea</code> encoded the address of <code>msg</code> relative to the current PC address due to the <code>rip</code> syntax, see also:<a href="/2021/04/11/How-to-use-x64-RIP-addressing/">How to use x64 RIP-relative addressing</a></p><p>Another fun thing that we can do is to put the <code>msg</code> in the data section instead of <code>.text</code> with:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">message:</span><br><span class="line">        .ascii  &quot;Hello, world\n&quot;</span><br></pre></td></tr></table></figure><p>Now the <code>.o</code> assembles to:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e:   48 8d 35 00 00 00 00    lea    0x0(%rip),%rsi        # 15 &lt;_start+0x15&gt;</span><br></pre></td></tr></table></figure><p>so the RIP offset is now <code>0</code>, and we guess that a relocation has been requested by the assembler. We confirm that with:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -r main.o</span><br></pre></td></tr></table></figure><p>which gives:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Relocation section &apos;.rela.text&apos; at offset 0x118 contains 1 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000011  000200000002 R_X86_64_PC32     0000000000000000 .data - 4</span><br></pre></td></tr></table></figure><p>so clearly <code>R_X86_64_PC32</code> is a PC relative relocation that <code>ld</code> can handle for PIE executables.</p><p>This experiment taught us that the linker itself checks the program can be PIE and marks it as such.</p><p>Then when compiling with GCC, <code>-pie</code> tells GCC to generate position independent assembly.</p><p>But if we write assembly ourselves, we must manually ensure that we have achieved position independence.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在stackoverflow上看了&lt;a href=&quot;https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What is the -fPIE option for position-independent executables in gcc and ld?&lt;/a&gt;，对其中的答案甚是满意，所以转载到博客中。
    
    </summary>
    
      <category term="计算机编程" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机编程" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>How to use GDB to analyze core dump file</title>
    <link href="http://liujunming.github.io/2021/04/16/How-to-use-GDB-to-analyze-core-dump-file/"/>
    <id>http://liujunming.github.io/2021/04/16/How-to-use-GDB-to-analyze-core-dump-file/</id>
    <published>2021-04-16T12:07:32.000Z</published>
    <updated>2021-04-16T15:52:08.053Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍core dump的相关内容，最后以一个具体的例子来展示:使用GDB解析core dump的基本用法。<br><a id="more"></a></p><h3 id="1-core-dump的基本概念"><a href="#1-core-dump的基本概念" class="headerlink" title="1. core dump的基本概念"></a>1. core dump的基本概念</h3><blockquote><p>A core dump is the recorded state of the working memory of a computer program at a specific time, generally when the program has terminated abnormally (crashed). In practice, other key pieces of program state are usually dumped at the same time, including the processor registers, which may include the program counter and stack pointer, memory management information, and other processor and operating system flags and information. </p></blockquote><h3 id="2-启用core-dump"><a href="#2-启用core-dump" class="headerlink" title="2. 启用core dump"></a>2. 启用core dump</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:~$ help ulimit</span><br><span class="line">    Options:</span><br><span class="line">      -c        the maximum size of core files created</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure><h3 id="3-设置-core-文件的存储目录和命名格式"><a href="#3-设置-core-文件的存储目录和命名格式" class="headerlink" title="3. 设置 core 文件的存储目录和命名格式"></a>3. 设置 core 文件的存储目录和命名格式</h3><p>设置 core 的存储目录和命名格式，主要是修改配置文件 <code>/proc/sys/kernel/core_pattern</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1. 默认在当前程序执行目录下生成，core-程序名-程序pid-时间 [core-test-3451-1516257740]</span><br><span class="line">echo "core-%e-%p-%t" &gt; /proc/sys/kernel/core_pattern</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 2. 添加路径，可以把所有的 core 集中到一个文件夹里 [把所有的core文件放到 /root/core-file 目录下]</span><br><span class="line">echo "/root/core-file/core-%e-%p-%t" &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>为什么会有设置core文件存储目录这个需求呢？答案是：如果程序中调用了<code>chdir</code>函数，则有可能改变了当前工作目录。这时core文件创建在<code>chdir</code>指定的路径下。</p><p>为什么会有设置core文件命名格式的需求呢？答案是：内核在coredump时所产生的core文件放在与该程序相同的目录中，并且文件名固定为<em>core</em>。很显然，如果有多个程序产生core文件，或者同一个程序多次崩溃，就会重复覆盖同一个core文件，因此我们有必要对不同程序生成的core文件分别命名。</p><h3 id="4-如何判断一个文件是coredump文件？"><a href="#4-如何判断一个文件是coredump文件？" class="headerlink" title="4. 如何判断一个文件是coredump文件？"></a>4. 如何判断一个文件是coredump文件？</h3><h4 id="4-1-method1"><a href="#4-1-method1" class="headerlink" title="4.1 method1"></a>4.1 method1</h4><p>在Linux系统下，coredump文件本身是ELF格式的，因此，我们可以通过<code>readelf</code>命令进行判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:~/test$ readelf -h core</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              CORE (Core file)</span><br></pre></td></tr></table></figure><p>可以看到ELF文件头的Type字段的类型是：<code>CORE (Core file)</code></p><h4 id="4-2-method2"><a href="#4-2-method2" class="headerlink" title="4.2 method2"></a>4.2 method2</h4><p>通过简单的file命令进行快速判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:~/test$ file core</span><br><span class="line">core: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from &apos;./a.out&apos;</span><br></pre></td></tr></table></figure><p><code>core file</code></p><h3 id="5-Example"><a href="#5-Example" class="headerlink" title="5. Example"></a>5. Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FILE：test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repeatFree</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* pstr =(<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    repeatFree(pstr); <span class="comment">// 第一次释放</span></span><br><span class="line"></span><br><span class="line">    repeatFree(pstr); <span class="comment">// 第二次释放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:~/test$ gcc -g test.c -o test</span><br><span class="line">acrn@acrn:~/test$ ./test</span><br><span class="line">*** Error in `./test&apos;: double free or corruption (fasttop): 0x000000000164c010 ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7fb1be3fb7e5]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x8037a)[0x7fb1be40437a]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7fb1be40853c]</span><br><span class="line">./test[0x400585]</span><br><span class="line">./test[0x4005b6]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7fb1be3a4830]</span><br><span class="line">./test[0x400499]</span><br><span class="line">======= Memory map: ========</span><br><span class="line">00400000-00401000 r-xp 00000000 103:02 3938165                           /home/acrn/test/test</span><br><span class="line">00600000-00601000 r--p 00000000 103:02 3938165                           /home/acrn/test/test</span><br><span class="line">00601000-00602000 rw-p 00001000 103:02 3938165                           /home/acrn/test/test</span><br><span class="line">0164c000-0166d000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7fb1b8000000-7fb1b8021000 rw-p 00000000 00:00 0</span><br><span class="line">7fb1b8021000-7fb1bc000000 ---p 00000000 00:00 0</span><br><span class="line">7fb1be16e000-7fb1be184000 r-xp 00000000 103:02 8917652                   /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7fb1be184000-7fb1be383000 ---p 00016000 103:02 8917652                   /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7fb1be383000-7fb1be384000 rw-p 00015000 103:02 8917652                   /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7fb1be384000-7fb1be544000 r-xp 00000000 103:02 8913417                   /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7fb1be544000-7fb1be744000 ---p 001c0000 103:02 8913417                   /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7fb1be744000-7fb1be748000 r--p 001c0000 103:02 8913417                   /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7fb1be748000-7fb1be74a000 rw-p 001c4000 103:02 8913417                   /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7fb1be74a000-7fb1be74e000 rw-p 00000000 00:00 0</span><br><span class="line">7fb1be74e000-7fb1be774000 r-xp 00000000 103:02 8913403                   /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7fb1be955000-7fb1be958000 rw-p 00000000 00:00 0</span><br><span class="line">7fb1be972000-7fb1be973000 rw-p 00000000 00:00 0</span><br><span class="line">7fb1be973000-7fb1be974000 r--p 00025000 103:02 8913403                   /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7fb1be974000-7fb1be975000 rw-p 00026000 103:02 8913403                   /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7fb1be975000-7fb1be976000 rw-p 00000000 00:00 0</span><br><span class="line">7fff6edaa000-7fff6edcb000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7fff6edf8000-7fff6edfb000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7fff6edfb000-7fff6edfd000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line">Aborted (core dumped)</span><br><span class="line">acrn@acrn:~/test$ ls</span><br><span class="line">core-test-14363-1618606735  test  test.c</span><br></pre></td></tr></table></figure><p>gdb 调试，找出出错的位置 <code>gdb 程序名 core文件名</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:~/test$ gdb test core-test-14363-1618606735</span><br><span class="line">Reading symbols from test...done.</span><br><span class="line">[New LWP 14363]</span><br><span class="line">Core was generated by `./test&apos;.</span><br><span class="line">Program terminated with signal SIGABRT, Aborted.</span><br><span class="line">#0  0x00007fb1be3b9428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54</span><br><span class="line">54      ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007fb1be3b9428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54</span><br><span class="line">#1  0x00007fb1be3bb02a in __GI_abort () at abort.c:89</span><br><span class="line">#2  0x00007fb1be3fb7ea in __libc_message (do_abort=do_abort@entry=2, fmt=fmt@entry=0x7fb1be514ed8 &quot;*** Error in `%s&apos;: %s: 0x%s ***\n&quot;) at ../sysdeps/posix/libc_fatal.c:175</span><br><span class="line">#3  0x00007fb1be40437a in malloc_printerr (ar_ptr=&lt;optimized out&gt;, ptr=&lt;optimized out&gt;, str=0x7fb1be514fa0 &quot;double free or corruption (fasttop)&quot;, action=3) at malloc.c:5006</span><br><span class="line">#4  _int_free (av=&lt;optimized out&gt;, p=&lt;optimized out&gt;, have_lock=0) at malloc.c:3867</span><br><span class="line">#5  0x00007fb1be40853c in __GI___libc_free (mem=&lt;optimized out&gt;) at malloc.c:2968</span><br><span class="line">#6  0x0000000000400585 in repeatFree (p=0x164c010 &quot;&quot;) at test.c:8</span><br><span class="line">#7  0x00000000004005b6 in main () at test.c:18</span><br></pre></td></tr></table></figure><p>在 gdb 内，输入 <code>where</code> 或者<code>bt</code>可以看出， 我们写的程序出错的两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#6  0x0000000000400585 in repeatFree (p=0x164c010 &quot;&quot;) at test.c:8</span><br><span class="line">#7  0x00000000004005b6 in main () at test.c:18</span><br></pre></td></tr></table></figure><p>在 repeatFree 函数中，test.c 文件的第 8 行错啦，释放了两次内存。</p><p>还有一个值得挖掘的信息是:<code>Program terminated with signal SIGABRT, Aborted.</code></p><p>signal的详细信息请查询<a href="https://man7.org/linux/man-pages/man7/signal.7.html" target="_blank" rel="noopener">signal(7)</a>。</p><h3 id="6-material"><a href="#6-material" class="headerlink" title="6. material"></a>6. material</h3><p>如果想要了解更加详细的内容，推荐阅读<a href="https://averageradical.github.io/Linux_Core_Dumps.pdf" target="_blank" rel="noopener">https://averageradical.github.io/Linux_Core_Dumps.pdf</a> 中对于core dump的介绍。</p><hr><p>参考资料:</p><ol><li><a href="https://www.jianshu.com/p/dc7e7bd7d1a2" target="_blank" rel="noopener">Linux 下生成 core dump 配置和用法</a></li><li><a href="https://blog.csdn.net/tenfyguo/article/details/8159176" target="_blank" rel="noopener">详解coredump</a></li><li><a href="https://man7.org/linux/man-pages/man7/signal.7.html" target="_blank" rel="noopener">signal(7)</a></li><li><a href="https://en.wikipedia.org/wiki/Core_dump" target="_blank" rel="noopener">wikipedia Core dump</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍core dump的相关内容，最后以一个具体的例子来展示:使用GDB解析core dump的基本用法。&lt;br&gt;
    
    </summary>
    
      <category term="debug" scheme="http://liujunming.github.io/categories/debug/"/>
    
    
      <category term="debug" scheme="http://liujunming.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第22期</title>
    <link href="http://liujunming.github.io/2021/04/11/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC22%E6%9C%9F/"/>
    <id>http://liujunming.github.io/2021/04/11/每周分享第22期/</id>
    <published>2021-04-11T13:01:27.000Z</published>
    <updated>2021-04-11T15:08:43.214Z</updated>
    
    <content type="html"><![CDATA[<h3 id="gitub-代码片段链接"><a href="#gitub-代码片段链接" class="headerlink" title="gitub 代码片段链接"></a>gitub 代码片段链接</h3><p><a href="https://github.com/projectacrn/acrn-hypervisor/blob/master/devicemodel/hw/pci/gvt.c#L53-L65" target="_blank" rel="noopener">https://github.com/projectacrn/acrn-hypervisor/blob/master/devicemodel/hw/pci/gvt.c#L53-L65</a><a id="more"></a></p><h3 id="hard-copy"><a href="#hard-copy" class="headerlink" title="hard-copy"></a>hard-copy</h3><p>A hard copy (or “hardcopy”) is a printed copy of information from a computer.</p><h3 id="IT-圈里有哪些经常被读错的词？"><a href="#IT-圈里有哪些经常被读错的词？" class="headerlink" title="IT 圈里有哪些经常被读错的词？"></a>IT 圈里有哪些经常被读错的词？</h3><p><a href="https://www.zhihu.com/question/19739907" target="_blank" rel="noopener">https://www.zhihu.com/question/19739907</a></p><h3 id="操作系统实验最全学习资料（xv6、ucore）等"><a href="#操作系统实验最全学习资料（xv6、ucore）等" class="headerlink" title="操作系统实验最全学习资料（xv6、ucore）等"></a>操作系统实验最全学习资料（xv6、ucore）等</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg4NjUxMzg5MA==&amp;mid=100004327&amp;idx=1&amp;sn=f0354f86bc655e7998cf3ccc735add3e&amp;chksm=4f99d86a78ee517c252dce904796640d5edc0f3abc0567939df02bf3a395d92d21cde42910b8#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg4NjUxMzg5MA==&amp;mid=100004327&amp;idx=1&amp;sn=f0354f86bc655e7998cf3ccc735add3e&amp;chksm=4f99d86a78ee517c252dce904796640d5edc0f3abc0567939df02bf3a395d92d21cde42910b8#rd</a></p><h3 id="rfc-patch"><a href="#rfc-patch" class="headerlink" title="rfc patch"></a>rfc patch</h3><p><a href="https://git-scm.com/docs/git-format-patch" target="_blank" rel="noopener">https://git-scm.com/docs/git-format-patch</a></p><p>RFC means “Request For Comments”; use this when sending an experimental patch for discussion rather than application.</p><h3 id="使用VGA显示字符串"><a href="#使用VGA显示字符串" class="headerlink" title="使用VGA显示字符串"></a>使用VGA显示字符串</h3><p><a href="https://blog.csdn.net/whimewcm/article/details/83155026" target="_blank" rel="noopener">https://blog.csdn.net/whimewcm/article/details/83155026</a></p><h3 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h3><p><a href="https://zh.wikipedia.org/wiki/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6</a></p><h3 id="城市规划局"><a href="#城市规划局" class="headerlink" title="城市规划局"></a>城市规划局</h3><p><a href="http://www.zgghw.org.cn/" target="_blank" rel="noopener">http://www.zgghw.org.cn/</a></p><h3 id="海天一洲"><a href="#海天一洲" class="headerlink" title="海天一洲"></a>海天一洲</h3><p><a href="https://baike.baidu.com/item/%E6%B5%B7%E5%A4%A9%E4%B8%80%E6%B4%B2" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%B5%B7%E5%A4%A9%E4%B8%80%E6%B4%B2</a></p><h3 id="职场心得：灵性，悟性，积极性"><a href="#职场心得：灵性，悟性，积极性" class="headerlink" title="职场心得：灵性，悟性，积极性"></a>职场心得：灵性，悟性，积极性</h3><h3 id="舟山旅游心得"><a href="#舟山旅游心得" class="headerlink" title="舟山旅游心得"></a>舟山旅游心得</h3><ol><li>若想去东极岛，提前三天，早上五点，公众号(舟山海星轮船)上抢票</li><li>舟山新区交通公众号可以购买不少船票</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;gitub-代码片段链接&quot;&gt;&lt;a href=&quot;#gitub-代码片段链接&quot; class=&quot;headerlink&quot; title=&quot;gitub 代码片段链接&quot;&gt;&lt;/a&gt;gitub 代码片段链接&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/projectacrn/acrn-hypervisor/blob/master/devicemodel/hw/pci/gvt.c#L53-L65&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/projectacrn/acrn-hypervisor/blob/master/devicemodel/hw/pci/gvt.c#L53-L65&lt;/a&gt;
    
    </summary>
    
      <category term="经验" scheme="http://liujunming.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://liujunming.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>How to use x64 RIP-relative addressing</title>
    <link href="http://liujunming.github.io/2021/04/11/How-to-use-x64-RIP-addressing/"/>
    <id>http://liujunming.github.io/2021/04/11/How-to-use-x64-RIP-addressing/</id>
    <published>2021-04-11T01:29:36.000Z</published>
    <updated>2021-04-16T15:52:08.054Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍x64 RIP-relative addressing的使用方法。<a id="more"></a></p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><blockquote><p>RIP-relative addressing: this is new for x64 and allows accessing data tables and such in the code relative to the current instruction pointer, making position independent code easier to implement.</p></blockquote><p>position independent code的相关内容较为复杂，本文不会介绍，后续会推出系列文章介绍该部分内容。</p><h3 id="2-Example"><a href="#2-Example" class="headerlink" title="2. Example"></a>2. Example</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># ----------------------------------------------------------------------------------------</span><br><span class="line"># Writes &quot;Hello, World&quot; to the console using only system calls. Runs on 64-bit Linux only.</span><br><span class="line"># To assemble and run:</span><br><span class="line">#</span><br><span class="line">#     gcc -c hello.s &amp;&amp; ld hello.o &amp;&amp; ./a.out</span><br><span class="line">#</span><br><span class="line"># or</span><br><span class="line">#</span><br><span class="line">#     gcc -nostdlib hello.s &amp;&amp; ./a.out</span><br><span class="line"># ----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">        .global _start</span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line">_start:</span><br><span class="line">        # write(1, message, 13)</span><br><span class="line">        mov     $1, %rax                # system call 1 is write</span><br><span class="line">        mov     $1, %rdi                # file handle 1 is stdout</span><br><span class="line">        lea message(%rip), %rsi# address of string to output</span><br><span class="line">        mov     $13, %rdx               # number of bytes</span><br><span class="line">        syscall                         # invoke operating system to do the write</span><br><span class="line"></span><br><span class="line">        # exit(0)</span><br><span class="line">        mov     $60, %rax               # system call 60 is exit</span><br><span class="line">        xor     %rdi, %rdi              # we want return code 0</span><br><span class="line">        syscall                         # invoke operating system to exit</span><br><span class="line">message:</span><br><span class="line">        .ascii  &quot;Hello, world\n&quot;</span><br></pre></td></tr></table></figure><p><code>lea     message(%rip), %rsi</code>就使用了x64 RIP-relative addressing。</p><blockquote><p>AT&amp;T: ‘symbol(%rip)’, Intel: ‘[rip + symbol]’<br>Points to the symbol in RIP relative way.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:~/test$ objdump -D a.out</span><br><span class="line"></span><br><span class="line">a.out:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000400078 &lt;_start&gt;:</span><br><span class="line">  400078:       48 c7 c0 01 00 00 00    mov    $0x1,%rax</span><br><span class="line">  40007f:       48 c7 c7 01 00 00 00    mov    $0x1,%rdi</span><br><span class="line">  400086:       48 8d 35 15 00 00 00    lea    0x15(%rip),%rsi        # 4000a2 &lt;message&gt;</span><br><span class="line">  40008d:       48 c7 c2 0d 00 00 00    mov    $0xd,%rdx</span><br><span class="line">  400094:       0f 05                   syscall</span><br><span class="line">  400096:       48 c7 c0 3c 00 00 00    mov    $0x3c,%rax</span><br><span class="line">  40009d:       48 31 ff                xor    %rdi,%rdi</span><br><span class="line">  4000a0:       0f 05                   syscall</span><br><span class="line"></span><br><span class="line">00000000004000a2 &lt;message&gt;:</span><br><span class="line">  4000a2:       48                      rex.W</span><br><span class="line">  4000a3:       65 6c                   gs insb (%dx),%es:(%rdi)</span><br><span class="line">  4000a5:       6c                      insb   (%dx),%es:(%rdi)</span><br><span class="line">  4000a6:       6f                      outsl  %ds:(%rsi),(%dx)</span><br><span class="line">  4000a7:       2c 20                   sub    $0x20,%al</span><br><span class="line">  4000a9:       77 6f                   ja     40011a &lt;message+0x78&gt;</span><br><span class="line">  4000ab:       72 6c                   jb     400119 &lt;message+0x77&gt;</span><br><span class="line">  4000ad:       64                      fs</span><br><span class="line">  4000ae:       0a                      .byte 0xa</span><br></pre></td></tr></table></figure><p>第11行展示了x64 RIP-relative addressing的效果。为什么是0x15呢？计算公式为:0x4000a2 - 0x40008d</p><h3 id="3-Extension"><a href="#3-Extension" class="headerlink" title="3. Extension"></a>3. Extension</h3><p>Intel SDM Vol2 2.2.1.6 RIP-Relative Addressing</p><blockquote><p>A new addressing form, RIP-relative (relative instruction-pointer) addressing, is implemented in 64-bit mode. An effective address is formed by adding displacement to the 64-bit RIP of the next instruction.</p></blockquote><p>想了解更多细节的话，请查阅SDM。</p><hr><p>参考资料:</p><ol><li><a href="https://sourceware.org/binutils/docs/as/i386_002dMemory.html" target="_blank" rel="noopener">Memory References</a></li><li><a href="https://software.intel.com/content/www/us/en/develop/articles/introduction-to-x64-assembly.html" target="_blank" rel="noopener">Introduction to x64 Assembly</a></li><li><a href="https://stackoverflow.com/questions/3250277/how-to-use-rip-relative-addressing-in-a-64-bit-assembly-program" target="_blank" rel="noopener">How to use RIP Relative Addressing in a 64-bit assembly program?</a></li><li><a href="https://www.polarxiong.com/archives/x64%E4%B8%8BPIC%E7%9A%84%E6%96%B0%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-RIP%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.html" target="_blank" rel="noopener">x64下PIC的新寻址方式：RIP相对寻址</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍x64 RIP-relative addressing的使用方法。
    
    </summary>
    
      <category term="计算机编程" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机编程" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Notes about system call</title>
    <link href="http://liujunming.github.io/2021/04/10/Notes-about-system-call/"/>
    <id>http://liujunming.github.io/2021/04/10/Notes-about-system-call/</id>
    <published>2021-04-10T10:49:52.000Z</published>
    <updated>2021-04-10T12:24:50.645Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要汇总system call相关资料。<a id="more"></a></p><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h3><p>建议阅读<a href="https://cs.lmu.edu/~ray/notes/syscalls/" target="_blank" rel="noopener">ray的notes</a>，并编译运行里面的程序。</p><p><a href="/pdf/syscall/System Calls.pdf">ray’s notes</a></p><p><a href="/pdf/syscall/Linux System Call Table for x86 64 · Ryan A. Chapman.pdf">LINUX SYSTEM CALL TABLE FOR X86 64</a></p><h3 id="2-syscall-vs-sysenter-vs-int-0x80"><a href="#2-syscall-vs-sysenter-vs-int-0x80" class="headerlink" title="2. syscall vs sysenter vs int 0x80"></a>2. syscall vs sysenter vs int 0x80</h3><blockquote><ul><li><code>syscall</code> is the default way of entering kernel mode on <code>x86-64</code>. This instruction is not available in 32 bit modes of operation <em>on Intel processors</em>.</li><li><code>sysenter</code> is an instruction most frequently used to invoke system calls in 32 bit modes of operation. It is similar to <code>syscall</code>, a bit more difficult to use though, but that is the kernel’s concern.</li><li><code>int 0x80</code> is a legacy way to invoke a system call and should be avoided.</li></ul></blockquote><p><a href="https://stackoverflow.com/questions/12806584/what-is-better-int-0x80-or-syscall-in-32-bit-code-on-linux" target="_blank" rel="noopener">What is better “int 0x80” or “syscall” in 32-bit code on Linux?</a></p><p>传统的int 0x80有点慢, Intel实现了sysenter和syscall, 即所谓的快速系统调用指令, 使用它们更快。</p><h3 id="3-vDSO-virtual-dynamic-shared-object"><a href="#3-vDSO-virtual-dynamic-shared-object" class="headerlink" title="3. vDSO(virtual dynamic shared object)"></a>3. vDSO(virtual dynamic shared object)</h3><p>首先运行几个指令，给读者直观地展示vDSO，测试环境为64-bit Linux。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:/proc$ cat /proc/self/maps | tail -2</span><br><span class="line">7ffe0ce1b000-7ffe0ce1d000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line">acrn@acrn:/proc$ cat /proc/self/maps | tail -2</span><br><span class="line">7ffc9c356000-7ffc9c358000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure><p>Note that the vDSO area has moved, while the vsyscall page remains at the same location. The location of the vsyscall page is nailed down in the kernel ABI, but the vDSO area - like most other areas in the user-space memory layout - has its location randomized every time it is mapped.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">acrn@acrn:/proc$ ldd /bin/sh</span><br><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffc03ffd000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2d40401000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f2d409f3000)</span><br></pre></td></tr></table></figure><p><code>linux-vdso.so.1</code> is a virtual shared object that doesn’t have any physical file on the disk; it’s a part of the kernel that’s exported into every program’s address space when it’s loaded.</p><p>For a more detailed description, <code>man vdso</code></p><p><a href="https://en.wikipedia.org/wiki/VDSO" target="_blank" rel="noopener">wikipedia</a>较好地介绍了vDSO。</p><h4 id="3-1-Introduction"><a href="#3-1-Introduction" class="headerlink" title="3.1 Introduction"></a>3.1 Introduction</h4><blockquote><p><strong>vDSO (virtual dynamic shared object)</strong> is a kernel mechanism for exporting a carefully selected set of kernel space routines to user space applications so that applications can call these kernel space routines in-process, without incurring the performance penalty of a mode switch from user mode to kernel mode that is inherent when calling these same kernel space routines by means of the system call interface.</p></blockquote><h4 id="3-2-Virtual-dynamic-shared-object"><a href="#3-2-Virtual-dynamic-shared-object" class="headerlink" title="3.2 Virtual dynamic shared object"></a>3.2 Virtual dynamic shared object</h4><blockquote><p>vDSO uses standard mechanisms for linking and loading i.e. standard Executable and Linkable Format (ELF) format. vDSO is a memory area allocated in user space which exposes some kernel functionalities. vDSO is dynamically allocated, offers improved safety through address space layout randomization, and supports more than 4 system calls. Some C standard libraries, like glibc, may provide vDSO links so that if the kernel does not have vDSO support, a traditional syscall is made. vDSO helps to reduce the calling overhead on simple kernel routines, and it also can work as a way to select the best system-call method on some computer architectures such as IA-32. </p></blockquote><h4 id="3-3-Vsyscall"><a href="#3-3-Vsyscall" class="headerlink" title="3.3 Vsyscall"></a>3.3 Vsyscall</h4><blockquote><p>DSO was developed to offer the vsyscall features while overcoming its limitations: a small amount of statically allocated memory, which allows only 4 system calls, and the same addresses application binary interface (ABI) in each process, which compromises security. This security issue has been mitigated by emulating a virtual system call, but the emulation introduces additional latency.</p></blockquote><h3 id="4-extension"><a href="#4-extension" class="headerlink" title="4. extension"></a>4. extension</h3><p>Linux内核中system call的实现，以及vDSO的具体实现较为复杂，本文不会介绍相关内容。读者若有兴趣，可以参阅本文引用的链接。当然，读者可以结合源码以及相关资料去学习具体的实现细节。</p><hr><p>参考资料：</p><ol><li><a href="https://lwn.net/Articles/446528/" target="_blank" rel="noopener">On vsyscalls and the vDSO</a></li><li><a href="https://stackoverflow.com/questions/58657036/where-is-linux-vdso-so-1-present-on-the-file-system" target="_blank" rel="noopener">Where is linux-vdso.so.1 present on the file system</a></li><li><a href="https://stackoverflow.com/questions/19938324/what-are-vdso-and-vsyscall" target="_blank" rel="noopener">What are vdso and vsyscall?</a></li><li><a href="https://blog.csdn.net/luozhaotian/article/details/79609077" target="_blank" rel="noopener">VDSO与vsyscall</a></li><li><a href="https://blog.packagecloud.io/eng/2017/03/08/system-calls-are-much-slower-on-ec2/" target="_blank" rel="noopener">Two frequently used system calls are ~77% slower on AWS EC2</a></li><li><a href="https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/" target="_blank" rel="noopener">The Definitive Guide to Linux System Calls</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要汇总system call相关资料。
    
    </summary>
    
      <category term="操作系统" scheme="http://liujunming.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://liujunming.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>The usage of .byte in GAS</title>
    <link href="http://liujunming.github.io/2021/04/01/The-usage-of-byte-in-GAS/"/>
    <id>http://liujunming.github.io/2021/04/01/The-usage-of-byte-in-GAS/</id>
    <published>2021-04-01T08:05:30.000Z</published>
    <updated>2021-04-01T12:26:34.269Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍<a href="/2021/03/29/Notes-for-GNU-related-knowledge/#GAS">GAS</a>中 <code>.byte</code>的用法。<a id="more"></a></p><p><a href="https://sourceware.org/binutils/docs/as/Byte.html#Byte" target="_blank" rel="noopener">权威说法</a>：</p><blockquote><p><code>.byte</code> expects zero or more expressions, separated by commas. Each expression is assembled into the next byte.</p></blockquote><p>本文主要内容转载自：<a href="https://stackoverflow.com/questions/7290318/what-is-the-use-of-byte-assembler-directive-in-gnu-assembly" target="_blank" rel="noopener">What is the use of .byte assembler directive in gnu assembly?</a></p><p><strong>Minimal runnable example</strong></p><p><code>.byte</code> spits out bytes wherever you are. </p><p>If you happen to be in the text segment, then that byte might get run like code.</p><p>Here’s a Linux x86_64 implementation of <code>exit(0)</code> with a <code>nop</code> thrown in:</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    mov $<span class="number">60</span>, %rax</span><br><span class="line">    nop</span><br><span class="line">    mov $<span class="number">0</span>, %rdi</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p>produces the exact same executable as:</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    mov $<span class="number">60</span>, %rax</span><br><span class="line">    .byte <span class="number">0x90</span></span><br><span class="line">    mov $<span class="number">0</span>, %rdi</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p>since <code>nop</code> is encoded as the byte <code>0x90</code>.</p><p><img src="/images/2021/04/1.PNG" alt></p><p>Here’s the method to run the example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as -o my_exit.o my_exit.s &amp;&amp; ld -s -o my_exit my_exit.o &amp;&amp; ./my_exit</span><br></pre></td></tr></table></figure><p><strong>One use case: new instructions</strong></p><p>One use case is when new instructions are added to a CPU ISA, but only very edge versions of the assembler would support it.</p><p>So project maintainers may choose to inline the bytes directly to make it compilable on older assemblers.</p><p>See for example this Spectre workaround on the Linux kernel with the analogous <code>.inst</code> directive: <a href="https://github.com/torvalds/linux/blob/94710cac0ef4ee177a63b5227664b38c95bbf703/arch/arm/include/asm/barrier.h#L23" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/94710cac0ef4ee177a63b5227664b38c95bbf703/arch/arm/include/asm/barrier.h#L23</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSDB    <span class="meta-string">".inst  0xe320f014"</span></span></span><br></pre></td></tr></table></figure><p>A new instruction was added for Spectre, and the kernel decided to hardcode it for the time being.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍&lt;a href=&quot;/2021/03/29/Notes-for-GNU-related-knowledge/#GAS&quot;&gt;GAS&lt;/a&gt;中 &lt;code&gt;.byte&lt;/code&gt;的用法。
    
    </summary>
    
      <category term="计算机编程" scheme="http://liujunming.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机编程" scheme="http://liujunming.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
