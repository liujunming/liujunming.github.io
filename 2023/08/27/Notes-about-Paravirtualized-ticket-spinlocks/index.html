<!DOCTYPE html>
<html lang="zh-CN">
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Notes about Paravirtualized ticket spinlocks">




  <meta name="keywords" content="虚拟化, KVM, Concurrency, L">










  <link rel="alternate" href="/atom.xml" title="L">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1">



<link rel="canonical" href="http://liujunming.github.io/2023/08/27/Notes-about-Paravirtualized-ticket-spinlocks/">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1">



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> Notes about Paravirtualized ticket spinlocks - L </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">L</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/links">
        <li class="mobile-menu-item">
          
          
            Links
          
        </li>
      </a>
    
      <a href="/books">
        <li class="mobile-menu-item">
          
          
            Books
          
        </li>
      </a>
    
      <a href="/course">
        <li class="mobile-menu-item">
          
          
            Course
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">L</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/links">
            
            
              Links
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/books">
            
            
              Books
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/course">
            
            
              Course
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Notes about Paravirtualized ticket spinlocks
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2023-08-27
        </span>
        
          <span class="post-category">
            
              <a href="/categories/KVM/">KVM</a>
            
          </span>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Background"><span class="toc-text">Background</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview"><span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化"><span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kvm-side"><span class="toc-text">kvm side</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#guest-side"><span class="toc-text">guest side</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#halt-when-vCPU-is-blocked-by-a-held-lock"><span class="toc-text">halt when vCPU is blocked by a held lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#guest-side-1"><span class="toc-text">guest side</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kvm-side-1"><span class="toc-text">kvm side</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kick-the-halted-vCPU-until-the-lock-is-detected-to-be-available"><span class="toc-text">kick the halted vCPU until the lock is detected to be available</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#guest-side-2"><span class="toc-text">guest side</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kvm-side-2"><span class="toc-text">kvm side</span></a></li></ol></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p>本文将mark下kvm中的Paravirtualized ticket spinlocks相关notes。<br>参考内核版本为v5.0，主要内容转载自<a href="http://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/10/01/kvm-performance-2" target="_blank" rel="noopener">kvm performance optimization technologies, part two</a>。<a id="more"></a></p>
<p>在kvm中，也会将Paravirtualized ticket spinlocks称为PV unhalt。</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Now, suppose that vCPU A grabs a spinlock, and before it finishes, is preempted by the scheduler. And then suppose vCPU B tries to grab the spinlock. Now B, instead of spinning for the short period of time that A needed the spinlock for, will be spinning until vCPU is scheduled again — which may be anywhere from several milliseconds to hundreds of milliseconds, depending on how busy the system is. B is now using the cpu but accomplishing nothing. It’s burning up its VM’s share of CPU time, and keeping other VMs with useful work to do from running. Worse yet, it may even be that the reason A is not running is that the hypervisor’s scheduler is trying to give priority to B — so B is actively keeping A from finishing the work that it needed to do with the spinlock.</p>
<p>The situation gets even worse with a more advanced form of spinlock called a ticketlock. Ticketlocks have a lot of advantages for large systems, including reduced cacheline bouncing and more predictable wait time. (See this <a href="https://lwn.net/Articles/267968/" target="_blank" rel="noopener">LWN article</a> for a complete description.) The key attribute for this discussion is that ticketlocks essentially make a first-come first-served queue: if A has the lock, then B tries to grab it, and then C, B is guaranteed to get the lock before C. So now, if C is spinning waiting for the lock, it must wait for both A and B to finish before it can get the lock.</p>
<p>The result is that on a moderately loaded system, the vast majority of the cpu cycles are actually spent waiting for ticketlocks rather than doing any useful work. This is called a “ticketlock storm”. </p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>The PV unhalt feature is used to set the <code>pv_lock_ops</code> to rewrite the native spinlock’s function so it can be more optimizated.</p>
<p>Though the total implementation of pv spinlock is related with the spinlock implementation such as ticketlock and queued spinlock, the basic idea behind the pv spinlock is the same. That is <strong>instead of spining while the vCPU can’t get the spinlock, it will execute halt instruction and let the other vCPU got scheduled. When the vCPU can get the spinlock, allows a vCPU to kick the target vCPU out of halt state.</strong></p>
<p>When the time spent waiting for a lock reaches a given threshold, kvm is notified via a hypercall that a vCPU is currently blocked by a held lock. KVM then halts the waiting vCPU until the lock is detected to be available.</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="kvm-side"><a href="#kvm-side" class="headerlink" title="kvm side"></a>kvm side</h3><p>kvm should expose the <code>KVM_FEATURE_PV_UNHALT</code> to the guest.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 function,</span><br><span class="line">                 u32 index, <span class="keyword">int</span> *nent, <span class="keyword">int</span> maxnent)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> KVM_CPUID_FEATURES:</span><br><span class="line">        entry-&gt;eax = (<span class="number">1</span> &lt;&lt; KVM_FEATURE_CLOCKSOURCE) |</span><br><span class="line">                 ...</span><br><span class="line">                 (<span class="number">1</span> &lt;&lt; KVM_FEATURE_PV_UNHALT) |</span><br><span class="line">                 ...</span><br></pre></td></tr></table></figure></p>
<h3 id="guest-side"><a href="#guest-side" class="headerlink" title="guest side"></a>guest side</h3><p>When the guest startup, <code>kvm_spinlock_init</code> is used to initialize the pv spinlock.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">kvm_spinlock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!kvm_para_available())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* Does host kernel support KVM_FEATURE_PV_UNHALT? */</span></span><br><span class="line">    <span class="keyword">if</span> (!kvm_para_has_feature(KVM_FEATURE_PV_UNHALT))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kvm_para_has_hint(KVM_HINTS_REALTIME))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't use the pvqspinlock code if there is only 1 vCPU. */</span></span><br><span class="line">    <span class="keyword">if</span> (num_possible_cpus() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    __pv_init_lock_hash();</span><br><span class="line">    pv_ops.lock.queued_spin_lock_slowpath = __pv_queued_spin_lock_slowpath;</span><br><span class="line">    pv_ops.lock.queued_spin_unlock =</span><br><span class="line">        PV_CALLEE_SAVE(__pv_queued_spin_unlock);</span><br><span class="line">    pv_ops.lock.wait = kvm_wait;</span><br><span class="line">    pv_ops.lock.kick = kvm_kick_cpu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kvm_para_has_feature(KVM_FEATURE_STEAL_TIME)) &#123;</span><br><span class="line">        pv_ops.lock.vcpu_is_preempted =</span><br><span class="line">            PV_CALLEE_SAVE(__kvm_vcpu_is_preempted);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最值得关注的函数是<code>kvm_wait</code>和<code>kvm_kick_cpu</code>，会在下面进行详细的介绍。</p>
<h2 id="halt-when-vCPU-is-blocked-by-a-held-lock"><a href="#halt-when-vCPU-is-blocked-by-a-held-lock" class="headerlink" title="halt when vCPU is blocked by a held lock"></a>halt when vCPU is blocked by a held lock</h2><h3 id="guest-side-1"><a href="#guest-side-1" class="headerlink" title="guest side"></a>guest side</h3><p>When the vCPU can’t get the spinlock, it will call wait callback.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">pv_wait</span><span class="params">(u8 *ptr, u8 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOP_VCALL2(lock.wait, ptr, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then it will execute the halt instruction in <code>kvm_wait</code>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_wait</span><span class="params">(u8 *ptr, u8 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_nmi())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (READ_ONCE(*ptr) != val)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * halt until it's our turn and kicked. Note that we do safe halt</span></span><br><span class="line"><span class="comment">     * for irq enabled case to avoid hang when lock info is overwritten</span></span><br><span class="line"><span class="comment">     * in irq spinlock slowpath and no spurious interrupt occur to save us.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (arch_irqs_disabled_flags(flags))</span><br><span class="line">        halt();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        safe_halt();</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="kvm-side-1"><a href="#kvm-side-1" class="headerlink" title="kvm side"></a>kvm side</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handle_halt</span><br><span class="line">└── kvm_emulate_halt</span><br><span class="line">    └── kvm_vcpu_halt</span><br></pre></td></tr></table></figure>
<p>When the guest execute halt instruction, the <code>kvm_emulate_halt</code>-&gt;<code>kvm_vcpu_halt</code> will be called. This will set the <code>vcpu-&gt;arch.mp_state</code> to <code>KVM_MP_STATE_HALTED</code>. Then <code>vcpu_block</code> will be called to block this vCPU.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vcpu_run</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm</span> *<span class="title">kvm</span> = <span class="title">vcpu</span>-&gt;<span class="title">kvm</span>;</span></span><br><span class="line"></span><br><span class="line">    vcpu-&gt;srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu);</span><br><span class="line">    vcpu-&gt;arch.l1tf_flush_l1d = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (kvm_vcpu_running(vcpu)) &#123;</span><br><span class="line">            r = vcpu_enter_guest(vcpu);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = vcpu_block(kvm, vcpu);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">vcpu_block</span><span class="params">(struct kvm *kvm, struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!kvm_arch_vcpu_runnable(vcpu) &amp;&amp;</span><br><span class="line">        (!kvm_x86_ops-&gt;pre_block || kvm_x86_ops-&gt;pre_block(vcpu) == <span class="number">0</span>)) &#123;</span><br><span class="line">        srcu_read_unlock(&amp;kvm-&gt;srcu, vcpu-&gt;srcu_idx);</span><br><span class="line">        kvm_vcpu_block(vcpu);</span><br><span class="line">        vcpu-&gt;srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kvm_x86_ops-&gt;post_block)</span><br><span class="line">            kvm_x86_ops-&gt;post_block(vcpu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!kvm_check_request(KVM_REQ_UNHALT, vcpu))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kvm_apic_accept_events(vcpu);</span><br><span class="line">    <span class="keyword">switch</span>(vcpu-&gt;arch.mp_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> KVM_MP_STATE_HALTED:</span><br><span class="line">        vcpu-&gt;arch.pv.pv_unhalted = <span class="literal">false</span>;</span><br><span class="line">        vcpu-&gt;arch.mp_state =</span><br><span class="line">            KVM_MP_STATE_RUNNABLE;</span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">    <span class="keyword">case</span> KVM_MP_STATE_RUNNABLE:</span><br><span class="line">        vcpu-&gt;arch.apf.halted = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KVM_MP_STATE_INIT_RECEIVED:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -EINTR;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kick-the-halted-vCPU-until-the-lock-is-detected-to-be-available"><a href="#kick-the-halted-vCPU-until-the-lock-is-detected-to-be-available" class="headerlink" title="kick the halted vCPU until the lock is detected to be available"></a>kick the halted vCPU until the lock is detected to be available</h2><h3 id="guest-side-2"><a href="#guest-side-2" class="headerlink" title="guest side"></a>guest side</h3><p>When the halted vCPU can get the spinlock, the <code>kick</code> callback will be called by <code>pv_kick</code> by a running vCPU. The <code>kvm_kick_cpu</code> will be called and this trigger a <code>KVM_HC_KICK_CPU</code> hypercall.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">pv_kick</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOP_VCALL1(lock.kick, cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Kick a cpu by its apicid. Used to wake up a halted vcpu */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_kick_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> apicid;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    apicid = per_cpu(x86_cpu_to_apicid, cpu);</span><br><span class="line">    kvm_hypercall2(KVM_HC_KICK_CPU, flags, apicid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="kvm-side-2"><a href="#kvm-side-2" class="headerlink" title="kvm side"></a>kvm side</h3><p>When the guest trigger <code>KVM_HC_KICK_CPU</code> hypercall, <code>kvm_pv_kick_cpu_op</code> will be called.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_emulate_hypercall</span><span class="params">(struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> KVM_HC_KICK_CPU:</span><br><span class="line">        kvm_pv_kick_cpu_op(vcpu-&gt;kvm, a0, a1);</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The <code>kvm_pv_kick_cpu_op</code> will send an interrupt to the lapic.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kvm_pv_kick_cpu_op:  Kick a vcpu.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @apicid - apicid of vcpu to be kicked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_pv_kick_cpu_op</span><span class="params">(struct kvm *kvm, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">int</span> apicid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_lapic_irq</span> <span class="title">lapic_irq</span>;</span></span><br><span class="line"></span><br><span class="line">    lapic_irq.shorthand = <span class="number">0</span>;</span><br><span class="line">    lapic_irq.dest_mode = <span class="number">0</span>;</span><br><span class="line">    lapic_irq.level = <span class="number">0</span>;</span><br><span class="line">    lapic_irq.dest_id = apicid;</span><br><span class="line">    lapic_irq.msi_redir_hint = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    lapic_irq.delivery_mode = APIC_DM_REMRD;</span><br><span class="line">    kvm_irq_delivery_to_apic(kvm, <span class="literal">NULL</span>, &amp;lapic_irq, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kvm_irq_delivery_to_apic</span><br><span class="line">└── kvm_apic_set_irq</span><br><span class="line">    └── __apic_accept_irq</span><br></pre></td></tr></table></figure>
<p>Then in <code>__apic_accept_irq</code> it will kick the blocked vCPU.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add a pending IRQ into lapic.</span></span><br><span class="line"><span class="comment"> * Return 1 if successfully added and 0 if discarded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __apic_accept_irq(struct kvm_lapic *apic, <span class="keyword">int</span> delivery_mode,</span><br><span class="line">                 <span class="keyword">int</span> <span class="built_in">vector</span>, <span class="keyword">int</span> level, <span class="keyword">int</span> trig_mode,</span><br><span class="line">                 struct dest_map *dest_map)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> APIC_DM_REMRD:</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">        vcpu-&gt;arch.pv.pv_unhalted = <span class="number">1</span>;</span><br><span class="line">        kvm_make_request(KVM_REQ_EVENT, vcpu);</span><br><span class="line">        kvm_vcpu_kick(vcpu);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>For the halted vCPU, then <code>kvm_vcpu_block</code> returns, it will set <code>vcpu-&gt;arch.mp_state</code> to <code>KVM_MP_STATE_RUNNABLE</code> and let the halted vCPU enter Non-root mode to get the spinlock.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">vcpu_block</span><span class="params">(struct kvm *kvm, struct kvm_vcpu *vcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!kvm_arch_vcpu_runnable(vcpu) &amp;&amp;</span><br><span class="line">        (!kvm_x86_ops-&gt;pre_block || kvm_x86_ops-&gt;pre_block(vcpu) == <span class="number">0</span>)) &#123;</span><br><span class="line">        srcu_read_unlock(&amp;kvm-&gt;srcu, vcpu-&gt;srcu_idx);</span><br><span class="line">        kvm_vcpu_block(vcpu);</span><br><span class="line">        vcpu-&gt;srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kvm_x86_ops-&gt;post_block)</span><br><span class="line">            kvm_x86_ops-&gt;post_block(vcpu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时kvm_check_request(KVM_REQ_UNHALT, vcpu)为true</span></span><br><span class="line">        <span class="comment">// 因为__apic_accept_irq调用了kvm_make_request(KVM_REQ_EVENT, vcpu)</span></span><br><span class="line">        <span class="keyword">if</span> (!kvm_check_request(KVM_REQ_UNHALT, vcpu))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kvm_apic_accept_events(vcpu);</span><br><span class="line">    <span class="keyword">switch</span>(vcpu-&gt;arch.mp_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> KVM_MP_STATE_HALTED:</span><br><span class="line">        vcpu-&gt;arch.pv.pv_unhalted = <span class="literal">false</span>;</span><br><span class="line">        vcpu-&gt;arch.mp_state =</span><br><span class="line">            KVM_MP_STATE_RUNNABLE;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>参考资料:</p>
<ol>
<li><a href="http://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/10/01/kvm-performance-2" target="_blank" rel="noopener">kvm performance optimization technologies, part two</a></li>
<li><a href="https://lore.kernel.org/kvm/20120323080503.14568.43092.sendpatchset@codeblue/" target="_blank" rel="noopener">kvm : Paravirt-spinlock support for KVM guests</a></li>
<li><a href="https://people.cs.pitt.edu/~ouyang/files/paper/vee13-pmtlock-paper.pdf" target="_blank" rel="noopener">Preemptable Ticket Spinlocks: Improving Consolidated Performance in the Cloud</a></li>
<li><a href="https://wiki.xenproject.org/wiki/Benchmarking_the_new_PV_ticketlock_implementation" target="_blank" rel="noopener">Benchmarking the new PV ticketlock implementation</a></li>
<li><a href="https://www.researchgate.net/publication/200014431_Lock-holder_preemption_on_Xen" target="_blank" rel="noopener">How to deal with lock-holder preemption</a></li>
<li>Towards scalable multiprocessor virtual machines. In Proceedings of the 3rd conference on Virtual Machine Research And Technology Symposium - Volume 3</li>
</ol>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/虚拟化/">虚拟化</a>
            
              <a href="/tags/KVM/">KVM</a>
            
              <a href="/tags/Concurrency/">Concurrency</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2023/09/03/每周分享第36期/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">每周分享第36期</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2023/08/26/Notes-about-PV-sched-yield/">
        <span class="next-text nav-default">Notes about PV sched yield</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:liujunming1163@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/liujunming" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2016 - 
    
    2023

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">liujunming</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://liujunming.github.io/2023/08/27/Notes-about-Paravirtualized-ticket-spinlocks/';
        this.page.identifier = '2023/08/27/Notes-about-Paravirtualized-ticket-spinlocks/';
        this.page.title = 'Notes about Paravirtualized ticket spinlocks';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//http-liujunming-top-2.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script>

  </body>
</html>
