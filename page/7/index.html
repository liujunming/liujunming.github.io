<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="liujunming's personal blog."/>













  <link rel="alternate" href="/atom.xml" title="L">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1" />



<link rel="canonical" href="http://liujunming.github.io/page/7/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> L </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">L</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/links">
        <li class="mobile-menu-item">
          
          
            Links
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">L</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/links">
            
            
              Links
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <section id="posts" class="posts">
    
      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/07/03/Linux内存管理内核函数/">Linux内存管理内核函数</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-07-03
        </span>
        
          <span class="post-category">
            
              <a href="/categories/内存管理/">内存管理</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="Linux内存管理内核函数"><a href="#Linux内存管理内核函数" class="headerlink" title="Linux内存管理内核函数"></a>Linux内存管理内核函数</h2><h3 id="get-page"><a href="#get-page" class="headerlink" title="get_page"></a>get_page</h3><p><code>get_page(struct page *page)</code><br>让page的count加一，以防在处理page的时候该page被内核释放掉。</p>
<h3 id="put-page"><a href="#put-page" class="headerlink" title="put_page"></a>put_page</h3><p><code>put_page(struct page *page)</code><br>让page的count加减一，一般该函数会与get_page配合使用。</p>
<h3 id="page-cache-release"><a href="#page-cache-release" class="headerlink" title="page_cache_release"></a>page_cache_release</h3><p><code>#define page_cache_release(page)    put_page(page)</code><br>该函数即为put_page(page)</p>
<h3 id="alloc-pages"><a href="#alloc-pages" class="headerlink" title="alloc_pages"></a>alloc_pages</h3><p><code>struct page * alloc_pages(gfp_t gfp_mask, unsigned int order)</code><br>该函数申请的内存是内核内存，而不是用户的内存。<br>alloc_pages（）函数以gfp_mask分配方式分配2的order次方(1&lt;&lt;order)个连续的物理页。</p>
<h3 id="get-free-pages"><a href="#get-free-pages" class="headerlink" title="__get_free_pages"></a>__get_free_pages</h3><p><code>unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)</code><br>与alloc_pages功能相同，只是该函数返回的值为所请求的第一个页的逻辑地址。</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/07/03/get-user-pages函数详解/">get_user_pages函数详解</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-07-03
        </span>
        
          <span class="post-category">
            
              <a href="/categories/内存管理/">内存管理</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>在理解这个函数之前，读者需要理解<a href="http://liujunming.top/2017/07/02/Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%9A%84%E5%85%B3%E7%B3%BB/" target="_blank" rel="noopener">Linux用户虚拟地址和内核虚拟地址的关系</a>。</p>
<p>最近在看内核源码过程中，需要根据进程的虚拟地址，获取page结构体,经过资料查阅，发现了<a href="http://elixir.free-electrons.com/linux/v3.14.69/source/mm/memory.c#L2014" target="_blank" rel="noopener">get_user_pages</a>这个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * get_user_pages() - pin user pages in memory</span></span><br><span class="line"><span class="comment"> * @tsk:	the task_struct to use for page fault accounting, or</span></span><br><span class="line"><span class="comment"> *		NULL if faults are not to be recorded.</span></span><br><span class="line"><span class="comment"> * @mm:		mm_struct of target mm</span></span><br><span class="line"><span class="comment"> * @start:	starting user address</span></span><br><span class="line"><span class="comment"> * @nr_pages:	number of pages from start to pin</span></span><br><span class="line"><span class="comment"> * @write:	whether pages will be written to by the caller</span></span><br><span class="line"><span class="comment"> * @force:	whether to force write access even if user mapping is</span></span><br><span class="line"><span class="comment"> *		readonly. This will result in the page being COWed even</span></span><br><span class="line"><span class="comment"> *		in MAP_SHARED mappings. You do not want this.</span></span><br><span class="line"><span class="comment"> * @pages:	array that receives pointers to the pages pinned.</span></span><br><span class="line"><span class="comment"> *		Should be at least nr_pages long. Or NULL, if caller</span></span><br><span class="line"><span class="comment"> *		only intends to ensure the pages are faulted in.</span></span><br><span class="line"><span class="comment"> * @vmas:	array of pointers to vmas corresponding to each page.</span></span><br><span class="line"><span class="comment"> *		Or NULL if the caller does not require them.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns number of pages pinned. This may be fewer than the number</span></span><br><span class="line"><span class="comment"> * requested. If nr_pages is 0 or negative, returns 0. If no pages</span></span><br><span class="line"><span class="comment"> * were pinned, returns -errno. Each page returned must be released</span></span><br><span class="line"><span class="comment"> * with a put_page() call when it is finished with. vmas will only</span></span><br><span class="line"><span class="comment"> * remain valid while mmap_sem is held.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Must be called with mmap_sem held for read or write.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * get_user_pages walks a process's page tables and takes a reference to</span></span><br><span class="line"><span class="comment"> * each struct page that each user address corresponds to at a given</span></span><br><span class="line"><span class="comment"> * instant. That is, it takes the page that would be accessed if a user</span></span><br><span class="line"><span class="comment"> * thread accesses the given user virtual address at that instant.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This does not guarantee that the page exists in the user mappings when</span></span><br><span class="line"><span class="comment"> * get_user_pages returns, and there may even be a completely different</span></span><br><span class="line"><span class="comment"> * page there in some cases (eg. if mmapped pagecache has been invalidated</span></span><br><span class="line"><span class="comment"> * and subsequently re faulted). However it does guarantee that the page</span></span><br><span class="line"><span class="comment"> * won't be freed completely. And mostly callers simply care that the page</span></span><br><span class="line"><span class="comment"> * contains data that was valid *at some point in time*. Typically, an IO</span></span><br><span class="line"><span class="comment"> * or similar operation cannot guarantee anything stronger anyway because</span></span><br><span class="line"><span class="comment"> * locks can't be held over the syscall boundary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If write=0, the page must not be written to. If the page is written to,</span></span><br><span class="line"><span class="comment"> * set_page_dirty (or set_page_dirty_lock, as appropriate) must be called</span></span><br><span class="line"><span class="comment"> * after the page is finished with, and before put_page is called.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * get_user_pages is typically used for fewer-copy IO operations, to get a</span></span><br><span class="line"><span class="comment"> * handle on the memory by some means other than accesses via the user virtual</span></span><br><span class="line"><span class="comment"> * addresses. The pages may be submitted for DMA to devices or accessed via</span></span><br><span class="line"><span class="comment"> * their kernel linear mapping (via the kmap APIs). Care should be taken to</span></span><br><span class="line"><span class="comment"> * use the correct cache flushing APIs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See also get_user_pages_fast, for performance critical applications.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_user_pages</span><span class="params">(struct task_struct *tsk, struct mm_struct *mm,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages, <span class="keyword">int</span> write,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> force, struct page **pages, struct vm_area_struct **vmas)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flags = FOLL_TOUCH;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pages)</span><br><span class="line">		flags |= FOLL_GET;</span><br><span class="line">	<span class="keyword">if</span> (write)</span><br><span class="line">		flags |= FOLL_WRITE;</span><br><span class="line">	<span class="keyword">if</span> (force)</span><br><span class="line">		flags |= FOLL_FORCE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __get_user_pages(tsk, mm, start, nr_pages, flags, pages, vmas,</span><br><span class="line">				<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数各参数的详细说明在代码注释中已经写的很清楚，下面给出一个demo来看看这个函数的具体用法吧(建议读者先看下<a href="http://liujunming.top/2016/04/22/linux-kernel-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">linux kernel模块化编程入门</a>这篇文章)。</p>
<p>get_user_pages()能获取用户区进程使用内存的某个页(struct page)，然后可以在内核区通过kmap_atomic(), kmap()等函数映射到内核区线性地址，从而可以在内核区向其写入数据。</p>
<p>内核程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pagemap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">class</span> *<span class="title">sample_class</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sample_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sample_release</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t  <span class="title">sample_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>     res;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="keyword">char</span>    *myaddr;</span><br><span class="line">        printk(KERN_INFO <span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line">        down_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line">        res = get_user_pages(current, current-&gt;mm,</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span>)buf,</span><br><span class="line">                <span class="number">1</span>,</span><br><span class="line">                <span class="number">1</span>,              </span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                &amp;page,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                printk(KERN_INFO <span class="string">"Got mmaped.\n"</span>);</span><br><span class="line">                myaddr = kmap(page);</span><br><span class="line">                printk(KERN_INFO <span class="string">"%s\n"</span>, myaddr);</span><br><span class="line">                <span class="built_in">strcpy</span>(myaddr, <span class="string">"Mohan"</span>);</span><br><span class="line">                page_cache_release(page);</span><br><span class="line">        &#125;</span><br><span class="line">        up_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span>   <span class="title">file_operations</span> <span class="title">sample_ops</span> = &#123;</span></span><br><span class="line">        .owner  = THIS_MODULE,</span><br><span class="line">        .open   = sample_open,</span><br><span class="line">        .release = sample_release,</span><br><span class="line">        .write  = sample_write</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">sample_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        ret = register_chrdev(<span class="number">42</span>, <span class="string">"Sample"</span>, &amp;sample_ops);</span><br><span class="line">        sample_class = class_create(THIS_MODULE, <span class="string">"Sample"</span>);</span><br><span class="line">        device_create(sample_class, <span class="literal">NULL</span>, MKDEV(<span class="number">42</span>, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">"Sample"</span>);</span><br><span class="line">        <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">sample_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        device_destroy(sample_class, MKDEV(<span class="number">42</span>, <span class="number">0</span>));</span><br><span class="line">        class_destroy(sample_class);</span><br><span class="line">        unregister_chrdev(<span class="number">42</span>, <span class="string">"Sample"</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(sample_init);</span><br><span class="line">module_exit(sample_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
<p>Makefile文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj-m += sample.o</span><br><span class="line">KDIR := /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<p>测试程序<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">char</span> *ptr;</span><br><span class="line">        fd = open(<span class="string">"/dev/Sample"</span>, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        posix_memalign((<span class="keyword">void</span> **)&amp;ptr, <span class="number">4096</span>, <span class="number">4096</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(ptr, <span class="string">"krishna"</span>, <span class="built_in">strlen</span>(<span class="string">"krishna"</span>));  <span class="comment">//Write String to Driver</span></span><br><span class="line">        write(fd, ptr, <span class="number">4096</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"data is %s\n"</span>, ptr);   <span class="comment">//Read Data from Driver</span></span><br><span class="line">        close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://bbs.chinaunix.net/thread-1924966-1-1.html" target="_blank" rel="noopener">chinaunix</a></li>
<li><a href="https://stackoverflow.com/questions/36337942/how-does-get-user-pages-work-for-linux-driver" target="_blank" rel="noopener">stackoverflow</a></li>
<li><a href="https://krishnamohanlinux.blogspot.jp/2015/02/getuserpages-example.html" target="_blank" rel="noopener">krishnamohanlinux</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/07/02/Linux用户虚拟地址和内核虚拟地址的关系/">Linux用户虚拟地址和内核虚拟地址的关系</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-07-02
        </span>
        
          <span class="post-category">
            
              <a href="/categories/内存管理/">内存管理</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="Linux用户虚拟地址和内核虚拟地址的关系"><a href="#Linux用户虚拟地址和内核虚拟地址的关系" class="headerlink" title="Linux用户虚拟地址和内核虚拟地址的关系"></a>Linux用户虚拟地址和内核虚拟地址的关系</h2><h3 id="知乎larmbr宇的回答"><a href="#知乎larmbr宇的回答" class="headerlink" title="知乎larmbr宇的回答"></a>知乎larmbr宇的回答</h3><ol>
<li><p>现在 Linux 内核是4级页表结构，3级页表的时代是10年前了。 X86_64 架构下，无论 Intel 还是 AMD 的 CPU, 都是四级的硬件页表，所以软件层面的页表至少要4级(否则，进程访问的空间将受限， 因为有一级页表被固定住了，所以3级页表时代，X86_64 只能访问 512GB 空间, 而 X86_64 的设计可访问空间达到 131 072( = 2^47) GB。打个比方就是，省，市，区，县 四级行政规划，硬要嵌套进三级规划，只能表达市，区，县三级，省一级给固定住了, 访问范围缩小了)。</p>
</li>
<li><p>不过你会问：i386 只有三级硬件页表：PUD -&gt; PMD -&gt; PTE， 怎么嵌入四级软件页表结构？ 答案就是虚设一层。打个比方：北京是省级行政单位，如果要按省，市，区，县结构来表达某县，就是: 北京(省)北京(市)XX区XX县， 有一层完全就是占个位而已。有兴趣了解 Linux 页表的变迁历史，可以参考这篇文章：<a href="http://larmbr.com/2014/01/19/the-evolution-of-4-level-page-talbe-in-linux/" target="_blank" rel="noopener">Linux内核4级页表的演进</a></p>
</li>
<li><p>内核空间，用户空间的地址都是虚拟地址，都要经过 MMU 的翻译，变成物理地址。用户空间的虚拟地址，就是按前面所述的走四级页表来翻译。 内核空间虚拟地址是所有进程共享的，重要的是，从效率角度看， 如果同样走四级页表翻译的流程，速度太慢；于是，内核在初始化时，就创建内核空间的映射（因为所有进程共享，有一份就够了），并且，采用的就是线性映射，而不是走页表翻译这种类似哈希表的方式。这样，内核地址的翻译，简化为一条偏移加减指令就行，相比走页表，效率大大提高(不过，内核空间并非完全不用页表，此处讲原理所以简化，详细的看尾注).</p>
</li>
<li><p>至于为什么用户空间不能也像内核空间这么做，原因是用户地址空间是随进程创建才产生的，它的页面可能散布在不同的物理内存中，无法这么做。另外，走页表的过程，不止是翻译的过程，还是一个权限检查的过程，对于不可控的用户态地址，这安全性检查必不可省。而内核空间，只有一份，所有可以提前固定下来一片连续的物理地址空间，按线性方法来映射。这是很正常的优化方法。</p>
</li>
<li><p>那么问题来了，在 Linux 刚引入的时候， i386 4G 的进程空间典型的是 3G user + 1G kernel 的划分，这教科书上都有说。 那按前面的线性方法， 1G 内核空间，只能映射 1G 物理地址空间，这对内核来说，太掣肘了。所以，折衷方案是， Linux 内核只对 1G 内核空间的前 896 MB 按前面所说的方法线性映射, 剩下的 128 MB 的内核空间， 采用动态映射[1]的方式，即按需映射的方式 ，这样，内核态的访问空间更多了。到了 64 位时代， 内核空间大大增大， 这种限制就没了，内核空间可以完全进行线性映射，不过，基于[1]的缘故， 仍保留有动态映射这部分。</p>
</li>
</ol>
<p>[1] 动态映射不全是为了内核空间可以访问更多的物理内存，还有一个重要原因： 当内核需要连续多页面的空间时，如果内核空间全线性映射，那么，可能会出现内核空间碎片化而满足不了这么多连续页面分配的需求。基于此，内核空间也必须有一部分是非线性映射，从而在这碎片化物理地址空间上，用页表构造连续虚拟地址空间,这就是所谓vmalloc空间。</p>
<h3 id="The-kernel-virtual-memory-area-in-x64-Linux"><a href="#The-kernel-virtual-memory-area-in-x64-Linux" class="headerlink" title="The kernel virtual memory area in x64 Linux"></a>The kernel virtual memory area in x64 Linux</h3><p>在课本上介绍的内核的地址空间都为1GB，然而这是在x86Linux上的情况。在x64Linux上内核虚拟地址空间又为多少呢?下面引用quora上的回答：</p>
<blockquote>
<p>Linux for AMD64 (x86_64) uses a 48-bit (“canonical mode”) address space which is divided into two regions.  The kernel’s virtual address space is 128TB and the user virtual address space is also 128TB (thus the two together are a 48-bit address space, though that is NOT contiguous).</p>
</blockquote>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="https://www.zhihu.com/question/34787574/answer/60214771" target="_blank" rel="noopener">知乎 larmbr宇</a></li>
<li><a href="https://www.quora.com/How-large-is-the-kernel-virtual-memory-area-in-x64-Linux-Is-it-still-1GB-as-in-x86-Linux" target="_blank" rel="noopener">quora Jim Dennis</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/07/02/Git的Patch功能/">Git的Patch功能</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-07-02
        </span>
        
          <span class="post-category">
            
              <a href="/categories/工具/">工具</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="Git的Patch功能"><a href="#Git的Patch功能" class="headerlink" title="Git的Patch功能"></a>Git的Patch功能</h2><p>UNIX世界的软件开发大多都是协作式的，因此，Patch（补丁）是一个相当重要的东西，因为几乎所有的大型UNIX项目的普通贡献者，都是通过 Patch来提交代码的。作为最重要的开源项目之一，Linux，也是这样的。普通开发者从软件仓库clone下代码，然后写入代码，做一个Patch， 最后用E-mail发给Linux Kernel的维护者就好了。Git最初作为Linux的版本控制工具，提供了透明、完整、稳定的Patch功能。</p>
<p>我们先介绍一下Patch是什么。如果一个软件有了新版本，我们可以完整地下载新版本的代码进行编译安装。然而，像Linux Kernel这样的大型项目，代码即使压缩，也超过70MB，每次全新下载是有相当大的代价的。然而，每次更新变动的代码可能不超过1MB，因此，我们只 要能够有两个版本代码的diff的数据，应该就可以以极低的代价更新程序了。因此，Larry Wall开发了一个工具：patch。它可以根据一个diff文件进行版本更新。</p>
<p>不过在git中，我们没有必要直接使用diff和patch来做补丁，这样做既危险又麻烦。git提供了两种简单的patch方案。一是用git diff生成的标准patch，二是git format-patch生成的Git专用Patch。</p>
<h3 id="git-diff生成的标准patch"><a href="#git-diff生成的标准patch" class="headerlink" title="git diff生成的标准patch"></a>git diff生成的标准patch</h3><p>我们可以首先用git diff制作一个patch。<br>本文示例的工作目录里最初有一个文件readme.txt，内容是“Git is a distributed version control system.”，放置在master分支中。为了修改代码，我们一般的做法是建立一个新分支：</p>
<p><code>git branch Fix</code><br><code>git checkout Fix</code></p>
<p><img src="/images/2017/7/1.png" alt=""></p>
<p>接下来我们在readme.txt文件里面追加一行，然后执行git diff。<br><code>echo &#39;Fix!!!&#39;&gt;&gt;readme.txt</code><br><code>git diff</code><br><img src="/images/2017/7/2.png" alt=""></p>
<p>我们看到了Git diff的输出，这是一个非常典型的Patch式diff。这样我们可以直接把这个输出变为一个Patch：<br><code>git commit -a -m &quot;Fix&quot;</code><br><code>git diff master &gt; patch</code><br><code>git checkout master</code><br><img src="/images/2017/7/3.png" alt=""></p>
<p>我们现在有一个patch文件，并且切换到了master，接下来我们可以使用git apply来应用这个patch。一般情况下，为了保护master，我们会建立一个专门处理新交来的patch的分支：<br><code>git branch PATCH</code><br><code>git checkout PATCH</code><br><code>git apply patch</code><br><code>git commit -a -m &quot;Patch Apply&quot;</code><br><img src="/images/2017/7/4.png" alt=""></p>
<p>看，现在我们在PATCH分支中应用了这个补丁，我们可以把PATCH分支和Fix比对一下，结果肯定是什么也没有，说明PATCH分支和Fix分支完全一样。patch应用成功。即使有多个文件git diff 也能生成一个patch。</p>
<h3 id="git-format-patch生成的git专用补丁"><a href="#git-format-patch生成的git专用补丁" class="headerlink" title="git format-patch生成的git专用补丁"></a>git format-patch生成的git专用补丁</h3><p>我们同样用上面那个例子的工作目录，这次，我们在Fix分支中的a添加了新行之后，用git format-patch生成一个patch。<br><code>git checkout Fix</code><br><code>echo &#39;Fix!!!&#39;&gt;&gt;readme.txt</code><br><code>git commit -a -m &quot;Fix1&quot;</code><br><code>git format-patch -M master</code></p>
<p><img src="/images/2017/7/5.png" alt=""></p>
<p>git format-patch的-M选项表示这个patch要和那个分支比对。现在它生成了一个patch文件，我们看看那是什么：<br><code>cat 0001-Fix1.patch</code><br><img src="/images/2017/7/6.png" alt=""></p>
<p>看，这次多了好多东西，不仅有diff的信息，还有提交者，时间等等，仔细一看你会发现，这是个E-mail的文件，你可以直接发送它！这种patch，我们要用<code>git am</code>来应用。</p>
<p><code>git checkout master</code><br><code>git branch PATCH</code><br><code>git checkout PATCH</code><br><code>git am 0001-Fix1.patch</code><br><code>git commit -a -m &quot;PATCH apply&quot;</code><br><img src="/images/2017/7/7.png" alt=""><br>在提交了补丁之后，我们可以再看看目前文件readme.txt的情况：</p>
<p><code>cat readme.txt</code><br><img src="/images/2017/7/8.png" alt=""></p>
<p>果然，多了一个Fix!!!</p>
<p>不过要注意的是，如果master与Fix分支中间有多次提交，它会针对每次提交生成一个patch。</p>
<h3 id="两种patch的比较"><a href="#两种patch的比较" class="headerlink" title="两种patch的比较"></a>两种patch的比较</h3><ul>
<li><p>兼容性：很明显，git diff生成的Patch兼容性强。如果你在修改的代码的官方版本库不是Git管理的版本库，那么你必须使用git diff生成的patch才能让你的代码被项目的维护人接受。</p>
</li>
<li><p>除错功能：对于git diff生成的patch，你可以用git apply –check 查看补丁是否能够干净顺利地应用到当前分支中；如果git format-patch 生成的补丁不能打到当前分支，git am会给出提示，并协助你完成打补丁工作，你也可以使用git am -3进行三方合并，详细的做法可以参考git手册或者《Progit》。从这一点上看，两者除错功能都很强。</p>
</li>
<li><p>版本库信息：由于git format-patch生成的补丁中含有这个补丁开发者的名字，因此在应用补丁时，这个名字会被记录进版本库，显然，这样做是恰当的。因此，目前使用Git的开源社区往往建议大家使用format-patch生成补丁。</p>
</li>
</ul>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://www.cnblogs.com/y041039/articles/2411600.html" target="_blank" rel="noopener">老z的博客</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743858312764dca7ad6d0754f76aa562e3789478044000" target="_blank" rel="noopener">git 廖雪峰</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/07/01/内核开发经验/">内核开发经验</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-07-01
        </span>
        
          <span class="post-category">
            
              <a href="/categories/经验/">经验</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>总结下在看Linux源码的过程中的开发经验。</p>
<ul>
<li><p>看内核源码的神器<a href="https://elixir.bootlin.com/linux/latest/source" target="_blank" rel="noopener">LXR</a></p>
</li>
<li><p>有时候需要下Linux内核特定版本，可能在kernel官网中没有找到，此时可以去<a href="https://www.kernel.org/pub/linux/kernel/" target="_blank" rel="noopener">这里</a>下载特定版本内核。</p>
</li>
<li><p>在内核调试的过程中,可以在 <code>/var/log/syslog</code>中查看到一些信息</p>
</li>
<li><p>dmesg时需要用到正则, <code>dmesg | grep ljm</code></p>
</li>
<li><p>在编译内核重启的时候,发现开不了机,很大可能是因为 printk打印的信息太多, 此刻,需要删除这些信息,删除的文件为 /var/log/syslog或者 /var/log/dmesg</p>
</li>
<li><p>编译完内核的时候打开kvm,发现总是报internal error:Network ‘default’ is not active.的错误。<br>首先尝试:<code>sudo virsh net-start default</code><br>否则采取如下方案：<br><a href="http://forums.debian.net/viewtopic.php?f=5&amp;t=94729" target="_blank" rel="noopener">forums</a>上给出了问题的解答,发现是编译内核的时候NAT有些模块没有模块化。<br><img src="/images/2017/6/1.png" alt=""></p>
</li>
<li><p>linux 没有高级选项引导内核的时候</p>
<ul>
<li>在 <code>/etc/default/grub</code>中,注释掉 <code>GRUB_HIDDEN_TIMEOUT</code></li>
<li>sudo update-grub</li>
</ul>
</li>
<li><p>KVM不可用,虚拟机的性能可能很差<br>必须使用CPU的VT技术支持,故需要<a href="http://www.linuxfly.org/post/635/" target="_blank" rel="noopener">开启VT功能</a></p>
</li>
<li><p>安装新的内核,打开kvm系统崩溃<br>经过一周时间的探索,发现是内核版本的问题,当内核选择3.14的时候没有问题,选择3.16内核就会崩溃</p>
</li>
<li><p>current的应用<br>current 指针指向当前在运行的进程，内核代码可以通过使用 current 来使用进程特定的信息。指向 task_struct 的current指针在内核堆栈内，是一个全局项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printk(KERN_INFO <span class="string">"The cuurent process commond ： \"%s\"  the pid ：%i\n"</span>,</span><br><span class="line">current-&gt;comm, current-&gt;pid);<span class="comment">//comm：当前进程执行的程序文件名,pid：当前进程的pid号。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/06/28/XLH-More-effective-memory-deduplication-scanners-through-cross-layer-hints/">XLH: More effective memory deduplication scanners through cross-layer hints</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-06-28
        </span>
        
          <span class="post-category">
            
              <a href="/categories/内存管理/">内存管理</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="XLH"><a href="#XLH" class="headerlink" title="XLH"></a>XLH</h2><p>此论文是ATC’13上的一篇文章，今天特意总结一下，希望对读者会有所帮助。</p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul>
<li><p><a href="https://www.usenix.org/node/174531" target="_blank" rel="noopener">XLH: More Effective Memory Deduplication Scanners Through Cross-layer Hints</a><br>这里可以下载到paper，同时还有视频观看。</p>
</li>
<li><p><a href="http://www.dcs.gla.ac.uk/conferences/resolve12/program.html" target="_blank" rel="noopener">KSM++</a><br>该工作在RESoLVE’12发表过。</p>
<ul>
<li><a href="http://www.dcs.gla.ac.uk/conferences/resolve12/papers/session3_paper2.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="http://www.dcs.gla.ac.uk/conferences/resolve12/ksm_slides.pdf" target="_blank" rel="noopener">slides</a></li>
</ul>
</li>
<li><p><a href="https://publikationen.bibliothek.kit.edu/1000041966" target="_blank" rel="noopener">Efficient Main Memory Deduplication Through Cross Layer Integration</a><br>XLH作者的phd毕业论文，里面内容更加详细。</p>
</li>
<li><p><a href="https://os.itec.kit.edu/deutsch/2652.php" target="_blank" rel="noopener">kit该工作介绍</a></p>
<ul>
<li><a href="https://os.itec.kit.edu/downloads/XLH.patch.gz" target="_blank" rel="noopener">源码下载</a></li>
</ul>
</li>
<li><p>友情链接</p>
<ul>
<li><a href="http://dblp.uni-trier.de/pers/hd/b/Bellosa:Frank" target="_blank" rel="noopener">dblp Frank Bellosa</a></li>
<li><a href="http://os.itec.kit.edu/bellosa" target="_blank" rel="noopener">kit Frank Bellosa</a></li>
</ul>
</li>
<li><p><a href="https://scholar.google.com/scholar?cites=2721624481712550460&amp;as_sdt=2005&amp;sciodt=0,5&amp;hl=zh-CN" target="_blank" rel="noopener">最新动态</a></p>
</li>
</ul>
<h3 id="论文详解"><a href="#论文详解" class="headerlink" title="论文详解"></a>论文详解</h3><p>Cross Layer I/O-based Hints (XLH)</p>
<h4 id="以前工作的缺点"><a href="#以前工作的缺点" class="headerlink" title="以前工作的缺点"></a>以前工作的缺点</h4><p>内存扫描器只能用于重删相对静态的内存页。当前的扫描仪需要相当多的时间来检测新的共享机会（例如5分钟），因此不会充分发挥共享潜力。</p>
<h4 id="贡献点"><a href="#贡献点" class="headerlink" title="贡献点"></a>贡献点</h4><ul>
<li>本文的主要贡献是观察主机中的客户机I/O，并将其用作内存扫描器的触发器，以加快识别新的共享机会。</li>
<li>每当客户机访问他们的后台存储时，XLH会在主机的虚拟文件系统（VFS）层中生成页面提示。然后，XLH在其内容建立后不久就对这些提示的页面进行索引，从而将它们提前进入合并阶段。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="生成重删提示"><a href="#生成重删提示" class="headerlink" title="生成重删提示"></a>生成重删提示</h4><p>当虚拟机从虚拟磁盘映像（VDI）读取数据时，主机中的虚拟DMA控制器处理请求并代表客户机读取物理磁盘。我们的假设是，DMA事务的目标是客户机page cache中的一个页面，因此是一个很好的共享候选。<br><img src="/images/2017/7/9.png" alt=""></p>
<h4 id="存储提示和应对突发增长"><a href="#存储提示和应对突发增长" class="headerlink" title="存储提示和应对突发增长"></a>存储提示和应对突发增长</h4><p>有界循环提示栈被证明是一种适当的数据结构，以低开销存储提示。提示栈保留最后一个未处理的堆栈大小磁盘访问的历史记录。<br><img src="/images/2017/7/10.png" alt=""><br>由于有限循环堆栈的性质，XLH始终处理最新的提示，而当堆栈已满时，旧的提示被覆盖——自动修剪和老化机制证明是快速和健壮的。 不需要定期维护。</p>
<h4 id="处理重删提示"><a href="#处理重删提示" class="headerlink" title="处理重删提示"></a>处理重删提示</h4><p>我们的提示处理循环（下图所示）与KSM已经实现的完整系统扫描喷射（唤醒）交错运行。XLH共享了为KSM设置的全局速率限制，在相同的设置下，产生与未修改的KSM大致相同的CPU负载。<br><img src="/images/2017/7/11.png" alt=""><br>交错比是可配置的; <code>hint_runs</code>提示处理喷射与<code>scan_runs</code>扫描喷射交错。0：1的比例对应于原始的KSM实现。我们的默认比例是1：1。使用这个策略，XLH可以保证在有大量提示的情况下，依然可以执行非I/O共享机会的线性扫描。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>当通知扫描仪最近修改的存储器页面时，可以显着改善存储器重删扫描仪。通过告诉KSM关于I/O操作，XLH实现了这个想法。KSM然后优先处理这些页面，与线性扫描相比，XLH可以获得更好的性能。</p>
<p>基于I/O的提示可以显着提高内存扫描器的有效性，而不会增加扫描仪所带来的开销。 XLH发现比KSM更多的共享机会，并且可以在几分钟之前检测它们。 因此，与之前的线性扫描相比，XLH可以在虚拟之内或者不同虚拟之间挖掘出更多的分享机会。</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/06/27/KVM内核模块重要的数据结构/">KVM内核模块重要的数据结构</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-06-27
        </span>
        
          <span class="post-category">
            
              <a href="/categories/虚拟化/">虚拟化</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>本文展示的代码中,Linux内核版本为<a href="http://elixir.free-electrons.com/linux/v3.14.69/source" target="_blank" rel="noopener">3.14.69</a>。</p>
<h2 id="KVM内核模块重要的数据结构"><a href="#KVM内核模块重要的数据结构" class="headerlink" title="KVM内核模块重要的数据结构"></a>KVM内核模块重要的数据结构</h2><h3 id="kvm结构体"><a href="#kvm结构体" class="headerlink" title="kvm结构体"></a>kvm结构体</h3><p>KVM结构体在    KVM的系统架构中代表一个具体的虚拟机。当通过VM_CREATE_KVM指令创建一个新的KVM结构体对象。</p>
<p><a href="http://elixir.free-electrons.com/linux/v3.14.69/source/include/linux/kvm_host.h#L355" target="_blank" rel="noopener">struct kvm</a>结构体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm</span> &#123;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> mmu_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">slots_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">/* userspace tied to this vm */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_memslots</span> *<span class="title">memslots</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">srcu_struct</span> <span class="title">srcu</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KVM_APIC_ARCHITECTURE</span></span><br><span class="line">	u32 bsp_vcpu_id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpus</span>[<span class="title">KVM_MAX_VCPUS</span>];</span></span><br><span class="line">	<span class="keyword">atomic_t</span> online_vcpus;</span><br><span class="line">	<span class="keyword">int</span> last_boosted_vcpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">vm_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_io_bus</span> *<span class="title">buses</span>[<span class="title">KVM_NR_BUSES</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAVE_KVM_EVENTFD</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">spinlock_t</span>        lock;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">items</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">resampler_list</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>      <span class="title">resampler_lock</span>;</span></span><br><span class="line">	&#125; irqfds;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ioeventfds</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vm_stat</span> <span class="title">stat</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_arch</span> <span class="title">arch</span>;</span></span><br><span class="line">	<span class="keyword">atomic_t</span> users_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> KVM_COALESCED_MMIO_PAGE_OFFSET</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_coalesced_mmio_ring</span> *<span class="title">coalesced_mmio_ring</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> ring_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">coalesced_zones</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">irq_lock</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAVE_KVM_IRQCHIP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Update side is protected by irq_lock and,</span></span><br><span class="line"><span class="comment">	 * if configured, irqfds.lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_irq_routing_table</span> __<span class="title">rcu</span> *<span class="title">irq_routing</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">mask_notifier_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">irq_ack_notifier_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MMU_NOTIFIER) &amp;&amp; defined(KVM_ARCH_WANT_MMU_NOTIFIER)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier</span> <span class="title">mmu_notifier</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mmu_notifier_seq;</span><br><span class="line">	<span class="keyword">long</span> mmu_notifier_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">long</span> tlbs_dirty;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">devices</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>KVM结构体对象包含了vCPU、内存、APIC、IRQ、MMU、Event事件管理等信息。该结构体中的信息主要在KVM虚拟机内部使用，用于跟踪虚拟机的状态。</p>
<p>在KVM中，连接了如下几个重要的结构体成员，它们对虚拟机的运行有重要的作用。</p>
<ul>
<li><p><code>struct kvm_memslots *memslots;</code><br>KVM虚拟机所分配到的内存slot，以数组形式存储这些slot的地址信息。<br>由于客户机物理地址不能直接用于宿主机物理 MMU 进行寻址，所以需要把客户机物理地址转换成宿主机虚拟地址 (Host Virtual Address, HVA)，为此，KVM 用一个 kvm_memory_slot 数据结构来记录每一个地址区间的映射关系，此数据结构包含了对应此映射区间的起始客户机页帧号 (Guest Frame Number, GFN)，映射的内存页数目以及起始宿主机虚拟地址。于是 KVM 就可以实现对客户机物理地址到宿主机虚拟地址之间的转换，也即首先根据客户机物理地址找到对应的映射区间，然后根据此客户机物理地址在此映射区间的偏移量就可以得到其对应的宿主机虚拟地址。进而再通过宿主机的页表也可实现客户机物理地址到宿主机物理地址之间的转换，也即 GPA 到 HPA 的转换。</p>
</li>
<li><p><code>struct kvm_vcpu *vcpus[KVM_MAX_VCPUS];</code><br>KVM虚拟机中包含的vCPU结构体，一个虚拟机CPU对应一个vCPU结构体。</p>
</li>
<li><p><code>struct kvm_io_bus *buses[KVM_NR_BUSES];</code><br>KVM虚拟机中的I/O总线，一条总线对应一个kvm_io_bus结构体，如ISA总线、PCI总线。</p>
</li>
<li><p><code>struct kvm_vm_stat stat;</code><br>KVM虚拟机中的页表、MMU等运行时的状态信息。</p>
</li>
<li><p><code>struct kvm_arch arch;</code><br>KVM的软件arch方面所需要的一些参数。</p>
</li>
</ul>
<h3 id="kvm-vcpu结构体"><a href="#kvm-vcpu结构体" class="headerlink" title="kvm_vcpu结构体"></a>kvm_vcpu结构体</h3><p>在用户通过KVM_CREATE_VCPU系统调用请求创建vCPU之后，KVM子模块讲创建kvm_vcpu结构体并进行初始化操作，然后返回对应的vcpu_fd描述符。在KVM的内部虚拟机调度中，kvm_vcpu和KVM中的相关数据进行操作。</p>
<p><a href="http://elixir.free-electrons.com/linux/v3.14.69/source/include/linux/kvm_host.h#L217" target="_blank" rel="noopener">sruct kvm_vcpu</a>如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm</span> *<span class="title">kvm</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">preempt_notifier</span> <span class="title">preempt_notifier</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line">	<span class="keyword">int</span> vcpu_id;</span><br><span class="line">	<span class="keyword">int</span> srcu_idx;</span><br><span class="line">	<span class="keyword">int</span> mode;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> requests;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> guest_debug;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_run</span> *<span class="title">run</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> fpu_active;</span><br><span class="line">	<span class="keyword">int</span> guest_fpu_loaded, guest_xcr0_loaded;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line">	<span class="keyword">int</span> sigset_active;</span><br><span class="line">	<span class="keyword">sigset_t</span> sigset;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu_stat</span> <span class="title">stat</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAS_IOMEM</span></span><br><span class="line">	<span class="keyword">int</span> mmio_needed;</span><br><span class="line">	<span class="keyword">int</span> mmio_read_completed;</span><br><span class="line">	<span class="keyword">int</span> mmio_is_write;</span><br><span class="line">	<span class="keyword">int</span> mmio_cur_fragment;</span><br><span class="line">	<span class="keyword">int</span> mmio_nr_fragments;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_mmio_fragment</span> <span class="title">mmio_fragments</span>[<span class="title">KVM_MAX_MMIO_FRAGMENTS</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KVM_ASYNC_PF</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		u32 queued;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">done</span>;</span></span><br><span class="line">		<span class="keyword">spinlock_t</span> lock;</span><br><span class="line">	&#125; async_pf;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Cpu relax intercept or pause loop exit optimization</span></span><br><span class="line"><span class="comment">	 * in_spin_loop: set when a vcpu does a pause loop exit</span></span><br><span class="line"><span class="comment">	 *  or cpu relax intercepted.</span></span><br><span class="line"><span class="comment">	 * dy_eligible: indicates whether vcpu is eligible for directed yield.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">bool</span> in_spin_loop;</span><br><span class="line">		<span class="keyword">bool</span> dy_eligible;</span><br><span class="line">	&#125; spin_loop;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">bool</span> preempted;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu_arch</span> <span class="title">arch</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>kvm_vcpu结构体中的字段较多，其中重要的成员如下：</p>
<ul>
<li><p><code>int vcpu_id;</code><br>对应的CPU的ID。</p>
</li>
<li><p><code>struct kvm_run *run;</code><br>vCPU的运行时参数，其中保存了寄存器信息、内存信息、虚拟机状态等各种动态信息。</p>
</li>
<li><p><code>struct kvm_vcpu_arch arch;</code><br>存储有KVM虚拟机的运行时参数，如定时器、中断、内存槽等方面的信息。</p>
</li>
</ul>
<h3 id="kvm-x86-ops结构体"><a href="#kvm-x86-ops结构体" class="headerlink" title="kvm_x86_ops结构体"></a>kvm_x86_ops结构体</h3><p>kvm_x86_ops结构体中包含了针对具体的CPU架构进行虚拟化时的函数指针调用，其定义在Linux内核文件的<a href="http://elixir.free-electrons.com/linux/v3.14.69/source/arch/x86/include/asm/kvm_host.h#L663" target="_blank" rel="noopener">arch/x86/include/asm/kvm_host.h</a>中。该结构体主要包含以下几种类型的操作。</p>
<ul>
<li>CPU VMM状态硬件初始化</li>
<li>vCPU创建与管理</li>
<li>中断管理</li>
<li>寄存器管理</li>
<li>时钟管理</li>
</ul>
<p>kvm_x86_ops结构体中的所有成员都是函数指针，在kvm-intel.ko和kvm-amd.ko这两个不同的模块中，针对各自的体系提供了不同的函数。在KVM的初始化过程和后续的运行过程中，KVM子系统的代码将通过该结构体的函数进行实际的硬件操作。</p>
<p>kvm_x86_ops结构体通过静态初始化。针对amd架构的初始化代码在svm.c中，针对Intel架构的初始化代码在<a href="http://elixir.free-electrons.com/linux/v3.14.69/source/arch/x86/kvm/vmx.c#L8566" target="_blank" rel="noopener">vmx.c</a>中。Intel架构的kvm_x86_ops结构体部分代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kvm_x86_ops</span> <span class="title">vmx_x86_ops</span> = &#123;</span></span><br><span class="line">	.cpu_has_kvm_support = cpu_has_kvm_support,</span><br><span class="line">	.disabled_by_bios = vmx_disabled_by_bios,</span><br><span class="line">	.hardware_setup = hardware_setup,</span><br><span class="line">	.hardware_unsetup = hardware_unsetup,</span><br><span class="line">	.check_processor_compatibility = vmx_check_processor_compat,</span><br><span class="line">	.hardware_enable = hardware_enable,</span><br><span class="line">	.hardware_disable = hardware_disable,</span><br><span class="line">	.cpu_has_accelerated_tpr = report_flexpriority,</span><br><span class="line"></span><br><span class="line">	.vcpu_create = vmx_create_vcpu,</span><br><span class="line">	.vcpu_free = vmx_free_vcpu,</span><br><span class="line">	.vcpu_reset = vmx_vcpu_reset,</span><br><span class="line"></span><br><span class="line">	.prepare_guest_switch = vmx_save_host_state,</span><br><span class="line">	.vcpu_load = vmx_vcpu_load,</span><br><span class="line">	.vcpu_put = vmx_vcpu_put,</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，因为KVM架构要同时考虑不同的架构体系。因此，kvm_x86_ops结构体是在KVM架构的初始化过程中注册并导出成为全局变量，让KVM的各个子模块能够方便地调用。</p>
<p>在<a href="http://elixir.free-electrons.com/linux/v3.14.69/source/arch/x86/kvm/x86.c#L91" target="_blank" rel="noopener">arch/x86/kvm/x86.c</a>中，定义了名为kvm_x86_ops的静态变量，通过export_symbol宏在全局范围内导出。在kvm_init的初始化过程中，通过调用kvm_arch_init函数给kvm_x86_ops赋值，代码如下，其中ops就是通过vmx.c调用kvm_init函数时传入的kvm_x86_ops结构体。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kvm_init_msr_list();</span><br><span class="line"></span><br><span class="line">kvm_x86_ops = ops;</span><br></pre></td></tr></table></figure></p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/06/26/QEMU-KVM-I-O-处理过程/">QEMU/KVM I/O 处理过程</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-06-26
        </span>
        
          <span class="post-category">
            
              <a href="/categories/虚拟化/">虚拟化</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>本文展示的代码中,qemu版本为<a href="https://github.com/qemu/qemu/tree/stable-1.6" target="_blank" rel="noopener">1.6.0</a>, Linux内核版本为<a href="http://elixir.free-electrons.com/linux/v3.12.73/source" target="_blank" rel="noopener">3.12.73</a>。<br>本篇文章主要描述IO从guest vm跳转到kvm和qemu后的处理过程。</p>
<p>首先回顾一下<a href="http://liujunming.top/2017/06/26/KVM%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">kvm的启动过程</a>。qemu通过调用kvm提供的一系列接口来启动kvm。qemu的入口为vl.c中的main函数,main函数通过调用kvm_init 和 machine-&gt;init来初始化kvm。 其中, machine-&gt;init会创建vcpu, 用一个线程去模拟vcpu, 该线程执行的函数为qemu_kvm_cpu_thread_fn, 并且该线程调用kvm_cpu_exec,该函数调用kvm_vcpu_ioctl切换到kvm中,下次从kvm中返回时,会接着执行kvm_vcpu_ioctl之后的代码,判断exit_reason,然后进行相应处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_cpu_exec</span><span class="params">(CPUState *cpu)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_run</span> *<span class="title">run</span> = <span class="title">cpu</span>-&gt;<span class="title">kvm_run</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> ret, run_ret;  </span><br><span class="line">  </span><br><span class="line">    DPRINTF(<span class="string">"kvm_cpu_exec()\n"</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (kvm_arch_process_async_events(cpu)) &#123;  </span><br><span class="line">        cpu-&gt;exit_request = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">return</span> EXCP_HLT;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (cpu-&gt;kvm_vcpu_dirty) &#123;  </span><br><span class="line">            kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE);  </span><br><span class="line">            cpu-&gt;kvm_vcpu_dirty = <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        kvm_arch_pre_run(cpu, run);  </span><br><span class="line">        <span class="keyword">if</span> (cpu-&gt;exit_request) &#123;  </span><br><span class="line">            DPRINTF(<span class="string">"interrupt exit requested\n"</span>);  </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * KVM requires us to reenter the kernel after IO exits to complete </span></span><br><span class="line"><span class="comment">             * instruction emulation. This self-signal will ensure that we </span></span><br><span class="line"><span class="comment">             * leave ASAP again. </span></span><br><span class="line"><span class="comment">             */</span>  </span><br><span class="line">            qemu_cpu_kick_self();  </span><br><span class="line">        &#125;  </span><br><span class="line">        qemu_mutex_unlock_iothread();  </span><br><span class="line">  </span><br><span class="line">        run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">        qemu_mutex_lock_iothread();  </span><br><span class="line">        kvm_arch_post_run(cpu, run);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (run_ret &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (run_ret == -EINTR || run_ret == -EAGAIN) &#123;  </span><br><span class="line">                DPRINTF(<span class="string">"io window exit\n"</span>);  </span><br><span class="line">                ret = EXCP_INTERRUPT;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"error: kvm run failed %s\n"</span>,  </span><br><span class="line">                    strerror(-run_ret));  </span><br><span class="line">            <span class="built_in">abort</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        trace_kvm_run_exit(cpu-&gt;cpu_index, run-&gt;exit_reason);  </span><br><span class="line">        <span class="keyword">switch</span> (run-&gt;exit_reason) &#123;  </span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_IO:  </span><br><span class="line">            DPRINTF(<span class="string">"handle_io\n"</span>);  </span><br><span class="line">            kvm_handle_io(run-&gt;io.port,  </span><br><span class="line">                          (<span class="keyword">uint8_t</span> *)run + run-&gt;io.data_offset,  </span><br><span class="line">                          run-&gt;io.direction,  </span><br><span class="line">                          run-&gt;io.size,  </span><br><span class="line">                          run-&gt;io.count);  </span><br><span class="line">            ret = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_MMIO:  </span><br><span class="line">            DPRINTF(<span class="string">"handle_mmio\n"</span>);  </span><br><span class="line">            cpu_physical_memory_rw(run-&gt;mmio.phys_addr,  </span><br><span class="line">                                   run-&gt;mmio.data,  </span><br><span class="line">                                   run-&gt;mmio.len,  </span><br><span class="line">                                   run-&gt;mmio.is_write);  </span><br><span class="line">            ret = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_IRQ_WINDOW_OPEN:  </span><br><span class="line">            DPRINTF(<span class="string">"irq_window_open\n"</span>);  </span><br><span class="line">            ret = EXCP_INTERRUPT;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_SHUTDOWN:  </span><br><span class="line">            DPRINTF(<span class="string">"shutdown\n"</span>);  </span><br><span class="line">            qemu_system_reset_request();  </span><br><span class="line">            ret = EXCP_INTERRUPT;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_UNKNOWN:  </span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"KVM: unknown exit, hardware reason %"</span> PRIx64 <span class="string">"\n"</span>,  </span><br><span class="line">                    (<span class="keyword">uint64_t</span>)run-&gt;hw.hardware_exit_reason);  </span><br><span class="line">            ret = <span class="number">-1</span>;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_INTERNAL_ERROR:  </span><br><span class="line">            ret = kvm_handle_internal_error(cpu, run);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">default</span>:  </span><br><span class="line">            DPRINTF(<span class="string">"kvm_arch_handle_exit\n"</span>);  </span><br><span class="line">            ret = kvm_arch_handle_exit(cpu, run);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">while</span> (ret == <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        cpu_dump_state(cpu, <span class="built_in">stderr</span>, <span class="built_in">fprintf</span>, CPU_DUMP_CODE);  </span><br><span class="line">        vm_stop(RUN_STATE_INTERNAL_ERROR);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    cpu-&gt;exit_request = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kvm_vcpu_ioctl执行时,调用的kvm函数是virt/kvm/kvm-main.c中的<a href="http://elixir.free-electrons.com/linux/v3.12.73/source/virt/kvm/kvm_main.c#L1968" target="_blank" rel="noopener">kvm_vcpu_ioctl</a>函数。当传入参数为KVM_RUN时,最终会调用vcpu_enter_guest函数, 在vcpu_enter_guest函数中调用了kvm_x86_ops-&gt;run(vcpu),在intel处理器架构中该函数对应的实现为vmx_vcpu_run, vmx_vcpu_run设置好寄存器状态之后调用VM_LAUNCH或者VM_RESUME进入guest vm, 一旦发生vm exit则从此处继续执行下去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">noclone <span class="title">vmx_vcpu_run</span><span class="params">(struct kvm_vcpu *vcpu)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vcpu_vmx</span> *<span class="title">vmx</span> = <span class="title">to_vmx</span>(<span class="title">vcpu</span>);</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> debugctlmsr;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*...此处省略n行代码...*/</span>  </span><br><span class="line">    vmx-&gt;__launched = vmx-&gt;loaded_vmcs-&gt;launched;  </span><br><span class="line">    <span class="keyword">asm</span>(  </span><br><span class="line">        <span class="comment">/* Store host registers */</span>  </span><br><span class="line">        <span class="string">"push %%"</span> _ASM_DX <span class="string">"; push %%"</span> _ASM_BP <span class="string">";"</span>  </span><br><span class="line">        <span class="string">"push %%"</span> _ASM_CX <span class="string">" \n\t"</span> <span class="comment">/* placeholder for guest rcx */</span>  </span><br><span class="line">        <span class="string">"push %%"</span> _ASM_CX <span class="string">" \n\t"</span>  </span><br><span class="line">        <span class="string">"cmp %%"</span> _ASM_SP <span class="string">", %c[host_rsp](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">"je 1f \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%"</span> _ASM_SP <span class="string">", %c[host_rsp](%0) \n\t"</span>  </span><br><span class="line">        __ex(ASM_VMX_VMWRITE_RSP_RDX) <span class="string">"\n\t"</span>  </span><br><span class="line">        <span class="string">"1: \n\t"</span>  </span><br><span class="line">        <span class="comment">/* Reload cr2 if changed */</span>  </span><br><span class="line">        <span class="string">"mov %c[cr2](%0), %%"</span> _ASM_AX <span class="string">" \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%cr2, %%"</span> _ASM_DX <span class="string">" \n\t"</span>  </span><br><span class="line">        <span class="string">"cmp %%"</span> _ASM_AX <span class="string">", %%"</span> _ASM_DX <span class="string">" \n\t"</span>  </span><br><span class="line">        <span class="string">"je 2f \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%"</span> _ASM_AX<span class="string">", %%cr2 \n\t"</span>  </span><br><span class="line">        <span class="string">"2: \n\t"</span>  </span><br><span class="line">        <span class="comment">/* Check if vmlaunch of vmresume is needed */</span>  </span><br><span class="line">        <span class="string">"cmpl $0, %c[launched](%0) \n\t"</span>  </span><br><span class="line">        <span class="comment">/* Load guest registers.  Don't clobber flags. */</span>  </span><br><span class="line">        <span class="string">"mov %c[rax](%0), %%"</span> _ASM_AX <span class="string">" \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %c[rbx](%0), %%"</span> _ASM_BX <span class="string">" \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %c[rdx](%0), %%"</span> _ASM_DX <span class="string">" \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %c[rsi](%0), %%"</span> _ASM_SI <span class="string">" \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %c[rdi](%0), %%"</span> _ASM_DI <span class="string">" \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %c[rbp](%0), %%"</span> _ASM_BP <span class="string">" \n\t"</span>  </span><br><span class="line">#ifdef CONFIG_X86_64  </span><br><span class="line">        <span class="string">"mov %c[r8](%0),  %%r8  \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %c[r9](%0),  %%r9  \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %c[r10](%0), %%r10 \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %c[r11](%0), %%r11 \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %c[r12](%0), %%r12 \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %c[r13](%0), %%r13 \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %c[r14](%0), %%r14 \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %c[r15](%0), %%r15 \n\t"</span>  </span><br><span class="line">#endif  </span><br><span class="line">        <span class="string">"mov %c[rcx](%0), %%"</span> _ASM_CX <span class="string">" \n\t"</span> <span class="comment">/* kills %0 (ecx) */</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* Enter guest mode */</span>  </span><br><span class="line">        <span class="string">"jne 1f \n\t"</span>  </span><br><span class="line">        __ex(ASM_VMX_VMLAUNCH) <span class="string">"\n\t"</span>  </span><br><span class="line">        <span class="string">"jmp 2f \n\t"</span>  </span><br><span class="line">        <span class="string">"1: "</span> __ex(ASM_VMX_VMRESUME) <span class="string">"\n\t"</span>  </span><br><span class="line">        <span class="string">"2: "</span>  </span><br><span class="line">        <span class="comment">/* Save guest registers, load host registers, keep flags */</span>  </span><br><span class="line">        <span class="string">"mov %0, %c[wordsize](%%"</span> _ASM_SP <span class="string">") \n\t"</span>  </span><br><span class="line">        <span class="string">"pop %0 \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%"</span> _ASM_AX <span class="string">", %c[rax](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%"</span> _ASM_BX <span class="string">", %c[rbx](%0) \n\t"</span>  </span><br><span class="line">        __ASM_SIZE(pop) <span class="string">" %c[rcx](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%"</span> _ASM_DX <span class="string">", %c[rdx](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%"</span> _ASM_SI <span class="string">", %c[rsi](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%"</span> _ASM_DI <span class="string">", %c[rdi](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%"</span> _ASM_BP <span class="string">", %c[rbp](%0) \n\t"</span>  </span><br><span class="line">#ifdef CONFIG_X86_64  </span><br><span class="line">        <span class="string">"mov %%r8,  %c[r8](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%r9,  %c[r9](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%r10, %c[r10](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%r11, %c[r11](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%r12, %c[r12](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%r13, %c[r13](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%r14, %c[r14](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%r15, %c[r15](%0) \n\t"</span>  </span><br><span class="line">#endif  </span><br><span class="line">        <span class="string">"mov %%cr2, %%"</span> _ASM_AX <span class="string">"   \n\t"</span>  </span><br><span class="line">        <span class="string">"mov %%"</span> _ASM_AX <span class="string">", %c[cr2](%0) \n\t"</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="string">"pop  %%"</span> _ASM_BP <span class="string">"; pop  %%"</span> _ASM_DX <span class="string">" \n\t"</span>  </span><br><span class="line">        <span class="string">"setbe %c[fail](%0) \n\t"</span>  </span><br><span class="line">        <span class="string">".pushsection .rodata \n\t"</span>  </span><br><span class="line">        <span class="string">".global vmx_return \n\t"</span>  </span><br><span class="line">        <span class="string">"vmx_return: "</span> _ASM_PTR <span class="string">" 2b \n\t"</span>  </span><br><span class="line">        <span class="string">".popsection"</span>  </span><br><span class="line">          : : <span class="string">"c"</span>(vmx), <span class="string">"d"</span>((<span class="keyword">unsigned</span> <span class="keyword">long</span>)HOST_RSP),  </span><br><span class="line">        [launched]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, __launched)),  </span><br><span class="line">        [fail]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, fail)),  </span><br><span class="line">        [host_rsp]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, host_rsp)),  </span><br><span class="line">        [rax]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),  </span><br><span class="line">        [rbx]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),  </span><br><span class="line">        [rcx]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),  </span><br><span class="line">        [rdx]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),  </span><br><span class="line">        [rsi]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),  </span><br><span class="line">        [rdi]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),  </span><br><span class="line">        [rbp]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),  </span><br><span class="line">#ifdef CONFIG_X86_64  </span><br><span class="line">        [r8]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),  </span><br><span class="line">        [r9]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),  </span><br><span class="line">        [r10]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),  </span><br><span class="line">        [r11]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),  </span><br><span class="line">        [r12]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),  </span><br><span class="line">        [r13]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),  </span><br><span class="line">        [r14]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),  </span><br><span class="line">        [r15]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),  </span><br><span class="line">#endif  </span><br><span class="line">        [cr2]<span class="string">"i"</span>(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),  </span><br><span class="line">        [wordsize]<span class="string">"i"</span>(<span class="keyword">sizeof</span>(ulong))  </span><br><span class="line">          : <span class="string">"cc"</span>, <span class="string">"memory"</span>  </span><br><span class="line">#ifdef CONFIG_X86_64  </span><br><span class="line">        , <span class="string">"rax"</span>, <span class="string">"rbx"</span>, <span class="string">"rdi"</span>, <span class="string">"rsi"</span>  </span><br><span class="line">        , <span class="string">"r8"</span>, <span class="string">"r9"</span>, <span class="string">"r10"</span>, <span class="string">"r11"</span>, <span class="string">"r12"</span>, <span class="string">"r13"</span>, <span class="string">"r14"</span>, <span class="string">"r15"</span>  </span><br><span class="line">#<span class="keyword">else</span>  </span><br><span class="line">        , <span class="string">"eax"</span>, <span class="string">"ebx"</span>, <span class="string">"edi"</span>, <span class="string">"esi"</span>  </span><br><span class="line">#endif  </span><br><span class="line">          );  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */</span>  </span><br><span class="line">    <span class="keyword">if</span> (debugctlmsr)  </span><br><span class="line">        update_debugctlmsr(debugctlmsr);  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_X86_64  </span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * The sysexit path does not restore ds/es, so we must set them to </span></span><br><span class="line"><span class="comment">     * a reasonable value ourselves. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * We can't defer this to vmx_load_host_state() since that function </span></span><br><span class="line"><span class="comment">     * may be executed in interrupt context, which saves and restore segments </span></span><br><span class="line"><span class="comment">     * around it, nullifying its effect. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    loadsegment(ds, __USER_DS);  </span><br><span class="line">    loadsegment(es, __USER_DS);  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">    vcpu-&gt;arch.regs_avail = ~((<span class="number">1</span> &lt;&lt; VCPU_REGS_RIP) | (<span class="number">1</span> &lt;&lt; VCPU_REGS_RSP)  </span><br><span class="line">                  | (<span class="number">1</span> &lt;&lt; VCPU_EXREG_RFLAGS)  </span><br><span class="line">                  | (<span class="number">1</span> &lt;&lt; VCPU_EXREG_CPL)  </span><br><span class="line">                  | (<span class="number">1</span> &lt;&lt; VCPU_EXREG_PDPTR)  </span><br><span class="line">                  | (<span class="number">1</span> &lt;&lt; VCPU_EXREG_SEGMENTS)  </span><br><span class="line">                  | (<span class="number">1</span> &lt;&lt; VCPU_EXREG_CR3));  </span><br><span class="line">    vcpu-&gt;arch.regs_dirty = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    vmx-&gt;idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (is_guest_mode(vcpu)) &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vmcs12</span> *<span class="title">vmcs12</span> = <span class="title">get_vmcs12</span>(<span class="title">vcpu</span>);</span>  </span><br><span class="line">        vmcs12-&gt;idt_vectoring_info_field = vmx-&gt;idt_vectoring_info;  </span><br><span class="line">        <span class="keyword">if</span> (vmx-&gt;idt_vectoring_info &amp; VECTORING_INFO_VALID_MASK) &#123;  </span><br><span class="line">            vmcs12-&gt;idt_vectoring_error_code =  </span><br><span class="line">                vmcs_read32(IDT_VECTORING_ERROR_CODE);  </span><br><span class="line">            vmcs12-&gt;vm_exit_instruction_len =  </span><br><span class="line">                vmcs_read32(VM_EXIT_INSTRUCTION_LEN);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    vmx-&gt;loaded_vmcs-&gt;launched = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">    vmx-&gt;exit_reason = vmcs_read32(VM_EXIT_REASON);  </span><br><span class="line">    trace_kvm_exit(vmx-&gt;exit_reason, vcpu, KVM_ISA_VMX);  </span><br><span class="line">  </span><br><span class="line">    vmx_complete_atomic_exit(vmx);  </span><br><span class="line">    vmx_recover_nmi_blocking(vmx);  </span><br><span class="line">    vmx_complete_interrupts(vmx);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2017/6/9.png" alt=""></p>
<p>介绍完初始化的流程,可以介绍IO在kvm和qemu中的处理流程了。当Guest Vm进行IO操作需要访问设备时,就会触发vm exit 返回到vmx_vcpu_run, vmx保存好vmcs并且记录下VM_EXIT_REASON后返回到调用该函数的<a href="http://elixir.free-electrons.com/linux/v3.12.73/source/arch/x86/kvm/x86.c#L5867" target="_blank" rel="noopener">vcpu_enter_guest</a>, 在vcpu_enter_guest函数末尾调用了<a href="http://elixir.free-electrons.com/linux/v3.12.73/source/arch/x86/kvm/x86.c#L6052" target="_blank" rel="noopener">r= kvm_x86_ops-&gt;handle_exit(vcpu)</a>, 该函数对应于<a href="http://elixir.free-electrons.com/linux/v3.12.73/source/arch/x86/kvm/vmx.c#L6759" target="_blank" rel="noopener">vmx_handle_exit</a>函数(intel cpu架构对应关系可以查看vmx.c文件中<a href="http://elixir.free-electrons.com/linux/v3.12.73/source/arch/x86/kvm/vmx.c#L8431" target="_blank" rel="noopener">static struct kvm_x86_ops vmx_x86_ops</a>), vmx_handle_exit 调用kvm_vmx_exit_handlers[exit_reason](vcpu),该语句根据exit_reason调用不同的函数,该数据结构定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*<span class="keyword">const</span> kvm_vmx_exit_handlers[])</span><span class="params">(struct kvm_vcpu *vcpu)</span> </span>= &#123;  </span><br><span class="line">    [EXIT_REASON_EXCEPTION_NMI]           = handle_exception,  </span><br><span class="line">    [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,  </span><br><span class="line">    [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,  </span><br><span class="line">    [EXIT_REASON_NMI_WINDOW]          = handle_nmi_window,  </span><br><span class="line">    [EXIT_REASON_IO_INSTRUCTION]          = handle_io,  </span><br><span class="line">    [EXIT_REASON_CR_ACCESS]               = handle_cr,  </span><br><span class="line">    [EXIT_REASON_DR_ACCESS]               = handle_dr,  </span><br><span class="line">    [EXIT_REASON_CPUID]                   = handle_cpuid,  </span><br><span class="line">    [EXIT_REASON_MSR_READ]                = handle_rdmsr,  </span><br><span class="line">    [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,  </span><br><span class="line">    [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,  </span><br><span class="line">    [EXIT_REASON_HLT]                     = handle_halt,  </span><br><span class="line">    [EXIT_REASON_INVD]            = handle_invd,  </span><br><span class="line">    [EXIT_REASON_INVLPG]              = handle_invlpg,  </span><br><span class="line">    [EXIT_REASON_RDPMC]                   = handle_rdpmc,  </span><br><span class="line">    [EXIT_REASON_VMCALL]                  = handle_vmcall,  </span><br><span class="line">    [EXIT_REASON_VMCLEAR]                 = handle_vmclear,  </span><br><span class="line">    [EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,  </span><br><span class="line">    [EXIT_REASON_VMPTRLD]                 = handle_vmptrld,  </span><br><span class="line">    [EXIT_REASON_VMPTRST]                 = handle_vmptrst,  </span><br><span class="line">    [EXIT_REASON_VMREAD]                  = handle_vmread,  </span><br><span class="line">    [EXIT_REASON_VMRESUME]                = handle_vmresume,  </span><br><span class="line">    [EXIT_REASON_VMWRITE]                 = handle_vmwrite,  </span><br><span class="line">    [EXIT_REASON_VMOFF]                   = handle_vmoff,  </span><br><span class="line">    [EXIT_REASON_VMON]                    = handle_vmon,  </span><br><span class="line">    [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,  </span><br><span class="line">    [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,  </span><br><span class="line">    [EXIT_REASON_WBINVD]                  = handle_wbinvd,  </span><br><span class="line">    [EXIT_REASON_XSETBV]                  = handle_xsetbv,  </span><br><span class="line">    [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,  </span><br><span class="line">    [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,  </span><br><span class="line">    [EXIT_REASON_EPT_VIOLATION]       = handle_ept_violation,  </span><br><span class="line">    [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,  </span><br><span class="line">    [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,  </span><br><span class="line">    [EXIT_REASON_MWAIT_INSTRUCTION]       = handle_invalid_op,  </span><br><span class="line">    [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果是因为IO原因导致的vm exit,则调用的处理函数为<a href="http://elixir.free-electrons.com/linux/v3.12.73/source/arch/x86/kvm/vmx.c#L4871" target="_blank" rel="noopener">handle_io</a>,handle_io的处理可以查看<a href="http://www.aiuxian.com/article/p-2337270.html" target="_blank" rel="noopener">io的虚拟化 </a>, 该过程结束之后需要qemu去处理IO,这时候会返回到qemu, 在kvm_cpu_exec中继续执行下去,看上面kvm_cpu_exec的代码,如果是因为IO原因返回到qemu,会调用kvm_handle_io函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (run-&gt;exit_reason) &#123;</span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_IO:</span><br><span class="line">            DPRINTF(<span class="string">"handle_io\n"</span>);</span><br><span class="line">            kvm_handle_io(run-&gt;io.port,</span><br><span class="line">                          (<span class="keyword">uint8_t</span> *)run + run-&gt;io.data_offset,</span><br><span class="line">                          run-&gt;io.direction,</span><br><span class="line">                          run-&gt;io.size,</span><br><span class="line">                          run-&gt;io.count);</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>kvm_handle_io调用cpu_outb, cpu_outw等指令处理IO操作。</p>
<p>当qemu完成IO操作后,会在kvm_cpu_exec函数的循环中,调用kvm_vcpu_ioctl重新进入kvm。<br><img src="/images/2017/6/10.png" alt=""></p>
<p>以上阐述了IO操作在kvm和qemu中处理的整个过程。</p>
<hr>
<p>参考资料:</p>
<ol>
<li><a href="http://blog.csdn.net/dashulu/article/details/17090293" target="_blank" rel="noopener">csdn dashulu</a></li>
<li><a href="http://www.aiuxian.com/article/p-2337270.html" target="_blank" rel="noopener">io的虚拟化 </a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/06/26/KVM初始化过程/">KVM初始化过程</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-06-26
        </span>
        
          <span class="post-category">
            
              <a href="/categories/虚拟化/">虚拟化</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>本文展示的代码中,qemu版本为<a href="https://github.com/qemu/qemu/tree/stable-1.6" target="_blank" rel="noopener">1.6.0</a>, Linux内核版本为<a href="http://elixir.free-electrons.com/linux/v3.12.73/source" target="_blank" rel="noopener">3.12.73</a></p>
<p>为了介绍qemu和kvm的交互过程,我首先介绍一下kvm给用户提供的接口。kvm是一个内核模块,它实现了一个/dev/kvm的字符设备来与用户进行交互,通过调用一系列ioctl函数可以实现qemu和kvm之间的切换。当要创建一个新的虚拟机时,首先打开/dev/kvm设备,在其上调用ioctl函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system_fd = open(<span class="string">"/dev/kvm"</span>, ORDWR);</span><br><span class="line">vm_fd = ioctl(system_fd, KVM_CREATE_VM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>ioctl函数在kvm中的实现为virt/kvm/kvm_main.c中<a href="http://elixir.free-electrons.com/linux/v3.12.73/source/virt/kvm/kvm_main.c#L2625" target="_blank" rel="noopener">kvm_dev_ioctl</a>函数,当传入的参数为<a href="http://elixir.free-electrons.com/linux/v3.12.73/source/virt/kvm/kvm_main.c#L2637" target="_blank" rel="noopener">KVM_CREATE_VM</a>时,该函数会创建一个VM,并且返回一个fd,通过该fd可以操作虚拟机。</p>
<p>创建完虚拟机之后,需要在该虚拟机上面创建vcpu,调用的接口也是ioctl,只是此时对应的fd为创建虚拟机时返回的fd。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpu_fd = ioctl(vm_fd, VM_CREATE_VCPU, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>此时ioctl函数对应的实现为virt/kvm/kvm_main.c中<a href="http://elixir.free-electrons.com/linux/v3.12.73/source/virt/kvm/kvm_main.c#L2319" target="_blank" rel="noopener">kvm_vm_ioctl</a>函数,当传入的参数为<a href="http://elixir.free-electrons.com/linux/v3.12.73/source/virt/kvm/kvm_main.c#L2329" target="_blank" rel="noopener">VM_CREATE_VCPU</a>时,与KVM_CREATE_VM过程类似,它创建一个vcpu并且返回可以操作该vcpu的fd。</p>
<p>创建完vcpu后,可以在该vcpu上面调用ioctl函数进入guest vm。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = ioctl(vcpu_fd, KVM_RUN, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>此时ioctl函数对应的实现为virt/kvm/kvm_main.c中<a href="http://elixir.free-electrons.com/linux/v3.12.73/source/virt/kvm/kvm_main.c#L1968" target="_blank" rel="noopener">kvm_vcpu_ioctl</a>函数,若传入的参数为<a href="http://elixir.free-electrons.com/linux/v3.12.73/source/virt/kvm/kvm_main.c#L1997" target="_blank" rel="noopener">KVM_RUN</a>,它最终会调用<a href="http://elixir.free-electrons.com/linux/v3.12.73/source/arch/x86/kvm/x86.c#L5867" target="_blank" rel="noopener">vcpu_enter_guest</a>函数进入guest vm。</p>
<p><img src="/images/2017/6/6.png" alt=""></p>
<p>qemu作为一个user mode的程序,其入口为main函数,该main函数定义在<a href="https://github.com/qemu/qemu/blob/stable-1.6/vl.c" target="_blank" rel="noopener">vl.c</a>文件中。main函数比较长,其中跟KVM初始化相关的主要有两个函数:configure_accelerator()和machine-&gt;init(&amp;args)。cofigure_accelerator()函数选择运用哪一种虚拟化方案,其应用到的数据结构为accel_list,会调用accel_list[i].init函数。accel_list的初始化如下所示,当使用kvm虚拟化解决方案时,accel_list[i].init对应的函数即为kvm_init。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *opt_name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> (*available)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">int</span> (*init)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">bool</span> *allowed;</span><br><span class="line">&#125; accel_list[] = &#123;</span><br><span class="line">    &#123; <span class="string">"tcg"</span>, <span class="string">"tcg"</span>, tcg_available, tcg_init, &amp;tcg_allowed &#125;,</span><br><span class="line">    &#123; <span class="string">"xen"</span>, <span class="string">"Xen"</span>, xen_available, xen_init, &amp;xen_allowed &#125;,</span><br><span class="line">    &#123; <span class="string">"kvm"</span>, <span class="string">"KVM"</span>, kvm_available, kvm_init, &amp;kvm_allowed &#125;,</span><br><span class="line">    &#123; <span class="string">"qtest"</span>, <span class="string">"QTest"</span>, qtest_available, qtest_init, &amp;qtest_allowed &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>kvm_init函数定义在<a href="https://github.com/qemu/qemu/blob/stable-1.6/kvm-all.c" target="_blank" rel="noopener">kvm-all.c</a>文件中,其主要功能是打开/dev/kvm设备,创建一个虚拟机。</p>
<p>machine-&gt;init(&amp;arg)函数主要初始化硬件设备,并且调用qemu_init_vcpu为每一个vcpu创建一个线程,线程执行的函数为qemu_kvm_cpu_thread_fn。<br>qemu_kvm_cpu_thread_fn函数创建vcpu,然后调用kvm_cpu_exec函数。kvm_cpu_exec函数调用ioctl进入kvm并最终进入guest vm。</p>
<p><img src="/images/2017/6/7.png" alt=""></p>
<p><img src="/images/2017/6/8.png" alt=""></p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://blog.csdn.net/dashulu/article/details/17074675" target="_blank" rel="noopener">csdn dashulu</a></li>
<li><a href="http://blog.csdn.net/lux_veritas/article/details/9383643" target="_blank" rel="noopener">csdn Lux_Veritas</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/06/25/内核学习资料总结/">内核学习资料总结</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-06-25
        </span>
        
          <span class="post-category">
            
              <a href="/categories/经验/">经验</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>在内核的学习过程中，记录下学习的资料，包括书籍，博客，论文等。</p>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ol>
<li><a href="https://www.kernel.org/doc/" target="_blank" rel="noopener">kernel doc</a></li>
<li><a href="https://lwn.net/Kernel/Index/" target="_blank" rel="noopener">lwn.net</a></li>
<li><a href="https://pdos.csail.mit.edu/~sbw/links/" target="_blank" rel="noopener">sbw links</a></li>
</ol>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><ol>
<li><a href="http://ilinuxkernel.com/" target="_blank" rel="noopener">ilinuxkernel</a></li>
<li><a href="http://landley.net/" target="_blank" rel="noopener">http://landley.net/</a></li>
<li><a href="http://sundayhut.is-programmer.com/" target="_blank" rel="noopener">sundayhut</a></li>
<li><a href="http://oenhan.com/" target="_blank" rel="noopener">oenhan</a></li>
<li><a href="http://nanxiao.me/category/%E6%8A%80%E6%9C%AF/linux-kernel-%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">nanxiao</a></li>
<li><a href="http://larmbr.com/" target="_blank" rel="noopener">larmbr</a></li>
<li><a href="https://krishnamohanlinux.blogspot.jp/" target="_blank" rel="noopener">krishnamohanlinux</a></li>
<li><a href="https://notes.shichao.io/" target="_blank" rel="noopener">notes.shichao</a></li>
</ol>
<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ol>
<li>深入理解Linux内核</li>
<li>Linux内核设计与实现</li>
<li>深入理解Linux虚拟内存管理</li>
</ol>

        
      
    </div>

    

    

  </article>

      
      
  <nav class="pagination">
    
      <a class="prev" href="/page/6/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/8/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


    
  </section>

          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:liujunming1163@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/liujunming" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2016 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">liujunming</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script>

  </body>
</html>
