<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="liujunming's personal blog."/>













  <link rel="alternate" href="/atom.xml" title="L">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1" />



<link rel="canonical" href="http://liujunming.github.io/page/10/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> L </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">L</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">L</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <section id="posts" class="posts">
    
      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/13/设计模式-适配器模式/">设计模式:适配器模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-04-13
        </span>
        
          <span class="post-category">
            
              <a href="/categories/软件工程/">软件工程</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>GOF是这样给适配器模式(Adapter)定义的：将一个类的接口转化成用户需要的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。<br>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们有一个 <em>MediaPlayer</em> 接口和一个实现了 <em>MediaPlayer</em> 接口的实体类 <em>AudioPlayer</em>。默认情况下，<em>AudioPlayer</em> 可以播放 mp3 格式的音频文件。<br>我们还有另一个接口 <em>AdvancedMediaPlayer</em> 和实现了 <em>AdvancedMediaPlayer</em> 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。<br>我们想要让 <em>AudioPlayer</em> 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 <em>MediaPlayer</em> 接口的适配器类 <em>MediaAdapter</em>，并使用 <em>AdvancedMediaPlayer</em> 对象来播放所需的格式。<br><em>AudioPlayer</em> 使用适配器类 <em>MediaAdapter</em> 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。<em>AdapterPatternDemo</em>，我们的演示类使用 <em>AudioPlayer</em> 类来播放各种格式。</p>
<p><img src="https://www.tutorialspoint.com/design_pattern/images/adapter_pattern_uml_diagram.jpg" alt=""><br><strong>步骤 1</strong><br>为媒体播放器和更高级的媒体播放器创建接口。<br><em>MediaPlayer.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>AdvancedMediaPlayer.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;	</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 2</strong><br>创建实现了 <em>AdvancedMediaPlayer</em> 接口的实体类。<br><em>VlcPlayer.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VlcPlayer</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Playing vlc file. Name: "</span>+ fileName);		</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//什么也不做</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>Mp4Player.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mp4Player</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//什么也不做</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Playing mp4 file. Name: "</span>+ fileName);		</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 3</strong><br>创建实现了 <em>MediaPlayer</em> 接口的适配器类。<br><em>MediaAdapter.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaAdapter</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   AdvancedMediaPlayer advancedMusicPlayer;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MediaAdapter</span><span class="params">(String audioType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>) )&#123;</span><br><span class="line">         advancedMusicPlayer = <span class="keyword">new</span> VlcPlayer();			</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">         advancedMusicPlayer = <span class="keyword">new</span> Mp4Player();</span><br><span class="line">      &#125;	</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>))&#123;</span><br><span class="line">         advancedMusicPlayer.playVlc(fileName);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">         advancedMusicPlayer.playMp4(fileName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 4</strong><br>创建实现了 <em>MediaPlayer</em> 接口的实体类。<br><em>AudioPlayer.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">   MediaAdapter mediaAdapter; </span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;		</span><br><span class="line"></span><br><span class="line">      <span class="comment">//播放 mp3 音乐文件的内置支持</span></span><br><span class="line">      <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"mp3"</span>))&#123;</span><br><span class="line">         System.out.println(<span class="string">"Playing mp3 file. Name: "</span>+ fileName);			</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">//mediaAdapter 提供了播放其他文件格式的支持</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>) </span><br><span class="line">         || audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">         mediaAdapter = <span class="keyword">new</span> MediaAdapter(audioType);</span><br><span class="line">         mediaAdapter.play(audioType, fileName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Invalid media. "</span>+</span><br><span class="line">            audioType + <span class="string">" format not supported"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 5</strong><br>使用 <em>AudioPlayer</em> 来播放不同类型的音频格式。<br><em>AdapterPatternDemo.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      AudioPlayer audioPlayer = <span class="keyword">new</span> AudioPlayer();</span><br><span class="line"></span><br><span class="line">      audioPlayer.play(<span class="string">"mp3"</span>, <span class="string">"beyond the horizon.mp3"</span>);</span><br><span class="line">      audioPlayer.play(<span class="string">"mp4"</span>, <span class="string">"alone.mp4"</span>);</span><br><span class="line">      audioPlayer.play(<span class="string">"vlc"</span>, <span class="string">"far far away.vlc"</span>);</span><br><span class="line">      audioPlayer.play(<span class="string">"avi"</span>, <span class="string">"mind me.avi"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 6</strong><br>验证输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Playing mp3 file. Name: beyond the horizon.mp3</span><br><span class="line">Playing mp4 file. Name: alone.mp4</span><br><span class="line">Playing vlc file. Name: far far away.vlc</span><br><span class="line">Invalid media. avi format not supported</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>结构型模式描述如何将类或者对象结合在一起形成更大的结构。</p>
<p>适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。</p>
<p>适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。</p>
<p>适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://www.hollischuang.com/archives/1524" target="_blank" rel="noopener">hollischuang</a></li>
<li><a href="http://www.runoob.com/design-pattern/adapter-pattern.html" target="_blank" rel="noopener">菜鸟教程</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/12/设计模式-原型模式/">设计模式:原型模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-04-12
        </span>
        
          <span class="post-category">
            
              <a href="/categories/软件工程/">软件工程</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们将创建一个抽象类 <em>Shape</em> 和扩展了 <em>Shape</em> 类的实体类。下一步是定义类 <em>ShapeCache</em>，该类把 shape 对象存储在一个 <em>Hashtable</em> 中，并在请求的时候返回它们的克隆。</p>
<p><em>PrototypPatternDemo</em>，我们的演示类使用 <em>ShapeCache</em> 类来获取 <em>Shape</em> 对象。</p>
<p><img src="https://www.tutorialspoint.com/design_pattern/images/prototype_pattern_uml_diagram.jpg" alt=""> </p>
<p><strong>步骤 1</strong><br>创建一个实现了 <em>Clonable</em> 接口的抽象类。<br><em>Shape.java</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String id;</span><br><span class="line">   <span class="keyword">protected</span> String type;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> type;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Object clone = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         clone = <span class="keyword">super</span>.clone();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> clone;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤 2</strong><br>创建扩展了上面抽象类的实体类。<br><em>Rectangle.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">     type = <span class="string">"Rectangle"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>Square.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">()</span></span>&#123;</span><br><span class="line">     type = <span class="string">"Square"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Square::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>Circle.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">     type = <span class="string">"Circle"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 3</strong><br>创建一个类，从数据库获取实体类，并把它们存储在一个 <em>Hashtable</em> 中。<br><em>ShapeCache.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeCache</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Hashtable&lt;String, Shape&gt; shapeMap </span><br><span class="line">      = <span class="keyword">new</span> Hashtable&lt;String, Shape&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String shapeId)</span> </span>&#123;</span><br><span class="line">      Shape cachedShape = shapeMap.get(shapeId);</span><br><span class="line">      <span class="keyword">return</span> (Shape) cachedShape.clone();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对每种形状都运行数据库查询，并创建该形状</span></span><br><span class="line">   <span class="comment">// shapeMap.put(shapeKey, shape);</span></span><br><span class="line">   <span class="comment">// 例如，我们要添加三种形状</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">      circle.setId(<span class="string">"1"</span>);</span><br><span class="line">      shapeMap.put(circle.getId(),circle);</span><br><span class="line"></span><br><span class="line">      Square square = <span class="keyword">new</span> Square();</span><br><span class="line">      square.setId(<span class="string">"2"</span>);</span><br><span class="line">      shapeMap.put(square.getId(),square);</span><br><span class="line"></span><br><span class="line">      Rectangle rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">      rectangle.setId(<span class="string">"3"</span>);</span><br><span class="line">      shapeMap.put(rectangle.getId(),rectangle);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 4</strong><br><em>PrototypePatternDemo</em> 使用 <em>ShapeCache</em> 类来获取存储在 <em>Hashtable</em> 中的形状的克隆。<br><em>PrototypePatternDemo.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypePatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ShapeCache.loadCache();</span><br><span class="line"></span><br><span class="line">      Shape clonedShape = (Shape) ShapeCache.getShape(<span class="string">"1"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Shape : "</span> + clonedShape.getType());		</span><br><span class="line"></span><br><span class="line">      Shape clonedShape2 = (Shape) ShapeCache.getShape(<span class="string">"2"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Shape : "</span> + clonedShape2.getType());		</span><br><span class="line"></span><br><span class="line">      Shape clonedShape3 = (Shape) ShapeCache.getShape(<span class="string">"3"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Shape : "</span> + clonedShape3.getType());		</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 5</strong><br>验证输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape : Circle</span><br><span class="line">Shape : Square</span><br><span class="line">Shape : Rectangle</span><br></pre></td></tr></table></figure></p>
<h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><ol>
<li>如果创建新对象成本较大，我们可以利用已有的对象进行复制来获得。</li>
<li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。 </li>
<li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li>
</ol>
<h3 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h3><ol>
<li><p>原型模式向客户隐藏了创建对象的复杂性。客户只需要知道要创建对象的类型，然后通过请求就可以获得和该对象一模一样的新对象，无须知道具体的创建过程。</p>
</li>
<li><p>克隆分为浅克隆和深克隆两种。</p>
</li>
<li><p>我们虽然可以利用原型模式来获得一个新对象，但有时对象的复制可能会相当的复杂，比如深克隆。</p>
</li>
</ol>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://www.cnblogs.com/chenssy/p/3313339.html" target="_blank" rel="noopener">cnblogs chenssy</a></li>
<li><a href="http://www.runoob.com/design-pattern/prototype-pattern.html" target="_blank" rel="noopener">菜鸟教程</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/09/UML基础知识/">UML基础知识</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-04-09
        </span>
        
          <span class="post-category">
            
              <a href="/categories/软件工程/">软件工程</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>转载自：<a href="http://blog.csdn.net/sfdev/article/details/3906243" target="_blank" rel="noopener">csdn sfdev</a> </p>
<h2 id="UML基础知识"><a href="#UML基础知识" class="headerlink" title="UML基础知识"></a>UML基础知识</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字<code>extends</code>明确标识，在设计时一般没有争议性</p>
<p><img src="/images/2017/4/1.jpg" alt=""></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>指的是一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系；在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性</p>
<p><img src="/images/2017/4/2.jpg" alt=""></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖；表现在代码层面，为类B作为参数被类A在某个method方法中使用</p>
<p><img src="/images/2017/4/3.jpg" alt=""></p>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量</p>
<p><img src="/images/2017/4/4.jpg" alt=""></p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分</p>
<p><img src="/images/2017/4/5.jpg" alt=""></p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑；表现在代码层面，和关联关系是一致的，只能从语义级别来区分</p>
<p><img src="/images/2017/4/6.jpg" alt=""></p>
<p>对于继承、实现这两种关系没多少疑问，他们体现的是一种类与类、或者类与接口间的纵向关系；其他的四者关系则体现的是类与类、或者类与接口间的引用、横向关系，是比较难区分的，有很多事物间的关系要想准备定位是很难的，前面也提到，这几种关系都是语义级别的，所以从代码层面并不能完全区分各种关系；但总的来说，后几种关系所表现的强弱程度依次为：组合&gt;聚合&gt;关联&gt;依赖</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/09/设计模式：建造者模式/">设计模式:建造者模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-04-09
        </span>
        
          <span class="post-category">
            
              <a href="/categories/软件工程/">软件工程</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>建造者模式（英：Builder Pattern）是一种创建型设计模式，又名：生成器模式。GOF 给建造者模式的定义为：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。这句话说的比较抽象，其实解释一下就是：将建造复杂对象的过程和组成对象的部件解耦。</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>假设现在我们是一家网游设计公司，现在我们要”抄袭”梦幻西游这款游戏，你是该公司的游戏角色设计人员。你怎么设计出该游戏中的各种角色呢？ 在梦幻西游来中包括人、仙、魔等种族的角色，而每种不同的种族的角色中又包含龙太子、逍遥生等具体的角色。</p>
<p>作为一个出色的开发人员，我们设计的角色生成系统应该包含以下功能和特性：</p>
<pre><code>为了保证游戏平衡，所有角色的基本属性应该一致

因为角色的创建过程可能很复杂，所以角色的生成细节不应该对外暴露

随时可以新增角色

对某个具体角色的修改应该不影响其他角色
</code></pre><p>其实，对于角色的设计，我们可以使用抽象工厂模式，将同一种族的角色看成是一个产品族。但是，这样做可能存在一个问题，那就是我们可能要在每个角色的创建过程中都要从头到尾的构建一遍该角色。比如一个角色包含头部、身体。其中头部又包括脸部、和其他部位。其中脸部又包含眉毛、嘴巴、鼻子等部位。整个角色的创建过程是极其复杂的。很容易遗漏其中的某个步骤。</p>
<p>那么，我们可以将这些具体部位的创建工作和对象的创建进行解耦。这就是建造者模式。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>建造者模式包含如下角色：</p>
<pre><code>Builder：抽象建造者(Builder)

ConcreteBuilder：具体建造者(CommonBuilder、SuperBuilder)

Director：指挥者(Director)

Product：产品角色(Role)
</code></pre><p><img src="/images/2017/4/7.jpg" alt=""></p>
<p>这里采用设计角色的例子，为了便于理解，我们只创建两个角色，分别是普通角色和超级角色。他们都有设置头部、脸部、身体、气血值、魔法值、能量值等方法。值得注意的是设置脸部是依赖于设置头部的，要有先后顺序。</p>
<p>产品角色：Role</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String head; <span class="comment">//头部</span></span><br><span class="line">    <span class="keyword">private</span> String face; <span class="comment">//脸部（脸部依赖于头部）</span></span><br><span class="line">    <span class="keyword">private</span> String body; <span class="comment">//身体</span></span><br><span class="line">    <span class="keyword">private</span> Double hp;   <span class="comment">//生命值</span></span><br><span class="line">    <span class="keyword">private</span> Double sp;   <span class="comment">//能量值</span></span><br><span class="line">    <span class="keyword">private</span> Double mp;   <span class="comment">//魔法值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//setter and getter </span></span><br><span class="line">     <span class="comment">// toString </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象建造者：Builder<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Role role = <span class="keyword">new</span> Role();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildFace</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildHp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildMp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> role;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体建造者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonRoleBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Role role = <span class="keyword">new</span> Role();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        role.setBody(<span class="string">"common head"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        role.setFace(<span class="string">"common face"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        role.setBody(<span class="string">"common body"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        role.setHp(<span class="number">100</span>d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        role.setSp(<span class="number">100</span>d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        role.setMp(<span class="number">100</span>d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> role;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperRoleBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Role role = <span class="keyword">new</span> Role();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        role.setBody(<span class="string">"suoer head"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        role.setFace(<span class="string">"super face"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        role.setBody(<span class="string">"super body"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        role.setHp(<span class="number">120</span>d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        role.setSp(<span class="number">120</span>d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        role.setMp(<span class="number">120</span>d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> role;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>指挥者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        builder.buildBody();</span><br><span class="line">        builder.buildHead();</span><br><span class="line">        builder.buildFace();</span><br><span class="line">        builder.buildHp();</span><br><span class="line">        builder.buildMp();</span><br><span class="line">        builder.buildSp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Director director = <span class="keyword">new</span> Director();</span><br><span class="line">        Builder commonBuilder = <span class="keyword">new</span> CommonRoleBuilder();</span><br><span class="line"></span><br><span class="line">        director.construct(commonBuilder);</span><br><span class="line">        Role commonRole = commonBuilder.getResult();</span><br><span class="line">        System.out.println(commonRole);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>再回到之前的需求，看看我们是否都满足？</p>
<p>由于建造角色的过程比较复杂，其中还有相互依赖关系（如脸部依赖于头部），所以我们使用建造者模式将建造复杂对象的过程和组成对象的部件解耦。这样既保证了基本属性全都一致（这里的一致指的是该包含的应该全都包含）也封装了其中的具体实现细节。</p>
<p>同时，在修改某个具体角色的时候我们只需要修改对应的具体角色就可以了，不会影响到其他角色。</p>
<p>如果需要新增角色，只要再增加一个具体建造者，并在该建造者中写好具体细节的建造部分代码就OK了。</p>
<h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用建造者模式：</p>
<pre><code>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。

需要生成的产品对象的属性相互依赖，需要指定其生成顺序。

对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。

隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。
</code></pre><hr>
<p>参考资料:</p>
<ol>
<li><a href="http://www.hollischuang.com/archives/1477" target="_blank" rel="noopener">hollischuang</a></li>
<li><a href="http://stackoverflow.com/questions/328496/when-would-you-use-the-builder-pattern" target="_blank" rel="noopener">stackoverflow</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/07/设计模式-抽象工厂模式/">设计模式:抽象工厂模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-04-07
        </span>
        
          <span class="post-category">
            
              <a href="/categories/软件工程/">软件工程</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们将创建 <em>Shape</em> 和 <em>Color</em> 接口和实现这些接口的实体类。下一步是创建抽象工厂类 <em>AbstractFactory</em>。接着定义工厂类 <em>ShapeFactory</em> 和 <em>ColorFactory</em>，这两个工厂类都是扩展了 <em>AbstractFactory</em>。然后创建一个工厂创造器(生成器)类 <em>FactoryProducer</em>。</p>
<p><em>AbstractFactoryPatternDemo</em>，我们的演示类使用 <em>FactoryProducer</em> 来获取 <em>AbstractFactory</em> 对象。它将向 <em>AbstractFactory</em> 传递形状信息 <em>Shape</em>（<em>CIRCLE / RECTANGLE / SQUARE</em>），以便获取它所需对象的类型。同时它还向 <em>AbstractFactory</em> 传递颜色信息 <em>Color</em>（<em>RED / GREEN / BLUE</em>），以便获取它所需对象的类型。</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/08/abstractfactory_pattern_uml_diagram.jpg" alt=""> </p>
<p><strong>步骤 1</strong><br>为形状创建一个接口。<br><em>Shape.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 2</strong><br>创建实现接口的实体类。<br><em>Rectangle.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>Square.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Square::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>Circle.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 3</strong><br>为颜色创建一个接口。<br><em>Color.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤4</strong><br>创建实现接口的实体类。<br><em>Red.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Red::fill() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>Green.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Green::fill() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>Blue.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Blue::fill() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 5</strong><br>为 Color 和 Shape 对象创建抽象类来获取工厂。<br><em>AbstractFactory.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 6</strong><br>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。<br><em>ShapeFactory.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;		</span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function">Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>ColorFactory.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function">Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(color == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;		</span><br><span class="line">      <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"RED"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Red();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"GREEN"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Green();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"BLUE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 7</strong><br>创建一个工厂创造器(生成器)类，通过传递形状或颜色信息来获取工厂。<br><em>FactoryProducer.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"SHAPE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"COLOR"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 8</strong><br>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。<br><em>AbstractFactoryPatternDemo.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取形状工厂</span></span><br><span class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">"SHAPE"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取形状为 Circle 的对象</span></span><br><span class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取形状为 Rectangle 的对象</span></span><br><span class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取形状为 Square 的对象</span></span><br><span class="line">      Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">      shape3.draw();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取颜色工厂</span></span><br><span class="line">      AbstractFactory colorFactory = FactoryProducer.getFactory(<span class="string">"COLOR"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取颜色为 Red 的对象</span></span><br><span class="line">      Color color1 = colorFactory.getColor(<span class="string">"RED"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用 Red 的 fill 方法</span></span><br><span class="line">      color1.fill();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取颜色为 Green 的对象</span></span><br><span class="line">      Color color2 = colorFactory.getColor(<span class="string">"Green"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用 Green 的 fill 方法</span></span><br><span class="line">      color2.fill();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取颜色为 Blue 的对象</span></span><br><span class="line">      Color color3 = colorFactory.getColor(<span class="string">"BLUE"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用 Blue 的 fill 方法</span></span><br><span class="line">      color3.fill();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 9</strong><br>验证输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Inside Circle::draw() method.</span><br><span class="line">Inside Rectangle::draw() method.</span><br><span class="line">Inside Square::draw() method.</span><br><span class="line">Inside Red::fill() method.</span><br><span class="line">Inside Green::fill() method.</span><br><span class="line">Inside Blue::fill() method.</span><br></pre></td></tr></table></figure></p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://www.runoob.com/design-pattern/abstract-factory-pattern.html" target="_blank" rel="noopener">菜鸟教程</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/06/设计模式：工厂方法模式/">设计模式：工厂方法模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-04-06
        </span>
        
          <span class="post-category">
            
              <a href="/categories/软件工程/">软件工程</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>工厂方法模式（Factory Method Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们将创建一个 <em>Shape </em>接口和实现 <em>Shape</em> 接口的实体类。下一步是定义工厂类 <em>ShapeFactory</em>。<br><em>FactoryPatternDemo</em>，我们的演示类使用 <em>ShapeFactory</em> 来获取 <em>Shape</em> 对象。它将向 <em>ShapeFactory</em> 传递信息（<em>CIRCLE / RECTANGLE / SQUARE</em>），以便获取它所需对象的类型。</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/08/factory_pattern_uml_diagram.jpg" alt=""> </p>
<p><strong>步骤 1</strong><br>创建一个接口。<br><em>Shape.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 2</strong><br>创建实现接口的实体类。<br><em>Rectangle.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>Square.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Square::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>Circle.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <strong>步骤 3</strong><br>创建一个工厂，生成基于给定信息的实体类的对象。<br><em>ShapeFactory.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;		</span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤4</strong><br>使用该工厂，通过传递类型信息来获取实体类的对象。<br><em>FactoryPatternDemo.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">      shape3.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤 5</strong><br>验证输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside Circle::draw() method.</span><br><span class="line">Inside Rectangle::draw() method.</span><br><span class="line">Inside Square::draw() method.</span><br></pre></td></tr></table></figure></p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">菜鸟教程</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/17/spark开发环境搭建/">spark开发环境搭建</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-03-17
        </span>
        
          <span class="post-category">
            
              <a href="/categories/spark/">spark</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>在<a href="http://liujunming.top/2017/03/16/spark%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">上一篇文章</a>已经介绍了spark源码环境搭建，本文的目的是spark开发环境的搭建。</p>
<h2 id="spark开发环境搭建"><a href="#spark开发环境搭建" class="headerlink" title="spark开发环境搭建"></a>spark开发环境搭建</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>开发者一般会采用项目构建工具来辅助完成项目的构建、源码的编译、依赖的解决等工作，通常情况下开发者会采用“java + maven、 scala + sbtt”的搭配组合。</p>
<ul>
<li><p>sbt<br>sbt会构建项目，并将scala文件编译出来的class文件打包成一个jar文件，在此期间sbt会自动从仓库中下载编译与运行程序所依赖的jar包。构建完成后会自动生成所需要的jar文件。</p>
</li>
<li><p>spark-submit<br><code>spark-submit</code>命令用于部署一个应用程序在spark集群中运行，使用该命令可以提交java、scala项目导出的jar包。</p>
</li>
</ul>
<h3 id="编译运行示例程序"><a href="#编译运行示例程序" class="headerlink" title="编译运行示例程序"></a>编译运行示例程序</h3><p>打开在上一章节中的spark源码项目，在{spark dir}/examples/目录下打开SparkPi.scala<br><img src="/images/2017/3/18/1.png" alt=""></p>
<h4 id="配置运行参数"><a href="#配置运行参数" class="headerlink" title="配置运行参数"></a>配置运行参数</h4><p>依次打开Run -&gt; Edit Configurations -&gt; 选择 + -&gt; Application</p>
<p>参数配置如下：<br><img src="/images/2017/3/18/2.png" alt=""></p>
<p><code>VM options: -Dspark.master=local</code>代表使用本地模式运行Spark代码，也可以选择其他模式。</p>
<h4 id="添加运行依赖的jars"><a href="#添加运行依赖的jars" class="headerlink" title="添加运行依赖的jars"></a>添加运行依赖的jars</h4><p>再次运行，这次会花费比较长的时间，因为已经可以成功编译SparkPi啦，但是还是没能运行成功，报错如下：<br><img src="/images/2017/3/18/3.png" alt=""></p>
<p>这说明你的代码编译已经成功啦，运行出错的原因是，运行Spark App一般都是通过spark-submit命令，把你的jar运行到已经安装的Spark环境里，也就是所有的Spark依赖都已经有啦，现在你用IDE的方式，就会缺少依赖。</p>
<p> 依次打开File -&gt; Project Structure -&gt; Modules -&gt; spark-examples_2.11 -&gt; Dependencies，添加依赖 jars -&gt; {spark dir}/spark/assembly/target/scala-2.11/jars/</p>
<p> <img src="/images/2017/3/18/5.png" alt=""><br> <img src="/images/2017/3/18/6.png" alt=""></p>
<p>需要注意是：<br>jars/*.jar: 这些依赖jars是在编译打包Spark项目的时候产生的，如果这个目录是空的，或者修改了源代码想更新这些jars，需要重新编译spark</p>
<h4 id="成功运行实例代码"><a href="#成功运行实例代码" class="headerlink" title="成功运行实例代码"></a>成功运行实例代码</h4><p>再次运行SparkPi的时候，可以看到输出啦：<br> <img src="/images/2017/3/18/4.png" alt=""></p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://blog.tomgou.xyz/shi-yong-intellij-ideapei-zhi-sparkying-yong-kai-fa-huan-jing-ji-yuan-ma-yue-du-huan-jing.html" target="_blank" rel="noopener">blog.tomgou.xyz</a></li>
<li><a href="https://github.com/linbojin/spark-notes/blob/master/ide-setup.md#%E7%BC%96%E8%AF%91spark%E9%A1%B9%E7%9B%AE" target="_blank" rel="noopener">linbojin</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/16/spark源码环境搭建/">spark源码环境搭建</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-03-16
        </span>
        
          <span class="post-category">
            
              <a href="/categories/spark/">spark</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>本文的目的是介绍spark源码环境搭建</p>
<h2 id="预备条件"><a href="#预备条件" class="headerlink" title="预备条件"></a>预备条件</h2><h3 id="安装jdk，scala"><a href="#安装jdk，scala" class="headerlink" title="安装jdk，scala"></a>安装jdk，scala</h3><p><a href="http://blog.tomgou.xyz/spark-160-dan-ji-an-zhuang-pei-zhi.html" target="_blank" rel="noopener">参考安装jdk，scala</a></p>
<h3 id="IDEA搭建安装"><a href="#IDEA搭建安装" class="headerlink" title="IDEA搭建安装"></a>IDEA搭建安装</h3><p><a href="http://www.codeceo.com/article/intellij-idea-ubuntu-linux.html" target="_blank" rel="noopener">如何在 Ubuntu Linux 上安装 IntelliJ IDEA</a></p>
<h3 id="配置ssh-localhost"><a href="#配置ssh-localhost" class="headerlink" title="配置ssh localhost"></a>配置ssh localhost</h3><p><a href="http://blog.tomgou.xyz/spark-160-dan-ji-an-zhuang-pei-zhi.html" target="_blank" rel="noopener">参考配置ssh localhost</a></p>
<h3 id="安装hadoop"><a href="#安装hadoop" class="headerlink" title="安装hadoop"></a>安装hadoop</h3><p><a href="http://blog.tomgou.xyz/spark-160-dan-ji-an-zhuang-pei-zhi.html" target="_blank" rel="noopener">参考安装hadoop</a></p>
<h2 id="spark编译环境配置"><a href="#spark编译环境配置" class="headerlink" title="spark编译环境配置"></a>spark编译环境配置</h2><h3 id="使用Maven编译源码"><a href="#使用Maven编译源码" class="headerlink" title="使用Maven编译源码"></a>使用Maven编译源码</h3><p>unutu上安装maven：<code>sudo apt-get install maven</code></p>
<h4 id="1-下载spark源码"><a href="#1-下载spark源码" class="headerlink" title="1. 下载spark源码"></a>1. 下载spark源码</h4><p>访问<a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">spark下载页</a>，选择下载Source Code，如下图所示。下载完成后解压缩下载好的资源包。<br><img src="/images/2017/3/16/1.png" alt=""></p>
<h4 id="2-设置maven内存限制"><a href="#2-设置maven内存限制" class="headerlink" title="2. 设置maven内存限制"></a>2. 设置maven内存限制</h4><p><code>export MAVEN_OPTS=&quot;-Xmx2g -XX:ReservedCodeCacheSize=512m&quot;</code></p>
<h4 id="3-编译源码"><a href="#3-编译源码" class="headerlink" title="3. 编译源码"></a>3. 编译源码</h4><p>在spark源码目录下执行如下指令：<br><code>./build/mvn -Pyarn -Phadoop-2.4 -Dhadoop.version=2.4.0 -DskipTests clean package</code></p>
<p>编译完成后的结果如下图所示：<br><img src="/images/2017/3/16/2.png" alt=""></p>
<h3 id="使用IDEA搭建源码编译与阅读环境"><a href="#使用IDEA搭建源码编译与阅读环境" class="headerlink" title="使用IDEA搭建源码编译与阅读环境"></a>使用IDEA搭建源码编译与阅读环境</h3><h4 id="1-IntelliJ-IDEA-安装-Scala-插件"><a href="#1-IntelliJ-IDEA-安装-Scala-插件" class="headerlink" title="1. IntelliJ IDEA 安装 Scala 插件"></a>1. IntelliJ IDEA 安装 Scala 插件</h4><p>依次选择 File -&gt; Setting -&gt; Plugins。搜索框输入 scala，右侧点击 Install Plugin，安装成功后重启 IntelliJ IDEA。<br><img src="/images/2017/3/16/8.png" alt=""></p>
<h4 id="2-导入spark项目"><a href="#2-导入spark项目" class="headerlink" title="2. 导入spark项目"></a>2. 导入spark项目</h4><p>依次选择File -&gt; open，在弹出的窗口中选择之前构建好的spark源码目录。</p>
<p>项目读取完毕之后，如果直接构建源码，IDEA会报出许多错误。</p>
<h4 id="3-构建spark项目"><a href="#3-构建spark项目" class="headerlink" title="3. 构建spark项目"></a>3. 构建spark项目</h4><p>需要进行一些额外配置。<br>选择File -&gt; Project Structure,依次打开Modules -&gt; spark-streaming-flume-sink.2.11，右键 target 目录，取消 Excluded 标签。<br><img src="/images/2017/3/16/4.png" alt=""></p>
<p>展开到 target -&gt; scala-2.11 -&gt; src_managed -&gt; main -&gt; compiled_avro 目录，右键，标记为 Source 目录。<br><img src="/images/2017/3/16/5.png" alt=""></p>
<p>依次选择Build -&gt; Rebuild Project，之后等待项目构建完毕即可，如下图：<br><img src="/images/2017/3/16/7.png" alt=""></p>
<h2 id="运行spark"><a href="#运行spark" class="headerlink" title="运行spark"></a>运行spark</h2><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>在<code>/etc/profile</code>文件的末尾添加环境变量：<br><code>export SPARK_HOME=/home/ljm/spark</code><br><code>export PATH=$SPARK_HOME/bin:$PATH</code></p>
<p>保存并更新/etc/profile：<br><code>source /etc/profile</code></p>
<p>在conf目录下复制并重命名spark-env.sh.template为spark-env.sh：<br><code>cp spark-env.sh.template spark-env.sh</code></p>
<p>在spark-env.sh中添加：<br><code>export JAVA_HOME=/home/ljm/jdk/</code><br><code>export SCALA_HOME=/home/ljm//scala</code><br><code>export SPARK_MASTER_IP=localhost</code><br><code>export SPARK_WORKER_MEMORY=4G</code></p>
<p>在任意目录下执行指令<code>spark-shell --help</code>，若没有提示命令找不到，则说明设置成功。</p>
<h3 id="运行测试应用"><a href="#运行测试应用" class="headerlink" title="运行测试应用"></a>运行测试应用</h3><p>测试Spark是否安装成功：<br><code>$SPARK_HOME/bin/run-example SparkPi</code></p>
<p><img src="/images/2017/3/16/9.png" alt=""></p>
<p>从途中可以观察到输出Pi is roughly 3.142355711778559，表明spark安装成功。</p>
<h3 id="交互式scala-shell"><a href="#交互式scala-shell" class="headerlink" title="交互式scala shell"></a>交互式scala shell</h3><p>配置完环境变量之后输入：<br><code>spark-shell</code><br><img src="/images/2017/3/17/1.png" alt=""></p>
<p>输入下面的指令，结果会返回1000<br><code>sc.parallelize(1 to 1000).count()</code><br><img src="/images/2017/3/17/2.png" alt=""></p>
<h3 id="运行与关闭集群"><a href="#运行与关闭集群" class="headerlink" title="运行与关闭集群"></a>运行与关闭集群</h3><p>启动集群上的所有节点：<br><code>$SPARK_HOME/sbin/start-all.sh</code></p>
<p>检查WebUI，浏览器打开端口：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br><img src="/images/2017/3/17/3.png" alt=""></p>
<p>关闭正在运行的所有节点：<br><code>$SPARK_HOME/sbin/stop-all.sh</code></p>
<h3 id="修改源码后重新编译即可"><a href="#修改源码后重新编译即可" class="headerlink" title="修改源码后重新编译即可"></a>修改源码后重新编译即可</h3><p><code>./build/mvn -Pyarn -Phadoop-2.4 -Dhadoop.version=2.4.0 -DskipTests clean package</code></p>
<hr>
<p>参考资料： </p>
<ol>
<li><a href="https://github.com/ihainan/SparkInternals" target="_blank" rel="noopener">ihainan</a></li>
<li><a href="http://spark.apache.org/docs/latest/building-spark.html" target="_blank" rel="noopener">spark编译文档</a></li>
<li><a href="https://www.zhihu.com/question/24869894/answer/97339151" target="_blank" rel="noopener">知乎</a></li>
<li><a href="http://dragonly.github.io/note/2016/05/10/Spark+Intellij-%E8%88%92%E6%9C%8D%E7%9A%84%E6%BA%90%E7%A0%81%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html" target="_blank" rel="noopener">dragonly.github.io</a></li>
<li><a href="https://www.supergloo.com/fieldnotes/intellij-scala-spark/" target="_blank" rel="noopener">www.supergloo.com</a></li>
<li><a href="http://blog.tomgou.xyz/spark-160-dan-ji-an-zhuang-pei-zhi.html" target="_blank" rel="noopener">blog.tomgou.xyz</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/12/scala中下划线的含义/">scala中下划线的含义</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-03-12
        </span>
        
          <span class="post-category">
            
              <a href="/categories/scala/">scala</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><h3 id="Placeholder-syntax"><a href="#Placeholder-syntax" class="headerlink" title="Placeholder syntax"></a>Placeholder syntax</h3><p>这个用法比较多，表示某一个参数。比如对collection调用方法map、filter、sortWith、foreach等等表示对每一个元素进行处理，甚至可以使用<code>_.XXX</code>方式</p>
<p>Scala represents anonymous functions with a elegant syntax. The <code>_</code>acts as a placeholder for parameters in the anonymous function. The <code>_</code> should be used only once, But we can use two or more underscores to refer different parameters.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).foreach(print(_))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).foreach( a =&gt; print(a))</span><br></pre></td></tr></table></figure>
<p>Here the <code>_</code> refers to the parameter. The first one is a short form of the second one. Lets look at another example which take two parameters.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).reduceLeft(_+_)</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).reduceLeft((a, b) =&gt; a + b)</span><br></pre></td></tr></table></figure>
<p>There is a good <a href="http://www.codecommit.com/blog/scala/quick-explanation-of-scalas-syntax" target="_blank" rel="noopener">post</a> which explains the inner details of the above example.</p>
<h3 id="Wildcard-patterns"><a href="#Wildcard-patterns" class="headerlink" title="Wildcard patterns"></a>Wildcard patterns</h3><p>In Scala, pattern matching is somewhat similar to java switch statement. But it is more powerful.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matchTest</span></span>(x: <span class="type">Int</span>): <span class="type">String</span> = x <span class="keyword">match</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"one"</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"two"</span></span><br><span class="line">   <span class="keyword">case</span> _ =&gt; <span class="string">"anything other than one and two"</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>In Scala, each selector will be matched with the patterns in the order they appear and the first match will be executed. <code>_</code>acts like a wildcard. It will match anything. Scala allows nested patterns, so we can nest the <code>_</code>also.Lets see another example that uses<code>_</code> in nested pattern.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expr <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>,_,_) =&gt; <span class="string">" a list with three element and the first element is 1"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(_*)  =&gt; <span class="string">" a list with zero or more elements "</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Map</span>[_,_] =&gt; <span class="string">" matches a map with any key type and any value type "</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Wildcard-imports"><a href="#Wildcard-imports" class="headerlink" title="Wildcard imports"></a>Wildcard imports</h3><p>In scala, <code>_</code>acts similar to <code>*</code> in java while importing packages.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imports all the classes in the package matching</span></span><br><span class="line"><span class="keyword">import</span> scala.util.matching._</span><br><span class="line"><span class="comment">// imports all the members of the object Fun. (static import in java)</span></span><br><span class="line"><span class="keyword">import</span> com.test.<span class="type">Fun</span>._</span><br><span class="line"><span class="comment">// imports all the members of the object Fun but renames Foo to Bar</span></span><br><span class="line"><span class="keyword">import</span> com.test.<span class="type">Fun</span>.&#123; <span class="type">Foo</span> =&gt; <span class="type">Bar</span> , _ &#125;</span><br><span class="line"><span class="comment">// imports all the members except Foo. To exclude a member rename it to _</span></span><br><span class="line"><span class="keyword">import</span> com.test.<span class="type">Fun</span>.&#123; <span class="type">Foo</span> =&gt; _ , _ &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="类的setter方法"><a href="#类的setter方法" class="headerlink" title="类的setter方法"></a>类的setter方法</h3><p><a href="http://dustinmartin.net/getters-and-setters-in-scala/" target="_blank" rel="noopener">getters-and-setters-in-scala</a></p>
<p>In scala, a getter and setter will be implicitly defined for all non-private var in a object. The getter name is same as the variable name and <code>_=</code> is added for setter name. We can define our own getters and setters.  Ok lets see an example which uses the getter and setters.<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">age</span> </span>= a</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">age_=</span></span>(n:<span class="type">Int</span>) = &#123;</span><br><span class="line">      require(n&gt;<span class="number">0</span>)</span><br><span class="line">      a = n</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = <span class="keyword">new</span> <span class="type">Test</span></span><br><span class="line">t.age = <span class="number">5</span></span><br><span class="line">println(t.age)</span><br></pre></td></tr></table></figure>
<h3 id="Converting-call-by-name-parameters-to-functions"><a href="#Converting-call-by-name-parameters-to-functions" class="headerlink" title="Converting call-by-name parameters to functions"></a>Converting call-by-name parameters to functions</h3><p>Scala is a functional language. So we can treat function as a normal variable. If you try to assign a function to a new variable, the function will be invoked and the result will be assigned to the variable. This confusion occurs due to the optional braces for method invocation. We should use _ after the function name to assign it to another variable.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fun</span> </span>= &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> funLike = fun _</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于将方法转换成函数</p>
<hr>
<p>参考资料:</p>
<ol>
<li><a href="http://ananthakumaran.in/2010/03/29/scala-underscore-magic.html" target="_blank" rel="noopener">ananthakumaran.in</a></li>
<li><a href="https://www.zhihu.com/question/21622725" target="_blank" rel="noopener">zhihu</a></li>
<li><a href="http://stackoverflow.com/questions/8000903/what-are-all-the-uses-of-an-underscore-in-scala" target="_blank" rel="noopener">stackoverflow</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/11/scala教程/">scala教程</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-03-11
        </span>
        
          <span class="post-category">
            
              <a href="/categories/scala/">scala</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="scala教程"><a href="#scala教程" class="headerlink" title="scala教程"></a>scala教程</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>本文档是 Scala 语言和编译器的快速入门介绍,适合已经有一定编程经验,且希望了解Scala 可以做什么的读者。我们假定本文的读者具有面向对象编程(尤其是 java 相关)的基础知识。</p>
<h3 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h3><p>我们使用最经典的“Hello world”作为第一个例子,这个例子虽然并不是特别炫,但它可以很好的展示 Scala 的用法,且无须涉及太多的语言特性。示例代码如下:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      println(<span class="string">"Hello, world!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于包含 main 方法的 object 声明,Java 程序员可能要相对陌生一些。这种声明方式引入了一个通常被称为单例对象(singleton object)的概念,也就是有且仅有一个实例的类。因此,上例中的声明,在定义了一个名为的 HelloWorld 类的同时,还声明了该类的一个实例,实例的名字也叫 HelloWorld 。该实例在第一次被用到的时候即时(on demand)创建。</p>
<p>细心的读者可能会注意到, main 方法并没有声明为 static 。这是因为 Scala 中不存在静态成员(无论方法还是属性)这一概念,Scala 使用前述的单例对象中的成员来代替静态成员。</p>
<h4 id="编译该示例"><a href="#编译该示例" class="headerlink" title="编译该示例"></a>编译该示例</h4><p>要编译上面写的例子,要 scalac 命令,这就是 Scala 的编译器。 scalac 的工作流程和多数编译器类似:从命令行上接收待编译的源文件名以及编译参数,生成一个或者多个目标文件。Scala 生成的目标文件是标准的 java class 文件。<br>假如我们将 HelloWorld 示例程序存放到 HelloWorld.scala 文件中,则可以用以下指令进行编译:</p>
<p><code>scalac HelloWorld.scala</code></p>
<p>该指令执行后,会在当前目录下生成几个 class 文件,其中一个是 HelloWorld.class,该文件中包含一个可以直接被 scala 指令执行的类(class)。</p>
<h4 id="运行该示例"><a href="#运行该示例" class="headerlink" title="运行该示例"></a>运行该示例</h4><p>代码编译通过以后,可以使用 scala 指令运行程序, scala 指令和 java 指令的用法非常相似,甚至它们接受的命令行参数都是一样的。前面编译好的例子,可以用如下指令运行,并输出预期的问候语:</p>
<p><img src="/images/2017/3/10/1.png" alt=""></p>
<h3 id="和-Java-进行交互"><a href="#和-Java-进行交互" class="headerlink" title="和 Java 进行交互"></a>和 Java 进行交互</h3><p>和 Java 代码的交互能力,是 Scala 语言的强项之一。在 Scala 程序中, <code>java.lang</code>包下的类是默认全部引入的,其它包下的类则需要显式引入。</p>
<p>我们可以通过一个例子来展示Scala与Java的交互能力。假如,我们想获取系统当前时间,并按照某个国家(比如法国)的显示习惯进行格式化。</p>
<p>我们知道,在 Java 的类库中已经实现了 Date、DateFormat 等功能强大的工具类,且Scala 可以和 Java 进行无缝的互操作,所以,想在 Scala 程序中使用这些功能,只需要引入这些 Java 类即可,无须从头重复实现相同的功能。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">Date</span>, <span class="type">Locale</span>&#125;</span><br><span class="line"><span class="keyword">import</span> java.text.<span class="type">DateFormat</span></span><br><span class="line"><span class="keyword">import</span> java.text.<span class="type">DateFormat</span>._</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FrenchDate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> now = <span class="keyword">new</span> <span class="type">Date</span></span><br><span class="line">    <span class="keyword">val</span> df = getDateInstance(<span class="type">LONG</span>, <span class="type">Locale</span>.<span class="type">FRANCE</span>)</span><br><span class="line">    println(df format now)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Scala 的 import 语句和 Java 中的 import 很想象,但 Scala 的语法更强大一些。比如,要想引入一个包中的多个类,在 Scala 中可以写在一行上,只需要把多个类名放到一个大括号中即可。此外,如果要引入一个包或者类中的所有名字,Scala 使用下划线而不是星号,这是因为,在 Scala中,星号是一个合法的标识符(比如:方法名),后面我们会遇到这种情况。</p>
<p>在 main 方法中,我们首先创建一个 Java 的 Date 实例,该实例默认取得系统当前时间;接下来,我们使用从 DateFormat 类中引入的静态方法 getDateInstance 创建一个 负 责 日 期 格 式 化 的 对 象 df , 创 建 过 程 中 , 通 过 参 数 指 定 了 本 地 化 区 域( Locale.FRANCE );最后,使用 df 将当前时间进行格式化并打印输出到控制台。这个方法的最后一行,体现了 Scala 语法中一种很有意思的特性:如果一个方法只接受一个参数,那么可以使用 infix 语法,也就是说,下面的表达式:</p>
<p><code>df format now</code></p>
<p>和 <code>df.format(now)</code> 的语义完全相同,只是前者更加简洁。</p>
<h3 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h3><p>Scala 中的一切都是对象,从这个意义上说,Scala 是纯粹的面向对象的语言。在这一点上,Scala 与 Java 不同,因为 Java 中,原子类型和引用类型是有区别的,而且 Java 中不能把函数当做值来对待。</p>
<h4 id="数字是对象"><a href="#数字是对象" class="headerlink" title="数字是对象"></a>数字是对象</h4><p>因为数字是对象,所以数字也拥有自己的方法,如下的算术表达式:</p>
<p><code>1+2*3/x</code></p>
<p>实际上完全是由方法调用构成的。前面章节已经提到过“单参数方法”的简化写法,所以,上述表达式实际上是下面这个表达式的等价简化写法:</p>
<p><code>(1).+(((2).*(3))./(x))</code></p>
<p>由此我们还可以看到: + , * 等符号在 Scala 中是合法的标识符(和前面进行印证)。</p>
<h4 id="函数是对象"><a href="#函数是对象" class="headerlink" title="函数是对象"></a>函数是对象</h4><p><a href="http://www.runoob.com/scala/scala-functions.html" target="_blank" rel="noopener">scala 函数教程</a></p>
<p>如果函数没有返回值，则可以省略函数定义中的等号，返回值类型为Unit(相当于Java中的void）</p>
<p>在 Scala 中,函数也是对象,所以,函数可以当做参数进行传递,可以把函数存储在变量中,也可以把函数作为其他函数的返回值,Java 程序员可能会觉得这是一项非常神奇的特性。这种将函数当做值进行操作的能力,是函数式编程最重要的特性之一。</p>
<h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>对于只使用一次的函数，可以定义为匿名函数，可以省去定义和命名的麻烦。下面给出示例代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TimerAnonymous</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">oncePerSecond</span></span>(callback: () =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; callback(); <span class="type">Thread</span> sleep <span class="number">1000</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    oncePerSecond(() =&gt;</span><br><span class="line">      println(<span class="string">"time flies like an arrow..."</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中的右箭头‘=&gt;’表明程序中存在一个匿名函数,箭头左边是匿名函数的参数列表,右边是函数体。在本例中,参数列表为空(箭头左边是一对空括号)。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>前面已经说过,Scala是面向对象的语言,所以它有类(class)的概念  。Scala中声明类的语法和Java类似,但有一点重要的差异,那就是Scala中的类定义可以带参数下面定义的复数类可以很清晰的展示这一特性:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>(<span class="params">real: <span class="type">Double</span>, imaginary: <span class="type">Double</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">re</span></span>() = real</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">im</span></span>() = imaginary</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该复数类可以接受两个参数,分别代表复数的实部和虚部,如果要创建 Complex 类的实例,则必须提供这两个参数,比如: new Complex(1.5, 2.3) 。该类有两个方法: re和 im ,分别用于访问复数的实部和虚部。</p>
<p>需要注意的是,这两个方法的返回值都没有显式定义。在编译过程中,编译器可以根据函数定义的右部,推断出两个函数的返回值都是 Double类型。</p>
<h3 id="无参方法"><a href="#无参方法" class="headerlink" title="无参方法"></a>无参方法</h3><p>Complex 类中的 re 和 im 方法有个小问题,那就是调用这两个方法时,需要在方法名后面跟上一对空括号,就像下面的例子一样:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ComplexNumbers</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> c= <span class="keyword">new</span> <span class="type">Complex</span>(<span class="number">1.2</span>, <span class="number">3.4</span>)</span><br><span class="line">    println(<span class="string">"imaginary part: "</span> + c.im())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果能够省掉这些方法后面的空括号,就像访问类属性(fields)一样访问类的方法,则程序会更加简洁。这在 Scala 中是可行的,只需将方法显式定义为没有参数即可。无参方法和零参方法的差异在于:无参方法在声明和调用时,均无须在方法名后面加括号。所以,前面的 Complex 类可以重写如下:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>(<span class="params">real: <span class="type">Double</span>, imaginary: <span class="type">Double</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">re</span> </span>= real</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">im</span> </span>= imaginary</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="继承和方法重写"><a href="#继承和方法重写" class="headerlink" title="继承和方法重写"></a>继承和方法重写</h4><p>Scala 中的所有类都继承自某一个父类(或者说超类),若没有显式指定<br>父类(比如前面的 Complex 类),则默认继承自 <code>scala.AnyRef</code> 。</p>
<p>在 Scala 中可以重写(overriding)从父类继承的方法,但必须使用 override 修饰符来显式声明,这样可以避免无意间的方法覆盖。例如,前面定义的 Complex 类中,我们可以重写从 Object 类中继承的 toString 方法,代码如下:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>(<span class="params">real: <span class="type">Double</span>, imaginary: <span class="type">Double</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">re</span> </span>= real</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">im</span> </span>= imaginary</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>() =</span><br><span class="line">    <span class="string">""</span> +re + (<span class="keyword">if</span> (im &lt; <span class="number">0</span>) <span class="string">""</span> <span class="keyword">else</span> <span class="string">"+"</span>) + im + <span class="string">"i"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="条件类和模式匹配-Case-classes-and-pattern-matching"><a href="#条件类和模式匹配-Case-classes-and-pattern-matching" class="headerlink" title="条件类和模式匹配(Case classes and pattern matching)"></a>条件类和模式匹配(Case classes and pattern matching)</h3><p>树是软件开发中使用频率很高的一种数据结构,例如:解释器和编译器内部使用树来表示代码结构;XML 文档是树形结构;还有一些容器(集合)也是基于树的,比如:红黑树。</p>
<p>接下来,我们通过一个示例程序,了解在 Scala 中如何表示和操作树形结构,这个示例将实现非常简单的计算器功能,该计算器可以处理包含加法、变量和整数常量的算术表达式,比如:1 + 2、(x + x) + (7 + y)等。</p>
<p>首先,我们要决定如何表示这样的表达式。最自然的选择是树形结构,用非叶子节点表示操作符(具体到这个例子,只有 加法操作),用叶子节点表示操作数(具体到这个例子是常量和变量)。</p>
<p>如果是在 Java 中,建立树形结构最常见的做法是:创建一个表示树的抽象类,然后每种类型的节点用一个继承自抽象类的子类来表示。而在函数式编程语言中,则可以使用代数数据类型(algebraic data-type)来达到同样的目的。Scala 则提供了一种介于两者之间(类继承和代数数据类型),被称为条件类(case classes)的概念,下面就是用条件类定义树的示例代码:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Sum</span>(<span class="params">l: <span class="type">Tree</span>, r: <span class="type">Tree</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Var</span>(<span class="params">n: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Const</span>(<span class="params">v: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span></span></span><br></pre></td></tr></table></figure></p>
<p>上例中的 Sum , Var 和 Const 就是条件类,它们与普通类的差异主要体现在如下几个方面:</p>
<ul>
<li>新建条件类的实例,无须使用 new 关键字(比如,可以直接用 Const(5)代替 newConst(5) 来创建实例)。</li>
<li>自动为构造函数所带的参数创建对应的 getter 方法(也就是说,如果 c 是Const 的实例,通过 c.v 即可访问构造函数中的同名参数v 的值)</li>
<li>条件类都默认实现 equals 和 hashCode 两个方法,不过这两个方法都是基于实例的结构本身,而不是基于实例中可用于区分的值,这一点和 java 中 Object提供的同名方法的默认实现是基本一致的。</li>
<li>条件类还提供了一个默认的 toString 方法,能够以源码形式打印实例的值(比如,表达式 x+1 会被打印成Sum(Var(x),Const(1)) ,这个打印结果,和源代码中创建表达式结构树的那段代码完全一致)。</li>
<li>条件类的实例可以通过模式匹配(pattern matching)进行分解(decompose),接下来会详细介绍。</li>
</ul>
<p>既然我们已经定义了用于表示算术表达式的数据结构,接下来我们可以定义作用在这些数据结构上的操作。首先,我们定义一个在特定环境(environment,上下文)中对表达式进行求值的函数,其中环境的作用是为了确定表达式中的变量的取值。例如:有一个环境,对变量 x 的赋值为 5,我们记为:{x → 5},那么,在这个环境上求 x + 1的值,得到的结果为 6。</p>
<p>在程序中,环境也需要一种合理的方式来表示。可以使用哈希表(hash table)之类的数据结构,也可以直接使用函数(functions)!实际上,环境就是一个给变量赋予特定值的函数。上面提到的环境:{x → 5},在 Scala 中可以写成:</p>
<p><code>{ case &quot;x&quot; =&gt; 5 }</code></p>
<p>上面这一行代码定义了一个函数,如果给该函数传入一个字符串 “x” 作为参数,则函数返回整数 5,否则,将抛出异常。</p>
<p>在写表达式求值函数之前,我们还要对环境的类型(type of the environments)进行命名。虽然在程序中全都使用 String =&gt; Int 这种写法也可以的,但给环境起名后,可以简化代码,并使得将来的修改更加方便(这里说的环境命名,简单的理解就是宏,或者说是自定义类型)。在 Scala 中,使用如下代码来完成命名:</p>
<p><code>type Environment = String =&gt; Int</code></p>
<p>此后,类型名 Environment 可以作为“从 String 转成 Int” 这一类函数的别名。</p>
<p>现在,我们来写求值函数。求值函数的实现思路很直观:两个表达式之和(sum),等于分别对两个表达式求值然后求和;变量的值直接从环境中获取;常量的值等于常量本身。在 Scala 中描述这个概念并不困难:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(t: <span class="type">Tree</span>, env: <span class="type">Environment</span>): <span class="type">Int</span> = t <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Sum</span>(l, r) =&gt; eval(l, env) + eval(r, env)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Var</span>(n) =&gt; env(n)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Const</span>(v) =&gt; v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>求值函数的工作原理是对树 t 上的结点进行模式匹配,下面是对匹配过程的详细描述(实际上是递归):</p>
<ol>
<li>求值函数首先检查树 t 是不是一个求和( Sum ),如果是,则把 t 的左子树和右子树分别绑定到两个新的变量 l 和 r 上,然后对箭头右边的表达式进行运算(实际上就是分别求左右子树的值然后相加,这是一个递归)。箭头右边的表达式可以使用箭头左边绑定的变量,也就是 l 和 r 。</li>
<li>如果第一个检查不满足,也就是说,树 t 不是 Sum ,接下来就要检查 t 是不是一个变量 Var ;如果是,则 Var 中包含的名字被绑定到变量 n 上,然后继续执行箭头右边的逻辑。</li>
<li>如果第二个检查也不满足,那意味着树t 既不是 Sum ,也不是 Var ,那就进一步检查 t 是不是常量 Const 。如果是,则将常量所包含的值赋给变量 v ,然后继续执行箭头右边的逻辑。</li>
<li>最后,如果以上所有的检查都不满足,程序会抛出异常,表明对表达式做模式匹配时产生了错误。这种情况,在本例中,只有声明了更多 Tree 的子类,却没有增加对应的模式匹配条件时,才会出现。</li>
</ol>
<p>通过上例,我们可以看到,模式匹配的过程,实际上就是把一个值和一系列的模式进行比对,如果能够匹配上,则从值中取出有用的部件进行命名,然后用这些命名的部件(作为参数)来驱动另一段代码的执行。</p>
<p>一个有经验的面向对象程序员可能会问:为什么不把 eval 定义成类 Tree 的成员方法?事实上,这么做也行,因为在 Scala 中,条件类和普通类一样,都可以定义方法。不过,“模式匹配”和“类方法”除了编程风格的差异,也各有利弊,决策者需要根据程序的扩展性需求做出权衡和选择:</p>
<ul>
<li>使用类方法,添加一种新的节点类型比较简单,因为只需要增加一个 Tree的 子类即可。但是,要在树上增加一种新的操作则比较麻烦,因为这需要修改 Tree 的所有子类。</li>
<li>使用模式匹配,情况则刚好相反:增加一种新的节点类型需要修改所有作用在树上的模式匹配函数;而增加新的操作则比较简单,只需要增加一个新的函数即可。</li>
</ul>
<p>模式匹配的功能非常强大,但限于本文的长度和定位,我们将不再做太多深入的讨论,接下来,我们还是通过一个实例,来看看前面定义的函数如何使用吧。为此,我们编写一个main 函数,在函数中,先创建一个表达式:(x + x) + (7 + y),然后在环境{x → 5, y → 7}上求表达式的值。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">  <span class="keyword">val</span> exp: <span class="type">Tree</span> = <span class="type">Sum</span>(<span class="type">Sum</span>(<span class="type">Var</span>(<span class="string">"x"</span>),<span class="type">Var</span>(<span class="string">"x"</span>)),<span class="type">Sum</span>(<span class="type">Const</span>(<span class="number">7</span>),<span class="type">Var</span>(<span class="string">"y"</span>)))</span><br><span class="line">  <span class="keyword">val</span> env: <span class="type">Environment</span> = &#123; <span class="keyword">case</span> <span class="string">"x"</span> =&gt; <span class="number">5</span> <span class="keyword">case</span> <span class="string">"y"</span> =&gt; <span class="number">7</span> &#125;</span><br><span class="line">  println(<span class="string">"Expression: "</span> + exp)</span><br><span class="line">  println(<span class="string">"Evaluation with x=5, y=7: "</span> + eval(exp, env))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Traits-特征、特性"><a href="#Traits-特征、特性" class="headerlink" title="Traits(特征、特性)"></a>Traits(特征、特性)</h3><p>Scala 中的类不但可以从父类继承代码,还可以从一个或者多个 traits 引入代码。<br>对于 Java 程序员来说,理解 traits 最简单的方法,是把它当作可以包含代码的接口。在 Scala 中,如果一个类继承自某个 trait,则该类实现了 trait 的接口,并继承了 trait 的所有代码。</p>
<p>我们用一个经典的例子:有序对象来展示 trait 的作用。有很多应用场景,需要在同类对象之间比较大小,比如排序算法。在 Java 中,可以实现Comparable 接口,而在 Scala 中,有更好的办法,那就是定义一个和Comparable 对等的 trait,名为: Ord 。</p>
<p>对象之间做比较,需要六种断言:小于,小于等于,等于,不等于,大于等于,大于。不过,这六种断言中的四种,可以用另外两种进行表述,比如,只要确定了等于和小于两种断言,其它四种就可以推导出来,所以,并不是每种断言都需要由具体类来实现(实现在 trait 上即可,相当于抽象类)。基于以上的分析,我们用下面的代码定义一个 trait:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ord</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">&lt;</span> </span>(that: <span class="type">Any</span>): <span class="type">Boolean</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">&lt;=</span></span>(that: <span class="type">Any</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> &lt; that) || (<span class="keyword">this</span> == that)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">&gt;</span> </span>(that: <span class="type">Any</span>): <span class="type">Boolean</span> = !(<span class="keyword">this</span> &lt;= that)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">&gt;=</span></span>(that: <span class="type">Any</span>): <span class="type">Boolean</span> = !(<span class="keyword">this</span> &lt; that)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码,定义了和 java 中 Comparable 接口对等的 trait: Ord ,同时,默认实现了三个断言,这三个断言依赖的第四个是抽象的(留给具体类实现)。等于和不等于默认存在于所有对象上,因此这里不需要显式定义。</p>
<p>代码中用到的类型 Any 是 Scala 中所有类型的超类。它比 java 中的 Object 类型更加通用,因为基本类型如: Int , Float 也是继承自该类的。</p>
<p>要想让一个类的实例可比,只需要继承前面定义的 Ord trait,并实现相等和小于两个断言即可。接下来还是用例子说话,我们定义一个 Date 类,这个类使用三个整数分别表示公历的年、月、日,该类继承自 Ord ,代码如下:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>(<span class="params">y: <span class="type">Int</span>, m: <span class="type">Int</span>, d: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Ord</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">year</span> </span>= y</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">month</span> </span>= m</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">day</span> </span>= d</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>(): <span class="type">String</span> = year + <span class="string">"-"</span> + month + <span class="string">"-"</span> + day</span><br></pre></td></tr></table></figure></p>
<p>请重点关注代码中紧跟在类名和参数后面的 extends Ord ,这是 Date 类声明继承自 Ord strait 的语法。<br>接下来,我们要重写(redefine)从 Object 上继承的 equals 方法,该方法的默认实现是比较对象的天然特性(比如内存地址),而 Date 类需要比较年、月、日字段的值才能确定大小。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equals</span></span>(that: <span class="type">Any</span>): <span class="type">Boolean</span> =</span><br><span class="line">  that.isInstanceOf[<span class="type">Date</span>] &amp;&amp; &#123;</span><br><span class="line">    <span class="keyword">val</span> o = that.asInstanceOf[<span class="type">Date</span>]</span><br><span class="line">    o.day == day &amp;&amp; o.month == month &amp;&amp; o.year == year</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码用到了两个预定义的方法: isInstanceOf 和 asInstanceOf 。其中isInstanceOf 方法对应 java 中的 instanceof 操作符,当且仅当一个对象的类型和方法参数所指定类型匹配时,才返回 true; asInstanceOf 方法对应 java 中的 cast 强制类型转换操作:如果当前对象是特定类的实例,转换成功,否则抛出 ClassCastException异常。</p>
<p>最后,还需要定义一个判断小于的函数,该函数又用到了一个预定义方法:error ,作用是抛出异常,并附带指定的错误信息。代码如下:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">&lt;</span></span>(that: <span class="type">Any</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span>(!that.isInstanceOf[<span class="type">Date</span>])</span><br><span class="line">    error(<span class="string">"cannot compare "</span> + that + <span class="string">"and a Date"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> o = that.asInstanceOf[<span class="type">Date</span>]</span><br><span class="line">  (year &lt; o.year) ||</span><br><span class="line">  (year == o.year &amp;&amp; (month &lt; o.month ||</span><br><span class="line">                     (month == o.month &amp;&amp; day &lt; o.day)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此, Date 类就写完了,该类的实例既可以被看作是一个日期(dates),也可以被看作一个可比的对象,并且,无论那种看法,他们都有六个用作比较的断言,其中, equals和 &lt; 直接定义在 Date 类上,而其它四个则继承自 Ord trait。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>范型就是定义以类型为参数的类或接口（Scala中为特征）的功能。Java里从JDK5开始就有了范型，想必知道的人应该比较多了，下面就简单举例说明一下。<br>例如，假设有如下的代码片段。这里java.util.List是范型接口，String就是赋给它的类型参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.List&lt;String&gt; strs = <span class="keyword">new</span> java.util.ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>这样，就可以用如下方法将String类型（或子类型）的对象加入List中了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strs.add(<span class="string">"hoge"</span>);</span><br></pre></td></tr></table></figure>
<p>Scala的范型与Java是非常相似的，基本上可以同样地使用，只是在标记方法上有些区别。以下是同刚才Java代码基本相同的Scala代码。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strs: java.util.<span class="type">List</span>[<span class="type">String</span>] = <span class="keyword">new</span> java.util.<span class="type">ArrayList</span></span><br></pre></td></tr></table></figure>
<p>Scala中用[..]来代替了Java中的&lt; ..&gt;来表现类型参数表。附带提一下，与Java有一点小的不同，Scala在new ArrayList时不需要指定String类型参数，这是编译器的类型推断起了效用（显示指定也是可以的）。</p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://www.scala-lang.org/docu/files/ScalaTutorial-zh_CN.pdf" target="_blank" rel="noopener">scala 教程</a></li>
<li><a href="http://www.runoob.com/scala/scala-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
      
  <nav class="pagination">
    
      <a class="prev" href="/page/9/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/11/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


    
  </section>

          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:liujunming1163@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/liujunming" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2016 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">liujunming</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script>

  </body>
</html>
