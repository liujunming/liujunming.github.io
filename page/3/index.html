<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="liujunming's personal blog."/>













  <link rel="alternate" href="/atom.xml" title="L">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1" />



<link rel="canonical" href="http://liujunming.github.io/page/3/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> L </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">L</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">L</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <section id="posts" class="posts">
    
      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/11/Intel-RDT特性详解/">Intel RDT特性详解</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-11
        </span>
        
          <span class="post-category">
            
              <a href="/categories/计算机系统/">计算机系统</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>英特尔至强 E5-2600 v4在对外宣传时候号称“为云而生”的，除了其强大的性能和众多核心外，主要亮点就是Resource Director Technology（RDT）新技术的加入。使得其有理由宣称“为云而生”。<br>我们知道在一个虚拟化环境中，宿主机的资源（包括CPU cache和内存带宽）都是共享的。但是如果有一个消耗cache的应用快速消耗了L3缓存，或者一个应用消耗了系统大量内存带宽，那么如何保证其他虚拟机应用呢？如何限制这些“可恶”的邻居呢？<br>针对上诉问题，以前都是通过控制虚拟机逻辑资源来实现，但是调整的粒度实在太粗，针对处理器缓存这样敏感而稀缺的资源，几乎是无能为力的。为此英特尔推出了RDT技术，希望可以解决这个问题。<br>那么看下RDT到底是什么神奇技术。</p>
<h2 id="技术组成"><a href="#技术组成" class="headerlink" title="技术组成"></a>技术组成</h2><p>RDT技术有其实有5个功能模块，分别是</p>
<ul>
<li>Cache Monitoring Technology (CMT)缓存监测技术</li>
<li>Cache Allocation Technology (CAT)缓存分配技术</li>
<li>Memory Bandwidth Monitoring (MBM)内存带宽监测技术</li>
<li>Memory Bandwidth Allocation (MBA)内存带宽分配技术</li>
<li>Code and Data Prioritization (CDP)代码和数据分区技术</li>
</ul>
<p>5个模块可以分为监控和控制两大类，CMT和MBM为监控技术，而CAT、MBA和CDP为控制技术。<br>RDT允许OS或VMM来监控线程，应用或VM使用的cache/内存带宽空间。通过分析cache/内存带宽使用率，OS或VMM可以优化调度策略提高效能，使得高级优化技术可以实现。</p>
<h2 id="为什么需要RDT"><a href="#为什么需要RDT" class="headerlink" title="为什么需要RDT"></a>为什么需要RDT</h2><p>配合这几个技术，OS能够知道应用使用了多少CACHE空间，内存带宽，从而给虚拟机的虚拟处理器分配真实的CPU资源。结合CMT和CAT，缓存可做到实时监测和使用，能够让处理器的资源向虚拟机中最重要、最紧迫的任务分配。CDP可以限制数据在LLC中的存储，从而将空间节省出来给代码存储。</p>
<h2 id="具体功能"><a href="#具体功能" class="headerlink" title="具体功能"></a>具体功能</h2><p>下面我们来看下RDT的一个具体功能。<br>以下方截图来说明，如下：<br><img src="/images/2018/4/8.png" alt=""><br>我们可以发现cores 0-5关联到了RMID 47-42,进 行了每个核监控,提供了CMT/MBM数据。</p>
<h3 id="RMID"><a href="#RMID" class="headerlink" title="RMID"></a>RMID</h3><p>OS或VMM会给每个应用或虚拟机标记一个软件定义的ID，叫做RMID（Resource Monitoring ID），通过RMID可以同时监控运行在多处理器上相互独立的线程。</p>
<h2 id="RDT的使用"><a href="#RDT的使用" class="headerlink" title="RDT的使用"></a>RDT的使用</h2><h3 id="工具软件"><a href="#工具软件" class="headerlink" title="工具软件"></a>工具软件</h3><p>使用Intel开源的工具来实现，不需要内核支持。通过这个软件包可以使用CAT,CMT,MBM,CDP功能。<br>工具软件<a href="https://github.com/intel/intel-cmt-cat" target="_blank" rel="noopener">下载链接</a><br>（注：下面的指令均在root下运行）</p>
<ul>
<li><code>make &amp;&amp; make install</code></li>
</ul>
<hr>
<p>WARN: Error opening file ‘/dev/cpu/0/msr’!<br>ERROR: CDP detection error!<br>ERROR: Fatal error encounter in CAT discovery!<br>ERROR: discover_capabilities() error 1<br>Error initializing PQoS library!<br>出现上述错误，则执行如下指令：</p>
<ul>
<li><code>modprobe msr</code></li>
</ul>
<p>具体使用教程参考<a href="https://github.com/intel/intel-cmt-cat/wiki/Usage-Examples" target="_blank" rel="noopener">Usage Examples</a></p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://linuxperformance.top/index.php/archives/21/" target="_blank" rel="noopener">Intel RDT特性详解</a></li>
<li><a href="http://www.litrin.net/2018/01/02/kernel-4-14%E7%9A%84rdt%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">Kernel 4.14的RDT配置</a></li>
<li><a href="http://www.litrin.net/2017/02/15/intel-rdt/" target="_blank" rel="noopener">Intel RDT</a></li>
<li><a href="http://www.litrin.net/2017/02/21/linux-4-10%E4%B8%ADcat%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">Linux 4.10中CAT的使用</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/x86/intel_rdt_ui.txt" target="_blank" rel="noopener">intel_rdt_ui.txt</a></li>
<li><a href="https://github.com/intel/intel-cmt-cat" target="_blank" rel="noopener">intel-cmt-cat</a></li>
<li><a href="https://github.com/intel/intel-cmt-cat/wiki" target="_blank" rel="noopener">intel-cmt-cat wiki</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/09/CPU-Cache/">CPU Cache</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-09
        </span>
        
          <span class="post-category">
            
              <a href="/categories/计算机系统/">计算机系统</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>本文主要转载自卢钧轶(cenalulu)<br>原文地址：<a href="http://cenalulu.github.io/linux/all-about-cpu-cache/" target="_blank" rel="noopener">http://cenalulu.github.io/linux/all-about-cpu-cache/</a></p>
<h2 id="为什么要有CPU-Cache"><a href="#为什么要有CPU-Cache" class="headerlink" title="为什么要有CPU Cache"></a>为什么要有CPU Cache</h2><p>随着工艺的提升最近几十年CPU的频率不断提升，而受制于制造工艺和成本限制，目前计算机的内存主要是DRAM并且在访问速度上没有质的突破。因此，CPU的处理速度和内存的访问速度差距越来越大，甚至可以达到上万倍。同时又由于内存数据访问的热点集中性，在CPU和内存之间用较为快速而成本较高的SDRAM做一层缓存，就显得性价比极高了。</p>
<h2 id="为什么要有多级CPU-Cache"><a href="#为什么要有多级CPU-Cache" class="headerlink" title="为什么要有多级CPU Cache"></a>为什么要有多级CPU Cache</h2><p>随着科技发展，热点数据的体积越来越大，单纯的增加一级缓存大小的性价比已经很低了。因此，就慢慢出现了在一级缓存(L1 Cache)和内存之间又增加一层访问速度和成本都介于两者之间的二级缓存(L2 Cache)。下面是一段从<a href="http://futuretech.blinkenlights.nl/misc/cpumemory.pdf" target="_blank" rel="noopener">What Every Programmer Should Know About Memory</a>中摘录的解释：</p>
<blockquote>
<p>Soon after the introduction of the cache the system got more complicated. The speed difference between the cache and the main memory increased again, to a point that another level of cache was added, bigger and slower than the first-level cache. Only increasing the size of the first-level cache was not an option for economical reasons.</p>
</blockquote>
<p>此外，又由于程序指令和程序数据的行为和热点分布差异很大，因此L1 Cache也被划分成L1i (i for instruction)和L1d (d for data)两种专门用途的缓存。 下面<a href="https://datatake.files.wordpress.com/2015/01/cpu-cache-access-in-cpu-cycles.png" target="_blank" rel="noopener">一张图</a>可以看出各级缓存之间的响应时间差距，以及内存到底有多慢！</p>
<p><img src="https://datatake.files.wordpress.com/2015/01/cpu-cache-access-in-cpu-cycles.png" alt=""></p>
<p>CPU包含多个核，每个核又有独自的一级缓存和二级缓存，各个核心之间共享三级缓存，并统一通过总线与内存进行交互。</p>
<p><img src="/images/2018/4/1.png" alt=""></p>
<h2 id="Cache-Line"><a href="#Cache-Line" class="headerlink" title="Cache Line"></a>Cache Line</h2><p>整个Cache被分成多个Line，每个Line通常是32byte或64byte。<br>Cache Line是Cache和内存交换数据的最小单位。</p>
<p><img src="/images/2018/4/2.png" alt=""></p>
<p>每个Cache Line包含三个部分:</p>
<ul>
<li>Valid：当前缓存是否有效</li>
<li>Tag：对应的内存地址</li>
<li>Block：缓存数据</li>
</ul>
<p><img src="/images/2018/4/3.png" alt=""></p>
<p><strong>了解Cache Line的概念对我们程序猿有什么帮助？</strong> 我们来看下面这个C语言中<a href="https://www.quora.com/What-are-some-things-that-programmers-know-but-not-computer-scientists/answer/Josh-Taylor-26?srid=XtLV&amp;share=1" target="_blank" rel="noopener">常用的循环优化</a>例子 下面两段代码中，第一段代码在C语言中总是比第二段代码的执行速度要快。具体的原因相信你仔细阅读了Cache Line的介绍后就很容易理解了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num;    </span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">        arr[i][j] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num;    </span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">        arr[j][i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CPU-Cache-是如何存放数据的"><a href="#CPU-Cache-是如何存放数据的" class="headerlink" title="CPU Cache 是如何存放数据的"></a>CPU Cache 是如何存放数据的</h2><p>假设我们有一块4MB的区域用于缓存，每个缓存对象的唯一标识是它所在的物理内存地址。每个缓存对象大小是64Bytes，所有可以被缓存对象的大小总和（即物理内存总大小）为4GB。那么我们该如何设计这个缓存？</p>
<h3 id="Fully-Associative-全关联映射"><a href="#Fully-Associative-全关联映射" class="headerlink" title="Fully Associative(全关联映射)"></a>Fully Associative(全关联映射)</h3><p>Fully Associative 字面意思是全关联。在CPU Cache中的含义是：如果在一个Cache集内，任何一个内存地址的数据可以被缓存在任何一个Cache Line里，那么我们成这个cache是Fully Associative。从定义中我们可以得出这样的结论：给到一个内存地址，要知道他是否存在于Cache中，需要遍历所有Cache Line并比较缓存内容的内存地址。而Cache的本意就是为了在尽可能少得CPU Cycle内取到数据。那么想要设计一个快速的Fully Associative的Cache几乎是不可能的。</p>
<p><img src="/images/2018/4/4.png" alt=""></p>
<h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>和Fully Associative完全相反，使用Direct Mapped模式的Cache给定一个内存地址，就唯一确定了一条Cache Line。设计复杂度低且速度快。那么为什么Cache不使用这种模式呢？直接映射方式的缺点是不够灵活，因每个主存只能固定地对应某个缓存快，即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分的利用。此外，如果程序恰好重复要访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而降低命中率。</p>
<p><img src="/images/2018/4/5.png" alt=""></p>
<h3 id="组相连映射"><a href="#组相连映射" class="headerlink" title="组相连映射"></a>组相连映射</h3><p>为了避免以上两种设计模式的缺陷，N-Way Set Associative缓存就出现了。他的原理是把一个缓存按照N个Cache Line作为一组（set），缓存按组划为等分。这样一个64位系统的内存地址在4MB二级缓存中就划成了三个部分（见下图），低位6个bit表示在Cache Line中的偏移量，中间12bit表示Cache组号（set index），剩余的高位46bit就是内存地址的唯一id。这样的设计相较前两种设计有以下两点好处：(16路组相连)</p>
<ul>
<li>给定一个内存地址可以唯一对应一个set，对于set中只需遍历16个元素就可以确定对象是否在缓存中（Full Associative中比较次数随内存大小线性增加）</li>
<li>每2^18(512K)*64=32M的连续热点数据才会导致一个set内的conflict（Direct Mapped中512K的连续热点数据就会出现conflict）</li>
</ul>
<p><img src="/images/2018/4/6.png" alt=""></p>
<p><img src="/images/2018/4/7.png" alt=""></p>
<h2 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h2><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>随机确定要替换的块</p>
<h3 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h3><p>选择最先调入的块进行替换</p>
<h3 id="LRU（最近最少使用）"><a href="#LRU（最近最少使用）" class="headerlink" title="LRU（最近最少使用）"></a>LRU（最近最少使用）</h3><p>根据块的使用情况，选择最近最少使用的块进行替换，反映了程序的局部性规律</p>
<h2 id="写模式"><a href="#写模式" class="headerlink" title="写模式"></a>写模式</h2><h3 id="Write-through（直写模式）"><a href="#Write-through（直写模式）" class="headerlink" title="Write-through（直写模式）"></a>Write-through（直写模式）</h3><p>在数据更新时，同时写入缓存Cache和后端存储(如下一级cache或者内存)。此模式的优点是操作简单；缺点是因为数据修改需要同时写入存储，数据写入速度较慢。</p>
<h3 id="Write-back（回写模式）"><a href="#Write-back（回写模式）" class="headerlink" title="Write-back（回写模式）"></a>Write-back（回写模式）</h3><p>在数据更新时只写入缓存Cache。只在数据被替换出缓存时，被修改的缓存数据才会被写到后端存储。此模式的优点是数据写入速度快，因为不需要写存储；缺点是一旦更新后的数据未被写入存储时出现系统掉电的情况，数据将无法找回。</p>
<hr>
<p>参考资料:</p>
<ol>
<li><a href="http://cenalulu.github.io/linux/all-about-cpu-cache/" target="_blank" rel="noopener">关于CPU Cache – 程序猿需要知道的那些事</a></li>
<li><a href="https://www.jianshu.com/p/061a5d66ea20" target="_blank" rel="noopener">CPU Cache结构
</a></li>
<li>《计算机组成原理》（第2版） 唐朔飞 编著</li>
<li><a href="http://witmax.cn/cache-writing-policies.html" target="_blank" rel="noopener">Cache写机制：Write-through与Write-back</a></li>
<li><a href="https://coolshell.cn/articles/10249.html" target="_blank" rel="noopener">7个示例科普CPU CACHE</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/09/Jeff-Dean系统资料整理/">Jeff Dean系统资料整理</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-09
        </span>
        
          <span class="post-category">
            
              <a href="/categories/经验/">经验</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p><a href="https://www.zhihu.com/question/22081653" target="_blank" rel="noopener">Jeff Dean的传说</a>。</p>
<ul>
<li><a href="https://scholar.google.com/citations?user=NMS69lQAAAAJ&amp;hl=zh-CN&amp;oi=ao" target="_blank" rel="noopener">Jeff Dean谷歌学术</a></li>
<li><a href="https://dblp.uni-trier.de/pers/hd/d/Dean:Jeffrey" target="_blank" rel="noopener">Jeff Dean dblp</a></li>
<li><p><a href="https://www.youtube.com/watch?v=modXC5IWTJI&amp;t=269s" target="_blank" rel="noopener">Building Software Systems At Google and Lessons Learned</a></p>
<p>Building Software Systems At Google and Lessons Learned为Jeff Dean 在Stanford大学做的一个非常精彩的演讲。<a href="http://www.slideshare.net/parallellabs/building-software-systems-at-google-and-lessons-learned" target="_blank" rel="noopener">slides</a></p>
</li>
<li><p><a href="https://gist.github.com/hellerbarde/2843375" target="_blank" rel="noopener">Latency numbers every programmer should know</a><br>需要记住的数字。最新:<a href="https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html" target="_blank" rel="noopener">Latency Numbers Every Programmer Should Know
</a></p>
</li>
<li><p><a href="http://infolab.stanford.edu/infoseminar/archive/WinterY2013/dean.pdf" target="_blank" rel="noopener">Large-Scale Data and Computation: Challenges and Opportunities</a></p>
</li>
</ul>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="https://coolshell.cn/articles/3301.html" target="_blank" rel="noopener">JEFF DEAN的STANFORD演讲</a></li>
<li><a href="http://www.parallellabs.com/2010/12/02/jeff-dean-on-google-system-architecture/" target="_blank" rel="noopener">Jeff Dean关于Google系统架构的讲座</a></li>
<li><a href="http://hedengcheng.com/?p=828#more-828" target="_blank" rel="noopener">何登成 2013年个人微博推荐技术资料汇总</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/20/数据结构-树的归纳总结/">数据结构:树的归纳总结</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-20
        </span>
        
          <span class="post-category">
            
              <a href="/categories/数据结构/">数据结构</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>最近，因为要准备找工作，所以本文特意总结归纳一下数据结构中重要的一块：树。</p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树（BST：Binary Search Tree）是一种特殊的二叉树，它改善了二叉树节点查找的效率。二叉查找树有以下性质：</p>
<p>对于任意一个节点 n，</p>
<ul>
<li>其左子树（left subtree）下的每个后代节点（descendant node）的值都小于节点 n 的值；</li>
<li>其右子树（right subtree）下的每个后代节点的值都大于节点 n 的值。</li>
</ul>
<p>所谓节点 n 的子树，可以将其看作是以节点 n 为根节点的树。子树的所有节点都是节点 n 的后代，而子树的根则是节点 n 本身。</p>
<p>BST的查找、插入、删除操作的运行时间与BST的拓扑结构有关，最佳情况是O(log­ n)，而最坏情况是 O(n)。</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html" target="_blank" rel="noopener">AVL树</a>是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>
<p>引入平衡二叉树的目的是为了提高二叉查找树的搜索的效率,减少树的平均搜索长度。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><a href="https://github.com/liujunming/Data-Structure/tree/master/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">红黑树</a>是一种自平衡二叉查找树，典型的用途是实现关联数组。</p>
<p>红黑树的性质:</p>
<ol>
<li>节点是红色或黑色</li>
<li>根是黑色</li>
<li>所有叶子都是黑色</li>
<li>每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</li>
</ol>
<p>红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，性能整体来说要优于AVL树。</p>
<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>在计算机科学中，<a href="http://liujunming.top/2016/07/12/Trie%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Trie</a>，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p><img src="/images/2018/3/6.png" alt=""></p>
<center>一个保存了8个键的trie结构，”A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, and “inn”.</center>

<h2 id="基数树-Radix-Tree"><a href="#基数树-Radix-Tree" class="headerlink" title="基数树(Radix Tree)"></a>基数树(Radix Tree)</h2><p>基数树，或称压缩前缀树，是一种更节省空间的Trie。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。</p>
<p><img src="/images/2018/3/7.png" alt=""></p>
<p>在Linux内核中，<a href="http://liujunming.top/2017/06/25/address-space-%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/" target="_blank" rel="noopener">一个address_space对象对应一个基树</a>。</p>
<h2 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h2><p>详情请从参考<a href="http://liujunming.top/2016/05/13/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">B树和B+树的定义以及应用</a>。</p>
<p>对于在内存中的查找结构而言，红黑树的效率已经非常好了。但是如果是数据量非常大的查找呢？将这些数据全部放入内存组织成红黑树结构显然是不实际的。实际上，像OS中的文件目录存储，数据库中的文件索引结构的存储…. 都不可能在内存中建立查找结构，必须在磁盘中建立好这个结构。那么在这个背景下，红黑树显然不是一种好的选择。</p>
<p>在磁盘中组织查找结构，从任何一个结点指向其他结点都有可能读取一次磁盘数据，再将数据写入内存进行比较。大家都知道，频繁的磁盘IO操作，效率是很低下的(机械运动比电子运动要慢不知道多少)。显而易见，所有的二叉树的查找结构在磁盘中都是低效的。因此，B树很好的解决了这一个问题。</p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="https://troywu0.gitbooks.io/spark/content/b-%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-avl%E6%A0%91-%E6%AF%94%E8%BE%83.html" target="_blank" rel="noopener">b-树-红黑树-二叉搜索树-avl树-比较</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/12/linux-kernel中哈希链表的解析/">linux kernel中哈希链表的解析</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-12
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Kernel/">Kernel</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>先来直观的比较下普通链表和哈希链表：<br><img src="/images/2018/3/5.png" alt=""></p>
<h2 id="普通链表"><a href="#普通链表" class="headerlink" title="普通链表"></a>普通链表</h2><p>普通链表的表头和节点相同<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>详情请参考<a href="http://fromwiz.com/share/s/1PYo-Q2jm4ra2b6ROu1eWFn11kdCyt0v54f82YHTYf0dOuhd" target="_blank" rel="noopener">内核数据结构之链表</a>。</p>
<h2 id="哈希链表"><a href="#哈希链表" class="headerlink" title="哈希链表"></a>哈希链表</h2><p>哈希链表头<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>哈希链表节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>Linux链表设计者认为双指针表头双循环链表对于HASH表来说过于浪费，因而另行设计了一套用于HASH表的hlist数据结构，即单指针表头双循环链表。hlist表头仅有一个指向首节点的指针，而没有指向尾节点的指针，这样在海量的HASH表中存储的表头就能减少一半的空间消耗。</p>
<p>这里还需要注意：struct hlist_node **pprev，也就是说pprev是指向前一个节点(也可以是表头)中next指针的指针。</p>
<p><strong>Q：</strong> 为什么不使用struct hlist_node *prev，即让prev指向前一个节点呢？<br><strong>A：</strong> 因为这时候表头(hlist_head)和节点(hlist_node)的数据结构不同。如果使用struct hlist_node *prev，只适用于前一个为节点的情况，而不适用于前一个为表头的情况。如果每次操作都要考虑指针类型转换，会是一件麻烦的事情。所以，我们需要一种统一的操作，而不用考虑前一个元素是节点还是表头。<br>struct hlist_node **pprev，pprev指向前一个元素的next指针，不用管前一个元素是节点还是表头。当我们需要操作前一个元素(节点或表头)，可以统一使用*(node-&gt;pprev)来访问和修改前一元素的next(或first)指针。</p>
<p>原理图如下：<br><img src="/images/2018/3/6" alt=""></p>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="(1) 初始化"></a>(1) 初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Double linked lists with a single pointer list head.</span></span><br><span class="line"><span class="comment"> * Mostly useful for hash tables where the two pointer list head is too wasteful.</span></span><br><span class="line"><span class="comment"> * You lose the ability to access the tail in O(1).</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLIST_HEAD_INIT &#123; .first = NULL &#125;  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLIST_HEAD (name) struct hlist_head name = &#123; .first = NULL &#125;  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)</span></span><br></pre></td></tr></table></figure>
<h3 id="2-插入"><a href="#2-插入" class="headerlink" title="(2) 插入"></a>(2) 插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* next must be != NULL */</span>  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_add_before</span><span class="params">(struct hlist_node *n, struct hlist_node *next)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    n-&gt;pprev = next-&gt;pprev;  </span><br><span class="line">    n-&gt;next = next;  </span><br><span class="line">    next-&gt;pprev = &amp;n-&gt;next;  </span><br><span class="line">    *(n-&gt;pprev) = n;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-删除"><a href="#3-删除" class="headerlink" title="(3) 删除"></a>(3) 删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __hlist_del(struct hlist_node *n)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span> = <span class="title">n</span>-&gt;<span class="title">next</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> **<span class="title">prev</span> = <span class="title">n</span>-&gt;<span class="title">pprev</span>;</span>  </span><br><span class="line">    *pprev = next;  </span><br><span class="line">    <span class="keyword">if</span> (next)  </span><br><span class="line">        next-&gt;pprev = pprev;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-遍历"><a href="#4-遍历" class="headerlink" title="(4) 遍历"></a>(4) 遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *) 0)-&gt;MEMBER)  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * container_of - cast a member of a structure out to the containing structure</span></span><br><span class="line"><span class="comment"> * @ptr: the pointer to the member.</span></span><br><span class="line"><span class="comment"> * @type: the type of the container struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member: the name of the member within the struct.</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;    \  </span></span><br><span class="line">    const typeof(((type *) 0)-&gt;member) * __mptr = (ptr);    \  </span><br><span class="line">    (type *) ((<span class="keyword">char</span> *) __mptr - offsetof(type, member)); &#125;)  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_entry(ptr, type, member) container_of(ptr, type, member)  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each(pos, head) \  </span></span><br><span class="line">    <span class="keyword">for</span> (pos = (head)-&gt;first; pos; pos = pos-&gt;next)  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_for_each_entry - iterate over list of given type</span></span><br><span class="line"><span class="comment"> * @tpos: the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @pos: the &amp;struct hlist_node to use a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head: the head for your list.</span></span><br><span class="line"><span class="comment"> * @member: the name of the hlist_node within the struct.</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_entry(tpos, pos, head, member)    \  </span></span><br><span class="line">    <span class="keyword">for</span> (pos = (head)-&gt;first;    \  </span><br><span class="line">           pos &amp;&amp; (&#123; tpos = hlist_entry(pos, typeof(*tpos), member); <span class="number">1</span>;&#125;);    \  </span><br><span class="line">           pos = pos-&gt;next)</span><br></pre></td></tr></table></figure>
<hr>
<p>参考资料:</p>
<ol>
<li><p><a href="http://blog.csdn.net/zhangskd/article/details/11225301" target="_blank" rel="noopener">哈希链表及其变种</a></p>
</li>
<li><p><a href="http://cxd2014.github.io/2015/10/26/KernelList/" target="_blank" rel="noopener">Linux内核链表</a></p>
</li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/06/系统性能分析工具/">系统性能分析工具</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-06
        </span>
        
          <span class="post-category">
            
              <a href="/categories/工具/">工具</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>在系统运行过程中，我们往往会对某实验结果感到困惑，此刻，我们需要利用一些系统性能分析工具进行分析，查看问题的来源。下面，就介绍几种常用的工具：</p>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况。top命令的详解请参考<a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="noopener">这篇文章</a>。</p>
<h2 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h2><p>perf 是用来进行软件性能分析的工具,使用 perf，你可以分析程序运行期间发生的硬件事件，比如 instructions retired ，processor clock cycles 等；你也可以分析软件事件，比如 page fault 和进程切换。<br>这使得 perf 拥有了众多的性能分析能力，举例来说，使用 perf 可以计算每个时钟周期内的指令数，称为 IPC，IPC 偏低表明代码没有很好地利用 CPU。perf 还可以对程序进行函数级别的采样，从而了解程序的性能瓶颈究竟在哪里等等。</p>
<h3 id="perf-的基本使用"><a href="#perf-的基本使用" class="headerlink" title="perf 的基本使用"></a>perf 的基本使用</h3><p>perf的安装：<br>sudo apt-get install linux-tools-common linux-tools-generic linux-tools-`uname -r`</p>
<p>说明一个工具的最佳途径是列举一个例子。</p>
<p>考查下面这个例子程序。其中函数 longa() 是个很长的循环，比较浪费时间。函数 foo1 和 foo2 将分别调用该函数 10 次，以及 100 次。</p>
<p>清单 1. 测试程序 t1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">  j=i; <span class="comment">//am I silly or crazy? I feel boring and desperate.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span> ; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">       longa();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)</span><br><span class="line">     longa();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  foo1();</span><br><span class="line">  foo2();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>找到这个程序的性能瓶颈无需任何工具，肉眼的阅读便可以完成。Longa() 是这个程序的关键，只要提高它的速度，就可以极大地提高整个程序的运行效率。</p>
<p>但因为其简单，却正好可以用来演示 perf 的基本使用。</p>
<h3 id="perf-stat"><a href="#perf-stat" class="headerlink" title="perf stat"></a>perf stat</h3><p>做任何事都最好有条有理。老手往往能够做到不慌不忙，循序渐进，而新手则往往东一下，西一下，不知所措。</p>
<p>面对一个问题程序，最好采用自顶向下的策略。先整体看看该程序运行时各种统计事件的大概，再针对某些方向深入细节。而不要一下子扎进琐碎细节，会一叶障目的。</p>
<p>有些程序慢是因为计算量太大，其多数时间都应该在使用 CPU 进行计算，这叫做 CPU bound 型；有些程序慢是因为过多的 IO，这种时候其 CPU 利用率应该不高，这叫做 IO bound 型；对于 CPU bound 程序的调优和 IO bound 的调优是不同的。</p>
<p>如果你认同这些说法的话，perf stat 应该是你最先使用的一个工具。它通过概括精简的方式提供被调试程序运行的整体情况和汇总数据。</p>
<p>还记得我们前面准备的那个例子程序么？现在将它编译为可执行文件 t1<br><code>gcc -o t1 -g test.c</code></p>
<p>下面演示了 perf stat 针对程序 t1 的输出：<br><code>perf stat ./t1</code><br><img src="/images/2018/3/1.png" alt=""><br>上面告诉我们，程序 t1 是一个 CPU bound 型，因为 task-clock-msecs 接近 1。</p>
<p>对 t1 进行调优应该要找到热点 ( 即最耗时的代码片段 )，再看看是否能够提高热点代码的效率。</p>
<p>缺省情况下，除了 task-clock-msecs 之外，perf stat 还给出了其他几个最常用的统计信息：</p>
<p>Task-clock-msecs：CPU 利用率，该值高，说明程序的多数时间花费在 CPU 计算上而非 IO。</p>
<p>Context-switches：进程切换次数，记录了程序运行过程中发生了多少次进程切换，频繁的进程切换是应该避免的。</p>
<p>Cache-references: cache 命中的次数</p>
<p>Cache-misses：cache 失效的次数,反应了程序运行过程中总体的 cache 利用情况，如果该值过高，说明程序的 cache 利用不好。</p>
<p>CPU-migrations：表示进程 t1 运行过程中发生了多少次 CPU 迁移，即被调度器从一个 CPU 转移到另外一个 CPU 上运行。</p>
<p>Cycles：处理器时钟，一条机器指令可能需要多个 cycles。</p>
<p>Instructions: 机器指令数目。</p>
<p>IPC：是 Instructions/Cycles 的比值，该值越大越好，说明程序充分利用了处理器的特性。</p>
<h3 id="perf-top"><a href="#perf-top" class="headerlink" title="perf top"></a>perf top</h3><p>使用 perf stat 的时候，往往你已经有一个调优的目标。比如我刚才写的那个程序 t1。</p>
<p>也有些时候，你只是发现系统性能无端下降，并不清楚究竟哪个进程占据了系统大部分资源。</p>
<p>此时需要一个类似 top 的命令，列出所有值得怀疑的进程，从中找到需要进一步审查的家伙。类似法制节目中办案民警常常做的那样，通过查看监控录像从茫茫人海中找到行为古怪的那些人，而不是到大街上抓住每一个人来审问。</p>
<p>perf top 用于实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程。</p>
<p>让我们再设计一个例子来演示吧。</p>
<p>不知道你怎么想，反正我觉得做一件有益的事情很难，但做点儿坏事儿却非常容易。我很快就想到了如代码清单 2 所示的一个程序：</p>
<p>清单 2. 一个死循环<br><code>while (1) i++;</code></p>
<p>我叫他 t2。启动 t2，然后用 perf top 来观察：</p>
<p>下面是 perf top 的输出：<br><img src="/images/2018/3/2.png" alt=""></p>
<p>很容易便发现 t2 是需要关注的可疑程序。不过其作案手法太简单：肆无忌惮地浪费着 CPU。所以我们不用再做什么其他的事情便可以找到问题所在。但现实生活中，影响性能的程序一般都不会如此愚蠢，所以我们往往还需要使用其他的 perf 工具进一步分析。</p>
<h3 id="使用-perf-record-和perf-report"><a href="#使用-perf-record-和perf-report" class="headerlink" title="使用 perf record 和perf report"></a>使用 perf record 和perf report</h3><p>使用 top 和 stat 之后，你可能已经大致有数了。要进一步分析，便需要一些粒度更细的信息。比如说你已经断定目标程序计算量较大，也许是因为有些代码写的不够精简。那么面对长长的代码文件，究竟哪几行代码需要进一步修改呢？这便需要使用 perf record 记录单个函数级别的统计信息，并使用 perf report 来显示统计结果。</p>
<p>你的调优应该将注意力集中到百分比高的热点代码片段上，假如一段代码只占用整个程序运行时间的 0.1%，即使你将其优化到仅剩一条机器指令，恐怕也只能将整体的程序性能提高 0.1%。俗话说，好钢用在刀刃上，不必我多说了。</p>
<p>仍以 t1 为例。<br><code>perf record – e cpu-clock ./t1</code><br><code>perf report</code></p>
<p> perf report 示例结果如下图所示：<br><img src="/images/2018/3/3.png" alt=""></p>
<p>不出所料，热点是 longa( ) 函数。</p>
<p>但代码是非常复杂的，t1 程序中的 foo1() 也是一个潜在的调优对象，为什么要调用 100 次那个无聊的 longa() 函数呢？但我们在上图中无法发现 foo1 和 foo2，更无法了解他们的区别了。</p>
<p>使用 perf 的 -g 选项便可以得到需要的信息：<br><code>perf record – e cpu-clock – g ./t1</code><br><code>perf report</code></p>
<p>perf – g report 示例结果如下图所示：<br><img src="/images/2018/3/4.png" alt=""></p>
<p>通过对调用图的分析，能很方便地看到 91% 的时间都花费在 foo1() 函数中，因为它调用了 100 次 longa() 函数，因此假如 longa() 是个无法优化的函数，那么程序员就应该考虑优化 foo1，减少对 longa() 的调用次数。</p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="noopener">top命令</a></li>
<li><a href="http://linux.51yip.com/search/perf" target="_blank" rel="noopener">perf linux指令</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/" target="_blank" rel="noopener">perf – Linux下的系统性能调优工具</a></li>
<li><a href="http://files.cnblogs.com/files/jiayy/Linux%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%BA%A7%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%E5%B7%A5%E5%85%B7-perf-1.pdf" target="_blank" rel="noopener">Linux 的系统级性能剖析工具‐perf </a></li>
<li><a href="http://www.brendangregg.com/perf.html" target="_blank" rel="noopener">perf Examples</a></li>
<li><a href="https://www.cnblogs.com/arnoldlu/p/6241297.html" target="_blank" rel="noopener">系统级性能分析工具perf的介绍与使用</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/01/19/Docker基础技术：DeviceMapper/">Docker基础技术：DeviceMapper</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-19
        </span>
        
          <span class="post-category">
            
              <a href="/categories/容器/">容器</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>本文转载自:<a href="https://coolshell.cn/articles/17200.html" target="_blank" rel="noopener">DOCKER基础技术：DEVICEMAPPER</a></p>
<p>在上一篇<a href="https://coolshell.cn/articles/17061.html" target="_blank" rel="noopener">介绍AUFS的文章</a>中，大家可以看到，Docker的分层镜像是怎么通过UnionFS这种文件系统做到的，但是，因为Docker首选的AUFS并不在Linux的内核主干里，所以，对于非Ubuntu的Linux分发包，比如CentOS，就无法使用AUFS作为Docker的文件系统了。于是作为第二优先级的DeviceMapper就被拿出来做分层镜像的一个实现。<br><img src="/images/2018/1/9.jpg" alt=""></p>
<h2 id="Device-Mapper-简介"><a href="#Device-Mapper-简介" class="headerlink" title="Device Mapper 简介"></a>Device Mapper 简介</h2><p>DeviceMapper自Linux 2.6被引入，成为了Linux最重要的一个技术。它是内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构，它包含三个重要的对象概念，Mapped Device、Mapping Table、Target device。</p>
<p>Mapped Device 是一个逻辑抽象，可以理解成为内核向外提供的逻辑设备，它通过Mapping Table描述的映射关系和 Target Device 建立映射。Target device 表示的是 Mapped Device 所映射的物理空间段，对 Mapped Device 所表示的逻辑设备来说，就是该逻辑设备映射到的一个物理设备。</p>
<p>Mapping Table里有 Mapped Device 逻辑的起始地址、范围、和表示在 Target Device 所在物理设备的地址偏移量以及Target 类型等信息（注：这些地址和偏移量都是以磁盘的扇区为单位的，即 512 个字节大小，所以，当你看到128的时候，其实表示的是128*512=64K）。</p>
<p>DeviceMapper 中的逻辑设备Mapped Device不但可以映射一个或多个物理设备Target Device，还可以映射另一个Mapped Device，于是，就是构成了一个迭代或递归的情况，就像文件系统中的目录里除了文件还可以有目录，理论上可以无限嵌套下去。</p>
<p>DeviceMapper在内核中通过一个个模块化的 Target Driver 插件实现对 IO 请求的过滤或者重新定向等工作，当前已经实现的插件包括软 Raid、加密、多路径、镜像、快照等，这体现了在 Linux 内核设计中策略和机制分离的原则。如下图所示。从图中，我们可以<strong>看到DeviceMapper只是一个框架，在这个框架上，我们可以插入各种各样的策略</strong>，在这诸多“插件”中，<strong>有一个东西叫Thin Provisioning Snapshot，这是Docker使用DeviceMapper中最重要的模块</strong>。</p>
<p><img src="/images/2018/1/10.gif" alt=""></p>
<center>图片来源：<a href="http://people.redhat.com/agk/talks/FOSDEM_2005/" target="_blank" rel="noopener">http://people.redhat.com/agk/talks/FOSDEM_2005/</a></center>

<h2 id="Thin-Provisioning-简介"><a href="#Thin-Provisioning-简介" class="headerlink" title="Thin Provisioning 简介"></a>Thin Provisioning 简介</h2><p>Thin Provisioning要怎么翻译成中文，真是一件令人头痛的事，我就不翻译了。这个技术是虚拟化技术中的一种。它是什么意思呢？你可以联想一下我们计算机中的内存管理中用到的——“虚拟内存技术”——操作系统给每个进程N多N多用不完的内址地址，但是呢，我们知道，物理内存是没有那么多的，如果按照进程内存和物理内存一一映射来玩的话，那么，我们得要多少的物理内存啊。所以，操作系统引入了虚拟内存的设计，意思是，我逻辑上给你无限多的内存，但是实际上是实报实销，因为我知道你一定用不了那么多，于是，达到了内存使用率提高的效果。（今天云计算中很多所谓的虚拟化其实完全都是在用和“虚拟内存”相似的Thin Provisioning的技术）</p>
<p>好了，话题拉回来，我们这里说的是存储。看下面两个图（<a href="http://www.architecting.it/2009/06/04/enterprise-computing-why-thin-provisioning-is-not-the-holy-grail-for-utilisation/" target="_blank" rel="noopener">图片来源</a>），第一个是Fat Provisioning，第二个是Thin Provisioning，其很好的说明了是个怎么一回事（和虚拟内存是一个概念）</p>
<p><img src="/images/2018/1/10.jpg" alt=""></p>
<p><img src="/images/2018/1/11.jpg" alt=""></p>
<p>那么，Docker是怎么使用Thin Provisioning这个技术做到像UnionFS那样的分层镜像的呢？答案是，Docker使用了Thin Provisioning的Snapshot的技术。下面我们来介绍一下Thin Provisioning的Snapshot。</p>
<h2 id="Thin-Provisioning-Snapshot-演示"><a href="#Thin-Provisioning-Snapshot-演示" class="headerlink" title="Thin Provisioning Snapshot 演示"></a>Thin Provisioning Snapshot 演示</h2><p>下面，我们用一系列的命令来演示一下Device Mapper的Thin Provisioning Snapshot是怎么玩的,请切换到root用户运行命令。</p>
<p>首先，我们需要先建两个文件，一个是data.img，另一个是meta.data.img：<br><code>dd if=/dev/zero of=/tmp/data.img bs=1K count=1 seek=10M</code><br><code>dd if=/dev/zero of=/tmp/meta.data.img bs=1K count=1 seek=100K</code></p>
<p><img src="/images/2018/1/12.png" alt=""></p>
<p>注意命令中seek选项，表示在备份时对of后面的部分也就是目标文件跳过多少块再开始写内容。因为bs是1K个字节，即块大小为1KB，所以当seek=10M时，也就是在备份时对data.img跳过10M个块（即10GB）再开始写内容。但此刻data.img在硬盘上占有空间只有1k的内容，当向其写入内容时，才会在硬盘上为其分配空间。我们可以用ls命令看一下data.img和meta.data.img实际分配的空间。</p>
<p><code>ls -lsh /tmp/data.img</code><br><code>ls -lsh /tmp/meta.data.img</code></p>
<p><img src="/images/2018/1/13.png" alt=""></p>
<p>然后，我们为这些文件创建<a href="http://liujunming.top/2018/01/17/%E5%9B%9E%E7%8E%AF%E8%AE%BE%E5%A4%87loopback-device/" target="_blank" rel="noopener">loopback设备</a>。</p>
<p><code>losetup /dev/loop2015 /tmp/data.img</code><br><code>losetup /dev/loop2016 /tmp/meta.data.img</code></p>
<p><code>losetup -a</code></p>
<p><img src="/images/2018/1/14.png" alt=""></p>
<p>现在，我们为设备建一个Thin Provisioning的Pool，用dmsetup命令</p>
<p><code>dmsetup create hchen-thin-pool --table &quot;0 20971520 thin-pool /dev/loop2016 /dev/loop2015 128 65536 1 skip_block_zeroing&quot;</code></p>
<p>其中的参数解释如下（更多信息可参看<a href="https://github.com/torvalds/linux/blob/master/Documentation/device-mapper/thin-provisioning.txt" target="_blank" rel="noopener">Thin Provisioning的man page</a>）：</p>
<ul>
<li>dmsetup create是用来创建thin pool的命令</li>
<li>hchen-thin-pool 是自定义的一个pool名，不冲突就好。</li>
<li>–table是这个pool的参数设置<ul>
<li>0代表数据起始的sector号</li>
<li>20971520数据结束的sector号，一个sector是512字节，所以，20971520个正好是10GB</li>
<li>/dev/loop2016是meta文件的设备（前面我们建好了）</li>
<li>/dev/loop2015是data文件的设备（前面我们建好了）</li>
<li>128是最小的可分配的sector数</li>
<li>65536是最少可用sector的water mark，也就是一个threshold</li>
<li>1 代表有一个附加参数</li>
<li>skip_block_zeroing是个附加参数，表示略过用0填充的块</li>
</ul>
</li>
</ul>
<p>然后，我们就可以看到一个Device Mapper的设备了：<br><code>ll /dev/mapper/hchen-thin-pool</code></p>
<p><img src="/images/2018/1/15.png" alt=""></p>
<p>我们的初始化工作还没有完成，接下来，还要创建一个Thin Provisioning 的 Volume：</p>
<p><code>dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_thin 0&quot;</code><br><code>dmsetup create hchen-thin-volumn-001 --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 0&quot;</code></p>
<p>其中：</p>
<ul>
<li>第一个命令中的create_thin是关键字，后面的0表示这个Volume的device 的 id</li>
<li>第二个命令，是真正的为这个Volumn创建一个可以mount的设备，名字叫hchen-thin-volumn-001。</li>
</ul>
<p>好了，在mount前，我们还要格式化一下：<br><code>mkfs.ext4 /dev/mapper/hchen-thin-volumn-001</code><br><img src="/images/2018/1/16.png" alt=""></p>
<p>好了，我们可以mount了（下面的命令中，我还创建了一个文件）<br><code>mkdir -p /mnt/base</code><br><code>mount /dev/mapper/hchen-thin-volumn-001 /mnt/base</code><br><code>echo &quot;hello world, I am a base&quot; &gt; /mnt/base/id.txt</code><br><code>cat /mnt/base/id.txt</code><br><img src="/images/2018/1/17.png" alt=""><br>好了，接下来，我们来看看snapshot怎么搞：<br><code>dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_snap 1 0&quot;</code><br><code>dmsetup create mysnap1 --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 1&quot;</code></p>
<p><code>ll /dev/mapper/mysnap1</code><br><img src="/images/2018/1/18.png" alt=""><br>上面的命令中：</p>
<ul>
<li>第一条命令是向hchen-thin-pool发一个create_snap的消息，后面跟两个id，第一个是新的dev id，第二个是要从哪个已有的dev id上做snapshot（0这个dev id是我们前面就创建了了）</li>
<li>第二条命令是创建一个mysnap1的device，并可以被mount。</li>
</ul>
<p>下面我们来看看：<br><code>mkdir -p /mnt/mysnap1</code><br><code>mount /dev/mapper/mysnap1 /mnt/mysnap1</code></p>
<p><code>ll /mnt/mysnap1/</code></p>
<p><code>cat /mnt/mysnap1/id.txt</code></p>
<p><img src="/images/2018/1/19.png" alt=""></p>
<p>我们来修改一下/mnt/mysnap1/id.txt，并加上一个snap1.txt的文件：<br><code>echo &quot;I am snap1&quot; &gt;&gt; /mnt/mysnap1/id.txt</code><br><code>echo &quot;I am snap1&quot; &gt; /mnt/mysnap1/snap1.txt</code></p>
<p><code>cat /mnt/mysnap1/id.txt</code></p>
<p><code>cat /mnt/mysnap1/snap1.txt</code></p>
<p><img src="/images/2018/1/20.png" alt=""></p>
<p>我们再看一下/mnt/base，你会发现没有什么变化：<br><code>ls /mnt/base</code><br><code>cat /mnt/base/id.txt</code></p>
<p><img src="/images/2018/1/21.png" alt=""></p>
<p>你是不是已经看到了分层镜像的样子了？</p>
<p>你还可以继续在刚才的snapshot上再建一个snapshot<br><code>dmsetup message /dev/mapper/hchen-thin-pool 0 &quot;create_snap 2 1&quot;</code><br><code>dmsetup create mysnap2  --table &quot;0 2097152 thin /dev/mapper/hchen-thin-pool 2&quot;</code></p>
<p><code>ll /dev/mapper/mysnap2</code></p>
<p><code>mkdir -p /mnt/mysnap2</code><br><code>mount /dev/mapper/mysnap2 /mnt/mysnap2</code><br><code>ls /mnt/mysnap2</code></p>
<p><img src="/images/2018/1/22.png" alt=""></p>
<p>好了，我相信你看到了分层镜像的样子了。</p>
<p>看完演示，我们再来补点理论知识吧：</p>
<ul>
<li>Snapshot来自LVM（<a href="http://liujunming.top/2018/01/18/%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86-LVM/" target="_blank" rel="noopener">Logic Volumn Manager</a>），它可以在不中断服务的情况下为某个device打一个快照。</li>
<li>Snapshot是Copy-On-Write的，也就是说，只有发生了修改，才会对对应的内容进行拷贝。</li>
</ul>
<p>另外，这里有篇文章<a href="http://searchstorage.techtarget.com/tip/Storage-thin-provisioning-benefits-and-challenges" target="_blank" rel="noopener">Storage thin provisioning benefits and challenges</a>可以前往一读。</p>
<h2 id="Docker的DeviceMapper"><a href="#Docker的DeviceMapper" class="headerlink" title="Docker的DeviceMapper"></a>Docker的DeviceMapper</h2><p>上面基本上就是Docker的玩法了。</p>
<p><code>ls -alhs /var/lib/docker/devicemapper/devicemapper</code><br><img src="/images/2018/1/24.png" alt=""></p>
<p>下面是相关的thin-pool。其中，有个一大串hash的device是正在启动的容器：<br><code>sudo ll /dev/mapper/dock*</code><br><img src="/images/2018/1/25.png" alt=""></p>
<p>我们可以看一下它的device id（Docker都把它们记下来了）：<br><code>cat /var/lib/docker/devicemapper/metadata/29ef919ba2a241fa4fdb024fb66923522cea89e155162ca83b454212569b8f21</code><br><img src="/images/2018/1/26.png" alt=""></p>
<p>device_id是1326，size是10737418240，除以512，就是20971520 个 sector，我们用这些信息来做个snapshot看看（注：我用了一个比较大的dev id – 2048）：<br><code>dmsetup message &quot;/dev/mapper/docker-thinpool&quot; 0 &quot;create_snap 2048 1326&quot;</code><br><code>dmsetup create dockersnap --table &quot;0 20971520 thin /dev/mapper/docker-thinpool 2048&quot;</code><br><code>mkdir /mnt/docker</code><br><code>mount /dev/mapper/dockersnap /mnt/docker/</code><br><code>ls /mnt/docker/</code><br><code>ls /mnt/docker/rootfs/</code><br><img src="/images/2018/1/27.png" alt=""></p>
<p>我们在docker的容器里用findmnt命令也可以看到相关的mount的情况（因为太长，下面只是摘要）：<br><code>findmnt</code><br><img src="/images/2018/1/28.png" alt=""></p>
<p>如果你在使用loopback的devicemapper的话，当你的存储出现了问题后，正确的解决方案是：<br><code>rm -rf /var/lib/docker</code></p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/01/18/逻辑卷管理-LVM/">逻辑卷管理(LVM)</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-18
        </span>
        
          <span class="post-category">
            
              <a href="/categories/文件系统/">文件系统</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>LVM是 Logical Volume Manager（逻辑卷管理）的简写，它是Linux环境下对磁盘分区进行管理的一种机制。通过使用 LVM，所有物理磁盘和分区，无论它们的大小和分布方式如何，都被抽象为单一存储（single storage）源。例如，在图 1 所示的物理到逻辑映射布局中，最大的磁盘是 80GB 的，那么用户如何创建更大（比如 150GB）的文件系统呢？<br><img src="/images/2018/1/4.gif" alt=""></p>
<center>图 1. 物理到逻辑的映射</center>

<p>LVM 可以将分区和磁盘聚合成一个虚拟磁盘（virtual disk），从而用小的存储空间组成一个统一的大空间。这个虚拟磁盘在 LVM 术语中称为卷组（volume group）。</p>
<p>建立比最大的磁盘还大的文件系统并不是这种高级存储管理方法的惟一用途。还可以使用 LVM 完成以下任务：</p>
<ul>
<li>在磁盘池中添加磁盘和分区，对现有的文件系统进行在线扩展</li>
<li>用一个 160GB 磁盘替换两个 80GB 磁盘，而不需要让系统离线，也不需要在磁盘之间手工转移数据</li>
<li>当存储空间超过所需的空间容量时，从池中去除磁盘，从而缩小文件系统</li>
<li>使用快照（snapshot）执行一致的备份</li>
</ul>
<h2 id="LVM-的结构"><a href="#LVM-的结构" class="headerlink" title="LVM 的结构"></a>LVM 的结构</h2><p>LVM 被组织为三种元素：</p>
<ul>
<li>卷（Volume）：物理卷和逻辑卷和卷组</li>
<li>区段（Extent）：物理区段和逻辑区段</li>
<li>设备映射器（Device mapper）：Linux 内核模块</li>
</ul>
<h3 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h3><p>Linux LVM 组织为物理卷（PV）、卷组（VG）和逻辑卷（LV）。物理卷 是物理磁盘或物理磁盘分区（比如 /dev/hda 或 /dev/hdb1）。卷组是物理卷的集合。卷组可以在逻辑上划分成多个逻辑卷。<br>图 2 显示一个三个磁盘构成的布局。<br><img src="/images/2018/1/5.gif" alt=""></p>
<center>图 2. 物理到逻辑卷的映射</center>

<p>物理磁盘 0 上的所有四个分区（/dev/hda[1-4]）以及完整的物理磁盘 1（/dev/hdb）和物理磁盘 2（/dev/hdd）作为物理卷添加到卷组 VG0 中。<br>卷组是实现 n-to-m 映射的关键（也就是，将 n 个 PV 看作 m 个 LV）。在将 PV 分配给卷组之后， 就可以创建任意大小的逻辑卷（只要不超过 VG 的大小）。在图 2 的示例中，创建了一个称为 LV0 的逻辑卷，并给其他 LV 留下了一些空间（这些空间也可以用来应付 LV0 以后的增长）。</p>
<p>LVM 中的逻辑卷就相当于物理磁盘分区；在实际使用中，它们就是物理磁盘分区。</p>
<p>在创建 LV 之后，可以使用任何文件系统对它进行格式化并将它挂载在某个挂载点上，然后就可以开始使用它了。图 3 显示一个经过格式化的逻辑卷 LV0 被挂载在 /var。</p>
<p><img src="/images/2018/1/6.gif" alt=""></p>
<center>图 3. 物理卷到文件系统的映射</center>

<h3 id="区段"><a href="#区段" class="headerlink" title="区段"></a>区段</h3><p>为了实现 n-to-m 物理到逻辑卷映射，PV 和 VG 的基本块必须具有相同的大小；这些基本块称为物理区段（PE）和逻辑区段（LE）。尽管 n 个物理卷映射到 m 个逻辑卷，但是 PE 和 LE 总是一对一映射的。<br><img src="/images/2018/1/7.gif" alt=""></p>
<center>图 4. 物理到逻辑区段的映射</center>

<p>如果决定创建第二个 LV（LV1），那么最终的 PE 布局可能像图 5 这样。<br><img src="/images/2018/1/8.gif" alt=""></p>
<p><center>图 5. 物理到逻辑区段的映射</center></p>
<h3 id="设备映射器"><a href="#设备映射器" class="headerlink" title="设备映射器"></a>设备映射器</h3><p>设备映射器（也称为 dm_mod）是一个 Linux 内核模块，最早出现在 2.6.9 内核中。它的作用是对设备进行映射。</p>
<h2 id="用快照执行备份"><a href="#用快照执行备份" class="headerlink" title="用快照执行备份"></a>用快照执行备份</h2><p>如果在备份过程期间数据没有发生变化，那么就能够获得一致的备份。如果不在备份期间停止系统，就很难保证数据没有变化。</p>
<p>Linux LVM 实现了一种称为快照（Snapshot）的特性，它的作用就像是 “拍摄” 逻辑卷在某一时刻的照片。通过使用快照， 可以获得同一 LV 的两个拷贝 —— 一个可以用于备份，另一个继续用于日常操作。</p>
<p>快照有两大优点：</p>
<ol>
<li>快照的创建非常快，不需要停止生产环境</li>
<li>建立两个拷贝，但是它们的大小并不一样。快照使用的空间仅仅是存储两个 LV 之间的差异所需的空间</li>
</ol>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-lvm2/#artrelatedtopics" target="_blank" rel="noopener">逻辑卷管理</a></li>
<li><a href="https://segmentfault.com/a/1190000009249534" target="_blank" rel="noopener">LVM、物理卷、逻辑卷、卷组、快照</a></li>
<li><a href="http://blog.csdn.net/jinbusi_blog/article/details/73718740" target="_blank" rel="noopener">lvm介绍，及基本管理命令</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/01/17/回环设备loopback-device/">回环设备loopback device</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-17
        </span>
        
          <span class="post-category">
            
              <a href="/categories/文件系统/">文件系统</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>你有没有想过在Linux的文件管理系统中再创建一个文件系统，这时你就需要用到回环设备（loop device）。</p>
<p>在Linux中，<strong>回环设备允许用户以一个普通磁盘文件虚拟一个块设备</strong>。设想一个磁盘设备，对它的所有读写操作都将被重定向到读写一个名为 disk-image 的普通文件而非操作实际磁盘或分区的轨道和扇区。当然，disk-image这个名字你可以任意取，但这个文件必须存在于一个实际的磁盘上，而这个实际的磁盘必须比虚拟的磁盘（disk-image）容量更大。</p>
<p>回环设备的使用与其它任何块设备相同。特别是，你可以在这个设备上创建文件系统并像普通的磁盘一样将它挂载在系统中。这样的一个将全部内容保存在一个普通文件中的文件系统，被称为虚拟文件系统（virtual file system）。</p>
<p>下面就来演示用磁盘文件创建一个Linux回环文件系统的步骤。</p>
<h2 id="创建一个用于承载虚拟文件系统的空文件"><a href="#创建一个用于承载虚拟文件系统的空文件" class="headerlink" title="创建一个用于承载虚拟文件系统的空文件"></a>创建一个用于承载虚拟文件系统的空文件</h2><p>这个文件的大小将成为挂载后文件系统的大小。创建指定大小文件的简单方法是通过 <code>dd</code> 命令。这个命令以块为单位（通常为 512 字节，或者你也可以自定义块大小）从一个文件向另一个文件复制数据。/dev/zero 文件则是一个很好的数据来源。</p>
<p>要建立一个 30 MB 大小（zero-filled）的名为 disk-image 的文件可以通过以下命令：<br><code>dd if=/dev/zero of=/tmp/disk-image bs=1M count=30</code></p>
<h2 id="创建一个loop-device"><a href="#创建一个loop-device" class="headerlink" title="创建一个loop device"></a>创建一个loop device</h2><p>使用losetup命令创建一个loop device<br><code>sudo losetup /dev/loop0 /tmp/disk-image</code></p>
<h2 id="创建一个文件系统"><a href="#创建一个文件系统" class="headerlink" title="创建一个文件系统"></a>创建一个文件系统</h2><p><code>sudo mkfs -t ext2 /dev/loop0</code><br><img src="/images/2018/1/1.png" alt=""></p>
<h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><p>创建一个目录 /tmp/virtualfs，这个目录将被用于挂载我们的文件系统:<br><code>mkdir /tmp/virtualfs</code></p>
<p><code>sudo mount /dev/loop0 /tmp/virtualfs</code><br>这时，这个设备应该已经被挂载，就如同一个普通的30M 空间的磁盘一样。<br><code>df -h /tmp/virtualfs</code><br><img src="/images/2018/1/2.png" alt=""></p>
<h2 id="使用该磁盘"><a href="#使用该磁盘" class="headerlink" title="使用该磁盘"></a>使用该磁盘</h2><p>你可以向其它任何磁盘一样使用这个设备：<br>要记住的是只有超级用户可以使用环回设备,所以此刻需要切换到root用户<br><code>cd /tmp/virtualfs</code><br><code>echo &#39;Hello, world!&#39; &gt; test.txt</code><br><code>ls -l</code><br><code>cat test.txt</code><br><img src="/images/2018/1/3.png" alt=""></p>
<h2 id="卸载文件系统"><a href="#卸载文件系统" class="headerlink" title="卸载文件系统"></a>卸载文件系统</h2><p><code>sudo umount -l /dev/loop0</code><br><code>sudo losetup -d /dev/loop0</code><br><code>rm /tmp/disk-image</code></p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://blog.csdn.net/baimafujinji/article/details/78810042" target="_blank" rel="noopener">csdn baimafujinji</a></li>
<li><a href="http://blog.csdn.net/zgyrelax/article/details/17579411" target="_blank" rel="noopener">csdn zgyrelax</a></li>
<li><a href="http://www.zphj1987.com/2015/03/22/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAloop-device/" target="_blank" rel="noopener">zphj1987</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/12/24/filebench-环境搭建/">filebench 环境搭建</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-24
        </span>
        
          <span class="post-category">
            
              <a href="/categories/benchmark/">benchmark</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="filebench"><a href="#filebench" class="headerlink" title="filebench"></a>filebench</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><code>wget https://jaist.dl.sourceforge.net/project/filebench/1.5-alpha3/filebench-1.5-alpha3.tar.gz</code></p>
<p><code>tar -zxf filebench-1.5-alpha3.tar.gz -C /usr/local</code></p>
<p><code>apt-get install gcc</code></p>
<p><code>apt-get install flex bison</code></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>cd /usr/local/filebench-1.5-alpha3</code></p>
<p><code>./configure</code></p>
<p><code>make</code></p>
<p><code>make install</code></p>
<p>安装完成后的界面：<br><img src="/images/2017/12/1.jpeg" alt=""></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><code>cd /usr/local/share/filebench/workloads</code></p>
<p><code>filebench -f webserver.f</code></p>
<h3 id="Workload-model-language解析"><a href="#Workload-model-language解析" class="headerlink" title="Workload model language解析"></a>Workload model language解析</h3><p>以videoserver.f为例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">set $dir=/tmp</span><br><span class="line">set $eventrate=96</span><br><span class="line">set $filesize=10g</span><br><span class="line">set $nthreads=48</span><br><span class="line">set $numactivevids=32</span><br><span class="line">set $numpassivevids=194</span><br><span class="line">set $reuseit=false</span><br><span class="line">set $readiosize=256k</span><br><span class="line">set $writeiosize=1m</span><br><span class="line"></span><br><span class="line">set $passvidsname=passivevids</span><br><span class="line">set $actvidsname=activevids</span><br><span class="line"></span><br><span class="line">set $repintval=10</span><br><span class="line"></span><br><span class="line">eventgen rate=$eventrate</span><br><span class="line"></span><br><span class="line">define fileset name=$actvidsname,path=$dir,size=$filesize,entries=$numactivevids,dirwidth=4,prealloc,paralloc,reuse=$reuseit</span><br><span class="line">define fileset name=$passvidsname,path=$dir,size=$filesize,entries=$numpassivevids,dirwidth=20,prealloc=50,paralloc,reuse=$reuseit</span><br><span class="line"></span><br><span class="line">define process name=vidwriter,instances=1</span><br><span class="line">&#123;</span><br><span class="line">  thread name=vidwriter,memsize=10m,instances=1</span><br><span class="line">  &#123;</span><br><span class="line">    flowop deletefile name=vidremover,filesetname=$passvidsname</span><br><span class="line">    flowop createfile name=wrtopen,filesetname=$passvidsname,fd=1</span><br><span class="line">    flowop writewholefile name=newvid,iosize=$writeiosize,fd=1,srcfd=1</span><br><span class="line">    flowop closefile name=wrtclose, fd=1</span><br><span class="line">    flowop delay name=replaceinterval, value=$repintval</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define process name=vidreaders,instances=1</span><br><span class="line">&#123;</span><br><span class="line">  thread name=vidreaders,memsize=10m,instances=$nthreads</span><br><span class="line">  &#123;</span><br><span class="line">    flowop read name=vidreader,filesetname=$actvidsname,iosize=$readiosize</span><br><span class="line">    flowop bwlimit name=serverlimit, target=vidreader</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo  &quot;Video Server Version 3.0 personality successfully loaded&quot;</span><br><span class="line"></span><br><span class="line">run</span><br></pre></td></tr></table></figure></p>
<p>workload最后必须要有run。</p>
<p>define fileset定义数据集：prealloc代表在实际的filebench工作负载启动之前预先分配的文件的百分比；reuse若设置为true，则如果在文件系统中存在相对应的文件，则filebench将重新使用该文件。</p>
<p>在workload中，run默认时间为60s，如果希望达到指定IO操作数就结束filebench，则可以使用<code>finishoncount</code>，语法为：</p>
<p><code>flowop finishoncount name=&lt;name&gt;,value=&lt;ops&gt;</code></p>
<ul>
<li>name = Mandatory. Name of the flowop.</li>
<li>value= Mandatory. The number of operations to finish on.</li>
</ul>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="https://github.com/filebench/filebench" target="_blank" rel="noopener">github filebench</a></li>
<li><a href="http://blog.csdn.net/microsoft2014/article/details/60145433" target="_blank" rel="noopener">Filebench的安装与使用</a></li>
<li><a href="https://github.com/filebench/filebench/wiki/Workload-model-language" target="_blank" rel="noopener">Workload model language</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
      
  <nav class="pagination">
    
      <a class="prev" href="/page/2/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/4/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


    
  </section>

          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:liujunming1163@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/liujunming" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2016 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">liujunming</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script>

  </body>
</html>
