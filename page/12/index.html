<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="liujunming's personal blog."/>













  <link rel="alternate" href="/atom.xml" title="L">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1" />



<link rel="canonical" href="http://liujunming.github.io/page/12/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> L </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">L</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">L</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <section id="posts" class="posts">
    
      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/30/CGroup技术的详解/">CGroup技术的详解</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-08-30
        </span>
        
          <span class="post-category">
            
              <a href="/categories/linux/">linux</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h1 id="cgroup的简介与功能"><a href="#cgroup的简介与功能" class="headerlink" title="cgroup的简介与功能"></a>cgroup的简介与功能</h1><p>Control Groups (cgroups), which provide a mechanism for easily managing and monitoring system resources, by partitioning things like cpu time, system memory, disk and network bandwidth, into groups, then assigning tasks to those groups.</p>
<p>Let me try and explain what control groups are, and what they allow you to do. Lets say for example that you have a resources intensive application on a server. Linux is great at sharing resources between all of the processes on a system, but in some cases, you want to allocate, or guarantee, a greater amount to a specific application, or a set of applications, this is where control groups are useful.</p>
<p>For example, lets say we wanted to assign or isolate an applications resources, lets create two groups, group #1 will be for our operating system, and group #2 will be for our application, then we can assign resource profiles to each group.</p>
<p><img src="/images/2017/5/14-cgroups-overview.gif" alt="这里写图片描述"></p>
<p>Lets focus on Group #2 for a moment. Typically when you create a group, you already have a problem in mind, so for the sake of this example, lets say we wanted to manage, cpu, memory, disk and network bandwidth, for our application. So, I would create a group, and assign resources limits to this group, something like this. Keep in mind, the application knows nothing about these limits, this is happening outside of our application. So, any application that is assigned to this group, cannot use more than 80% of the cpu, 10 GB of memory, 80% of disk reads and writes, and finally, 80% of our network bandwidth. Once the group is created, you simple need to add your applications process ids, or pids, into a file, and your applications are automatically throttled. This can happen on the fly, without system reboots, you can also adjust these limits on the fly. I just wanted to mention, that our application will be allowed to spike outside these percentage limits, but if there is resource contention, our application will be throttled back to 80%.</p>
<p><img src="/images/2017/5/14-cgroups-your-app.gif" alt="这里写图片描述"></p>
<p>Monitoring is also baked in from the start, so we can monitor resource consumption for any application that is assigned to this group, things like, cpu cycles used, the memory profile, IOPS and bytes written and read from our disks, along with network bandwidth used.</p>
<p>Lets jump back for a moment, and use a different example, lets say we have an environment, where we are hosting virtual machines, instead of just having two groups, one for our operating system, and one for our application, we can have many groups, one assigned to each virtual machine. For example, lets say we are worried about a virtual machine saturating the network link or disk IOPS, we can limit the impact by using control groups, which can be really handy.</p>
<p><img src="/images/2017/5/14-cgroups-your-app-big-picture.png" alt="这里写图片描述"></p>
<h1 id="cgroup相关概念"><a href="#cgroup相关概念" class="headerlink" title="cgroup相关概念"></a>cgroup相关概念</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ol>
<li>任务（task）。在 cgroups 中，任务就是系统的一个进程；</li>
<li>控制族群（control group）。控制族群就是一组按照某种标准划分的进程。cgroups 中的资源控制都是以控制族群为单位实现。一个进程可以加入到某个控制族群，也从一个进程组迁移到另一个控制族群。一个进程组的进程可以使用 cgroups 以控制族群为单位分配的资源，同时受到 cgroups 以控制族群为单位设定的限制；</li>
<li>层级（hierarchy）。控制族群可以组织成 hierarchical 的形式，即一颗控制族群树。控制族群树上的子节点控制族群是父节点控制族群的孩子，继承父控制族群的特定的属性；</li>
<li>子系统（subsystem）。一个子系统就是一个资源控制器，比如 cpu 子系统就是控制 cpu 时间分配的一个控制器。子系统必须附加（attach）到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。</li>
</ol>
<h2 id="相互关系"><a href="#相互关系" class="headerlink" title="相互关系"></a>相互关系</h2><ol>
<li>每次在系统中创建新层级时，该系统中的所有任务都是那个层级的默认 cgroup（我们称之为 root cgroup ，此cgroup在创建层级时自动创建，后面在该层级中创建的cgroup都是此cgroup的后代）的初始成员。</li>
<li>一个子系统最多只能附加到一个层级。</li>
<li>一个层级可以附加多个子系统</li>
<li>一个任务可以是多个cgroup的成员，但是这些cgroup必须在不同的层级。</li>
<li>系统中的进程（任务）创建子进程（任务）时，该子任务自动成为其父进程所在 cgroup 的成员。然后可根据需要将该子任务移动到不同的 cgroup 中，但开始时它总是继承其父任务的cgroup。</li>
</ol>
<p><img src="/images/2016/8/30/3.png" alt=""></p>
<p>上图所示的 cgroup 层级关系显示，CPU 和 Memory 两个子系统有自己独立的层级系统，而又通过 Task Group 取得关联关系。</p>
<h1 id="cgroups子系统介绍"><a href="#cgroups子系统介绍" class="headerlink" title="cgroups子系统介绍"></a>cgroups子系统介绍</h1><ul>
<li>blkio –这个子系统为块设备设定输入/输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）。</li>
<li>cpu –这个子系统使用调度程序提供对CPU 的cgroup 任务访问。</li>
<li>cpuacct –这个子系统自动生成cgroup 中任务所使用的CPU 报告。</li>
<li>cpuset –这个子系统为cgroup 中的任务分配独立CPU（在多核系统）和内存节点。</li>
<li>devices –这个子系统可允许或者拒绝cgroup 中的任务访问设备。</li>
<li>freezer –这个子系统挂起或者恢复cgroup 中的任务。</li>
<li>memory –这个子系统设定cgroup 中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告。</li>
<li>net_cls –这个子系统使用等级识别符（classid）标记网络数据包，可允许Linux 流量控制程序（tc）识别从具体cgroup 中生成的数据包。</li>
<li>ns –名称空间子系统。</li>
</ul>
<h1 id="cgroups的使用"><a href="#cgroups的使用" class="headerlink" title="cgroups的使用"></a>cgroups的使用</h1><p>这个教程是在ubuntu下使用cgroups，限制进程的内存大小，从而验证cgroup的功能。</p>
<h2 id="安装cgroup"><a href="#安装cgroup" class="headerlink" title="安装cgroup"></a>安装cgroup</h2><p><code>sudo apt-get install cgroup-bin</code></p>
<h2 id="编写测试程序"><a href="#编写测试程序" class="headerlink" title="编写测试程序"></a>编写测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** mem-limit.c **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// intro message</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Starting ...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop 50 times, try and consume 50 MB of memory</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// failure to allocate memory?</span></span><br><span class="line">        <span class="keyword">if</span> ((p = <span class="built_in">malloc</span>(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Malloc failed at %d MB\n"</span>, i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// take memory and tell user where we are at</span></span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, (<span class="number">1</span>&lt;&lt;<span class="number">20</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Allocated %d to %d MB\n"</span>, i, i+<span class="number">1</span>);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exit message and return</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Done!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试程序的核心是循环部分，每次循环都向内存申请1MB的空间，总共循环50次。</p>
<p><code>gcc mem-limit.c -o mem-limit</code></p>
<h2 id="建立cgroup"><a href="#建立cgroup" class="headerlink" title="建立cgroup"></a>建立cgroup</h2><p><code>mkdir /sys/fs/cgroup/memory/test</code></p>
<p>限制进程的内存大小为5MB。</p>
<p><code>echo 5242880 &gt; /sys/fs/cgroup/memory/test/memory.limit_in_bytes</code></p>
<h2 id="运行测试程序"><a href="#运行测试程序" class="headerlink" title="运行测试程序"></a>运行测试程序</h2><p>将进程加入到cgroup中。<br>下面的命令需要root用户运行，否则会报错！</p>
<p><code>cgexec -g memory:test ./mem-limit</code></p>
<p><img src="/images/2016/8/30/1.png" alt=""></p>
<p><img src="/images/2016/8/30/2.png" alt=""></p>
<p>从这两张图中可以看到，当进程向内存申请8MB空间时，swap空间大小为3MB，当进程向内存申请9MB空间时，swap空间大小为4MB。正是由于cgroup对于进程内存的限制，所以才会用到swap空间，这也验证了cgroup的作用达到了。<br>由于篇幅的限制，只介绍了cgroup中内存子系统的应用实例，若想尝试其他子系统，可查询<a href="https://www.kernel.org/doc/Documentation/cgroup-v1/" target="_blank" rel="noopener">官方文档</a>。</p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://blog.csdn.net/jesseyoung/article/details/39077829#t0" target="_blank" rel="noopener">csdn jesseyoung</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html" target="_blank" rel="noopener">IBM 周明耀</a></li>
<li><a href="http://files.cnblogs.com/files/lisperl/cgroups%E4%BB%8B%E7%BB%8D.pdf" target="_blank" rel="noopener">王喆锋 Linux cgroups 详解</a></li>
<li><a href="https://sysadmincasts.com/episodes/14-introduction-to-linux-control-groups-cgroups" target="_blank" rel="noopener">sysadmincasts</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt" target="_blank" rel="noopener">kernel Documentation</a></li>
<li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/index.html" target="_blank" rel="noopener">redhat</a></li>
<li><a href="http://www.linux-kongress.org/2010/slides/seyfried-cgroups-linux-kongress-2010-presentation.pdf" target="_blank" rel="noopener">linux-kongress</a></li>
<li><a href="https://help.ubuntu.com/lts/serverguide/cgroups.html" target="_blank" rel="noopener">Control Groups - Official Ubuntu Documentation</a></li>
<li><a href="http://www.cnblogs.com/yjf512/p/3298582.html" target="_blank" rel="noopener">cnblogs 轩脉刃de刀光剑影</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/18/知识检索与研究技能/">知识检索与研究技能</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-08-18
        </span>
        
          <span class="post-category">
            
              <a href="/categories/经验/">经验</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="文献检索与研究技能"><a href="#文献检索与研究技能" class="headerlink" title="文献检索与研究技能"></a>文献检索与研究技能</h2><p>研究生阶段，找topic，搜索文献，阅读论文，写论文的能力是必不可少的。<br>这篇文章将时刻保持更新,记录收获与经验。</p>
<h3 id="实用网站"><a href="#实用网站" class="headerlink" title="实用网站"></a>实用网站</h3><ol>
<li><a href="http://www.dictionary.com/" target="_blank" rel="noopener">dictionary.com</a>（查询单词必备）</li>
</ol>
<h3 id="博客推荐"><a href="#博客推荐" class="headerlink" title="博客推荐"></a>博客推荐</h3><ol>
<li><a href="https://storagemojo.com/" target="_blank" rel="noopener">storagemojo</a></li>
<li><a href="http://dblab.xmu.edu.cn/" target="_blank" rel="noopener">厦门大学数据库实验室</a></li>
</ol>
<h3 id="搜索论文"><a href="#搜索论文" class="headerlink" title="搜索论文"></a>搜索论文</h3><ul>
<li><a href="http://dblp.uni-trier.de/" target="_blank" rel="noopener">dblp</a></li>
<li><a href="https://www.google.com.hk/search?newwindow=1&amp;safe=strict&amp;biw=1855&amp;bih=966&amp;q=how+to+use+google+scholar&amp;oq=how+to+use+google+scholar&amp;gs_l=serp.3...44869648.44869648.0.44869826.1.1.0.0.0.0.0.0..0.0....0...1c.1.64.serp..1.0.0.Tk7HOztKII8" target="_blank" rel="noopener">how to use google scholar</a></li>
</ul>
<p>有时候用 Google Scholar 搜出来的不是期刊而是一本专著，一般来说是无法直接获得电子书的下载链接的。这个时候，一般就马上切换到这两个网站：<br><a href="http://gen.lib.rus.ec/" target="_blank" rel="noopener">Library Genesis</a><br><a href="http://bookzz.org/" target="_blank" rel="noopener">Electronic library. Download books free. Finding books</a></p>
<h3 id="常用的会议与期刊"><a href="#常用的会议与期刊" class="headerlink" title="常用的会议与期刊"></a>常用的会议与期刊</h3><p>由于研究生阶段的研究方向是存储，所以总结出与存储相关的会议与期刊。<br><a href="http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf" target="_blank" rel="noopener">ccf推荐排名</a></p>
<table>
<thead>
<tr>
<th>简称</th>
<th style="text-align:center">全称</th>
<th style="text-align:right">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/osdi/" target="_blank" rel="noopener">OSDI</a></td>
<td style="text-align:center">USENIX Symposium on Operating Systems Design and Implementations</td>
<td style="text-align:right">A类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/sosp/" target="_blank" rel="noopener">SOSP</a></td>
<td style="text-align:center">Symposium on Operating Systems Principles</td>
<td style="text-align:right">A类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/asplos/" target="_blank" rel="noopener">ASPLOS</a></td>
<td style="text-align:center">Architectural Support for Programming Languages and Operating Systems</td>
<td style="text-align:right">A类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/fast/" target="_blank" rel="noopener">FAST</a></td>
<td style="text-align:center">Conference on File and Storage Technologies</td>
<td style="text-align:right">A类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/usenix/index.html" target="_blank" rel="noopener">ATC</a></td>
<td style="text-align:center">USENIX Annual Technical Conference</td>
<td style="text-align:right">A类会议</td>
</tr>
<tr>
<td><a href="http://dblp.org/db/conf/hpca/" target="_blank" rel="noopener">HPCA</a></td>
<td style="text-align:center">High-Performance Computer Architecture</td>
<td style="text-align:right">A类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/isca/" target="_blank" rel="noopener">ISCA</a></td>
<td style="text-align:center">International Symposium on Computer Architecture</td>
<td style="text-align:right">A类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/sc/" target="_blank" rel="noopener">SC</a></td>
<td style="text-align:center">International Conference for High Performance Computing, Networking, Storage, and Analysis</td>
<td style="text-align:right">A类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/micro/" target="_blank" rel="noopener">MICRO</a></td>
<td style="text-align:center">MICRO</td>
<td style="text-align:right">A类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/sigmod/" target="_blank" rel="noopener">SIGMOD</a></td>
<td style="text-align:center">ACM Conference on Management of Data</td>
<td style="text-align:right">A类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/vldb/" target="_blank" rel="noopener">VLDB</a></td>
<td style="text-align:center">International Conference on Very Large Data Bases</td>
<td style="text-align:right">A类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/icde/" target="_blank" rel="noopener">ICDE</a></td>
<td style="text-align:center">IEEE International Conference on Data Engineering</td>
<td style="text-align:right">A类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/journals/tpds/" target="_blank" rel="noopener">TPDS</a></td>
<td style="text-align:center">IEEE Transactions on Parallel and Distributed Systems</td>
<td style="text-align:right">A类期刊</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/journals/tocs/" target="_blank" rel="noopener">TOCS</a></td>
<td style="text-align:center">ACM Transactions on Computer Systems</td>
<td style="text-align:right">A类期刊</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/journals/tos/" target="_blank" rel="noopener">TOS</a></td>
<td style="text-align:center">ACM Transactions on Storage</td>
<td style="text-align:right">A类期刊</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/nsdi/" target="_blank" rel="noopener">NSDI</a></td>
<td style="text-align:center">Networked Systems Design and Implementation</td>
<td style="text-align:right">B类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/vee/" target="_blank" rel="noopener">VEE</a></td>
<td style="text-align:center">Virtual Execution Environments</td>
<td style="text-align:right">B类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/dsn/" target="_blank" rel="noopener">DSN</a></td>
<td style="text-align:center">The International Conference on Dependable Systems and Networks</td>
<td style="text-align:right">B类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/hpdc/" target="_blank" rel="noopener">HPDC</a></td>
<td style="text-align:center">High-Performance Distributed Computing</td>
<td style="text-align:right">B类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/eurosys/" target="_blank" rel="noopener">EuroSys</a></td>
<td style="text-align:center">EuroSys</td>
<td style="text-align:right">B类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/cloud/" target="_blank" rel="noopener">SOCC </a></td>
<td style="text-align:center">ACM Symposium on Cloud Computing</td>
<td style="text-align:right">B类会议</td>
</tr>
<tr>
<td><a href="http://dblp.uni-trier.de/db/conf/mss/" target="_blank" rel="noopener">MSST</a></td>
<td style="text-align:center">Mass Storage Systems and Technologies</td>
<td style="text-align:right">B类会议</td>
</tr>
<tr>
<td><a href="https://www.kernel.org/doc/ols/" target="_blank" rel="noopener">ols</a></td>
<td style="text-align:center">Proceedings of the  Linux Symposium</td>
</tr>
</tbody>
</table>
<h3 id="论文经验-amp-amp-科研经验"><a href="#论文经验-amp-amp-科研经验" class="headerlink" title="论文经验&amp;&amp;科研经验"></a>论文经验&amp;&amp;科研经验</h3><p>下面给出的链接不一定全面，要想获取更多资料请根据关键字google。</p>
<ul>
<li><a href="http://www.cs.virginia.edu/~robins/YouAndYourResearch.html" target="_blank" rel="noopener">You and Your Research</a></li>
<li><a href="http://ccr.sigcomm.org/online/files/p83-keshavA.pdf" target="_blank" rel="noopener">How to Read a Paper</a></li>
<li><a href="https://www.eecs.harvard.edu/~michaelm/postscripts/ReadPaper.pdf" target="_blank" rel="noopener">How to Read a Research Paper</a></li>
<li><a href="http://pages.cs.wisc.edu/~markhill/the_task_of_the_referee.pdf" target="_blank" rel="noopener">The Task of the Referee</a></li>
<li><a href="https://people.inf.ethz.ch/troscoe/pubs/review-writing.pdf" target="_blank" rel="noopener">Writing Reviews for Systems Conference</a></li>
<li><a href="https://cs.brown.edu/~sk/Memos/Paper-Reviews/" target="_blank" rel="noopener">How to Write Technical Paper Reviews</a></li>
<li><a href="https://cs.brown.edu/~sk/Memos/Paper-Reviews/" target="_blank" rel="noopener">How to Write Technical Paper Reviews</a></li>
<li><a href="http://www.cs.berkeley.edu/~pattrsn/talks/BadCareer.pdf" target="_blank" rel="noopener">How to Have a Bad Career in Research/Academia</a></li>
<li><a href="https://www.youtube.com/watch?v=GDVAHA0oyJU" target="_blank" rel="noopener">The Power of Abstraction</a></li>
</ul>
<h3 id="论文写作"><a href="#论文写作" class="headerlink" title="论文写作"></a>论文写作</h3><ul>
<li><a href="http://www.cjig.cn/UploadFile/%E5%90%B4%E5%85%B4%E4%B8%9C-%E5%A6%82%E4%BD%95%E6%92%B0%E5%86%99%E9%AB%98%E6%B0%B4%E5%B9%B3%E6%96%87%E7%AB%A0.ppt" target="_blank" rel="noopener">吴兴东-如何撰写高水平文章</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/giving-a-talk/writing-a-paper-slides.pdf" target="_blank" rel="noopener">How to write a great research paper</a></li>
<li><a href="http://www.phrasebank.manchester.ac.uk/" target="_blank" rel="noopener">英文学术写作要领</a></li>
</ul>
<h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><ul>
<li>《科研有方：科研需要“想好”再“做”》</li>
</ul>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/17/Linux的fork函数详解/">Linux的fork函数详解</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-08-17
        </span>
        
          <span class="post-category">
            
              <a href="/categories/C语言/">C语言</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。</p>
<p>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。<br>我们来看一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">pid_t</span> fpid; <span class="comment">//fpid表示fork函数返回的值  </span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;  </span><br><span class="line">    fpid=fork();   </span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error in fork!"</span>);   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am the child process, my process id is %d\n"</span>,getpid());   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是爹的儿子\n"</span>);<span class="comment">//对某些人来说中文看着更直白。  </span></span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am the parent process, my process id is %d\n"</span>,getpid());   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是孩子他爹\n"</span>);  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"统计结果是: %d\n"</span>,count);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果是：</p>
<p><img src="/images/2016/8/17/1.png" alt=""></p>
<p>在语句fpid=fork()之前，只有一个进程在执行这段代码，但在这条语句之后，就变成两个进程在执行了，这两个进程的几乎完全相同，将要执行的下一条语句都是if(fpid&lt;0)……</p>
<p>为什么两个进程的fpid不同呢，这与fork函数的特性有关。<br><code>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</code></p>
<ol>
<li>在父进程中，fork返回新创建子进程的进程ID；</li>
<li>在子进程中，fork返回0；</li>
<li>如果出现错误，fork返回一个负值；</li>
</ol>
<p>在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p>
<p>fork出错可能有两种原因：</p>
<ol>
<li>当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。</li>
<li>系统内存不足，这时errno的值被设置为ENOMEM。</li>
</ol>
<p>创建新进程成功后，系统中出现两个基本完全相同的进程，<code>这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。</code><br>每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid（）函数获得，还有一个记录父进程pid的变量，可以通过getppid（）函数获得变量的值。</p>
<p>fork执行完毕后，出现两个进程:<br><img src="/images/2016/8/17/2.png" alt=""></p>
<p>有人说两个进程的内容完全一样啊，怎么打印的结果不一样啊，那是因为判断条件的原因，上面列举的只是进程的代码和指令，还有变量啊。<br>执行完fork后，进程1的变量为count=0，fpid！=0（父进程）。进程2的变量为count=0，fpid=0（子进程），这两个进程的变量都是独立的，存在不同的地址中，不是共用的，这点要注意。可以说，我们就是通过fpid来识别和操作父子进程的。<br>还有人可能疑惑为什么不是从#include处开始复制代码的，<code>这是因为fork是把进程当前的情况拷贝一份，</code>执行fork时，进程已经执行完了int count=0;fork只拷贝下一个要执行的代码到新的进程。</p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://blog.csdn.net/jason314/article/details/5640969" target="_blank" rel="noopener">jason314</a></li>
<li><a href="https://www.youtube.com/watch?v=9seb8hddeK4" target="_blank" rel="noopener">youtube DrBFraser</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/16/Web服务器/">Web服务器</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-08-16
        </span>
        
          <span class="post-category">
            
              <a href="/categories/计算机网络/">计算机网络</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Ｗeb服务器"></a>Ｗeb服务器</h2><h3 id="Web基础"><a href="#Web基础" class="headerlink" title="Ｗeb基础"></a>Ｗeb基础</h3><p>  Ｗeb客户端和服务器之间的交互用的是一个基于文本的应用层协议，叫做HTTP。<br>  Ｗeb服务和常规的文件检索服务（例如ＦＴＰ）有什么区别呢？主要的区别是Ｗeb内容可以用一种叫做HTTP的语言来编写。</p>
<h3 id="Web内容"><a href="#Web内容" class="headerlink" title="Ｗeb内容"></a>Ｗeb内容</h3><p>对于Ｗeb客户端和服务器而言，内容是与一个ＭＩＭＫＥ类型相关的字节序列。下表展示了一些常用的ＭＩＭＥ类型。</p>
<table>
<thead>
<tr>
<th>MIME类型</th>
<th style="text-align:right">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>text/html</td>
<td style="text-align:right">ＨＴＭＬ页面</td>
</tr>
<tr>
<td>text/plain</td>
<td style="text-align:right">无格式文本</td>
</tr>
<tr>
<td>application/postscript</td>
<td style="text-align:right">Ｐostscript文档</td>
</tr>
<tr>
<td>image/gif</td>
<td style="text-align:right">ＧＩＦ格式编码的二进制图像</td>
</tr>
<tr>
<td>image/jpeg</td>
<td style="text-align:right">ＪＰＥＧ格式编码的二进制图像</td>
</tr>
</tbody>
</table>
<p>web服务器以两种不同的方式向客服端提供内容：</p>
<ul>
<li>静态内容：取一个磁盘文件，并将它的内容返回给客户端。</li>
<li>动态内容：执行一个可执行文件，并将它的输出返回给客户端。<br>运行时可执行文件产生的输出称为动态内容，而运行程序并返回它的输出到客户端的过程称为服务动态内容。</li>
</ul>
<p>统一资源定位符：URL</p>
<p><a href="http://www.google.com:80/index.html" target="_blank" rel="noopener">http://www.google.com:80/index.html</a></p>
<p>表示因特网主机 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 上一个称为 index.html 的HTML文件，它是由一个监听端口80的Web服务器所管理的。 HTTP默认端口号为80</p>
<p>可执行文件的URL可以在文件名后包括程序参数， “？”字符分隔文件名和参数，而且每个参数都用“&amp;”字符分隔开，如：</p>
<p><a href="http://www.ics.cs.cmu.edu:8000/cgi-bin/adder?123&amp;456" target="_blank" rel="noopener">http://www.ics.cs.cmu.edu:8000/cgi-bin/adder?123&amp;456</a></p>
<p>表示一个 /cgi-bin/adder 的可执行文件，带两个参数字符串为 123 和 456来调用它。</p>
<p><img src="/images/2016/8/16/2.png" alt=""></p>
<h3 id="HTTP事务"><a href="#HTTP事务" class="headerlink" title="HTTP事务"></a>HTTP事务</h3><p>因为HTTP是基于在因特网连接上传送的文本行，我们可以使用Unix的TELNET程序和因特网上的任何Web服务器执行事务。对于调试在连接上通过文本行来与客户端对话的服务器来说，TELNET十分便利。</p>
<p><img src="/images/2016/8/16/3.png" alt=""></p>
<h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><p>一个HTTP请求：一个请求行(request line) 后面跟随0个或多个请求报头(request header), 再跟随一个空的文本行来终止报头。<br><img src="/images/2016/8/16/4.png" alt=""><br><img src="/images/2016/8/16/5.png" alt=""></p>
<h4 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h4><p>一个HTTP响应：一个响应行(response line) 后面跟随0个或多个响应报头(response header)，再跟随一个空的文本行来终止报头，最后跟随一个响应主体(response body)</p>
<p>一个响应行的格式是：</p>
<p> (verion)    (status code)   (status message)</p>
<p>status code 是一个三位的正整数，指明对请求的处理。状态消息给出与错误代码等价的英文描述。</p>
<table>
<thead>
<tr>
<th>状态代码</th>
<th style="text-align:right">状态消息</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td style="text-align:right">成功</td>
<td style="text-align:center">处理请求无误</td>
</tr>
<tr>
<td>301</td>
<td style="text-align:right">永久移动</td>
<td style="text-align:center">内容移动到位置头中指明的主机上</td>
</tr>
<tr>
<td>400</td>
<td style="text-align:right">错误请求</td>
<td style="text-align:center">服务器不能理解请求</td>
</tr>
<tr>
<td>403</td>
<td style="text-align:right">禁止</td>
<td style="text-align:center">服务器无权访问所请求的文件</td>
</tr>
<tr>
<td>404</td>
<td style="text-align:right">未发现</td>
<td style="text-align:center">服务器不能找到所请求的文件</td>
</tr>
<tr>
<td>501</td>
<td style="text-align:right">未实现</td>
<td style="text-align:center">服务器不支持请求的方法</td>
</tr>
<tr>
<td>505</td>
<td style="text-align:right">HTTP版本不支持</td>
<td style="text-align:center">服务器不支持请求的版本</td>
</tr>
</tbody>
</table>
<h3 id="服务动态内容"><a href="#服务动态内容" class="headerlink" title="服务动态内容"></a>服务动态内容</h3><p>一个称为ＣＧＩ（Ｃommon Ｇateway Ｉnterface，通用网关接口）的实际标准的出现解决了这些问题。</p>
<h4 id="客户端如何将程序参数传递给服务器"><a href="#客户端如何将程序参数传递给服务器" class="headerlink" title="客户端如何将程序参数传递给服务器"></a>客户端如何将程序参数传递给服务器</h4><p>GET请求的参数在URI中传递， “？”字符分隔了文件名和参数，每个参数都用一个”&amp;”分隔开，参数中不允许有空格，必须用字符串“%20”来表示。<br>HTTP POST请求的参数是在请求主体中而不是 URI中传递的。</p>
<h4 id="服务器如何将参数传递给子进程"><a href="#服务器如何将参数传递给子进程" class="headerlink" title="服务器如何将参数传递给子进程"></a>服务器如何将参数传递给子进程</h4><p><code>GET /cgi-bin/adder?123&amp;456 HTTP/1.1</code></p>
<p>它调用 fork 来创建一个子进程，并调用 execve 在子进程的上下文中执行 /cgi-bin/adder 程序。在调用 execve 之前，子进程将CGI环境变量 QUERY_STRING 设置为”123&amp;456”， adder 程序在运行时可以用unix <code>getenv</code>函数来引用它。</p>
<h4 id="服务器如何将其他信息传递给子进程"><a href="#服务器如何将其他信息传递给子进程" class="headerlink" title="服务器如何将其他信息传递给子进程"></a>服务器如何将其他信息传递给子进程</h4><table>
<thead>
<tr>
<th>环境变量</th>
<th style="text-align:right">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>QUERY_STRING</td>
<td style="text-align:right">程序参数</td>
</tr>
<tr>
<td>SERVER_PORT</td>
<td style="text-align:right">父进程侦听的端口</td>
</tr>
<tr>
<td>REQUEST_METHOD</td>
<td style="text-align:right">GET 或 POST</td>
</tr>
<tr>
<td>REMOTE_HOST</td>
<td style="text-align:right">客户端的域名</td>
</tr>
<tr>
<td>REMOTE_ADDR</td>
<td style="text-align:right">客户端的点分十进制IP地址</td>
</tr>
<tr>
<td>CONTENT_TYPE</td>
<td style="text-align:right">只对POST而言，请求体的MIME类型</td>
</tr>
<tr>
<td>CONTENT_LENGTH</td>
<td style="text-align:right">只对POST而言，请求体的字节大小</td>
</tr>
</tbody>
</table>
<h4 id="子进程将它的输出发送到哪里"><a href="#子进程将它的输出发送到哪里" class="headerlink" title="子进程将它的输出发送到哪里"></a>子进程将它的输出发送到哪里</h4><p>一个CGI程序将它的动态内容发送到标准输出，在子进程加载并运行CGI程序之前，它使用UNIX dup2 函数将它标准输出重定向到和客户端相关连的已连接描述符。因此，任何CGI程序写到标准输出的东西都会直接到达客户端。</p>
<h3 id="TINY-Web服务器"><a href="#TINY-Web服务器" class="headerlink" title="ＴＩＮＹ Ｗeb服务器"></a>ＴＩＮＹ Ｗeb服务器</h3><p>由于时间的问题，这一节的内容来不及完成，在这一章节还将展示ＣＧＩ程序的编写。将在接下来的时间里去完成这部分的内容吧！</p>
<hr>
<p>参考资料：</p>
<ol>
<li>《深入理解计算机系统》</li>
<li><a href="http://www.2cto.com/kf/201603/495753.html" target="_blank" rel="noopener">2cto</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/14/网络编程/">网络编程</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-08-14
        </span>
        
          <span class="post-category">
            
              <a href="/categories/计算机网络/">计算机网络</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>所有的网络应用都是基于相同的基本编程模型，有着相似的整体逻辑结构，并且依赖相同的编程接口。</p>
<h3 id="客户端-服务器编程模型"><a href="#客户端-服务器编程模型" class="headerlink" title="客户端-服务器编程模型"></a>客户端-服务器编程模型</h3><p>每个网络应用都是基于 <em>客户端-服务器模型</em> 的。这个模型中的基本操作是事务（这个事务不是数据库事务，没有数据库事务的任何特性）。</p>
<p><img src="/images/2016/8/13/11.png" alt=""></p>
<p>认识到客户端和服务器是进程，而不是常常提到的机器或者主机，这是很重要的。一台主机可以同时运行许多不同的客户端和服务器，而且一个客户端和服务器的事务可以在同一台或是不同的主机上运行。无论客户端和服务器是怎样映射到主机上的，客户端-服务器模型是相同的。</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>对于一个主机而言，网络只是又一种 I/O 设备，作为数据源和数据接收方。</p>
<p><img src="/images/2016/8/14/1.png" alt=""></p>
<p>对于物理上而言，网络是一个按照地理远近组成的层次系统。最低层是LAN(Local Area Network,局域网):在一个建筑或校园范围内。迄今为止，最流行的LAN技术是以网(Ethernet)。</p>
<p>一个以太网段(Ethernet segment)包括一些电缆(通常是双绞线)和一个叫做集线器的小盒子。集线器不加分辨地将从一个端口收到的每个位复制到其他所有端口上。因此每台主机都能看到每个位。</p>
<p><img src="/images/2016/8/14/2.png" alt=""></p>
<p>使用一些电缆和叫做网桥(bridge)的小盒子，多个以太网段可以连接成较大的局域网，称为桥接以太网(bridged Ethernet)。</p>
<p><img src="/images/2016/8/14/3.png" alt=""></p>
<p><img src="/images/2016/8/14/4.png" alt=""></p>
<p>在层次的更高级别，多个不兼容的局域网可以通过叫做路由器(router)的特殊计算机连接起来，组成一个internet(互联网络)。</p>
<p><img src="/images/2016/8/14/5.png" alt=""></p>
<p>互联网至关重要的特性是:它能由采用完全不同和不兼容技术的各种局域网和广域网组成。</p>
<p><img src="/images/2016/8/14/6.png" alt=""></p>
<h3 id="全球IP因特网"><a href="#全球IP因特网" class="headerlink" title="全球IP因特网"></a>全球IP因特网</h3><p><img src="/images/2016/8/16/1.png" alt=""></p>
<ul>
<li>IP地址</li>
<li>因特网域名</li>
<li>因特网连接</li>
</ul>
<h3 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h3><p><img src="/images/2016/8/16/TCPsockets.jpg" alt=""></p>
<p>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>
<h4 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket()函数"></a>socket()函数</h4><p><code>int  socket(int protofamily, int type, int protocol);//返回sockfd</code></p>
<p>sockfd是描述符。</p>
<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而<code>socket()</code>用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p>
<ul>
<li><p>protofamily：即协议域，又称为协议族（family）。常用的协议族有，AF_INET(IPV4)、AF_INET6(IPV6)、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p>
</li>
<li><p>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</p>
</li>
<li><p>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</p>
</li>
</ul>
<p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p>
<p>当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p>
<h4 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind()函数"></a>bind()函数</h4><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p>
<p><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p>
<p>函数的三个参数分别为：</p>
<ul>
<li><p>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</p>
</li>
<li><p>addrlen：对应的是地址的长度。</p>
</li>
<li><p>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generic socket address structure (for connect, bind, and accept) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family; <span class="comment">/* Protocol family */</span></span><br><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/* Address data. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet-style socket address structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sin_family; <span class="comment">/*Address family (always AF_INET) */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sin_port; <span class="comment">/*Port number in network byte order */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/*IP address in network byte order */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/*Pad to sizeof(struct sockaddr) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来连接服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
<p>网络字节序与主机字节序</p>
<p><strong>主机字节序</strong> :就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：</p>
<p>　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p>
<p>　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p>
<p><strong>网络字节序</strong> ：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p>
<p>所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。</p>
<h4 id="listen-、connect-函数"><a href="#listen-、connect-函数" class="headerlink" title="listen()、connect()函数"></a>listen()、connect()函数</h4><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p>
<p><code>int listen(int sockfd, int backlog);</code></p>
<p><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p>
<p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h4 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h4><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p>
<p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); //返回连接connect_fd</code></p>
<ul>
<li><p>sockfd<br>参数sockfd就是上面解释中的监听套接字，这个套接字用来监听一个端口，当有一个客户与服务器连接时，它使用这个一个端口号，而此时这个端口号正与这个套接字关联。当然客户不知道套接字这些细节，它只知道一个地址和一个端口号。</p>
</li>
<li><p>addr<br>这是一个结果参数，它用来接受一个返回值，这返回值指定客户端的地址，当然这个地址是通过某个地址结构来描述的，用户应该知道这一个什么样的地址结构。如果对客户的地址不感兴趣，那么可以把这个值设置为NULL。</p>
</li>
<li><p>len<br>如同大家所认为的，它也是结果的参数，用来接受上述addr的结构的大小的，它指明addr结构所占有的字节个数。同样的，它也可以被设置为NULL。</p>
</li>
</ul>
<p>如果accept成功返回，则服务器与客户已经正确建立连接了，此时服务器通过accept返回的套接字来完成与客户的通信。<br>注意：<br>accept默认会阻塞进程，直到有一个客户连接建立后返回，它返回的是一个新可用的套接字，这个套接字是连接套接字。此时我们需要区分两种套接字，</p>
<p><em>监听套接字</em> : 监听套接字正如accept的参数sockfd，它是监听套接字，在调用listen函数之后，是服务器开始调用socket()函数生成的，称为监听socket描述字(监听套接字)</p>
<p><em>连接套接字</em> ：一个套接字会从主动连接的套接字变身为一个监听套接字；而accept函数返回的是已连接socket描述字(一个连接套接字)，它代表着一个网络已经存在的点点连接。</p>
<p>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<p>自然要问的是：为什么要有两种套接字？原因很简单，如果使用一个描述字的话，那么它的功能太多，使得使用很不直观，同时在内核确实产生了一个这样的新的描述字。</p>
<h4 id="read-、write-等函数"><a href="#read-、write-等函数" class="headerlink" title="read()、write()等函数"></a>read()、write()等函数</h4><p>可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！</p>
<p>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p>
<p>write函数将buf中的n字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</p>
<h4 id="close-函数"><a href="#close-函数" class="headerlink" title="close()函数"></a>close()函数</h4><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p>
<h4 id="echo-示例"><a href="#echo-示例" class="headerlink" title="echo 示例"></a>echo 示例</h4><p>下面，给出一个简单的示例，代码如下：<br>server.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> listen_fd, comm_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bzero( &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">22000</span>);</span><br><span class="line">    bind(listen_fd, (struct sockaddr *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    listen(listen_fd, <span class="number">10</span>);</span><br><span class="line">    comm_fd = accept(listen_fd, (struct sockaddr*) <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       　bzero( str, <span class="number">100</span>);</span><br><span class="line">        read(comm_fd,str,<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Echoing back - %s"</span>,str);</span><br><span class="line">        write(comm_fd, str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd,n;</span><br><span class="line">    <span class="keyword">char</span> sendline[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> recvline[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    sockfd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    bzero(&amp;servaddr,<span class="keyword">sizeof</span> servaddr);</span><br><span class="line">    servaddr.sin_family=AF_INET;</span><br><span class="line">    servaddr.sin_port=htons(<span class="number">22000</span>);</span><br><span class="line">    inet_pton(AF_INET,<span class="string">"127.0.0.1"</span>,&amp;(servaddr.sin_addr));</span><br><span class="line">    connect(sockfd,(struct sockaddr *)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bzero( sendline, <span class="number">100</span>);</span><br><span class="line">        bzero( recvline, <span class="number">100</span>);</span><br><span class="line">        fgets(sendline,<span class="number">100</span>,<span class="built_in">stdin</span>); <span class="comment">/*stdin = 0 , for standard input */</span></span><br><span class="line">        write(sockfd,sendline,<span class="built_in">strlen</span>(sendline)+<span class="number">1</span>);</span><br><span class="line">        read(sockfd,recvline,<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,recvline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器实现的功能是接受来自客户端发来的文本，并将文本再次发送给客户端。</p>
<p>网络编程的内容先介绍到这里，在后面，将会有一篇文章介绍web服务器的相关内容。</p>
<hr>
<p>参考资料：</p>
<ol>
<li>《深入理解计算机系统》</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7445768/" target="_blank" rel="noopener">csdn 真实的归宿</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/12/计算机系统中的链接（二）/">计算机系统中的链接（二）</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-08-12
        </span>
        
          <span class="post-category">
            
              <a href="/categories/计算机系统/">计算机系统</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h3 id="加载可执行目标文件"><a href="#加载可执行目标文件" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h3><p>下图概括了一个典型的ELF可执行文件中的各类信息。</p>
<p><img src="/images/2016/8/12/fig2.png" alt=""></p>
<p>通过调用某个驻留在存储器中称为加载器（loader）的操作系统代码来运行可执行文件。任何 UNIX 程序都可以通过调用 execve 函数来调用加载器。</p>
<p>加载器将可执行目标文件中的代码和数据从磁盘拷贝到存储器中，然后通过跳转到程序的第一条指令或入口段（entry point）来运行该程序。这个将程序拷贝到存储器并运行的过程叫做加载（loading）。</p>
<p>当加载器运行时，它创建一个存储器映像。在可执行文件中段头部表的指导下，加载器将可执行文件的相关内容拷贝到代码和数据段。接下来，加载器跳转到程序的入口点，也就是符号 _start 的地址。在 _start 地址处的启动代码（startup code）是在目标文件 ctl1.o中定义的，对所有的 C 程序都是一样的。</p>
<p><img src="/images/2016/8/12/fig3.png" alt=""></p>
<h3 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h3><p>静态库有一些明显的缺点。</p>
<p>静态库和所有的软件一样，需要定期维护和更新。如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们的程序与更新了的库重新链接。</p>
<p>另一个问题是几乎每个 C 程序都使用标准的 I/O 函数，如 printf 和 scanf。在运行时，这些函数的代码会被复制到每个运行进程的文本段中。在一个运行 50~100 个进程的典型系统上，这将是对稀缺的存储器系统资源的极大浪费。</p>
<p>共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为动态链接（dynamic linking），是由一个叫作动态链接器（dynamic linker）的程序来执行的。</p>
<p>共享库也称为共享目标（shared object），在 UNIX 系统中通常用 .so 后缀来表示。微软的操作系统大量地利用了共享库，它们称为 DLL（动态链接库）。</p>
<p><img src="/images/2016/8/12/1.png" alt=""></p>
<p>为了构造上图中向量运算示例程序的共享库libvector.so，我们会调用编译器，给编译器如下特殊指令：</p>
<p><code>gcc -shared -fPIC -o libvector.so addvec.c multvec.c</code></p>
<p>-fPIC选项指示编译器生成与位置无关的代码。编译库代码，使得不需要链接器修改库代码就可以在任何地址加载和执行这些代码。这样的代码叫做与位置无关的代码（Position-Independent Code, PIC）。用户对 GCC 使用-fPIC 选项指示 GNU 编译系统生成 PIC 代码。</p>
<p>-shared选项指示链接器创建一个共享的目标文件。</p>
<p><code>gcc -o p2 main2.c ./libvector.so</code></p>
<p>这样就创建了一个可执行文件 p2，而此文件的形式使得它在运行时可以和 libvector.so链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。</p>
<p>认识到这一点很重要：此时，没有任何 libvector.so 的代码和数据真的被拷贝到可执行文件 p2 中。反之，链接器拷贝了一些重定位和符号表信息，它们使得运行时可以解析对libvector.so 中代码和数据的引用。</p>
<p>当加载器加载和运行可执行文件 p2 时，加载部分链接的可执行文件 p2。接着，它注意到p2 包含一个 .interp 节，这个节包含动态链接器的路径名，动态链接器本身就是一个共享目标（比如，在 Linux 系统上的 ld-linux.so）。加载器不再像它通常那样将控制传递给应用，而是加载和运行这个动态链接器。</p>
<p>动态链接器通过执行下面的重定位完成链接任务：</p>
<ul>
<li>重定位 libc.so 的文本和数据到某个存储器段</li>
<li>重定位 libvector.so 的文本和数据到另一个存储器段</li>
<li>重定位 p2 中所有对 libc.so 和 libvector.so 定义的符号的引用</li>
</ul>
<p>最后，动态链接器将控制传递到应用程序。从这个时刻开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变。</p>
<h3 id="从应用程序中加载和链接共享库"><a href="#从应用程序中加载和链接共享库" class="headerlink" title="从应用程序中加载和链接共享库"></a>从应用程序中加载和链接共享库</h3><p>到此刻为止，我们已经讨论了在应用程序执行之前，即应用程序被加载时，动态链接器加载和链接共享库的情景。然而，应用程序还可能在它运行时要求动态链接器加载和链接任意共享库，而无需在编译时链接那些库到应用中。</p>
<p>动态链接在现实世界中的例子：分发软件，构建高性能web服务器。</p>
<p>linux系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">int</span> floag)</span></span>;</span><br><span class="line"><span class="comment">//成功，就返回指向句柄的指针，这里的句柄应该是指一个目标文件吧。失败，就返回NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">char</span> *symbol)</span></span>;</span><br><span class="line"><span class="comment">//第一个参数是上面函数返回的句柄的指针，第二个参数是符号的名字，如果符号存在就返回符号的地址，这里符号的地址应该是目标文件的符号表中的符号的地址吧，否则返回NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span> *handle)</span></span>;</span><br><span class="line"><span class="comment">//如果没有其他共享库正在使用这个共享库，那么就卸载该共享库。这里值得考虑，没有其他共享库，而不是没有其他函数。卸载共享库。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//上面的3个函数运行之后，运行这个函数，可以看看最近发生的最近的错误，如果没有错误，就返回NULL</span></span><br></pre></td></tr></table></figure>
<p>下面将展示如何利用这个接口动态链接libvector.so共享库，然后调用它的addvec程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** dll.c **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> z[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *handle;</span><br><span class="line">    <span class="keyword">void</span> (*addvec)(<span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dynamically load the shared library that contains addvec() */</span></span><br><span class="line">    handle = dlopen(<span class="string">"./libvector.so"</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, dlerror());</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* get a pointer to the addvec() function we just loaded */</span></span><br><span class="line">    addvec = dlsym(handle, <span class="string">"addvec"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, error);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Now we can call addvec() it just like any other function */</span></span><br><span class="line">    addvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"z = [%d %d]\n"</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">/* unload the shared library */</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, dlerror());</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要编译这个程序，我们将以下面的方式调用gcc:<br><code>gcc -rdynamic -O2 -o p3 dll.c -ldl</code></p>
<p>-rdynamic 用来通知链接器将所有符号添加到动态符号表中（目的是能够通过使用 dlopen 来实现向后跟踪）</p>
<p>-ldl 指示链接器链接一个库，这个库里包含了 dlopen, dlsym 等等的函数，也就是说，是支持“在运行时，显示加载使用动态连接库”的函数库。相关的头文件是 dlfcn.h。</p>
<h3 id="处理目标文件的工具"><a href="#处理目标文件的工具" class="headerlink" title="处理目标文件的工具"></a>处理目标文件的工具</h3><p><img src="/images/2016/8/13/1.png" alt=""></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/images/2016/8/13/2.png" alt=""></p>
<p><img src="/images/2016/8/13/3.png" alt=""></p>
<hr>
<p>参考资料：</p>
<ol>
<li>《深入理解计算机系统》</li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/19/计算机系统中的链接（一）/">计算机系统中的链接（一）</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-07-19
        </span>
        
          <span class="post-category">
            
              <a href="/categories/计算机系统/">计算机系统</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>链接(linking)是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可<em>被加载</em>（或被拷贝）到存储器并执行。链接可以执行于<em>编译时</em>，也就是在源代码被翻译成机器代码时；也可以执行于<em>加载时</em>，也就是在程序被<em>加载器</em>加载到内存存储器并执行时；甚至执行于<em>运行时</em>，由应用程序来执行。</p>
<h3 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h3><p>考虑如下的c语言程序，它包含两个源文件：main.c和swap.c。函数main()调用swap交换外部全局数组buf中的两个元素。</p>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	swap();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>swap.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* swap.c */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> buf[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *bufp0 = &amp;buf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> *bufp1;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	bufp1 = &amp;buf[<span class="number">1</span>];</span><br><span class="line">	temp = *bufp0;</span><br><span class="line">	*bufp0 = * bufp1;</span><br><span class="line">	*bufp1 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你对如上的代码有困惑，这说明你对c语言中<code>extern</code>关键字不太理解，关于extern的解析请看<a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/" target="_blank" rel="noopener">这里</a>。我就总结一下吧，函数在声明和定义的时候默认用extern修饰，这一点变量则与函数不同。申明的函数或者变量并未分配内存，只有在定义的时候才分配内存。</p>
<p>大多数编译系统提供编译驱动程序，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。比如，要用GNU编译系统构造示例，我们就要通过在外壳中输入下列命令行来调用GCC驱动程序：</p>
<p><code>gcc -O2 -g -o p main.c swap.c</code></p>
<p>-O2 ：更多的优化，会尝试几乎全部的优化功能，但不会进行“空间换时间”的优化方法。</p>
<p>gcc编译源代码时指定-g选项可以产生带有调试信息的目标代码。</p>
<p>下图概括了驱动程序在将示例程序从ASCII码源文件翻译成可执行目标文件的行为。</p>
<p><img src="/images/2016/7/25/untitled.png" alt=""></p>
<p>上图中，cpp为C预处理器，ccl为C编译器，as为汇编器。</p>
<p>执行可执行文件，外壳调用操作系统中一个叫做<code>加载器</code>的函数，它拷贝可执行文件p中的代码和数据到存储器，然后将控制转移到这个程序的开头。</p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>像Unix ld程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据结组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另一个节中。</p>
<p>为了构造可执行文件，链接器必须完成两个主要任务：</p>
<ul>
<li><p><strong>符号解析</strong>。目标文件定义和引用<strong>符号</strong>。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。</p>
</li>
<li><p><strong>重定位</strong>。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而<strong>重定位</strong>这些节。</p>
</li>
</ul>
<p>要记住关于链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。</p>
<h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><p>目标文件有三种形式：</p>
<ul>
<li><p><strong>可重定位目标文件</strong>。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</p>
</li>
<li><p><strong>可执行目标文件</strong>。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。</p>
</li>
<li><p><strong>共享目标文件</strong>。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态加载到存储器并链接。</p>
</li>
</ul>
<p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是存放在磁盘文件中的目标模块。</p>
<p>各个系统之间，目标文件格式都不相同。下表将列出各个系统的目标文件格式。</p>
<table>
<thead>
<tr>
<th>系统</th>
<th style="text-align:right">目标文件格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>System V Unix早期版本</td>
<td style="text-align:right">一般目标文件格式(Common Object File Format, COFF)</td>
</tr>
<tr>
<td>Windows</td>
<td style="text-align:right">可移植可执行（Portable Executable, PE）格式</td>
</tr>
<tr>
<td>现代Unix系统，如Linux</td>
<td style="text-align:right">可执行和可链接格式（Executable and Linkable Format,ELF）</td>
</tr>
</tbody>
</table>
<h3 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h3><p><img src="/images/2016/8/11/1359777256_5685.jpg" alt=""></p>
<p>上图展示了一个典型的ELF可重定位目标文件的格式。</p>
<p>夹在ELF头和节头部表之间的都是节。下面介绍几个常用的节:</p>
<ul>
<li>.text：已编译程序的机器代码。</li>
<li>.rodata：只读数据。</li>
<li>.data： <em>已初始化</em> 的全局C变量。局部C变量在运行时保存在栈中，既不出现在.data节中，也不出现在.bss节中。</li>
<li>.bss： <em>未初始化</em> 的全局C变量。在目标文件中这个节不占据实际空间，它仅仅是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。</li>
<li>.symtab。一个 <em>符号表</em> ，它存放在程序中定义和引用的函数和全局变量的信息。</li>
</ul>
<h3 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h3><p>每个可重定位目标模块m都有一个符号表，它包含m所定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：</p>
<ul>
<li>全局符号（global）</li>
</ul>
<p>由 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数以及被定义为不带 C static 属性的全局变量。</p>
<ul>
<li>外部符号(external)</li>
</ul>
<p>由其他模块定义并被模块 m 引用的全局符号。这些符号称为外部符号，应对与定义在其他模块中的 C 函数和变量。</p>
<ul>
<li>本地符号（local）</li>
</ul>
<p>只被模块 m 定义和引用的本地符号。有的本地链接器符号对应于带 static 属性的C 函数和全局变量。这些符号在模块 m 中随处可见，但是不能被其他模块引用。目标文件中对应于模块 m 的节和相应的源文件的名字也能获得本地符号。</p>
<p>认识到本地链接器符号和本地程序变量的不同是很重要的。.symtab 中的符号表不包含对应于本地非静态程序变量的任何符号。</p>
<p>有趣的是，定义为带有 C static 属性的本地过程变量是不在栈中管理的。相反，编译器在.data 和 .bss 中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号。</p>
<h3 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h3><p>实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库（staticlibrary）。它可以用作链接器的输入。当链接器构造一个输出的可执行文件时，它只拷贝静态库里被应用程序引用的目标模块。</p>
<p>在 UNIX 系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀 .a 标识。</p>
<p>为了使我们对库的讨论更加形象具体，假设我们想在一个叫做libvector.a的静态库中提供下图中的向量例程。</p>
<p><img src="/images/2016/8/11/1.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** addvec.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y, <span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		z[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** multvec.c **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y, <span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		z[i] = x[i] * y[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了创建该库，我们将使用AR工具，具体如下：</p>
<p><code>gcc -c addvec.c multvec.c</code></p>
<p><code>ar rcs libvector.a addvec.o multvec.o</code></p>
<p>为了使用这个库，我们可以编写一个应用main2.c,它调用addvec库例程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** vector.h **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y, <span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multvec</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y, <span class="keyword">int</span> *z, <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main2.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector.h"</span></span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> z[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	addvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"z = [%d %d]\n"</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了创建这个可执行文件，我们要编译和链接输入文件main.o和libvector.a:</p>
<p><code>gcc -O2 -c main2.c</code></p>
<p><code>gcc -static -o p2 main2.o ./libvector.a</code></p>
<p>下图概括了链接器的行为。</p>
<p><img src="/images/2016/8/11/2.png" alt=""></p>
<p>-static参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到存储器并运行，在加载时无需更进一步的链接。当链接器运行时，它判定addvec.o定义的addvec符号是被main.o引用的，所以它拷贝addvec.o到可执行文件。因为程序不引用任何由multvec.o定义的符号，所以链接器就不会拷贝这个模块到可执行文件。链接器还会拷贝libc.a中的printf.o模块，以及许多C运行时系统中的其他模块。</p>
<p>在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。</p>
<p>例如在上面的demo中，<code>gcc -static ./libvector.a main2.c</code>，就会出现如下的错误。</p>
<p><img src="/images/2016/8/11/3.png" alt=""></p>
<p>对于链接的其他内容，请参考另一篇文章。</p>
<hr>
<p>参考资料：</p>
<ol>
<li>《深入理解计算机系统》</li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/12/Trie树的概念及其实现/">Trie树的概念及其实现</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-07-12
        </span>
        
          <span class="post-category">
            
              <a href="/categories/数据结构/">数据结构</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="Trie的概念"><a href="#Trie的概念" class="headerlink" title="Trie的概念"></a>Trie的概念</h2><p>在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>看到概念，也许读者会觉得有点抽象，博主搜到一篇大神写的博客，顿时觉得茅塞顿开（ps：博主给的参考链接可能访问不了，请fq）。这篇文章真是太棒了，原文是英文，博主就不翻译了，相信读者们的英语水平，故直接转到本篇博文中，希望对大家会有所帮助。</p>
<h2 id="Trie-implementation-in-C"><a href="#Trie-implementation-in-C" class="headerlink" title="Trie implementation in C"></a>Trie implementation in C</h2><p>To implement the kind of storage which stores strings as the search keys , there is a need to have special data structures which can store the strings efficiently and the searching of data based on the string keys is easier, efficient and faster. One such data structure is a tree based implementation called Trie.</p>
<p>Trie is a data structure which can be used to implement a dictionary kind of application. It provides all the functionality to insert a string, search a string and delete a string from the dictionary. The insertion and deletion operation takes O(n) time where n is the length of the string to be deleted or inserted.<br>Some of the application of tries involve web based search engines, URL completion in autocomplete feature, Spell checker etc.</p>
<p><strong> Structure of Trie(Specific to this implementation): </strong></p>
<p>The trie implemented here consists of nodes. Each node has these fields:</p>
<ol>
<li><p><strong>Key</strong> - Part of the string to be serached,inserted or deleted.</p>
</li>
<li><p><strong>Value</strong> -  The value associated with a string (e.g In a dictionary it could be the meaning of the word which we are searching)</p>
</li>
<li><p><strong>Neighbour node address</strong> - It consists of the address of the neighbouring node at the same level.</p>
</li>
<li><p><strong>Previous neighbour address</strong> - It consists of the address of the previous node at the same level.</p>
</li>
<li><p><strong>Children node address</strong> - It consists of the address of the child nodes of the current node.</p>
</li>
<li><p><strong>Parent node address</strong> - It consists of the address of the parent node of the current node.</p>
</li>
</ol>
<p>The additional nodes like Parent and Previous nodes are added to this implementation for making the search, and deletions easier.</p>
<p>Here is a diagrammatical view of a trie nodes I have used in this implementation. The field key is not represented in the diagram due to symmetry purposes.</p>
<p><img src="/images/2016/7/12/TrieNodes1.png" alt="这里写图片描述"></p>
<p>Let us consider an example to understand tries in detail.</p>
<p>Suppose we have to implement a database for the HR department of an organisation in which we have to store an employee’s name and their ages. There is an assumption for this example that there each employee’s name is unique.So there is a strange policy in this organisation that any new employee which has a name that already exists in the organisation, it would not hire that new employee.</p>
<p>Let’s use this hypothetical example just to understand how tries work.</p>
<ul>
<li>Consider we have a new employee named Andrew with age 36. Lets populate our trie for “andrew”.</li>
</ul>
<p><img src="/images/2016/7/12/Trie1.png" alt="这里写图片描述"></p>
<ul>
<li>Now add “tina”.</li>
</ul>
<p><img src="/images/2016/7/12/Trie2.png" alt="这里写图片描述"></p>
<ul>
<li>Add “argo”.</li>
</ul>
<p><img src="/images/2016/7/12/Trie3.png" alt="这里写图片描述"></p>
<ul>
<li>Add “tim”.</li>
</ul>
<p><img src="/images/2016/7/12/Trie4.png" alt="这里写图片描述"></p>
<ul>
<li>Add “t”.</li>
</ul>
<p><img src="/images/2016/7/12/Trie5.png" alt="这里写图片描述"></p>
<ul>
<li>Add “amy”.</li>
</ul>
<p><img src="/images/2016/7/12/Trie6.png" alt="这里写图片描述"></p>
<ul>
<li>Add “aramis”.</li>
</ul>
<p><img src="/images/2016/7/12/Trie7.png" alt="这里写图片描述"></p>
<p>This is the complete Trie with all the entries. Now let us try deleting the names. I am not capturing the trivial cases.</p>
<ul>
<li>Lets try deleting Argo.</li>
</ul>
<p><img src="/images/2016/7/12/TrieD1.png" alt="这里写图片描述"></p>
<ul>
<li>Delete Tina</li>
</ul>
<p><img src="/images/2016/7/12/TrieD2.png" alt="这里写图片描述"></p>
<ul>
<li>Delete Andrew</li>
</ul>
<p><img src="/images/2016/7/12/TrieD3.png" alt="这里写图片描述"></p>
<p>There is also a video from IIT Delhi which explains the tries. <a href="http://www.youtube.com/watch?v=uhAUk63tLRM" target="_blank" rel="noopener">Tries Explained</a>.</p>
<p>The implementation for this Trie is given below. Please provide your suggestions to further improve the implementation.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> trieVal_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">trieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> key;</span><br><span class="line">    trieVal_t value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trieNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trieNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trieNode</span> *<span class="title">children</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trieNode</span> *<span class="title">parent</span>;</span></span><br><span class="line">&#125; trieNode_t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrieCreate</span><span class="params">(trieNode_t **root)</span></span>;</span><br><span class="line"><span class="function">trieNode_t* <span class="title">TrieSearch</span><span class="params">(trieNode_t *root, <span class="keyword">const</span> <span class="keyword">char</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrieAdd</span><span class="params">(trieNode_t **root, <span class="keyword">char</span> *key, <span class="keyword">int</span> data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrieRemove</span><span class="params">(trieNode_t **root, <span class="keyword">char</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrieDestroy</span><span class="params">( trieNode_t* root )</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*trie.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"trie.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function">trieNode_t *<span class="title">TrieCreateNode</span><span class="params">(<span class="keyword">char</span> key, <span class="keyword">int</span> data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrieCreate</span><span class="params">(trieNode_t **root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> *root = TrieCreateNode(<span class="string">'\0'</span>, <span class="number">0xffffffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">trieNode_t *<span class="title">TrieCreateNode</span><span class="params">(<span class="keyword">char</span> key, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> trieNode_t *node = <span class="literal">NULL</span>;</span><br><span class="line"> node = (trieNode_t *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(trieNode_t));</span><br><span class="line"> <span class="keyword">if</span>(<span class="literal">NULL</span> == node)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Malloc failed\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line"> &#125;</span><br><span class="line"> node-&gt;key = key;</span><br><span class="line"> node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"> node-&gt;children = <span class="literal">NULL</span>;</span><br><span class="line"> node-&gt;value = data;</span><br><span class="line"> node-&gt;parent= <span class="literal">NULL</span>;</span><br><span class="line"> node-&gt;prev= <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrieAdd</span><span class="params">(trieNode_t **root, <span class="keyword">char</span> *key, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> trieNode_t *pTrav = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">if</span>(<span class="literal">NULL</span> == *root)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"NULL tree\n"</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"\nInserting key %s: \n"</span>,key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> pTrav = (*root)-&gt;children;</span><br><span class="line"> <span class="keyword">if</span>(pTrav == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">/*First Node*/</span></span><br><span class="line">  <span class="keyword">for</span>(pTrav = *root; *key; pTrav = pTrav-&gt;children)</span><br><span class="line">  &#123;</span><br><span class="line">   pTrav-&gt;children = TrieCreateNode(*key, <span class="number">0xffffffff</span>);</span><br><span class="line">   pTrav-&gt;children-&gt;parent = pTrav;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Inserting: [%c]\n"</span>,pTrav-&gt;children-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   key++;</span><br><span class="line">  &#125;</span><br><span class="line">  pTrav-&gt;children = TrieCreateNode(<span class="string">'\0'</span>, data);</span><br><span class="line">  pTrav-&gt;children-&gt;parent = pTrav;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Inserting: [%c]\n"</span>,pTrav-&gt;children-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(TrieSearch(pTrav, key))</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Duplicate!\n"</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span>(*key != <span class="string">'\0'</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(*key == pTrav-&gt;key)</span><br><span class="line">  &#123;</span><br><span class="line">   key++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Traversing child: [%c]\n"</span>,pTrav-&gt;children-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   pTrav = pTrav-&gt;children;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span>(pTrav-&gt;next)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(*key == pTrav-&gt;next-&gt;key)</span><br><span class="line">  &#123;</span><br><span class="line">   key++;</span><br><span class="line">   TrieAdd(&amp;(pTrav-&gt;next), key, data);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pTrav = pTrav-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(*key)</span><br><span class="line"> &#123;</span><br><span class="line">  pTrav-&gt;next = TrieCreateNode(*key, <span class="number">0xffffffff</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  pTrav-&gt;next = TrieCreateNode(*key, data);</span><br><span class="line"> &#125;</span><br><span class="line"> pTrav-&gt;next-&gt;parent = pTrav-&gt;parent;</span><br><span class="line"> pTrav-&gt;next-&gt;prev = pTrav;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Inserting [%c] as neighbour of [%c] \n"</span>,pTrav-&gt;next-&gt;key, pTrav-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> <span class="keyword">if</span>(!(*key))</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> key++;</span><br><span class="line"> <span class="keyword">for</span>(pTrav = pTrav-&gt;next; *key; pTrav = pTrav-&gt;children)</span><br><span class="line"> &#123;</span><br><span class="line">  pTrav-&gt;children = TrieCreateNode(*key, <span class="number">0xffffffff</span>);</span><br><span class="line">  pTrav-&gt;children-&gt;parent = pTrav;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Inserting: [%c]\n"</span>,pTrav-&gt;children-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  key++;</span><br><span class="line"> &#125;</span><br><span class="line"> pTrav-&gt;children = TrieCreateNode(<span class="string">'\0'</span>, data);</span><br><span class="line"> pTrav-&gt;children-&gt;parent = pTrav;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Inserting: [%c]\n"</span>,pTrav-&gt;children-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">trieNode_t* <span class="title">TrieSearch</span><span class="params">(trieNode_t *root, <span class="keyword">const</span> <span class="keyword">char</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> trieNode_t *level = root;</span><br><span class="line"> trieNode_t *pPtr = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">int</span> lvl=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  trieNode_t *found = <span class="literal">NULL</span>;</span><br><span class="line">  trieNode_t *curr;</span><br><span class="line">  <span class="keyword">for</span> (curr = level; curr != <span class="literal">NULL</span>; curr = curr-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span> (curr-&gt;key == *key)</span><br><span class="line">   &#123;</span><br><span class="line">    found = curr;</span><br><span class="line">    lvl++;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="literal">NULL</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (*key == <span class="string">'\0'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   pPtr = curr;</span><br><span class="line">   <span class="keyword">return</span> pPtr;</span><br><span class="line">  &#125;</span><br><span class="line">  level = found-&gt;children;</span><br><span class="line">  key++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrieRemove</span><span class="params">(trieNode_t **root, <span class="keyword">char</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> trieNode_t *tPtr = <span class="literal">NULL</span>;</span><br><span class="line"> trieNode_t *tmp = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">if</span>(<span class="literal">NULL</span> == *root || <span class="literal">NULL</span> == key)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> tPtr = TrieSearch((*root)-&gt;children, key);</span><br><span class="line"> <span class="keyword">if</span>(<span class="literal">NULL</span> == tPtr)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Key [%s] not found in trie\n"</span>, key);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Deleting key [%s] from trie\n"</span>, key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>( tPtr-&gt;prev &amp;&amp; tPtr-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">   tmp = tPtr;</span><br><span class="line">   tPtr-&gt;next-&gt;prev = tPtr-&gt;prev;</span><br><span class="line">   tPtr-&gt;prev-&gt;next = tPtr-&gt;next;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Deleted [%c] \n"</span>, tmp-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="built_in">free</span>(tmp);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(tPtr-&gt;prev &amp;&amp; !(tPtr-&gt;next))</span><br><span class="line">  &#123;</span><br><span class="line">   tmp = tPtr;</span><br><span class="line">   tPtr-&gt;prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Deleted [%c] \n"</span>, tmp-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="built_in">free</span>(tmp);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!(tPtr-&gt;prev) &amp;&amp; tPtr-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">   tmp = tPtr;</span><br><span class="line">   tPtr-&gt;next-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">   tPtr-&gt;parent-&gt;children = tPtr-&gt;next;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Deleted [%c] \n"</span>, tmp-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="built_in">free</span>(tmp);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">   tmp = tPtr;</span><br><span class="line">   tPtr = tPtr-&gt;parent;</span><br><span class="line">   tPtr-&gt;children = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Deleted [%c] \n"</span>, tmp-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="built_in">free</span>(tmp);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Deleted key [%s] from trie\n"</span>, key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrieDestroy</span><span class="params">( trieNode_t* root )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> trieNode_t *tPtr = root;</span><br><span class="line"> trieNode_t *tmp = root;</span><br><span class="line">    <span class="keyword">while</span>(tPtr)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">while</span>(tPtr-&gt;children)</span><br><span class="line">   tPtr = tPtr-&gt;children;</span><br><span class="line">  <span class="keyword">if</span>( tPtr-&gt;prev &amp;&amp; tPtr-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">   tmp = tPtr;</span><br><span class="line">   tPtr-&gt;next-&gt;prev = tPtr-&gt;prev;</span><br><span class="line">   tPtr-&gt;prev-&gt;next = tPtr-&gt;next;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Deleted [%c] \n"</span>, tmp-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="built_in">free</span>(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(tPtr-&gt;prev &amp;&amp; !(tPtr-&gt;next))</span><br><span class="line">  &#123;</span><br><span class="line">   tmp = tPtr;</span><br><span class="line">   tPtr-&gt;prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Deleted [%c] \n"</span>, tmp-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="built_in">free</span>(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!(tPtr-&gt;prev) &amp;&amp; tPtr-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">   tmp = tPtr;</span><br><span class="line">   tPtr-&gt;parent-&gt;children = tPtr-&gt;next;</span><br><span class="line">   tPtr-&gt;next-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">   tPtr = tPtr-&gt;next;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Deleted [%c] \n"</span>, tmp-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="built_in">free</span>(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">   tmp = tPtr;</span><br><span class="line">   <span class="keyword">if</span>(tPtr-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="comment">/*Root*/</span></span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   tPtr = tPtr-&gt;parent;</span><br><span class="line">   tPtr-&gt;children = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Deleted [%c] \n"</span>, tmp-&gt;key);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="built_in">free</span>(tmp);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*triedriver.c*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * To Compile : gcc -o trie trie.c triedriver.c</span></span><br><span class="line"><span class="comment"> * To run: ./trie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"trie.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    trieNode_t *root = <span class="literal">NULL</span>;</span><br><span class="line">    trieNode_t* ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Trie Example\n"</span>);</span><br><span class="line">    <span class="comment">/*Create a trie*/</span></span><br><span class="line">    TrieCreate(&amp;root);</span><br><span class="line">    TrieAdd(&amp;root, <span class="string">"andrew"</span>, <span class="number">1</span>);</span><br><span class="line">    TrieAdd(&amp;root, <span class="string">"tina"</span>, <span class="number">2</span>);</span><br><span class="line">    TrieAdd(&amp;root, <span class="string">"argo"</span>, <span class="number">3</span>);</span><br><span class="line">    TrieAdd(&amp;root, <span class="string">"timor"</span>, <span class="number">5</span>);</span><br><span class="line">    TrieRemove(&amp;root, <span class="string">"tim"</span>);</span><br><span class="line">    TrieAdd(&amp;root, <span class="string">"tim"</span>, <span class="number">6</span>);</span><br><span class="line">    TrieRemove(&amp;root, <span class="string">"tim"</span>);</span><br><span class="line">    TrieAdd(&amp;root, <span class="string">"ti"</span>, <span class="number">6</span>);</span><br><span class="line">    TrieAdd(&amp;root, <span class="string">"amy"</span>, <span class="number">7</span>);</span><br><span class="line">    TrieAdd(&amp;root, <span class="string">"aramis"</span>, <span class="number">8</span>);</span><br><span class="line">     ret = TrieSearch(root-&gt;children, <span class="string">"andrew"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != ret)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"value %d\n"</span>, ret-&gt;value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"not found\n"</span>);</span><br><span class="line">    <span class="comment">/*Destroy the trie*/</span></span><br><span class="line">    TrieDestroy(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In order to print the debug messages, use -DDEBUG while compiling with gcc:</p>
<p><code>gcc trie.c triedriver.c -DDEBUG -o trie</code></p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="noopener">维基百科</a></li>
<li><a href="https://simplestcodings.blogspot.com/2012/11/trie-implementation-in-c.html" target="_blank" rel="noopener">simplestcodings</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/07/Linux中libhugetlbfs的使用/">Linux中libhugetlbfs的使用</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-07-07
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Kernel/">Kernel</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>熟悉了linux中的透明大页机制之后，这次又调研了hugetlbfs，对于hugetlbfs的具体介绍，不是本文的重点，如果读者对于hugetlbfs不太了解的话，可以参考<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hugetlb/" target="_blank" rel="noopener">这篇文章</a>，它介绍了hugetlbfs的使用。接下来，我将介绍libhugetlbfs的安装与使用。</p>
<p>最初，我参照libhugetlbfs的文档<a href="https://github.com/libhugetlbfs/libhugetlbfs/blob/master/HOWTO" target="_blank" rel="noopener">点击这里</a>，将源代码解压，安装。之后去谷歌搜了一下ubuntu install libhugetlbfs,发现已经有官方安装包了，顿时。。。。废话不多说，直接切入正题。</p>
<p>(1) libhugetlbfs的安装如下：</p>
<p><code>sudo apt-get update</code></p>
<p><code>sudo apt-get install libhugetlbfs-dev</code></p>
<p>ok,hugetlbfs安装完毕，下面输入<code>hugeadm</code>这一指令来检测安装是否成功。如果出现如下图所示的界面，恭喜你，安装成功。</p>
<p><img src="/images/2016/7/7/1.png" alt=""></p>
<p>(2) 建立挂载点</p>
<p><code>mkdir -p /mnt/hugetlbfs</code></p>
<p><code>mount -t hugetlbfs none /mnt/hugetlbfs</code></p>
<p>通过<code>hugeadm --list-all-mounts</code>检测是否挂在成功</p>
<p><img src="/images/2016/7/8/1.png" alt=""></p>
<p>(3) 由于大页是由大页池进行维护的，此刻，我们需要设置维护池中大页的个数。为了简单起见，我们设置大页个数的最小值为30,最大值为40。</p>
<p><code>hugeadm --pool-pages-min 2MB:30</code></p>
<p><code>hugeadm --pool-pages-max 2MB:40</code></p>
<p>之后，通过<code>hugeadm --pool-list</code> 和<code>grep HugePages /proc/meminfo</code>去查看大页池中大页的数目。</p>
<p><img src="/images/2016/7/8/2.png" alt=""></p>
<p>(4)测试透明大页</p>
<p>编写一个测试程序，测试程序申请了二十几个大页。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, len;</span><br><span class="line">	<span class="keyword">int</span> *mem;</span><br><span class="line">	len = <span class="number">13</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">	mem = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		mem[i] = i;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">free</span>(mem);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译程序，最终的可执行文件名为a.out。在a.out的目录下，执行如下指令：</p>
<p><code>LD_PRELOAD=libhugetlbfs.so HUGETLB_MORECORE=yes ./a.out</code><br>此刻，查看大页池中大页的数目。</p>
<p><img src="/images/2016/7/8/3.png" alt=""><br>通过<code>HugePages_Tota</code>和<code>HugePages_Free</code>参数的值证明大页已经成功使用。</p>
<p>好了，我们完成了libhugetlbfs的使用，下面对上述步骤中的细节进行简要的说明吧。</p>
<ol>
<li>libhugetlb库对malloc()/free()等常用的内存相关的库函数进行了重载，以使得应用程序的数据可以放置在采用大页面的内存区域中，以提高内存性能。</li>
<li>若你对<code>LD_PRELOAD</code>这个指令不太清楚，可参见<a href="http://www.catonmat.net/blog/simple-ld-preload-tutorial/" target="_blank" rel="noopener">这里</a>。</li>
<li>针对大页池，HugePages_Totalis the size of the pool of huge pages，HugePages_Freeis the number of huge pages in the pool that are not yet allocated，HugePages_Surpis the number of huge pages in the pool above the value in /proc/sys/vm/nr_hugepages。具体请查看官方文档。</li>
<li>kvm亦可以使用hugepage，具体步骤请参考<a href="https://help.ubuntu.com/community/KVM%20-%20Using%20Hugepages" target="_blank" rel="noopener">这里</a></li>
</ol>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hugetlb/" target="_blank" rel="noopener">Linux 大页面使用与实现简介</a></li>
<li><a href="https://software.intel.com/sites/default/files/Large_pages_mic.pdf" target="_blank" rel="noopener">How to use hugepage to improve application performance</a></li>
<li><a href="https://github.com/libhugetlbfs/libhugetlbfs/blob/master/HOWTO" target="_blank" rel="noopener">libhugetlbfs HOWTO</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/04/Linux内核中zram模块的理解/">Linux内核中zram模块的理解</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-07-04
        </span>
        
          <span class="post-category">
            
              <a href="/categories/内存管理/">内存管理</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>在第一次接触zram这个名词的时候有点懵，究竟什么是zram呢？其实zram就是linux内核中内存压缩模块，那么问题又来了，什么是内存压缩呢？</p>
<h2 id="内存压缩"><a href="#内存压缩" class="headerlink" title="内存压缩"></a>内存压缩</h2><p>术语：</p>
<h3 id="Active-memory"><a href="#Active-memory" class="headerlink" title="Active memory"></a>Active memory</h3><p>Active memory：活跃的内存，比方可以说是开个5个App，每个占用了100M，那么就有500M活跃内存；</p>
<h3 id="Inactive-memory"><a href="#Inactive-memory" class="headerlink" title="Inactive memory"></a>Inactive memory</h3><p>Inactive memory：非活跃的内存，比如关掉了三个App，那么这三个App占用的共300M内存就不再是活跃了，但是内核还会保留它。如果这时立马再启动这三个App，就会以非常快的速度打开了，因为还没有被其他App占用的Inactive memory这时又被激活了。如果很长一段时间内这些非活跃内存都没有再用的话，随着系统内存占用增加，这些非活跃内存也会被清空而用做新的用途。</p>
<h3 id="Compressed-Memory的作用"><a href="#Compressed-Memory的作用" class="headerlink" title="Compressed Memory的作用"></a>Compressed Memory的作用</h3><p>那么Compressed Memory在其中扮演什么角色呢？很简单，它尽可能久的保留那些会用到的非活跃内存，以使系统更快的响应潜在的第二次响应。但是为了照顾新的内存需求，内核会压缩这些非活跃内存以腾出空间，以供新的App使用。</p>
<p><img src="/images/2016/7/4/1.png" alt="这里写图片描述"></p>
<h3 id="技术特点"><a href="#技术特点" class="headerlink" title="技术特点"></a>技术特点</h3><ol>
<li>缩减了内存使用：很明显，压缩了非活跃内存；</li>
<li>改善了电源效能：在内存不足的情况下，优先使用压缩非活跃内存技术，而非把内存存为SWAP到硬盘上，减少了硬盘IO带来的能量损耗；</li>
<li>最小化CPU使用：正如上面一样，通过CPU压缩或解压内存是非常快速的一件事情，也减少了CPU处理其他任务的损耗；</li>
<li>多核支持：传统的虚拟内存、或写SWAP等操作都是单核的，但是压缩内存技术则是可以并行跑在多核上，同时压缩内存和开辟新的内存空间</li>
</ol>
<h2 id="zram的使用"><a href="#zram的使用" class="headerlink" title="zram的使用"></a>zram的使用</h2><p>在调研期间，尝试过各种方法，最终发现一个好的方法。</p>
<h3 id="创建zramswap-conf-文件"><a href="#创建zramswap-conf-文件" class="headerlink" title="创建zramswap.conf 文件"></a>创建zramswap.conf 文件</h3><p>在<code>/etc/init</code>目录下，创建<code>zramswap.conf</code>，文本内容如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">description "Initializes zram swaping"</span><br><span class="line">start on runlevel [2345]</span><br><span class="line">stop on runlevel [!2345]</span><br><span class="line">pre-start script</span><br><span class="line"><span class="meta">#</span><span class="bash"> load dependency modules</span></span><br><span class="line">modprobe zram num_devices=2</span><br><span class="line"><span class="meta">#</span><span class="bash"> initialize the devices</span></span><br><span class="line">echo 1073741824 &gt; /sys/block/zram0/disksize</span><br><span class="line">echo 1073741824 &gt; /sys/block/zram1/disksize</span><br><span class="line"><span class="meta">#</span><span class="bash"> Creating swap filesystems</span></span><br><span class="line">mkswap /dev/zram0</span><br><span class="line">mkswap /dev/zram1</span><br><span class="line"><span class="meta">#</span><span class="bash"> Switch the swaps on</span></span><br><span class="line">swapon -p 5 /dev/zram0</span><br><span class="line">swapon -p 5 /dev/zram1</span><br><span class="line">end script</span><br><span class="line">post-stop script</span><br><span class="line"><span class="meta">#</span><span class="bash"> Switching off swap</span></span><br><span class="line">swapoff /dev/zram0</span><br><span class="line">swapoff /dev/zram1</span><br><span class="line">rmmod zram</span><br><span class="line">end script</span><br></pre></td></tr></table></figure></p>
<h3 id="重启计算机"><a href="#重启计算机" class="headerlink" title="重启计算机"></a>重启计算机</h3><h3 id="查看swap的信息"><a href="#查看swap的信息" class="headerlink" title="查看swap的信息"></a>查看swap的信息</h3><ol>
<li><code>grep Swap /proc/meminfo</code> see total swap, and free swap (all linux)</li>
<li><code>cat /proc/swaps</code> see which swap devices are being used (all linux)</li>
<li><code>swapon -s</code> see swap devices and sizes (where swapon is installed)</li>
</ol>
<h3 id="验证zram的使用"><a href="#验证zram的使用" class="headerlink" title="验证zram的使用"></a>验证zram的使用</h3><p>说明运行环境，物理内存8个G，设置zram0和zram1两个块设备的大小为1个G，测试程序申请7个G的内存，测试程序源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//printf("%d\n", sizeof(int));</span></span><br><span class="line">	<span class="keyword">int</span>  *mem;</span><br><span class="line">	<span class="keyword">int</span> i, size;</span><br><span class="line">	size = <span class="number">0x70000000</span>;</span><br><span class="line">	mem = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">		mem[i] = (i%<span class="number">1024</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">free</span>(mem);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试程序运行前，zram0和zram1的使用情况如下图：</p>
<p><img src="/images/2016/7/11/1.png" alt="这里写图片描述"></p>
<p>测试程序运行后，zram0和zram1的使用情况如下图：</p>
<p><img src="/images/2016/7/11/2.png" alt="这里写图片描述"></p>
<p>从以上两张图看出zram已经成功使用了！</p>
<h2 id="zram源码解析"><a href="#zram源码解析" class="headerlink" title="zram源码解析"></a>zram源码解析</h2><p>对于zram源码的解析，<a href="http://kernel.meizu.com/zram-introduction.html" target="_blank" rel="noopener">魅族内核团队</a>已经写了技术博客。<br><a href="http://lxr.free-electrons.com/source/drivers/block/zram/zram_drv.c?v=3.14" target="_blank" rel="noopener">zram源码</a></p>
<p>对于块设备基础概念和块设备驱动整体框架的相关知识，请读者自己查阅相关资料。</p>
<ul>
<li><a href="http://blog.chinaunix.net/xmlrpc.php?r=blog/article&amp;uid=30282771&amp;id=5144166" target="_blank" rel="noopener">资料1</a></li>
<li><a href="http://blog.csdn.net/flyingcloud_2008/article/details/5818995" target="_blank" rel="noopener">资料2</a></li>
</ul>
<h3 id="zram-架构"><a href="#zram-架构" class="headerlink" title="zram 架构"></a>zram 架构</h3><p>zram 从架构上可以分为三部分：</p>
<ul>
<li>驱动部分</li>
</ul>
<p>该部分创建了一个块设备，然后提供了处理 IO 请求的接口；</p>
<ul>
<li>数据流操作部分</li>
</ul>
<p>该部分主要提供串行或者并行的压缩和解压操作；</p>
<ul>
<li>解压缩算法部分</li>
</ul>
<p>该部分主要是一个个压缩和解压算法，每个算法都提供统一的压缩和解压接口给数据流操作部分调用。</p>
<p><img src="/images/2016/7/12/zram 架构.png" alt="这里写图片描述"></p>
<h3 id="zram-驱动部分代码分析"><a href="#zram-驱动部分代码分析" class="headerlink" title="zram 驱动部分代码分析"></a>zram 驱动部分代码分析</h3><ul>
<li>zram_init</li>
</ul>
<p>首先调用 register_blkdev 注册块设备驱动到内核中，然后再根据 num_devices 调用 create_device 来创建相应个数的块设备， 这里默认是创建一个块设备。</p>
<p><img src="/images/2016/7/12/zram_init.png" alt="这里写图片描述"></p>
<ul>
<li>create_device</li>
</ul>
<p>对于 flash、 RAM 等完全随机访问的非机械设备，并不需要进行复杂的 I/O 调度，所以这里直接调用 blk_alloc_queue 分配一个 “请求队列”，然后使用 blk_queue_make_request 函数绑定分配好的 “请求队列” 和 “请求处理”函数 zram_make_request。接着初始化块设备的操作函数集 zram_devops 及设备容量、名字、队列等其他属性，最后调用 add_disk 将该块设备真正添加到内核中。</p>
<p><img src="/images/2016/7/12/create_device.png" alt="这里写图片描述"></p>
<ul>
<li>disksize_store</li>
</ul>
<p>zram 使用了 Zsmalloc 分配器来管理它的内存空间，Zsmalloc 分配器尝试将多个相同大小的对象存放在组合页（称为 zspage）中，这个组合页不要求物理连续，从而提高内存的使用率。</p>
<p>首先会根据 zram 的内存中页面的个数，创建相应个数的 zram table，每个 zram table 都对应一个页面；然后会调用 zs_create_pool 创建一个 zsmalloc 的内存池，以后所有的页面申请和释放都是通过 zs_malloc 和 zs_free 来分配和释放相对应的对象。</p>
<p><img src="/images/2016/7/12/disksize_store.png" alt="这里写图片描述"></p>
<ul>
<li>zram_make_request</li>
</ul>
<p>在整个块设备的 I/O 操作中，贯穿于始终的就是“请求”，块设备的 I/O 操作会排队和整合。块设备驱动的任务就是处理请求，对请求的排队和整合则是由 I/O 调度算法解决，因此，zram 块设备驱动的核心这个请求处理函数，所有的 zram I/O 请求都是通过这个请求处理函数来处理的。</p>
<p>首先它判断这个 I/O 请求是否是有效的，即检测请求是否在 zram 逻辑块的范围以内，且是否对齐。然后调用__zram_make_request 遍历 bio 中的每个段 bio_vec，根据 bio 的传输方向选择执行写 (zram_bvec_write) 或者读 (zram_bvec_read) 操作。</p>
<p><img src="/images/2016/7/12/zram_make_request.png" alt="这里写图片描述"></p>
<ul>
<li>zram_bvec_write</li>
</ul>
<p>在写数据之前，首先使用 GFP_NOIO 标志创建一个不允许任何 I/O 初始化的页面，然后将 zram_data 对应的数据先解压出来放到该创建的页面中。接着去调用 zcomp_strm_find 找到一个压缩操作流，如果是单压缩流，则实际调用的是 zcomp_strm_single_find，如果是多压缩流，则实际调用的是 zcomp_strm_multi_find。</p>
<p>然后，将段 bio_vec 中的页面临时映射到高端地址，并将高端地址空间页面的内容复制到已保存好 zram_data 压缩后的数据的页面。调用 zs_malloc 申请一个 zram table，使 zcomp_compress 压缩内容并将压缩后的内容存放到新申请的 zram table。最后调用 zram_free_page 删除旧内容所占用的 zram table。</p>
<p>zcomp_decompress 会根据 struct zcomp_backend 初始化时设定的压缩算法来调用相应的解压接口，lzo 压缩算法的解压接口是 lzo_compress ，而 lz4 压缩算法的解压接口是 zcomp_lz4_compress ，该接口还调用了压缩操作流，以此执行串行或者并行写操作。</p>
<p><img src="/images/2016/7/12/zram_bvec_write.png" alt="这里写图片描述"></p>
<ul>
<li>zram_bvec_read</li>
</ul>
<p>读操作首先将段 bio_vec 中的页面临时映射到高端地址，然后再调用 zram_decompress_page 将 zram_meta 所对应的数据解压到这块映射的高端内存空间，解压的接口是 zcomp_decompress，它会根据 struct zcomp_backend 初始化时设定的压缩算法来调用相应的解压接口，lzo 压缩算法的解压接口是 lzo_decompress ，而 lz4 压缩算法的解压接口是 zcomp_lz4_decompress 。</p>
<p><img src="/images/2016/7/12/zram_bvec_read.png" alt="这里写图片描述"></p>
<h3 id="数据流操作部分代码分析"><a href="#数据流操作部分代码分析" class="headerlink" title="数据流操作部分代码分析"></a>数据流操作部分代码分析</h3><ul>
<li>zcomp_create</li>
</ul>
<p>若最大可能同时执行压缩操作的个数来调用为一，则调用 zcomp_strm_single_create 来创建一个压缩流，而若最大可能同时执行压缩操作的个数来调用大于一，则调用 zcomp_strm_multi_create 先创建一个压缩流，然后创建一个压缩流链表，并将创建好的压缩流加到压缩流链表中，后面再根据需求来动态创建更多的压缩流。</p>
<hr>
<p>参考资料:</p>
<ol>
<li><a href="https://imtx.me/archives/1830.html" target="_blank" rel="noopener">imtx</a></li>
<li><a href="https://weirdfellow.wordpress.com/2011/05/04/compressed-ram-with-zram/" target="_blank" rel="noopener">weirdfellow</a></li>
<li><a href="http://unix.stackexchange.com/questions/23072/how-can-i-check-if-swap-is-active-from-the-command-line" target="_blank" rel="noopener">stackexchange</a></li>
<li><a href="http://kernel.meizu.com/zram-introduction.html" target="_blank" rel="noopener">魅族</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/blockdev/zram.txt" target="_blank" rel="noopener">kernel.org</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
      
  <nav class="pagination">
    
      <a class="prev" href="/page/11/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/13/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


    
  </section>

          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:liujunming1163@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/liujunming" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2016 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">liujunming</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script>

  </body>
</html>
