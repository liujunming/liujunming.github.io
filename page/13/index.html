<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="liujunming's personal blog."/>













  <link rel="alternate" href="/atom.xml" title="L">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1" />



<link rel="canonical" href="http://liujunming.github.io/page/13/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1" />



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> L </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">L</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/links">
        <li class="mobile-menu-item">
          
          
            Links
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">L</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/links">
            
            
              Links
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <section id="posts" class="posts">
    
      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/06/30/理解inode/">理解inode</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-06-30
        </span>
        
          <span class="post-category">
            
              <a href="/categories/linux/">linux</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>这篇文章转自阮一峰老师的博客，很好的介绍了inode这个概念，故特此搬到自己的博客中来。<br><a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener">阮一峰老师博客原文</a></p>
<p>我觉得，理解inode，不仅有助于提高系统操作水平，还有助于体会Unix设计哲学，即如何把底层的复杂性抽象成一个简单概念，从而大大简化用户接口。</p>
<p>下面就是我的inode学习笔记，尽量保持简单。</p>
<h2 id="inode是什么？"><a href="#inode是什么？" class="headerlink" title="inode是什么？"></a>inode是什么？</h2><p>理解inode，要从文件储存说起。</p>
<p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。<br>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p>
<p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。<br>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p>
<h2 id="inode的内容"><a href="#inode的内容" class="headerlink" title="inode的内容"></a>inode的内容</h2><p>inode包含文件的元信息，具体来说有以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">文件的字节数</span><br><span class="line">文件拥有者的User ID</span><br><span class="line">文件的Group ID</span><br><span class="line">文件的读、写、执行权限</span><br><span class="line">文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</span><br><span class="line">链接数，即有多少文件名指向这个inode</span><br><span class="line">文件数据block的位置</span><br></pre></td></tr></table></figure></p>
<p>可以用stat命令，查看某个文件的inode信息：</p>
<p><code>stat example.txt</code></p>
<p><img src="http://image.beekka.com/blog/201112/bg2011120402.png" alt="这里写图片描述"></p>
<p>总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。</p>
<h2 id="inode的大小"><a href="#inode的大小" class="headerlink" title="inode的大小"></a>inode的大小</h2><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p>
<p>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p>
<p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。<br><code>df -i</code></p>
<p><img src="http://image.beekka.com/blog/201112/bg2011120403.png" alt="这里写图片描述"></p>
<p>查看每个inode节点的大小，可以用如下命令：</p>
<p><code>sudo tune2fs -l /dev/sda2 | grep Inode</code></p>
<p><img src="http://image.beekka.com/blog/201112/bg2011120404.png" alt="这里写图片描述"></p>
<p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p>
<h2 id="inode号码"><a href="#inode号码" class="headerlink" title="inode号码"></a>inode号码</h2><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p>
<p>这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。<br>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p>
<p>使用ls -i命令，可以看到文件名对应的inode号码：</p>
<p><code>ls -i example.txt</code></p>
<p><img src="http://image.beekka.com/blog/201112/bg2011120405.png" alt="这里写图片描述"></p>
<h2 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h2><p>Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p>
<p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p>
<p>ls命令只列出目录文件中的所有文件名：</p>
<p><code>ls /etc</code></p>
<p><img src="http://image.beekka.com/blog/201112/bg2011120406.png" alt="这里写图片描述"></p>
<p>ls -i命令列出整个目录文件，即文件名和inode号码：</p>
<p><code>ls -i /etc</code></p>
<p><img src="http://image.beekka.com/blog/201112/bg2011120407.png" alt="这里写图片描述"></p>
<p>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。</p>
<p><code>ls -l /etc</code></p>
<p><img src="http://image.beekka.com/blog/201112/bg2011120408.png" alt="这里写图片描述"></p>
<p>理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。</p>
<h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。</p>
<p>这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。</p>
<p>ln命令可以创建硬链接：</p>
<p><code>ln 源文件 目标文件</code></p>
<p><img src="http://image.beekka.com/blog/201112/bg2011120409.png" alt="这里写图片描述"></p>
<p>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。</p>
<p>反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</p>
<p>这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）。</p>
<h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>除了硬链接以外，还有一种特殊情况。</p>
<p>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。</p>
<p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。</p>
<p>ln -s命令可以创建软链接。</p>
<p><code>ln -s 源文文件或目录 目标文件或目录</code></p>
<p><img src="http://image.beekka.com/blog/201112/bg2011120410.png" alt="这里写图片描述"></p>
<h2 id="inode的特殊作用"><a href="#inode的特殊作用" class="headerlink" title="inode的特殊作用"></a>inode的特殊作用</h2><p>由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。</p>
<ol>
<li><p>有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</p>
</li>
<li><p>移动文件或重命名文件，只是改变文件名，不影响inode号码。</p>
</li>
<li>打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</li>
</ol>
<p>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/05/13/B树和B-树的定义以及应用/">B树和B+树的定义以及应用</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-05-13
        </span>
        
          <span class="post-category">
            
              <a href="/categories/数据结构/">数据结构</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>对于数据结构的学习，现在有些心得，就记录一下吧，想想自己当初学数据结构的时候，真是too young too simple。对于像红黑树，B树，B+树等数据结构，也许听上去很复杂，有点吓人，其实，我们所做的工作是利用好别人写好的代码，例如可以利用linux内核中的红黑树等数据结构，不需要造轮子，当然，如果有时间也可以自己动手写写，毕竟对自己也是一种提高麽！熟悉数据结构的应用场景，这点特别重要！接下来，我就放个大招了，哈哈，点开链接去看看吧，相信对你帮助巨大！！！<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">大招链接</a></p>
<h3 id="B-tree的定义"><a href="#B-tree的定义" class="headerlink" title="B-tree的定义"></a>B-tree的定义</h3><p>下面先说下B树的定义吧:</p>
<p>According to Knuth’s definition, a B-tree of order m is a tree which satisfies the following properties:</p>
<ol>
<li><p>Every node has at most m children.</p>
</li>
<li><p>Every non-leaf node (except root) has at least ⌈m/2⌉ children.</p>
</li>
<li><p>The root has at least two children if it is not a leaf node.</p>
</li>
<li><p>A non-leaf node with k children contains k−1 keys.</p>
</li>
<li><p>All leaves appear in the same level</p>
</li>
</ol>
<p>注：⌈m/2⌉是求大于m/2的最小整数值<br>上面是对m阶B树的定义，具体细节参考<a href="https://en.wikipedia.org/wiki/B-tree#Technical_description" target="_blank" rel="noopener">维基百科B树定义</a></p>
<p><em>4阶B-树更流行的称呼是2-3-4树，而3阶B-树叫做2-3树。</em></p>
<p>怎么样，是不是感觉很抽象，好，下面我将举一个例子，往3阶B树中依次插入整数1,2,3,4,5,6,7,8,然后再删除3,下面展示下结果</p>
<p>插入数据的结果如下图：<br><img src="/images/2016/5/13/1.png" alt="这里写图片描述"></p>
<p>删除3后的结果如下图：<br><img src="/images/2016/5/13/2.png" alt="这里写图片描述"></p>
<h3 id="B-树的定义"><a href="#B-树的定义" class="headerlink" title="B+树的定义"></a>B+树的定义</h3><p>B+树是一种特殊的B树，B+树与B树的区别如下：</p>
<blockquote>
<p>B+ trees don’t store data pointer in interior nodes, they are ONLY stored in leaf nodes. This is not optional as in B-Tree. This means that interior nodes can fit more keys on block of memory.</p>
</blockquote>
<blockquote>
<p>The leaf nodes of B+ trees are linked, so doing a linear scan of all keys will requires just one pass through all the leaf nodes. A B tree, on the other hand, would require a traversal of every level in the tree. This property can be utilized for efficient search as well since data is stored only in leafs.</p>
</blockquote>
<p>看到这里，也许读者们可能会感到困惑，好了，下面看看具体的示例吧。<br>分别往B树和B+中插入15,1,4,14,6,9,3,2,11,5,12,7,13,8,10。结果如下图：</p>
<p><img src="/images/2016/7/12/12.png" alt="这里写图片描述"></p>
<p><img src="/images/2016/7/12/11.png" alt="这里写图片描述"></p>
<p>第一张图片为B树的结点情况，第二张图片为B+树的结点情况，此刻，对于B树和B+树的区别一目了然了吧。</p>
<h3 id="B树与B-树的应用"><a href="#B树与B-树的应用" class="headerlink" title="B树与B+树的应用"></a>B树与B+树的应用</h3><p>看到一篇讲述B树和B+树特别好的一篇文章<a href="https://loveforprogramming.quora.com/Memory-locality-the-magic-of-B-Trees" target="_blank" rel="noopener">这里</a>，怕自己的翻译水平误导到读者，故直接把原本搬过来，相信这篇文章觉得值得慢慢鉴赏。</p>
<p>I love arrays because they are amazing data structures. Most languages allocate contiguous memory locations for an array thus they offer great memory locality. For accessing an element of an array, there is virtually no seek time required because elements are stored contiguously. With linked list, you never know where the next pointer is stored in memory, thus system might have to hop around quite a lot for locating a linked list node. This is very subtle distinction. Thus, while retrieving the elements of an array from disk, the access is super fast. To understand this better, lets understand how data is stored &amp; accessed from external memory. Below diagram shows a glimpse of how data might be stored in memory:</p>
<p><img src="/images/2016/7/12/21.png" alt="这里写图片描述"></p>
<p>As you might have read, traditional HDD (Hard Disk Drive) has rotating drives which store data in tracks (parallel circular areas). When the data needs to be read or written, the actuator with an arm, needs to go to a particular sector on the track to read or write data. This is measured as seek time. After that, the drive needs to rotate to reach to a particular sector (rotational latency). This happens really fast but when we are reading huge amount of data, it might become a bottleneck since disk has to continuously move to specific sectors. Average seek times vary from 4ms for high end servers to 9ms for commonly used desktop drives.</p>
<p><img src="/images/2016/7/12/22.png" alt="这里写图片描述"></p>
<p>SSD (Solid State Drive) offer superior performance because they have electrical connection for locating specific memory areas, rather then moving actuator with an arm. Thus, the access is very quick. But still, they also have average seek time of .10ms which might add up overtime for large data sets. Also, SSDs are expensive as compared to HDDs so not everyone is able to afford those.</p>
<p>I wanted to explain the process involved in fetching data from external memory perspective so that you can develop appreciation for memory locality. When we are accessing large data set and doing frequent read/write to/from disk, we need to consider this overhead. Based on type of disk, this can make your algorithm crawl. Anyways, since we now understand that memory locality is great for fast access, lets talk more about arrays.</p>
<p>As I said, arrays are fixed length data structures which offer great memory locality, but in real world, the size of the incoming data set cannot be predetermined. Also, if we store data arbitrarily in an array, we will have to do a linear scan to find a element. For large data sets stored in an array, two issues arise:</p>
<ol>
<li><p>We don’t know the size of the data set in advance. If the data set size exceeds the preallocated size, we need to allocate bigger memory slot and copy old elements to new location. This is called dynamic array resizing.</p>
</li>
<li><p>Unless we keep data in some predefined order, searching will be really inefficient with O(n) worst case time for large data sets. If we keep data sorted, we can do efficient binary search to find items. But for large sorted data set, inserting new element will also require rearranging other elements which will be very inefficient. For small set, this should not be a big problem.</p>
</li>
</ol>
<p>So looking at above two issues, it seem smaller fixed size sorted arrays are most efficient. But how this relates to use case where we have large data set? Well, we can break large data set into manageable small sorted arrays which can be efficiently searched. Also there has to be a way to link these different small sorted arrays with each other. Lets try it with an example. Assume that below array can’t be stored in one contiguous block of external memory:</p>
<p><img src="/images/2016/7/12/23.png" alt="这里写图片描述"></p>
<p>We first try to sequentially break big array into multiple small ones as shown in below diagram. It seems like a singly linked list but with a caveat that each node has multiple keys. We can inspect the first &amp; last element of each sub array and move forward until we reach to one which might have an element which we are looking for. Visualize doing this for large data set &amp; how inefficient this linear search would be.</p>
<p><img src="/images/2016/7/12/24.png" alt="这里写图片描述"></p>
<p>The other approach is to break array in ranges as shown in below diagram. Here we keep the top level array with few elements &amp; the first sub array has elements less than the first element in the top array &amp; so on. This is very similar to how we structure binary search tree but with two differences. Each parent node has more than one key and can point to more than two children. Also we can restrict on how many keys a particular node can have so that it doesn’t exceed allocated memory block [For example, 4 in below use case]. Here is an example:</p>
<p><img src="/images/2016/7/12/25.png" alt="这里写图片描述"></p>
<p>How will this improve efficiency? Well, if we keep this structure optimal, then while searching we can concentrate on one tree path which might have a particular element. For example, if we were to search for 22, we can do a linear search on top array (since array is small) and will figure out that a pointer between 6-29 must have our element. This means that we can virtually discard everything greater than equal to 29 since array is sorted. In technical terms, we are sub dividing search boundary to very small arrays at every step and eventually this would offer a logarithmic time. Feel it, this is really nice!</p>
<p>If you look at above diagram, we are trying to do following three things:</p>
<ol>
<li><p>Every sub-array or node (for simplicity), should have pre defined maximum size. The size determines how many maximum keys can a node store. In above example it is 4.</p>
</li>
<li><p>If a node has k keys, then it can point to maximum (k+1) sub arrays. In our case, the top level array points to 5 sub-arrays, including ones before 6 and one after 81. This means that if an internal node has 3 child nodes (or sub-arrays) then it must have 2 keys: k1 and k2. All values in the leftmost sub-array will be less than k1, all values in the middle sub-array will be between k1 and k2, and all values in the rightmost sub-array will be greater than k2. <strong>The maximum number of child sub-arrays a node can point to is called order of the tree</strong>.</p>
</li>
<li><p>If we are dynamically creating this partitioning, then we need to make sure that each array has a minimum number of elements so that space is not wasted and our distribution doesn’t get skewed. This is a little more complicated than it sounds, since we need to split or merge sub-arrays if they have keys less than minimum number. That’s why keeping “structure optimal”, is essential.</p>
</li>
</ol>
<p>Well, if you look at array tree diagram along with above properties, it essentially reflects the idea behind B-Tree. A linked sorted distributed range array with predefined sub array size which allows searches, sequential access, insertions, and deletions in logarithmic time. This structure is well suited for range queries as well. So lets formally define B-Tree now with some more properties:</p>
<p>A B-Tree of order k (children) is an k-ary search tree with the following properties:</p>
<ol>
<li><p>The root node is either a leaf or has at least two children.</p>
</li>
<li><p>Each node, except for the root and the leaves, has between k/2 and k children. This is to make sure that tree is making optimal use of space and is not skewed.</p>
</li>
<li><p>Each path from the root to a leaf has the same length. In other words, all leaf are at same level. [This is something new but is needed to keep tree balanced]</p>
</li>
<li><p>The root, each internal node, and each leaf is typically a disk block. [For memory locality as explained above]</p>
</li>
<li><p>Each internal node has up to (k - 1) key values and up to k pointers to children, as k is the order of tree (order=maximum children).</p>
</li>
<li><p>The records are typically stored in leaves. In some cases, they are also stored in internal nodes.</p>
</li>
</ol>
<p>Here is a better hierarchical example:</p>
<p><img src="/images/2016/7/12/26.png" alt="这里写图片描述"></p>
<p>B+ Trees are different from B Trees with following two properties:</p>
<ol>
<li><p>B+ trees don’t store data pointer in interior nodes, they are ONLY stored in leaf nodes. This is not optional as in B-Tree. This means that interior nodes can fit more keys on block of memory and thus fan out better.</p>
</li>
<li><p>The leaf nodes of B+ trees are linked, so doing a linear scan of all keys will requires just one pass through all the leaf nodes. A B tree, on the other hand, would require a traversal of every level in the tree. This property can be utilized for efficient search as well, since data is stored only in leafs.</p>
</li>
</ol>
<p><img src="/images/2016/7/12/27.png" alt="这里写图片描述"></p>
<p>B+ trees are extensively used in both database and file systems because of the efficiency they provide to store and retrieve data from external memory. To understand indexing in a database, knowing about B and B+ trees is a pre requisite.</p>
<p>Consider this SQL &amp; lets relate it to above structure:</p>
<p><code>select * from employees where salary between 100000 &amp; 200000;</code></p>
<p>If we had created an index on salary, then we can find minimum bound in O(log n) time and then use the leaf linking property to scan through the elements until we reach to an element which is above 200000 (elements are sorted). If the leaf node size is big enough, then the range can be obtained very efficiently because of memory locality. If we had used binary search tree with some variant of in order traversal to find element between 100000 &amp; 200000, it would not be as efficient as above. This is because of two reasons. One, because binary search tree have only two linked nodes &amp; second, you can’t predict where the nodes are located in memory and thus have to hop a lot more in memory to extract the data. This technique is applicable to both RDBMS and key-value NoSql databases.</p>
<p>Thus B or B+ trees can be viewed as hierarchical index where root node represents the top level index. The insertion and deletion in a binary tree can trigger splitting or merging of a node(s) which I will cover in other post later. For now, sit back and appreciate the advantages which these data structures provide for accessing data from external memory while keeping data sorted. It is for this reason, they are used in both RDBMS and NoSql databases.</p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">数据结构可视化</a></li>
<li><a href="https://en.wikipedia.org/wiki/B-tree#Technical_description" target="_blank" rel="noopener">B树定义</a></li>
<li><a href="https://www.quora.com/What-are-the-differences-between-B+Tree-and-B-Tree" target="_blank" rel="noopener">quora </a></li>
<li><a href="https://loveforprogramming.quora.com/Memory-locality-the-magic-of-B-Trees" target="_blank" rel="noopener">loveforprogramming</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/05/11/c语言字节对齐/">c语言字节对齐</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-05-11
        </span>
        
          <span class="post-category">
            
              <a href="/categories/C语言/">C语言</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>偶然的机会，看到关于字节对齐的相关内容，查了相关资料，自己做一下总结吧，233333。</p>
<h2 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h2><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>先上来直接做四道题,在纸上写出你的答案吧！<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// Alignment requirements</span></span><br><span class="line"><span class="comment">// (typical 32 bit machine)</span></span><br><span class="line"><span class="comment">// char         1 byte</span></span><br><span class="line"><span class="comment">// short     2 bytes</span></span><br><span class="line"><span class="comment">// int          4 bytes</span></span><br><span class="line"><span class="comment">// double       8 bytes</span></span><br><span class="line"><span class="comment">// structure A</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">structa_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>        c;</span><br><span class="line">   <span class="keyword">short</span>    s;</span><br><span class="line">&#125; <span class="keyword">structa_t</span>;</span><br><span class="line"><span class="comment">// structure B</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">structb_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">short</span>    s;</span><br><span class="line">   <span class="keyword">char</span>        c;</span><br><span class="line">   <span class="keyword">int</span>         i;</span><br><span class="line">&#125; <span class="keyword">structb_t</span>;</span><br><span class="line"><span class="comment">// structure C</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">structc_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>        c;</span><br><span class="line">   <span class="keyword">double</span>      d;</span><br><span class="line">   <span class="keyword">int</span>         s;</span><br><span class="line">&#125; <span class="keyword">structc_t</span>;</span><br><span class="line"><span class="comment">// structure D</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">structd_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">double</span>      d;</span><br><span class="line">   <span class="keyword">int</span>         s;</span><br><span class="line">   <span class="keyword">char</span>        c;</span><br><span class="line">&#125; <span class="keyword">structd_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"sizeof(structa_t) = %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">structa_t</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"sizeof(structb_t) = %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">structb_t</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"sizeof(structc_t) = %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">structc_t</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"sizeof(structd_t) = %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">structd_t</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>Every data type in C/C++ will have alignment requirement (infact it is mandated by processor architecture, not by language). A processor will have processing word length as that of data bus size. On a 32 bit machine, the processing word size will be 4 bytes.<br><img src="/images/2016/5/12/1.gif" alt="这里写图片描述"><br>Historically memory is byte addressable and arranged sequentially. If the memory is arranged as single bank of one byte width, the processor needs to issue 4 memory read cycles to fetch an integer. It is more economical to read all 4 bytes of integer in one memory cycle. To take such advantage, the memory will be arranged as group of 4 banks as shown in the above figure.</p>
<p>The memory addressing still be sequential. If bank 0 occupies an address X, bank 1, bank 2 and bank 3 will be at (X + 1), (X + 2) and (X + 3) addresses. If an integer of 4 bytes is allocated on X address (X is multiple of 4), the processor needs only one memory cycle to read entire integer.</p>
<p>Where as, if the integer is allocated at an address other than multiple of 4, it spans across two rows of the banks as shown in the below figure. Such an integer requires two memory read cycle to fetch the data.<br><img src="/images/2016/5/12/2.gif" alt="这里写图片描述"><br>A variable’s <em>data alignment</em> deals with the way the data stored in these banks. For example, the natural alignment of <em>int</em> on 32-bit machine is 4 bytes. When a data type is naturally aligned, the CPU fetches it in minimum read cycles.</p>
<p>Similarly, the natural alignment of <em>short</em> is 2 bytes. It means, a <em>short</em> can be stored in bank 0 – bank 1 pair or bank 2 – bank 3 pair. A <em>double</em> requires 8 bytes, and occupies two rows in the memory banks. Any misalignment of <em>double</em> will force more than two read cycles to fetch <em>double</em> data.</p>
<p>Note that a double variable will be allocated on 8 byte boundary on 32 bit machine and requires two memory read cycles. On a 64 bit machine, based on number of banks, double variable will be allocated on 8 byte boundary and requires only one memory read cycle.</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>For the sake of convenience, assume every structure type variable is allocated on 4 byte boundary (say 0x0000), i.e. the base address of structure is multiple of 4 (need not necessary always, see explanation of <em>structc_t</em>).</p>
<font color="#4590a3" size="4px">structure A</font>

<p>The <em>structa_t</em> first element is <em>char</em> which is one byte aligned, followed by <em>short</em>. <em>short</em> is 2 byte aligned. If the the <em>short</em> element is immediately allocated after the <em>char</em> element, it will start at an odd address boundary. The compiler will insert a padding byte after the char to ensure <em>short</em> will have an address multiple of 2 (i.e. 2 byte aligned). The total size of <em>structa_t</em> will be <code>sizeof(char)</code> + 1 (padding) + <code>sizeof(short)</code>, 1 + 1 + 2 = 4 bytes.</p>
<font color="#4590a3" size="4px">structure B</font>

<p>The first member of <em>structb_t</em> is <em>short</em> followed by <em>char</em>. Since <em>char</em> can be on any byte boundary no padding required in between <em>short</em> and <em>char</em>, on total they occupy 3 bytes. The next member is <em>int</em>. If the <em>int</em> is allocated immediately, it will start at an odd byte boundary. We need 1 byte padding after the <em>char</em> member to make the address of next <em>int</em> member is 4 byte aligned. On total, the <em>structb_t</em> requires 2 + 1 + 1 (padding) + 4 = 8 bytes.</p>
<font color="#4590a3" size="4px">structure C – Every structure will also have alignment requirements</font>

<p>Applying same analysis, <em>structc_t</em> needs <code>sizeof(char)</code> + 7 byte padding + <code>sizeof(double)</code> + <code>sizeof(int)</code> = 1 + 7 + 8 + 4 = 20 bytes. However, the <code>sizeof(structc_t)</code> will be 24 bytes. It is because, along with structure members, structure type variables will also have natural alignment. Let us understand it by an example. Say, we declared an array of <em>structc_t</em> as shown below<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">structc_t</span> structc_array[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p>
<p>Assume, the base address of <em>structc_array</em> is 0x0000 for easy calculations. If the <em>structc_t</em> occupies 20 (0x14) bytes as we calculated, the second <em>structc_t</em> array element (indexed at 1) will be at 0x0000 + 0x0014 = 0x0014. It is the start address of index 1 element of array. The <em>double</em> member of this <em>structc_t</em> will be allocated on 0x0014 + 0x1 + 0x7 = 0x001C (decimal 28) which is not multiple of 8 and conflicting with the alignment requirements of <em>double</em>. As we mentioned on the top, the alignment requirement of <em>double</em> is 8 bytes.</p>
<p>Inorder to avoid such misalignment, compiler will introduce alignment requirement to every structure. It will be as that of the largest member of the structure. In our case alignment of <em>structa_t</em> is 2, <em>structb_t</em> is 4 and <em>structc_t</em> is 8. If we need nested structures, the size of largest inner structure will be the alignment of immediate larger structure.</p>
<p>In <em>structc_t</em> of the above program, there will be padding of 4 bytes after int member to make the structure size multiple of its alignment. Thus the <code>sizeof (structc_t)</code> is 24 bytes. It guarantees correct alignment even in arrays. You can cross check.</p>
<font color="#4590a3" size="4px">structure D – How to Reduce Padding?</font>

<p>By now, it may be clear that padding is unavoidable. There is a way to minimize padding. The programmer should declare the structure members in their increasing/decreasing order of size. An example is <em>structd_t</em> given in our code, whose size is 16 bytes in lieu of 24 bytes of <em>structc_t</em>.</p>
<h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><p><img src="/images/2016/5/12/3.png" alt="这里写图片描述"></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>请牢记以下3条原则:(<font color="#ff0000">在没有#pragma pack宏的情况下</font>)</p>
<p>１:数据成员对齐规则：结构(<code>struct</code>)(或联合(<code>union</code>))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在32位机为４字节,则要从４的整数倍地址开始存储)。</p>
<p>２:结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</p>
<p>３:收尾工作:结构体的总大小,也就是sizeof的结果,必须是其内部最大成员的整数倍,不足的要补齐。</p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://blog.csdn.net/21aspnet/article/details/6729724/" target="_blank" rel="noopener">csdn 21aspnet</a></li>
<li><a href="http://blog.csdn.net/hairetz/article/details/4084088" target="_blank" rel="noopener">csdn hairetz</a></li>
<li><a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/" target="_blank" rel="noopener">www.geeksforgeeks.org</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/05/08/linux-mmap函数的应用/">linux mmap函数的应用</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-05-08
        </span>
        
          <span class="post-category">
            
              <a href="/categories/C语言/">C语言</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>最近，在看《深入理解计算机系统》，在看到虚拟存储器这一章节时，遇到一个习题:</p>
<blockquote>
<p>编写一个C程序mmapcopy.c， 使用mmap将一个任意大小的磁盘文件拷贝到stdout。输出文件的名字必须作为一个命令行参数来传递。</p>
</blockquote>
<p>google了一下，下面附上代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">        <span class="keyword">off_t</span> len;</span><br><span class="line">        <span class="keyword">char</span> *p;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;file&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fd = open (argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror (<span class="string">"open"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fstat (fd, &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror (<span class="string">"fstat"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!S_ISREG (sb.st_mode)) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"%s is not a file\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = mmap (<span class="number">0</span>, sb.st_size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (p == MAP_FAILED) &#123;</span><br><span class="line">                perror (<span class="string">"mmap"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (close (fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror (<span class="string">"close"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (len = <span class="number">0</span>; len &lt; sb.st_size; len++)</span><br><span class="line">                <span class="built_in">putchar</span> (p[len]);</span><br><span class="line">        <span class="keyword">if</span> (munmap (p, sb.st_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror (<span class="string">"munmap"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这个代码，下面附上我的收获:</p>
<ul>
<li>以前写代码的时候很少考虑出错处理，在看到这段代码的时候，顿时收获良多</li>
<li>fprintf stderr的用法很重要，同时要区别与stdout的关系<a href="http://zhidao.baidu.com/question/98997227.html" target="_blank" rel="noopener">(区别)</a></li>
<li>利用main函数进行命令行参数的传递，<code>int main (int argc, char *argv[])</code>，main函数 return 0 代表成功，return 非0 代表error</li>
<li><code>perror()</code>的<a href="http://c.biancheng.net/cpp/html/347.html" target="_blank" rel="noopener">用法</a>：<blockquote>
<p>函数<code>perror()</code>用于抛出最近的一次系统错误信息，其原型如下：<br> <code>void perror(char *string)</code>;</p>
<p>说明：<code>perror()</code>用来将上一个函数发生错误的原因输出到标准错误(stderr)。参数string所指的字符串会先打印出，后面再加上错误原因字符串，此错误原因依照全局变量errno的值来决定要输出的字符串。</p>
</blockquote>
</li>
</ul>
<ul>
<li>fstat( ) returns information about a given file</li>
<li>off_t代表文件的偏移，与size_t的区别和联系可参考<a href="http://stackoverflow.com/questions/10634629/what-are-the-usage-differences-between-size-t-and-off-t" target="_blank" rel="noopener">stackoverflow</a></li>
</ul>
<hr>
<p>参考资料:</p>
<ol>
<li><a href="https://www.safaribooksonline.com/library/view/linux-system-programming/0596009585/ch04s03.html" target="_blank" rel="noopener">safaribooksonline</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/04/29/深入理解计算机系统之重要概念/">深入理解计算机系统之重要概念</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-04-29
        </span>
        
          <span class="post-category">
            
              <a href="/categories/计算机系统/">计算机系统</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <h2 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h2><h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><p>在深入理解计算机系统中，是这样定义并发与并行的。</p>
<blockquote>
<p>并发(concurrency)是一个通用的概念，指一个同时具有多个活动的系统；并行(parallelism)指的是用并发使一个系统运行的更快。</p>
</blockquote>
<p>感觉很抽象，有木有！嘿嘿，于是我机智的google了一下，在<a href="http://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference" target="_blank" rel="noopener">stackoverflow</a>中找到了满意的答案。</p>
<blockquote>
<p> Concurrency is when two or more tasks can start, run, and complete in overlapping time periods. It doesn’t necessarily mean they’ll ever both be running at the same instant. Eg. multitasking on a single-core machine.</p>
</blockquote>
<blockquote>
<p>Parallelism is when tasks literally run at the same time, eg. on a multicore processor.</p>
</blockquote>
<p>并行可以在计算机系统的多个抽象层次上应用。在此，我们按照系统层次结构中由高到低的顺序重点强调三个层次。</p>
<h5 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h5><p>在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置成为<em>单处理器系统</em>。<br><img src="/images/2016/4/29/11.png" alt="这里写图片描述"><br><img src="/images/2016/4/29/12.png" alt="这里写图片描述"><br><em>超线程</em>，有时称为同时多线程是一项允许一个CPU执行多个控制流的技术。<br>对于超线程的解释，可以参考下面内容：</p>
<blockquote>
<p>Intel的超线程技术，目的是为了更充分地利用一个单核CPU的资源。CPU在执行一条机器指令时，并不会完全地利用所有的CPU资源，而且实际上，是有大量资源被闲置着的。超线程技术允许两个线程同时不冲突地使用CPU中的资源。比如一条整数运算指令只会用到整数运算单元，此时浮点运算单元就空闲了，若使用了超线程技术，且另一个线程刚好此时要执行一个浮点运算指令，CPU就允许属于两个不同线程的整数运算指令和浮点运算指令同时执行，这是真的并行。</p>
</blockquote>
<blockquote>
<p>我不了解其它的硬件多线程技术是怎么样的，但单就超线程技术而言，它是可以实现真正的并行的。但这也并不意味着两个线程在同一个CPU中一直都可以并行执行，只是恰好碰到两个线程当前要执行的指令不使用相同的CPU资源时才可以真正地并行执行。</p>
</blockquote>
<p>上面的解释来自<a href="https://www.zhihu.com/question/20277695" target="_blank" rel="noopener">知乎</a></p>
<h5 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h5><p>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为<em>指令级并行</em>。如果处理器可以达到比一个周期一个指令更快的执行速率，就称之位<em>超标量</em>处理器。</p>
<h5 id="单指令、多数据并行"><a href="#单指令、多数据并行" class="headerlink" title="单指令、多数据并行"></a>单指令、多数据并行</h5><p>在最底层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为<em>单指令、多数据</em>，即SIMD并行。例如，较新的Intel和AMD处理器都具有并行地对4对单精度浮点数(c数据类型float)做加法的指令。</p>
<h4 id="计算机系统中抽象的重要性"><a href="#计算机系统中抽象的重要性" class="headerlink" title="计算机系统中抽象的重要性"></a>计算机系统中抽象的重要性</h4><p><img src="/images/2016/4/29/13.png" alt="这里写图片描述"></p>
<hr>
<p>参考资料：</p>
<ol>
<li>《深入理解计算机系统》</li>
<li><a href="http://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference" target="_blank" rel="noopener">stackoverflow 并发并行区别</a></li>
<li><a href="https://www.zhihu.com/question/20277695" target="_blank" rel="noopener">超线程的解释</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/04/28/深入理解计算机系统之系统概论/">深入理解计算机系统之系统概论</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-04-28
        </span>
        
          <span class="post-category">
            
              <a href="/categories/计算机系统/">计算机系统</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>开始看《深入理解计算机系统》（<a href="https://book.douban.com/subject/1230413/" target="_blank" rel="noopener">豆瓣</a>）这本书，才看了一点，顿时感觉收获颇多，所以记录下读书笔记，方便以后复习。</p>
<h2 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h2><p>文章以hello程序入手，介绍了计算机系统的概念。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位 + 上下文"></a>信息就是位 + 上下文</h4><p>上文的hello.c源程序以字节序列的方式存储在文件中，下面展示hello.c的ASCII文本表示。</p>
<p><img src="/images/2016/4/28/ascii.png" alt="这里写图片描述"></p>
<p>像hello.c这样只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件。</p>
<p>hello.c的表示方法说明了一个基本的思想：系统中所有的信息——包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传输的数据，都是有一串位表示的。区分不同数据对象的唯一方法是我们读到这些对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。</p>
<h4 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h4><p><img src="/images/2016/4/28/com.png" alt="这里写图片描述"></p>
<p>如上图所示，执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统。</p>
<h4 id="了解编译系统如何工作是大有益处的"><a href="#了解编译系统如何工作是大有益处的" class="headerlink" title="了解编译系统如何工作是大有益处的"></a>了解编译系统如何工作是大有益处的</h4><ol>
<li>优化程序性能</li>
<li>理解链接时出现的错误</li>
<li>避免安全漏洞</li>
</ol>
<h4 id="处理器读并解释存储在存储器中的指令"><a href="#处理器读并解释存储在存储器中的指令" class="headerlink" title="处理器读并解释存储在存储器中的指令"></a>处理器读并解释存储在存储器中的指令</h4><p> <em>系统的硬件组成</em></p>
<p><img src="/images/2016/4/29/1.png" alt="这里写图片描述"></p>
<p><em>运行hello程序</em></p>
<p>初始时，外壳程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串”./hello”后，外壳程序将字符逐一读入寄存器，再把它存放到存储器中。<br><img src="/images/2016/4/29/2.png" alt="这里写图片描述"><br>当我们在键盘上敲回车键时，外壳程序就知道我们已经结束了命令行的输入。然后外壳程序执行一系列指令来加载可执行的hello文件，将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串“hello， world\n”。<br>利用直接存储器存取(DMA)的技术，数据可以不用通过处理器而直接从磁盘到达主存。这个步骤如下图所示。<br><img src="/images/2016/4/29/3.png" alt="这里写图片描述"><br>一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将”hello, world\n”字符串中的字节从主存复制到寄存器文件中，再从寄存器文件中复制到显示设备，最终显示在屏幕上。这个步骤如下图所示。<br><img src="/images/2016/4/29/4.png" alt="这里写图片描述"></p>
<h4 id="高速缓存至关重要"><a href="#高速缓存至关重要" class="headerlink" title="高速缓存至关重要"></a>高速缓存至关重要</h4><p>处理器与主存之间的差异，系统设计者采用了更小、更快的存储设备，即<em>高速缓冲存储器</em>，作为暂时的集结区域，用来存放处理器近期可能会需要的信息。<br><img src="/images/2016/4/29/5.png" alt="这里写图片描述"></p>
<h4 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h4><p><img src="/images/2016/4/29/6.png" alt="这里写图片描述"></p>
<h4 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h4><p><img src="/images/2016/4/29/7.png" alt="这里写图片描述"><br><img src="/images/2016/4/29/8.png" alt="这里写图片描述"></p>
<h4 id="系统之间利用网络通信"><a href="#系统之间利用网络通信" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h4><p>从一个单独的系统来看，网络可视为一个I/O设备，如下图所示。当系统从主存将一串字节复制到网络适配器时，数据流经过网络到达另一台机器，而不是其他地方，例如本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。<br><img src="/images/2016/4/29/9.png" alt="这里写图片描述"><br><img src="/images/2016/4/29/10.png" alt="这里写图片描述"></p>
<hr>
<p>参考资料：</p>
<ol>
<li>《深入理解计算机系统》</li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/04/28/linux-内核编译/">linux 内核编译</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-04-28
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Kernel/">Kernel</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>在第一次编译内核的时候，我尝试去youtube上看视频，查询技术博客，但是，直到看到实验室师兄的博客，那叫一个简单啊<a href="http://blog.csdn.net/chenyouxu/article/details/46985909" target="_blank" rel="noopener">点击查看博客</a>，下面我将其内容搬到自己博客中来，方便以后查看。</p>
<h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>首先来说下编译内核是怎么实现的，其实这方面网上有很多教程，也有很多博客讲到来这点，但是就我个人经验而言，我会将最简洁但又实用的办法分享出来，大概就几条命令的事吧(以下命令均在root下运行)。</p>
<h4 id="下载所需的内核源文件，然后解压，进入该源文件夹"><a href="#下载所需的内核源文件，然后解压，进入该源文件夹" class="headerlink" title="下载所需的内核源文件，然后解压，进入该源文件夹"></a>下载所需的内核源文件，然后解压，进入该源文件夹</h4><h4 id="make-menuconfig"><a href="#make-menuconfig" class="headerlink" title="make menuconfig"></a>make menuconfig</h4><p>选择需要模块化的地方，正确的话会出现下述画面。</p>
<p><img src="/images/2016/4/28/20150721145658916.png" alt="这里写图片描述"></p>
<p>如果出现错误，则缺少相应的文件，此时执行  <code>apt-get install libncurses5-dev libncursesw5-dev</code>，然后再执行<code>make menuconfig</code>即可。</p>
<p>此时需要选择需要模块化的地方，我当时是为将文件系统模块化，所以进入file system，通过空格来选‘M’还是‘*’,M表示模块化，*表示编译内核时就将该模块编译进去，后期无法自由删除修改。所以，在file system上面对所有条目而言，能选‘M’的都选‘M’，不能选的再选‘*’。最后保存下结果即可。</p>
<h4 id="make-j4"><a href="#make-j4" class="headerlink" title="make -j4"></a>make -j4</h4><h4 id="sudo-make-modules-install-j4"><a href="#sudo-make-modules-install-j4" class="headerlink" title="sudo make modules_install -j4"></a>sudo make modules_install -j4</h4><h4 id="sudo-make-install-j4"><a href="#sudo-make-install-j4" class="headerlink" title="sudo make install -j4"></a>sudo make install -j4</h4><h4 id="sudo-reboot"><a href="#sudo-reboot" class="headerlink" title="sudo reboot"></a>sudo reboot</h4><p>上面命令的后面加上 -j4 表示分成4个任务运行，只为了加快速度。大概等半个小时吧，内核编译应该就结束了。</p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://blog.csdn.net/chenyouxu/article/details/46985909" target="_blank" rel="noopener">小表弟皮卡丘</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/04/26/KSM源码解析之大页函数/">KSM源码解析之大页函数</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-04-26
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Kernel/">Kernel</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>最近需要修改linux内核代码中ksm部分，所以记录下遇到的一些重要函数，方便以后查阅与理解。</p>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><h3 id="PageTransHuge"><a href="#PageTransHuge" class="headerlink" title="PageTransHuge"></a><code>PageTransHuge</code></h3><p>函数原型：<code>static inline int PageTransHuge(struct page *page)</code></p>
<p>函数功能： returns true for both transparent huge and hugetlbfs pages, but not normal pages.</p>
<h3 id="PageTransCompound"><a href="#PageTransCompound" class="headerlink" title="PageTransCompound"></a><code>PageTransCompound</code></h3><p>函数原型： <code>static inline int PageTransCompound(struct page *page)</code></p>
<p>函数功能： 如果page是透明大页，则返回<code>true</code></p>
<h3 id="page-trans-compound-anon"><a href="#page-trans-compound-anon" class="headerlink" title="page_trans_compound_anon"></a><code>page_trans_compound_anon</code></h3><p> 函数原型： <code>static struct page * page_trans_compound_anon(struct page *page)</code></p>
<p> 函数代码：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct page *<span class="title">page_trans_compound_anon</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (PageTransCompound(page)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">head</span> = <span class="title">compound_head</span>(<span class="title">page</span>);</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * head may actually be splitted and freed from under</span></span><br><span class="line"><span class="comment">		 * us but it's ok here.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (PageAnon(head))</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 函数功能： *head等于compound_head(page)，如果PageAnon(head)则返回head，否则返回NULL</p>
<h3 id="split-huge-page"><a href="#split-huge-page" class="headerlink" title="split_huge_page"></a><code>split_huge_page</code></h3><p>函数原型： <code>static inline int split_huge_page(struct page *page)</code></p>
<p>函数功能： splits huge page into normal pages；<br>Returns 0 if the hugepage is split successfully；<br>Returns -EBUSY if the page is pinned or if anon_vma disappeared from under us.</p>
<h3 id="page-trans-compound-anon-split"><a href="#page-trans-compound-anon-split" class="headerlink" title="page_trans_compound_anon_split"></a><code>page_trans_compound_anon_split</code></h3><p>函数原型： <code>static int page_trans_compound_anon_split(struct page *page)</code></p>
<p>函数代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">page_trans_compound_anon_split</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">transhuge_head</span> = <span class="title">page_trans_compound_anon</span>(<span class="title">page</span>);</span></span><br><span class="line">	<span class="keyword">if</span> (transhuge_head) &#123;</span><br><span class="line">		<span class="comment">/* Get the reference on the head to split it. */</span></span><br><span class="line">		<span class="keyword">if</span> (get_page_unless_zero(transhuge_head)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Recheck we got the reference while the head</span></span><br><span class="line"><span class="comment">			 * was still anonymous.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (PageAnon(transhuge_head))</span><br><span class="line">				ret = split_huge_page(transhuge_head);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Retry later if split_huge_page run</span></span><br><span class="line"><span class="comment">				 * from under us.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				ret = <span class="number">1</span>;</span><br><span class="line">			put_page(transhuge_head);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="comment">/* Retry later if split_huge_page run from under us. */</span></span><br><span class="line">			ret = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数功能： 拆分复合透明匿名页，若拆分成功返回0,否则返回非0</p>
<hr>
<p> 参考资料：</p>
<ol>
<li><p><a href="http://blog.csdn.net/xiaocainiaoshangxiao/article/details/47058187" target="_blank" rel="noopener">复合页</a></p>
</li>
<li><p><a href="http://elixir.free-electrons.com/linux/v3.14.69/source/mm/ksm.c" target="_blank" rel="noopener">ksm源码</a></p>
</li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/04/22/linux-kernel-模块化编程入门/">linux kernel 模块化编程入门</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-04-22
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Kernel/">Kernel</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>相信hello world是所有编程语言的demo吧，linux kernel也不例外，昨天搜集了相关资料，终于完成linux 模块化编程的hello world！特此写下这个博客，记录下步骤。</p>
<h2 id="linux-kernel-模块化编程入门"><a href="#linux-kernel-模块化编程入门" class="headerlink" title="linux kernel 模块化编程入门"></a>linux kernel 模块化编程入门</h2><h3 id="安装Linux头部"><a href="#安装Linux头部" class="headerlink" title="安装Linux头部"></a>安装Linux头部</h3><p><code>sudo apt-get install build-essential linux-headers-$(uname -r)</code></p>
<h3 id="编写hello-world程序"><a href="#编写hello-world程序" class="headerlink" title="编写hello world程序"></a>编写hello world程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;   // Needed by all modules</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;   // Needed for KERN_ALERT</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;     // Needed for the macros</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   printk(KERN_ALERT <span class="string">"Hello, world \n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   printk(KERN_ALERT <span class="string">"Goodbye, world \n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure>
<h3 id="编写Makefile文件"><a href="#编写Makefile文件" class="headerlink" title="编写Makefile文件"></a>编写Makefile文件</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj-m += hello.o</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<p>此刻，当前目录下文件为：<br><img src="/images/2016/4/22/20160411103147782" alt="这里写图片描述"></p>
<h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p> 此刻，观察当前目录下文件：<br> <img src="/images/2016/4/22/20160411102413144" alt="这里写图片描述"></p>
<h3 id="将-ko文件添加到内核中"><a href="#将-ko文件添加到内核中" class="headerlink" title="将.ko文件添加到内核中"></a>将.ko文件添加到内核中</h3><p> <code>sudo insmod hello.ko</code></p>
<h3 id="信息验证"><a href="#信息验证" class="headerlink" title="信息验证"></a>信息验证</h3><p>为了查看内核控制台信息，需要用到<code>dmesg</code>指令<br> <img src="/images/2016/4/22/20160411102623307" alt="这里写图片描述"><br> 可以看到，hello world成功输出</p>
<h3 id="移除模块文件"><a href="#移除模块文件" class="headerlink" title="移除模块文件"></a>移除模块文件</h3><p>移除模块文件，需要用到如下指令<br> <code>sudo rmmod hello</code></p>
<p>此刻，再查看下message<br> <img src="/images/2016/4/22/20160411102743667" alt="这里写图片描述"><br> 发现Goodbye， world成功输出</p>
<p>如果想要了解具体细节，可以结合下参考资料！</p>
<hr>
<p>参考资料:</p>
<ol>
<li><a href="http://www.tldp.org/LDP/lkmpg/2.4/html/c147.htm" target="_blank" rel="noopener">tldp</a></li>
<li><a href="http://www.thegeekstuff.com/2013/07/write-linux-kernel-module/" target="_blank" rel="noopener">thegeekstuff</a></li>
<li><a href="https://www.youtube.com/watch?v=ewG-CI6vjX4" target="_blank" rel="noopener">youtube</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/04/20/python 操作excel/">python 操作excel</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-04-20
        </span>
        
          <span class="post-category">
            
              <a href="/categories/python/">python</a>
            
          </span>
        
        
      </div>
    </header>

    
    


    <div class="post-content">
      
        
        

        
          <p>在统计数据的时候，发现需要写个脚本去操作excel，于是找到了python，python大法好啊，哈哈，下面记录下过程。</p>
<h2 id="python操作excel"><a href="#python操作excel" class="headerlink" title="python操作excel"></a>python操作excel</h2><p>我最先google了一下，发现有一个库<code>xlrd</code>可以操作excel，但是，这个库有个局限性，就是最多只能操作256列，对于超过256列的表格就不能处理了，于是发现了一个新的库<code>openpyxl</code>，下面我将讲述一个这个库的用法!</p>
<h4 id="安装openpyxl库"><a href="#安装openpyxl库" class="headerlink" title="安装openpyxl库"></a>安装<code>openpyxl</code>库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install openpyxl</span><br></pre></td></tr></table></figure>
<h4 id="将文本数据转入到excel中"><a href="#将文本数据转入到excel中" class="headerlink" title="将文本数据转入到excel中"></a>将文本数据转入到excel中</h4><p>说一下的我的需求吧：<br>在<code>mainon.tem</code>文件中有如下数据：<br><img src="/images/2016/4/20/text_data.png" alt=""><br>最终excel中展示的数据如下:<br><img src="/images/2016/4/20/excel_result.png" alt=""><br>为了完成我的目标，需要下面脚本处理:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -- coding: UTF-8</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="comment">#文本转换成xls的函数，filename 表示一个要被转换的txt文本，xlsname 表示转换后的文件名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">txt2xls</span><span class="params">(filename,xlsname)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'converting xls ... '</span></span><br><span class="line">    f = open(filename)   <span class="comment">#打开txt文本进行读取</span></span><br><span class="line">    y = <span class="number">2</span>                <span class="comment">#在excel开始写的位置（y）</span></span><br><span class="line">    wb = Workbook()</span><br><span class="line">    ws3 = wb.create_sheet(title=<span class="string">"Sheet Data"</span>)</span><br><span class="line">    ws3.cell(column=<span class="number">1</span>, row=<span class="number">1</span>, value=<span class="string">"时间(s)"</span>)</span><br><span class="line">    ws3.cell(column=<span class="number">1</span>, row=<span class="number">2</span>, value=<span class="string">"透明大页容量"</span>)</span><br><span class="line">    ws3.cell(column=<span class="number">1</span>, row=<span class="number">3</span>, value=<span class="string">"memory free"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:  <span class="comment">#循环，读取文本里面的所有内容</span></span><br><span class="line">        line_time = f.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line_time:  <span class="comment">#如果没有内容，则退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        line_memoryfree = f.readline()</span><br><span class="line">        line_hugepage = f.readline()</span><br><span class="line">        ws3.cell(column=y, row=<span class="number">1</span>, value=<span class="string">"%s"</span> % line_time)</span><br><span class="line">        ws3.cell(column=y, row=<span class="number">2</span>, value=<span class="string">"%s"</span> % line_memoryfree)</span><br><span class="line">        ws3.cell(column=y, row=<span class="number">3</span>, value=<span class="string">"%s"</span> % line_hugepage)</span><br><span class="line">        y = y + <span class="number">1</span></span><br><span class="line">    f.close()</span><br><span class="line">    wb.save(filename = xlsname + <span class="string">".xlsx"</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    filename = sys.argv[<span class="number">1</span>]</span><br><span class="line">    xlsname  = sys.argv[<span class="number">2</span>]</span><br><span class="line">    txt2xls(filename,xlsname)</span><br></pre></td></tr></table></figure>
<p>对于以上代码，需要说明的步骤是:</p>
<ol>
<li>创建工作簿<code>wb = Workbook()</code></li>
<li>创建Sheet<code>ws3 = wb.create_sheet(title=&quot;Sheet Data&quot;)</code></li>
<li>在sheet指定位置操作数据<code>ws3.cell(column=1, row=1, value=&quot;时间(s)&quot;)</code></li>
<li>保存工作簿<code>wb.save(filename = xlsname + &quot;.xlsx&quot;)</code></li>
</ol>
<p>哈哈，就这样提高了效率！</p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://openpyxl.readthedocs.org/en/2.3.3/usage.html" target="_blank" rel="noopener">http://openpyxl.readthedocs.org/</a></li>
</ol>

        
      
    </div>

    

    

  </article>

      
      
  <nav class="pagination">
    
      <a class="prev" href="/page/12/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
  </nav>


    
  </section>

          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:liujunming1163@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/liujunming" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2016 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">liujunming</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script>

  </body>
</html>
